---
layout : post
title : DFS 와 BFS
comments : true
categories : 
- CodingTest
tags : [CodingTest, DFS, BFS]
---

# DFS 와 BFS

## 문제


1~N까지의 정점을 가지는 양방향 그래프와 탐색을 시작하는 정점이 주어진다.

이 때 시작점에서 DFS와 BFS로 각각 탐색하며 방문하게 되는 정점을 순서대로 출력해야 한다.

단, 한 정점은 직접 연결된 정점을 방문할 때 정점 번호가 작은 것을 먼저 방문하며,

더 이상 방문할 정점이 없는 경우 종료한다.


## 입력
첫째 줄에 정점의 개수 N(1<=N<=100), 간선의 개수 M(1<=M<=1,000)이 주어진다.

둘째 줄에 탐색을 시작한 정점의 번호 s(1<=s<=N)가 주어진다.

셋째 줄부터 M개의 줄에 걸쳐 간선이 연결하는 두 정점의 번호 a,b(1<=a,b<=N)가 주어진다.

두 정점 사이에 여러개의 간선이 있을 수 있다.


## 출력
첫째 줄에 DFS를 수행할 때의 순서를 출력하고

둘째 줄에 BFS를 수행할 때의 순서를 출력한다.




## 풀이

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

#define ARR_MAX_LEN 1001

using namespace std;
vector<vector<int> > graph(ARR_MAX_LEN);
vector<bool> isvisited(ARR_MAX_LEN, false);
int N, M;


void dfs(vector<vector<int>> & graph, int start)
{    
    isvisited[start] = true;
    cout << start << " ";
    for(int nnum : graph[start]){
        if(!isvisited[nnum]){
            dfs(graph, nnum);
        }
    }

}

void bfs(vector<vector<int>> & graph, int start)
{
    queue<int> q;
    q.push(start);
    isvisited[start] = true;
    while(!q.empty()){
        int cnum = q.front();
        q.pop();
        cout << cnum << " "; 
        for(int nnum : graph[cnum]){
            if(!isvisited[nnum]){
                q.push(nnum);
                isvisited[nnum] = true;
            }
        }
    }
    cout << "\n";
}
int main(void){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int s;
    cin >> N >> M;
    cin >> s;
    
    for(int num = 0; num < M; ++num){
        int i, j;
        cin >> i >> j;
        graph[i].push_back(j);
        graph[j].push_back(i);
    }

    // 방문 순서 일정하게 하려면 정렬
    for (int i = 1; i <= N; ++i) 
        sort(graph[i].begin(), graph[i].end());

        
    dfs(graph, s);
    cout << "\n";
    for(int i = 1; i <= M; i++)
        isvisited[i] = false;

    bfs(graph, s);
    
    return 0;
}
```