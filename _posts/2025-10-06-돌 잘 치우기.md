---
layout : post
title : 돌 잘 치우기
comments : true
categories : 
- CodingTest
tags : [CodingTest, BFS]
---

# 돌 잘 치우기

[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-clear-stones-well/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-clear-stones-well/descriptionn)


## 풀이

조합 + BFS 로 문제 해결

```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <vector>
#include <cstring>
#include <string>
#include <climits>
using namespace std;

int n, k, m, answer = INT_MIN;
int grid[100][100] = { 0 };
int temp_grid[100][100] = { 0 };
int r[10000], c[10000];
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };
bool isvisited[100][100] = { false };

typedef struct{
    int y;
    int x;
}loc_t;

vector<loc_t> stone_pos;
vector<loc_t> cand_stone_pos;
vector<vector<loc_t> > comb_lst;

void bfs(int y, int x){

    queue<loc_t> q;
    q.push({y, x});
    isvisited[y][x] = true;

    while(!q.empty()){
        int cy = q.front().y;
        int cx = q.front().x;
        q.pop();
        
        for(int dir = 0; dir < 4; dir++){
            int ny = cy + dy[dir];
            int nx = cx + dx[dir];

            if(ny < 0 || ny >= n || nx < 0 || nx >= n)
                continue;
            
            if(temp_grid[ny][nx] == 0 && !isvisited[ny][nx]){
                q.push({ny, nx});
                isvisited[ny][nx] = true;
            }
        }

    }


}

void comb(int idx, int cnt){

    if(cnt == m){
        comb_lst.push_back(cand_stone_pos);
        return;
    }

    for(int i = idx; i < stone_pos.size(); i++){
        cand_stone_pos.push_back(stone_pos[i]);
        comb(i + 1, cnt + 1);
        cand_stone_pos.pop_back();
    }

}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> k >> m;

    for (int i = 0; i < n; i++){
        for (int j = 0; j < n; j++){
            cin >> grid[i][j];
            if(grid[i][j] == 1)
                stone_pos.push_back({i, j});
        }
    }
    for (int i = 0; i < k; i++) {
            cin >> r[i] >> c[i];
            r[i]--;
            c[i]--;
    }     

    comb(0, 0);

    for(int i = 0; i < comb_lst.size(); i++){
        memset(isvisited, false, sizeof(isvisited));
        memcpy(temp_grid, grid, sizeof(grid));
        for(int idx = 0; idx < comb_lst[i].size(); idx++){
            temp_grid[comb_lst[i][idx].y][comb_lst[i][idx].x] = 0;
        }
        int ret = 0;
        for (int j = 0; j < k; j++) {
            bfs(r[j], c[j]);
            
        }
        for (int r = 0; r < n; r++){
            for (int c = 0; c < n; c++){
                if(isvisited[r][c])
                    ret++;
            }
        }
        answer = max(answer, ret);

    }

    cout << answer << "\n";
    return 0;
}

```