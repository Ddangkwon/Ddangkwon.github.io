---
layout : post
title : 지하철
comments : true
categories :
- CodingTest
tags : [CodingTest, Floyd Warshall]
---

# 지하철

## 문제 설명

지방에서 서울로 관광을 온 도훈이는 지하철 노선을 보고 깜짝 놀랐다.
노선이 매우 복잡하게 얽혀 있어, 잘못 이동하면 10분이면 갈 수 있는 거리를 1시간이나 돌아서 가는 상황이 발생할 수 있었다.

어쩔 수 없이 도훈이는 **현재 숙소가 있는 역(1번 역)**에서 관광할 목적지 역까지
가장 짧은 시간에 도착할 수 있는 경로와 소요 시간을 표로 정리하려고 한다.

다음 조건이 주어진다.

각 지하철역에는 관광지가 있다.

지하철을 갈아타는 데 걸리는 시간은 없다고 가정한다.

역과 역 사이의 이동 시간은 모두 주어진다.

## 입력

첫 줄에 두 개의 정수 N과 M이 주어진다.

N은 지하철역의 개수이다. (3 ≤ N ≤ 100)

M은 도착하고자 하는 목적역의 번호이다. (1 ≤ M ≤ N)

다음 N개의 줄에는 각각 N개의 정수가 주어진다.

i번째 줄의 j번째 수 Sij는
i번 역에서 j번 역까지 이동하는 데 걸리는 시간이다.

i = j 인 경우 항상 0이다.

이동 시간 Sij는 0 이상 100 이하의 정수이다.

1번 역이 도훈이의 숙소가 있는 출발역이다.


## 출력

목적역 M까지 이동하는 데 걸리는 최소 시간을 출력한다.

## 풀이

```cpp
#include <iostream>
#include <climits>

#define ARR_MAX_LEN 101
using namespace std;

int N, M;
// timemap[i][j] : i번 역에서 j번 역까지 걸리는 최소 시간
int timemap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
// path[i][j] : i → j 최단경로에서의 중간 경유 정점
// 경유지가 없으면 0
int path[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
void input(void)
{
    cin >> N >> M;

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= N; j++){
            cin >> timemap[i][j];
        }
    }
}

void floydwarshall(void)
{
    for(int k = 1; k <= N; k++){
        for(int i = 1; i <= N; i++){
            for(int j = 1; j <= N; j++){
                if(timemap[i][j] > timemap[i][k] + timemap[k][j]){
                    timemap[i][j] = timemap[i][k] + timemap[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}


void trace(int start, int end)
{
    // 중간 경유지가 없으면 start를 출력
    if(path[start][end] == 0){
        cout << start << " ";
        return ;
    }

    // start → mid → end 로 경로를 분리
    int mid = path[start][end];

    // start → mid 경로 출력
    trace(start, mid);
    // mid → end 경로 출력
    trace(mid, end);
}
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();
    floydwarshall();
    // 목적역까지 가는 최단 거리
    cout << timemap[1][M] << "\n";
    // 목적지까지의 경로 출력
    trace(1, M);
    cout << M << "\n";
    return 0;
};

```
