---
layout : post
title : 우선순위 큐 문제
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---

# 우선순위 큐 문제

## 최소힙 문제


### 답안

```cpp
#include <stdio.h>

#define ARR_MAX 100001

int heap[ARR_MAX];
int hn;
int N;

int pop(int* heap, int& hn)
{
	register int tmp, ret;
	//1) pop의 return값 heap[1]을 기억해둔다.
	ret = heap[1];
	//2) heap의 배열에서 가장 끝에 값, 즉 heap[hn]을 heap[1]로 변경한다.
	heap[1] = heap[hn];
	//3) heap[hn]은 최악의 우선순위값(최소힙이므로 0x7fff0000 정도의 큰 값)으로 변경해둔다.
	//4) heap이 1개 줄었으므로 hn 을 1 감소 시킨다.
	heap[hn--] = 0x7fff0000;

	for (register int i = 1; i * 2 <= hn;)
	{
		// 자식노드가 더 크면 pass
        // 종료조건 heap을 만족할 경우
		if (heap[i] < heap[i * 2] && heap[i] < heap[i * 2 + 1])
			break;
		// 자식노드가 부모노드보다 크고, 오른쪽 자식노드가 더 크면 왼쪽 자식노드와 부모노드 교환
		else if (heap[i * 2] < heap[i * 2 + 1])
		{
			tmp = heap[i * 2];
			heap[i * 2] = heap[i];
			heap[i] = tmp;

			i = i * 2;
		}
		// 자식노드가 부모노드보다 크고, 왼쪽 자식노드가 더 크면 오른쪽 자식노드와 부모노드 교환
		else
		{
			tmp = heap[i * 2 + 1];
			heap[i * 2 + 1] = heap[i];
			heap[i] = tmp;

			i = i * 2 + 1;
		}
	}

	return ret;
}

//heap은 eap은 부모 자식 간에만 우선순위를 만족해주기만 하면 되기 때문에 다른 자식노드들끼리의 우선순위 순서는 틀릴 수 있다.
void push(int* heap, int& hn, int x)
{
	register int tmp;
	//모든 i에 대해서 자식 node는 i * 2, i * 2 + 1이 되고,
	//부모 node는 i / 2로 하면 된다.
    // hn = 0이므로 hn을 먼저 1로 만들어주고 값을 넣는다.
	heap[++hn] = x;
	for (register int i = hn; i > 1; i /= 2)
	{
        // 종료조건 heap을 만족할 경우
		// 자식 노드가 더 크면 pass
		if (heap[i / 2] <= heap[i]) 
			break;
		// 아니면 조상 <-> 부모 <-> 자식 노드간에 교환을 반복해서 수행한다. (부모노드가 자식노드보다 작을때까지)
		// 부모 노드와 자식 노드와의 교환
		tmp = heap[i / 2];
		heap[i / 2] = heap[i];
		heap[i] = tmp;
	}
}

int main(void)
{
	scanf("%d", &N);
	for (int i = 0; i < N; i++)
	{
		int x;
		scanf("%d", &x);
		if (x)
		{
			push(heap, hn, x);
		}
		else
		{
			if (hn)
			{
				printf("%d\n", pop(heap, hn));
			}
			// 큐가 비어있는 경우
			else
			{
				printf("0\n");
			}
		}

	}

	return 0;
}  

```


## 최대 힙 문제

최대힙에서 크게 바뀌는 부분은 다음과 같다.

- 부모노드 자식노드 크기 비교 부등호 관계
- heap 마지막 노드에 최대 힙이므로 최소값 저장

```cpp
#include <stdio.h>

#define ARR_MAX 100001

int N, hn;
int heap[ARR_MAX];

void push(int* heap, int& hn, int x)
{
	int tmp;
    // hn = 0이므로 hn을 먼저 1로 만들어주고 값을 넣는다.
	heap[++hn] = x;
	// bottom-up
	for (int i = hn; i > 1; i/=2)
	{
        // 종료조건 heap을 만족할 경우
		// 부모노드가 자식노드보다 크면 break;
		if (heap[i] <= heap[i / 2])
			break;

		tmp = heap[i / 2];
		heap[i / 2] = heap[i];
		heap[i] = tmp;

	}
}
int pop(int* heap, int& hn)
{
	int tmp, ret = heap[1];
	heap[1] = heap[hn];
    // 자연수가 입력되므로 최소값으로 -1 저장
	heap[hn--] = -1;
	// 자식노드를 훑어가며 저장
	// top-down
	for (int i = 1; i * 2 <= hn;)
	{
        // 종료조건 heap을 만족할 경우
		if (heap[i] > heap[i * 2] && heap[i] > heap[i * 2 + 1])
			break;
		else if (heap[i * 2] > heap[i * 2 + 1])
		{
			tmp = heap[i * 2];
			heap[i * 2] = heap[i];
			heap[i] = tmp;
			i = i * 2;
		}
		else
		{
			tmp = heap[i * 2 + 1];
			heap[i * 2 + 1] = heap[i];
			heap[i] = tmp;
			i = i * 2 + 1;
		}
	}


	return ret;
}


int main(void)
{
	scanf("%d", &N);
	
	for (int i = 0; i < N; i++)
	{
		int x;
		scanf("%d", &x);
		if (x)
		{
			push(heap, hn, x);
		}
		// 결과 출력
		else
		{
			if (hn)
			{
				printf("%d\n", pop(heap, hn));
			}
			// 힙이 비었을 경우 0 출력
			else
			{
				printf("0\n");
			}
		}
	}

	return 0;
}
```