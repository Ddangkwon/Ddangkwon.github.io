---
layout : post
title : 생명체 분류
comments : true
categories : 
- CodingTest
tags : [CodingTest, Trie]
---

# 생명체 분류

## 문제


지구상에 존재하는 모든 생명체는 여러가지 방법에 따라 분류가 된다.

가장 큰 그룹으로 분류하면 26종으로 분류가 가능하다고 한다.그리고 각 그룹의 멤버들은 다시 26종으로 분류가 가능하다.이렇게 최대 9단계까지 세부 분류가 될 수 있다. 

이러한 단계를 나타낸다면 총 26^9의 서로 다른 종류의 생명체로 분류가 가능하고 그 단계를 알파벳 대문자로 표현할 수 있다."AB"라면 가장 높은 단계의 분류가 'A'이고 두번째 단계가 'B'인 모든 생명체를 의미한다. 

생명체를 연구하는 정올 박사는 어떤 무인도에서 서식하는 생명체의 연구를 하면서 생명체가 발견될 때마다 분류표에 넣고 있다.그러다가 수시로 현재까지 발견된 특정 종의 개수를 알고 싶어 한다.예를 들어 생명체 "ABC"와 "ABDF"가 있을때 "AB"종의 개수를 구하려고 하면 모두 "AB"그룹에 포함되므로 2가 된다.알고리즘을 모르는 정올 박사를 위해 프로그램을 작성해 주자.


## 입력
첫째 줄에 테스트케이스의 개수를 나타내는 정수 T가 주어진다. (1 ≤ T ≤ 50)

각 테스트케이스마다 첫째 줄에 정올박사가 요구하는 연산의 횟수를 나타내는 정수 N이 주어진다. ( 1 ≤ N ≤ 1000 ) 

이후 N개의 줄에 걸쳐서 정올박사가 요구하는 연산의 정보가 순서대로 주어진다. 

각 연산 정보는 한 개의 문자로 구성된 명령의 종류 C와 생명체의 분류를 나타내는 문자열 S가 공백을 사이에 두고 주어진다. 

C가 'I'이면 정올 박사가 새로운 생명체를 발견하여 분류표에 저장하는 것이다. 

C가 'O'이면 현재까지 저장된 생명체중 S그룹의 수를 묻는 것이다. S의 길이는 1 이상 9이하이다.


## 출력
각 테스트케이스마다 한줄에 C가 'O'인 연산들에 대해 공백 하나를 사이에 두고 순서대로 답을 출력한다.


## 풀이

```cpp
#include <iostream>
#include <string>
#include <vector>

using namespace std;

int T, N;
char C;
string S;

typedef struct{
    int path_cnt; // 이 노드를 root 로 하는 word 개수 (해당 prefix 개수)
    int child[26]; // 문자를 Integer Index 로 변환, A -> 0 Z -> 25
}trie_node_t;

vector<trie_node_t> buf;
int buf_cnt = 0; // 새로 할당되는 node 의 수 (root node 제외)

void init()
{
    buf_cnt = 0;
    buf.clear();
    buf.push_back({ 0 }); // root = index 0

    // Root 노드를 초기화하는 다른 방법
    /*
    trie_node_t root;
    root.pathCnt = 0;
    for (int i = 0; i < 26; i++) {
        root.child[i] = 0;
    }
    buf.push_back(root);

    */
}

void push(string str)
{
    int cur_buf_idx = 0;
    for (int i = 0; i < str.length(); i++) {
        int idx = str[i] - 'A';

        if (buf[cur_buf_idx].child[idx] == 0) {
            // 새로운 노드 할당
            buf.push_back({ 0 });
            buf[cur_buf_idx].child[idx] = ++buf_cnt;  // 새 노드 인덱스 = 1,2,3...
        }

        cur_buf_idx = buf[cur_buf_idx].child[idx];
        // buf[cur_buf_idx] 를 root node 로 하는 word 개수 증가
        buf[cur_buf_idx].path_cnt++;
    }
}

int get_cnt(string str)
{   
    int cur_buf_idx = 0;

    for(int i = 0; i < str.length(); i++){
        int idx = str[i] - 'A';
        // 검색하는 문자열이 없는 경우 return 0
        if(buf[cur_buf_idx].child[idx] == 0)
            return 0;
        cur_buf_idx = buf[cur_buf_idx].child[idx];
    }
    // buf[cur_buf_idx] 를 root node 로 하는 word 개수를 반환
    return buf[cur_buf_idx].path_cnt;
}

int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> T;
    for(int i = 0; i < T; i++){
        cin >> N;
        init();
        for(int cmd_idx = 0; cmd_idx < N; cmd_idx++){
            cin >> C >> S;
            
            if(C == 'I'){
                push(S);
            }
            else if(C == 'O'){
                int answer_cnt = get_cnt(S);
                
                cout << answer_cnt << " ";
            }
        }

        cout << "\n";

    }

    return 0;
}
```