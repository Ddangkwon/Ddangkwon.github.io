---
layout : post
title : 방화벽 설치하기
comments : true
categories : 
- CodingTest
tags : [CodingTest, BFS]
---

# 방화벽 설치하기

[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-move-to-max-k-times/descriptionn](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-move-to-max-k-times/description)

## 풀이

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#include <cstring>
#include <string>

using namespace std;

int n, k;
int grid[100][100];
bool isvisited[100][100] = { false };
int r, c;

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

typedef struct {
    int y;
    int x;
}loc_t;



int bfs(int y, int x, int val){
    int max_num = 0;
    queue<loc_t> q;
    
    q.push({y, x});
    isvisited[y][x] = true;
    while(!q.empty()){
        int cy = q.front().y;
        int cx = q.front().x;
        q.pop();
        

        for (int dir = 0; dir < 4; dir++) {
            int ny = cy + dy[dir];
            int nx = cx + dx[dir];
            if (ny < 1 || ny > n || nx < 1 || nx > n)
                continue;
            
            if ((grid[ny][nx] < val) && !isvisited[ny][nx]) {
                q.push({ny, nx});
                isvisited[ny][nx] = true;
                // 시작 좌표는 제외하고 MAX 값 구해야 함
                max_num = max(max_num, grid[ny][nx]);
            }
        }
    }

    return max_num;
}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // 입력 시퀀스
    cin >> n >> k;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> grid[i][j];
        }
    }

    cin >> r >> c;

    // 문제 풀이 시작
    for (int i = 0; i < k; i++) {
        bool move_flag = false;
        int max_val = 0;
        memset(isvisited, false, sizeof(isvisited));
        max_val = bfs(r, c, grid[r][c]);

        if (max_val == 0)
            break;

        else {
            // 다음 좌표 탐색
            for (int i = 1; i <= n; i++) {
                bool find_flag = false;
                for (int j = 1; j <= n; j++) {
                    if (!find_flag && isvisited[i][j]) {
                        if (grid[i][j] == max_val) {
                            r = i;
                            c = j;
                            find_flag = true;
                        }
                    }
                }
                if (find_flag)
                    break;
            }
        }
    }

    cout << r << " " << c << "\n";

    return 0;
}

```