---
layout : post
title : 숨바꼭질 3
comments : true
categories :
- CodingTest
tags : [CodingTest, BFS]
---

# 숨바꼭질 3

[https://www.acmicpc.net/problem/13549](https://www.acmicpc.net/problem/13549)


## 문제
수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

## 입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

## 출력
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

## 풀이

```cpp
#include <iostream>
#include <queue>
#include <climits>

#define ARR_MAX_LEN 100001
#define MAX_NUM 100000
using namespace std;

typedef struct{
    int pos;
    int time;
}info_t;

struct less_compare{
    bool operator()(const info_t &a, const info_t &b) const{
        return a.time > b.time; // min-heap
    }
};

int N, K;
int time_arr[ARR_MAX_LEN];

void input(void)
{
    cin >> N >> K;
    for(int i = 0; i <= MAX_NUM; i++)
        time_arr[i] = INT_MAX;
}

void bfs(int start)
{
    priority_queue<info_t, vector<info_t>, less_compare> pq;
    pq.push({start, 0});
    time_arr[start] = 0;

    while(!pq.empty()){
        info_t cur = pq.top();
        pq.pop();

        int cur_pos = cur.pos;
        int cur_time = cur.time;

        if(cur_time > time_arr[cur_pos])
            continue;
        // 목표 위치 찾으면 탐색 종료
        if(cur_pos == K)
            return;

        // cur_pos - 1 (cost 1)
        if(cur_pos > 0){
            int npos = cur_pos - 1;
            int ntime = cur_time + 1;
            if(time_arr[npos] > ntime){
                time_arr[npos] = ntime;
                pq.push({npos, ntime});
            }
        }

        // cur_pos + 1 (cost 1)
        if(cur_pos + 1 <= MAX_NUM){
            int npos = cur_pos + 1;
            int ntime = cur_time + 1;
            if(time_arr[npos] > ntime){
                time_arr[npos] = ntime;
                pq.push({npos, ntime});
            }
        }

        // cur_pos * 2 (cost 0)
        if(cur_pos * 2 <= MAX_NUM){
            int npos = cur_pos * 2;
            int ntime = cur_time;
            if(time_arr[npos] > ntime){
                time_arr[npos] = ntime;
                pq.push({npos, ntime});
            }
        }
    }
}

int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();
    bfs(N);
    cout << time_arr[K] << "\n";
    return 0;
}

```
