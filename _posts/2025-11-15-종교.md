---
layout : post
title : 종교
comments : true
categories : 
- CodingTest
tags : [CodingTest, Union Find]
---

# 종교

## 문제


오늘날 아주 많은 다른 종교들이 있고 이들 모두를 추적하는 것은 어려운 일이다.

당신이 다니는 학교에서 학생들이 믿고 있는 종교가 총 몇 가지 있는가를 알고자 한다.

학교에는 n (0 < n ≤ 50,000)명의 학생이 있다. 모든 학생에게 자기가 가진 종교가 무엇인지를 물어보는 것은 힘든 일이고 

게다가 많은 학생들은 그들의 종교를 나타내는 것을 좋아하지 않는다.

이 문제를 해결하기 위한 한 가지 방법은 같은 종교를 가지는 사람들 끼리 짝을 짓도록 하는 것이다.

쌍의 수는 m ( 0 ≤ m ≤ 100,000 ) 이다. 

이 데이터로 당신은 모든 학생들이 어떤 종교를 가지고 있는가는 알지 못하지만 

학생들이 최대한 가질 수 있는 종교의 가지 수를 알 수 있다.

모든 학생들이 최대 한 가지 종교를 가지고 있다고 하자.


## 입력
정수 n , m 이 주어진다. 다음 m 라인은 두 정수 i , j 가 주어진다.

i, j 는 i번 학생과 j번 학생이 같은 종교를 가진 학생의 쌍이다(1≤i, j≤n).


## 출력
종교의 가지 수를 출력한다.




## 풀이

```cpp
#include <iostream>
#include <vector>

#define ARR_MAX_LEN 100001

using namespace std;

// 각 노드가 속한 집합 정보 (Union-Find parent)
vector<vector<int> > graph(ARR_MAX_LEN); 
vector<int> parent(ARR_MAX_LEN, 0);   // 각 노드의 부모 노드
vector<int> rankv(ARR_MAX_LEN, 0);    // 랭크(트리 높이 개념)

// n = 노드 개수, m = 간선(Union 연산) 개수
// answer = 최종적으로 남는 집합의 개수
int n, m, answer = 0;


// find: 경로 압축을 사용한 대표 노드 찾기
// 경로 압축: 부모를 루트로 직접 연결
int find_parent(int x)
{
    if(parent[x] == x)   // x가 루트 노드면 그대로 반환
        return x;
    return parent[x] = find_parent(parent[x]);  
    
}


// union: 두 집합을 병합
int union_parent(int x, int y)
{
    x = find_parent(x);   // x의 루트 찾기
    y = find_parent(y);   // y의 루트 찾기
    
    // 이미 같은 집합 → 병합 X (집합 수 변화 없음)
    if(x == y)
        return 0;         

    // 트리 랭크 기준으로 작은 트리를 큰 트리에 붙임
    if(rankv[x] < rankv[y])
        parent[x] = y;
    else{
        parent[y] = x;
        if(rankv[x] == rankv[y])
            rankv[x]++;   // 높이가 같다면 합친 쪽 트리 랭크 증가
    }
       
    return 1;
}


int main(void){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m;
    answer = n;   // 초기에는 집합이 n개 (각 노드가 자기 자신)

    // 초기 parent 설정
    for(int i = 1; i <= n; i++){
        parent[i] = i;            // 자기 자신이 루트
        graph[i].push_back(i);    // (그래프는 사실 안 쓰지만 초기 형태 유지)
    }

    // m개의 union 연산 처리
    for(int cnt = 0; cnt < m; ++cnt){
        int i, j;
        cin >> i >> j;
        answer -= union_parent(i, j);  
    }

    // 최종적으로 남은 서로소 집합의 개수 출력
    cout << answer << "\n";
    return 0;
}

```