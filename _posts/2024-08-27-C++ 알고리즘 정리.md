---
layout : post
title : C++ ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬ 
comments : true
categories : 
- CodingTest
tags : [CodingTest, DFS, BFS]
---
 
# C++ ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬


[C++ STL ë¼ì´ë¸ŒëŸ¬ë¦¬ ì •ë¦¬](https://ddangkwon.github.io/posts/C++_STL_%EC%A0%95%EB%A6%AC/)

<br/>

# C++ DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰) ì •ë¦¬

<br/>

## ğŸ§­ ê°œìš”

DFS(Depth First Search)ëŠ” ê·¸ë˜í”„ë‚˜ íŠ¸ë¦¬ì—ì„œ ëª¨ë“  ë…¸ë“œë¥¼ ë°©ë¬¸í•˜ëŠ” ë°©ë²• ì¤‘ í•˜ë‚˜ì´ë‹¤.
í•œ ë°©í–¥ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆì„ ë§Œí¼ ê¹Šê²Œ íƒìƒ‰í•˜ë‹¤ê°€, ë” ì´ìƒ ê°ˆ ê³³ì´ ì—†ìœ¼ë©´ ë˜ëŒì•„(backtrack)ì™€ì„œ ë‹¤ë¥¸ ê²½ë¡œë¥¼ íƒìƒ‰í•˜ëŠ” ë°©ì‹ì´ë‹¤.

ì£¼ë¡œ **ì¬ê·€ í˜¸ì¶œ(recursion)** ì´ë‚˜ **ìŠ¤íƒ(stack)** ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•˜ì—¬ êµ¬í˜„í•œë‹¤.
---

<br/>

## ğŸ§  íŠ¹ì§•

- **ìŠ¤íƒ ê¸°ë°˜** (ì¬ê·€ í•¨ìˆ˜ ë˜ëŠ” ëª…ì‹œì  ìŠ¤íƒ ì‚¬ìš© ê°€ëŠ¥)
- **ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì  íƒìƒ‰ ê°€ëŠ¥**
- ê²½ë¡œ ì°¾ê¸°, ìˆœí™˜ íƒì§€, ì—°ê²° ìš”ì†Œ íƒìƒ‰ ë“±ì— ì‚¬ìš©

---

<br/>

## ğŸ”§ DFS êµ¬í˜„ ë°©ì‹

<br/>

### 1ï¸âƒ£ ì¬ê·€ í•¨ìˆ˜ ë°©ì‹

```cpp
#include <iostream>
#include <vector>

using namespace std;

vector<vector<int>> graph;
vector<bool> visited;

void dfs(int node) {
    visited[node] = true;
    cout << node << ' ';

    for (int next : graph[node]) {
        if (!visited[next]) {
            dfs(next);
        }
    }
}

int main() {
    int n = 5; // ì •ì  ìˆ˜
    graph.resize(n + 1);
    visited.resize(n + 1, false);

    // ì˜ˆì œ ê°„ì„  ì¶”ê°€
    graph[1] = {2, 3};
    graph[2] = {4};
    graph[3] = {5};

    dfs(1); // 1ë²ˆ ë…¸ë“œë¶€í„° ì‹œì‘
}
```
<br/>

### 2ï¸âƒ£ ìŠ¤íƒì„ ì´ìš©í•œ ë¹„ì¬ê·€ ë°©ì‹

```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

vector<vector<int>> graph;
vector<bool> visited;

void dfs_iterative(int start) {
    stack<int> s;
    s.push(start);

    while (!s.empty()) {
        int node = s.top(); s.pop();
        if (visited[node]) continue;

        visited[node] = true;
        cout << node << ' ';

        for (int i = graph[node].size() - 1; i >= 0; --i) {
            int next = graph[node][i];
            if (!visited[next]) {
                s.push(next);
            }
        }
    }
}
```

### DFS ê¸°ë³¸ êµ¬ì¡° (ê·¸ë˜í”„)

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> graph;
bool visited[100];

void dfs(int node) {
    visited[node] = true;
    cout << node << " ";

    for (int next : graph[node]) {
        if (!visited[next]) {
            dfs(next);
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m; // ë…¸ë“œ ìˆ˜ì™€ ì—£ì§€ ìˆ˜ ì…ë ¥
    graph.resize(n + 1);

    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }

    dfs(1); // 1ë²ˆ ë…¸ë“œë¶€í„° íƒìƒ‰ ì‹œì‘
}
```
--- 

## ë°±íŠ¸ë˜í‚¹(Backtracking) ê°œë…

ë°±íŠ¸ë˜í‚¹ì€ í˜„ì¬ ìƒíƒœì—ì„œ ê°€ëŠ¥í•œ ëª¨ë“  í›„ë³´êµ°ì„ ë”°ë¼ ë“¤ì–´ê°€ë©° íƒìƒ‰í•˜ë‹¤ê°€,
ë¬¸ì œì˜ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ì•Šìœ¼ë©´ **ë‹¤ì‹œ ì´ì „ ìƒíƒœë¡œ ëŒì•„ê°€ì„œ ë‹¤ë¥¸ ê²½ë¡œë¥¼ íƒìƒ‰**í•˜ëŠ” ê¸°ë²•ì´ë‹¤.

**DFSë¥¼ ê¸°ë°˜ìœ¼ë¡œ êµ¬í˜„**í•˜ëŠ” ê²½ìš°ê°€ ë§ìœ¼ë©°, ëª¨ë“  ê²½ìš°ì˜ ìˆ˜ë¥¼ íƒìƒ‰í•  ë•Œ ì£¼ë¡œ ì‚¬ìš©ëœë‹¤.

ëŒ€í‘œì ì¸ ì˜ˆì‹œë¡œëŠ” **N-Queen ë¬¸ì œ, ë¶€ë¶„ ì§‘í•© êµ¬í•˜ê¸°, ìˆœì—´(permutation) ë¬¸ì œ** ë“±ì´ ìˆë‹¤.

## DFS + ë°±íŠ¸ë˜í‚¹ ê¸°ë³¸ êµ¬ì¡°

```cpp
#include <iostream>
#include <vector>
using namespace std;

int n;
bool isvisited[10]; // ìˆ«ì ì‚¬ìš© ì—¬ë¶€ ì²´í¬

void dfs(vector<int>& perm, int depth) {
    if (depth == n) {
        for (int num : perm) {
            cout << num << " ";
        }
        cout << "\n";
        return;
    }

    for (int i = 1; i <= n; i++) {
        if (!isvisited[i]) {
            isvisited[i] = true;
            perm.push_back(i);
            dfs(perm, depth + 1);
            perm.pop_back();
            isvisited[i] = false;
        }
    }
}

int main() {
    cin >> n;
    vector<int> perm;
    dfs(perm, 0);
}
```

## DFSì™€ ë°±íŠ¸ë˜í‚¹ì˜ ì°¨ì´ì 

- **DFS** ëŠ” ë‹¨ìˆœíˆ ê¹Šì´ ìš°ì„ ìœ¼ë¡œ ëª¨ë“  ê²½ë¡œë¥¼ íƒìƒ‰í•˜ëŠ” ê²ƒ
- **ë°±íŠ¸ë˜í‚¹** ì€ DFS íƒìƒ‰ ì¤‘ ì¡°ê±´ì„ ë§Œì¡±í•˜ì§€ ëª»í•˜ëŠ” ê²½ë¡œë¥¼ ì¡°ê¸°ì— ì°¨ë‹¨í•˜ê³  ëŒì•„ê°€ëŠ” ê²ƒ

## DFS ë°±íŠ¸ë˜í‚¹ ìµœì í™” ë°©ë²•

1. **ê°€ì§€ì¹˜ê¸°(Pruning)**
   - ìœ ë§í•˜ì§€ ì•Šì€ ë…¸ë“œì— ëŒ€í•´ íƒìƒ‰ì„ ì¤‘ë‹¨í•˜ì—¬ ë¶ˆí•„ìš”í•œ ê³„ì‚°ì„ ì¤„ì¸ë‹¤.

2. **ì¡°ê±´ ê²€ì‚¬ ìˆœì„œ ìµœì í™”**
   - ë¹ ë¥´ê²Œ ì‹¤íŒ¨ë¥¼ ë°œê²¬í•  ìˆ˜ ìˆë„ë¡ ì¡°ê±´ì„ ë¨¼ì € ê²€ì‚¬í•œë‹¤.

3. **ìƒíƒœ ë³µì› ìµœì†Œí™”**
   - ê°€ëŠ¥í•œ í•œ ìƒíƒœ ë³µì› ë¹„ìš©ì„ ì¤„ì´ëŠ” ë°©ë²•ì„ ì„¤ê³„í•œë‹¤.

## ìš”ì•½

- DFSëŠ” ê¹Šì´ ìš°ì„  íƒìƒ‰ì´ë‹¤.
- ë°±íŠ¸ë˜í‚¹ì€ DFSì— ì¡°ê±´ ê²€ì‚¬ë¥¼ ì¶”ê°€í•˜ì—¬ ë¶ˆí•„ìš”í•œ íƒìƒ‰ì„ ì¤„ì´ëŠ” ê¸°ë²•ì´ë‹¤.
- DFS + ë°±íŠ¸ë˜í‚¹ ì¡°í•©ì€ ë§ì€ ê²½ìš°ì˜ ìˆ˜ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ íƒìƒ‰í•  ë•Œ ìœ ìš©í•˜ë‹¤.
- ìµœì í™”ë¥¼ ìœ„í•´ ê°€ì§€ì¹˜ê¸°ë¥¼ ì ê·¹ì ìœ¼ë¡œ í™œìš©í•œë‹¤.

---

<br/>

## ğŸ“Œ ì£¼ìš” ì‘ìš© ì˜ˆì‹œ

- **ê·¸ë˜í”„ íƒìƒ‰** (ëª¨ë“  ì •ì  ë°©ë¬¸)
- **ê²½ë¡œ ì°¾ê¸°** (ë‘ ë…¸ë“œ ì‚¬ì´ì˜ ê²½ë¡œ)
- **ì‚¬ì´í´ ê²€ì‚¬** (ë°©ë¬¸ ì¤‘ì— ë‹¤ì‹œ ë°©ë¬¸í•˜ëŠ” ì •ì  ì¡´ì¬ ì—¬ë¶€)
- **ë¯¸ë¡œ íƒìƒ‰** (ì¶œêµ¬ ì°¾ê¸°)
- **ìœ„ìƒ ì •ë ¬**, **íŠ¸ë¦¬ì˜ ê¹Šì´ ê³„ì‚°** ë“±

---

<br/>

## ğŸ” ì‹œê°„ ë° ê³µê°„ ë³µì¡ë„

| í•­ëª©           | ë³µì¡ë„        |
|----------------|---------------|
| ì‹œê°„ ë³µì¡ë„    | O(V + E)      |
| ê³µê°„ ë³µì¡ë„    | O(V) + í˜¸ì¶œ ìŠ¤íƒ or ëª…ì‹œì  ìŠ¤íƒ |

(V: ì •ì  ê°œìˆ˜, E: ê°„ì„  ê°œìˆ˜)

---



<br/>
<br/>


# C++ BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰) ì •ë¦¬

<br/>

## ğŸ§­ ê°œìš”

BFS(Breadth-First Search, ë„ˆë¹„ ìš°ì„  íƒìƒ‰)ëŠ” ì‹œì‘ ë…¸ë“œì—ì„œ ê°€ê¹Œìš´ ë…¸ë“œë¶€í„° íƒìƒ‰í•´ë‚˜ê°€ëŠ” ê·¸ë˜í”„ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤. ì£¼ë¡œ **í(queue)** ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„ë©ë‹ˆë‹¤.

---

<br/>

## ğŸ§  íŠ¹ì§•

- **í ê¸°ë°˜**
- ê°€ì¥ ê°€ê¹Œìš´ ê±°ë¦¬ì˜ ì •ì ì„ ë¨¼ì € ë°©ë¬¸í•¨
- **ìµœë‹¨ ê²½ë¡œ íƒìƒ‰**ì— í™œìš©
- ë¬´ë°©í–¥/ìœ í–¥ ê·¸ë˜í”„ ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥

---

<br/>

## ğŸ”§ BFS êµ¬í˜„ ì˜ˆì‹œ

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

vector<vector<int>> graph;
vector<bool> visited;

void bfs(int start) {
    queue<int> q;
    visited[start] = true;
    q.push(start);

    while (!q.empty()) {
        int node = q.front(); q.pop();
        cout << node << ' ';

        for (int next : graph[node]) {
            if (!visited[next]) {
                visited[next] = true;
                q.push(next);
            }
        }
    }
}

int main() {
    int n = 5;
    graph.resize(n + 1);
    visited.resize(n + 1, false);

    // ì˜ˆì œ ê°„ì„  ì¶”ê°€
    graph[1] = {2, 3};
    graph[2] = {4};
    graph[3] = {5};

    bfs(1); // 1ë²ˆ ë…¸ë“œë¶€í„° BFS ì‹œì‘
}
```

---
<br/>
## ğŸ“Œ ì£¼ìš” ì‘ìš© ì˜ˆì‹œ

- **ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰** (ê°€ì¤‘ì¹˜ ì—†ëŠ” ê·¸ë˜í”„)
- **ë¯¸ë¡œ íƒìƒ‰ ë¬¸ì œ**
- **ë‹¤ë‹¨ê³„ íƒìƒ‰ (ì†Œì…œ ê·¸ë˜í”„)**
- **ë ˆë²¨ ìˆœì„œ íƒìƒ‰ (íŠ¸ë¦¬)**
- **ìµœì†Œ ì´ë™ íšŸìˆ˜ ê³„ì‚°**

---
<br/>
## ğŸ” ì‹œê°„ ë° ê³µê°„ ë³µì¡ë„

| í•­ëª©           | ë³µì¡ë„        |
|----------------|---------------|
| ì‹œê°„ ë³µì¡ë„    | O(V + E)      |
| ê³µê°„ ë³µì¡ë„    | O(V) + í ê³µê°„ |

(V: ì •ì  ê°œìˆ˜, E: ê°„ì„  ê°œìˆ˜)

---


<br/>
<br/>

## DFS BFS ì•Œê³ ë¦¬ì¦˜ ìš”ì•½
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
#include <stack>
#include <algorithm>

#define MAX_SIZE 25

using namespace std;

// ìœ„, ì˜¤ë¥¸, ì•„ë˜, ì™¼
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

int n; // í–‰ê³¼ ì—´ì˜ ìˆ˜
int group_id; // ë‹¨ì§€ì˜ ë²ˆí˜¸ë¡œ ì²«ë²ˆì§¸ ë‹¨ì§€ë¶€í„° 1ë¡œ ì‹œì‘
int groups[MAX_SIZE * MAX_SIZE]; // ê° ë‹¨ì§€ë³„ ì§‘ì˜ ìˆ˜

int map[MAX_SIZE][MAX_SIZE]; // ì§€ë„
bool visited[MAX_SIZE][MAX_SIZE]; // ë°©ë¬¸í–ˆëŠ”ì§€ë¥¼ í‘œì‹œí•˜ëŠ” ì§€ë„

// DFS - Recursion
void dfs_recursion(int x, int y) {

    // í•¨ìˆ˜ì— ë“¤ì–´ì™”ìœ¼ë©´ -> ë°©ë¬¸ìœ¼ë¡œ í‘œì‹œ
    visited[x][y] = true;
    // í•´ë‹¹ ë‹¨ì§€ì˜ ì§‘ì˜ ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚´
    groups[group_id]++;

    // í•´ë‹¹ ìœ„ì¹˜ì˜ ì£¼ë³€ì„ í™•ì¸
    for(int i = 0; i < 4; i++){
        int nx = x + dx[i];
        int ny = y + dy[i];

        // ì§€ë„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ 
        if(0 <= nx && nx < n && 0 <= ny && ny < n){
            // ì§‘ì´ë©´ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ -> ë°©ë¬¸
            if(map[nx][ny] == 1 && visited[nx][ny] == false){
                dfs_recursion(nx, ny);
            }
        }
    }
}

// DFS - Stack
void dfs_stack(int x, int y) {

    stack< pair<int,int> > s; // ì´ìš©í•  ìŠ¤íƒ, (x,y) -> (í–‰, ì—´)
    s.push(make_pair(x,y)); // pairë¥¼ ë§Œë“¤ì–´ì„œ stackì— ë„£ìŠµë‹ˆë‹¤.

    // ì²˜ìŒ x,yë¥¼ ë°©ë¬¸ í–ˆê¸°ë•Œë¬¸ì—
    visited[x][y] = true;
    groups[group_id]++;

    while(!s.empty()){

        // ìŠ¤íƒì˜ top ì›ì†Œ êº¼ë‚´ê¸°
        x = s.top().first;
        y = s.top().second;
        s.pop();

        // í•´ë‹¹ ìœ„ì¹˜ì˜ ì£¼ë³€ì„ í™•ì¸
        for(int i = 0; i < 4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];

            // ì§€ë„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ 
            if(0 <= nx && nx < n && 0 <= ny && ny < n){
                // ì§‘ì´ë©´ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ -> ë°©ë¬¸
                if(map[nx][ny] == 1 && visited[nx][ny] == false){
                    visited[nx][ny]=true;

                    // í•´ë‹¹ ë‹¨ì§€ì˜ ì§‘ì˜ ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚´
                    groups[group_id]++;

                    s.push(make_pair(x,y)); // pushí•˜ëŠ” ê²½ìš°ì´ê¸° ë•Œë¬¸ì— í˜„ì¬ ìœ„ì¹˜ë„ ë„£ì–´ì¤€ë‹¤.
                    s.push(make_pair(nx,ny)); // ìŠ¤íƒì— í˜„ì¬ nx,nyë„ í‘¸ì‹œ
                }
            }
        }   
    }
}

// BFS
void bfs(int x, int y){

    queue< pair<int,int> > q; // ì´ìš©í•  í, (x,y) -> (í–‰, ì—´)
    q.push(make_pair(x,y)); // pairë¥¼ ë§Œë“¤ì–´ì„œ queueì— ë„£ìŠµë‹ˆë‹¤.

    // ì²˜ìŒ x,yë¥¼ ë°©ë¬¸ í–ˆê¸°ë•Œë¬¸ì—
    visited[x][y] = true;
    groups[group_id]++;  

    while(!q.empty()){

        // íì˜ í˜„ì¬ ì›ì†Œë¥¼ êº¼ë‚´ê¸°
        x = q.front().first;
        y = q.front().second;
        q.pop();

        // í•´ë‹¹ ìœ„ì¹˜ì˜ ì£¼ë³€ì„ í™•ì¸
        for(int i = 0; i < 4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];

            // ì§€ë„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê³ 
            if(0 <= nx && nx < n && 0 <= ny && ny < n){
                // ì§‘ì´ë©´ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ -> ë°©ë¬¸
                if(map[nx][ny] == 1 && visited[nx][ny] == false){
                    visited[nx][ny]=true;

                    // í•´ë‹¹ ë‹¨ì§€ì˜ ì§‘ì˜ ìˆ˜ë¥¼ ì¦ê°€ì‹œí‚´
                    groups[group_id]++;

                    // íì— í˜„ì¬ nx,nyë¥¼ ì¶”ê°€
                    q.push(make_pair(nx,ny));   
                }
            }
        }
    }
}

int main (){

    scanf("%d", &n);

    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++)
            //ì…ë ¥ì„ 1ê°œì”© ìˆ«ìë¡œ ëŠì–´ì„œ ë°›ìŠµë‹ˆë‹¤ -> %1d
            scanf("%1d", &map[i][j]);
    }

    // ì „ì²´ ì§€ë„ íƒìƒ‰
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            // ì§‘ì´ë©´ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ -> ë°©ë¬¸
            if(map[i][j]==1 && visited[i][j]==false){

                // í•´ë‹¹ ì§€ì—­ì— ë‹¨ì§€ idë¥¼ ë¶€ì—¬í•˜ê³ 
                group_id++;

                // íƒìƒ‰
                //dfs_recursion(i, j);
                //dfs_stack(i, j);
                //bfs(i, j);
            }
        }
    }

    sort(groups + 1, groups + group_id + 1);

    printf("%d\n", group_id);
    for (int i = 1; i <= group_id; i++) {
        printf("%d\n", groups[i]);
    }
}
```
## BFS

```cpp

```

<br/>

## Hash

STL ì—ì„œëŠ” map container ë¥¼ í†µí•´ ê°„ë‹¨íˆ êµ¬í˜„ ê°€ëŠ¥

```cpp

#define MAX_TABLE (10007)

unsigned long hash(const char* str)
{
    unsigned long hash = 5381;
    int c;

    while (c = *str++)
    {
        hash = (((hash << 5) + hash) + c) % MAX_TABLE;
    }

    return hash % MAX_TABLE;
}
```

<br/>

## Union Find


```cpp

```

<br/>

## Binary search


```cpp

```

<br/>
## ë¶€ë¶„í•©

```cpp

```

<br/>
## Segment Tree

```cpp

```

<br/>
## Priority Queue

```cpp

```

<br/>
## Trie 

```cpp

```

<br/>
## ì •ë ¬

```cpp

```

<br/>
## KMP

```cpp

```

<br/>
