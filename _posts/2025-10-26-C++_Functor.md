---
layout : post
title : C++_Functor
comments : true
categories : 
- CodingTest
tags : [CodingTest, C++]
---

# C++_Functor

# 1. Functor란?

**Functor(펑터)** 는 **함수처럼 동작하는 객체(Function Object)** 를 의미한다.  
즉, **클래스나 구조체 내부에 operator() 연산자를 정의하여, 객체를 함수처럼 호출할 수 있도록 만든 것**이다.

C++에서는 함수 포인터보다 **상태를 보존할 수 있는 함수 객체**가 더 유연하게 사용된다.  
Functor는 **STL(Standard Template Library)** 의 핵심 구성 요소로, 알고리즘(예: sort, find, transform)과 컨테이너(priority_queue, map 등)에서 **비교자, 조건자, 변환자**로 자주 사용된다.

---

# 2. Functor의 기본 형태

```cpp
#include <iostream>
using namespace std;

struct Adder {
    int base;
    int operator()(int x) const {
        return base + x;
    }
};

int main() {
    Adder add{10};
    cout << add(5) << "\n"; // add.operator()(5) 와 동일, 결과는 15
}
```

이때 `Adder` 객체는 **함수처럼 호출 가능**하다.  
즉, `add(5)` 는 `add.operator()(5)` 를 호출하는 문법적 축약이다.

**Functor의 장점**
- 상태(`base`)를 내부에 유지 가능
- 컴파일 시 인라인 최적화 가능
- 함수 포인터보다 타입 안정성이 높음

---

# 3. struct cmp 비교자 Functor 예시

priority_queue, sort, set, map 등에서 **정렬 기준**을 바꾸려면 Functor를 직접 정의한다.

```cpp
struct Edge {
    int to;
    int cost;
};

struct cmp {
    bool operator()(const Edge& a, const Edge& b) const {
        return a.cost > b.cost;
    }
};
```

이 Functor는 **비교자(Comparator)** 로 동작한다.  
`a.cost > b.cost` 를 반환하므로, **비용(cost)** 이 작은 Edge 가 더 높은 우선순위를 가진다.  
즉, **min-heap** 형태의 priority_queue를 만들 때 사용한다.

---

# 4. 문법 요소별 해석

| 문법 요소 | 설명 |
|------------|------|
| **struct cmp** | 비교용 Functor 정의 |
| **operator()** | 함수 호출 연산자 오버로딩 (객체를 함수처럼 호출) |
| **const Edge& a, const Edge& b** | 복사 없이 참조로 전달하며, 원본을 변경하지 않음 |
| **함수 뒤 const** | Functor 객체가 상수 컨텍스트에서 호출되어도 동작 가능하도록 보장 |

즉, `operator()` 함수는 다음과 같이 동작한다.

```cpp
cmp cmpObj;
Edge e1{1, 5}, e2{2, 3};
bool result = cmpObj(e1, e2); // cmpObj.operator()(e1, e2)
```

이때 `result` 는 `true` (5 > 3)이므로, e1이 e2보다 우선순위가 낮다는 의미다.

---

# 5. priority_queue에서의 사용 예시

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Edge {
    int to;
    int cost;
};

struct cmp {
    bool operator()(const Edge& a, const Edge& b) const {
        return a.cost > b.cost;
    }
};

int main() {
    priority_queue<Edge, vector<Edge>, cmp> pq;

    pq.push({1, 5});
    pq.push({2, 3});
    pq.push({3, 7});

    while (!pq.empty()) {
        auto e = pq.top();
        pq.pop();
        cout << e.to << ":" << e.cost << "\n";
    }
}
```

**출력**
```
2:3
1:5
3:7
```

이처럼 Functor를 통해 priority_queue를 **최소 힙(min-heap)** 으로 구성할 수 있다.

---

# 6. Functor vs Lambda

Functor와 Lambda는 같은 기능을 수행할 수 있다.  
람다는 C++11 이후 Functor를 간결하게 표현하는 문법이다.

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Edge { int to; int cost; };

int main() {
    auto cmp = [](const Edge& a, const Edge& b) {
        return a.cost > b.cost;
    };
    priority_queue<Edge, vector<Edge>, decltype(cmp)> pq(cmp);

    pq.push({1, 5});
    pq.push({2, 3});
    pq.push({3, 7});

    while (!pq.empty()) {
        auto e = pq.top(); pq.pop();
        cout << e.to << ":" << e.cost << "\n";
    }
}
```

**람다**는 문법이 간단하고, 지역 범위에서 쉽게 정의할 수 있지만,  
**Functor**는 명시적 타입 정의가 가능하고 **복잡한 비교 로직이나 상태를 유지할 때 유리하다.**

---

# 7. Functor가 STL에서 쓰이는 이유

STL 알고리즘과 컨테이너는 **함수를 인자로 받는 일반화된 구조**를 갖는다.  
이때 Functor를 사용하면 **템플릿 기반 타입 안정성과 인라인 최적화**가 가능하다.

예시: sort()에서 Functor를 이용한 사용자 정의 정렬
```cpp
struct cmpInt {
    bool operator()(int a, int b) const { return a > b; }
};

vector<int> v = {5, 1, 4, 2};
sort(v.begin(), v.end(), cmpInt()); // Functor 객체 전달
```

**결과:** 1 2 4 5

---

# 8. 요약

| 항목 | 설명 |
|------|------|
| **Functor** | 함수처럼 동작하는 객체 |
| **operator()** | 함수 호출 연산자 오버로딩 |
| **cmp 구조체** | 비교자 Functor, 우선순위 큐에서 사용 |
| **const 참조** | 불필요한 복사 방지 및 안전성 확보 |
| **함수 뒤 const** | 상수 객체 호출 보장 |
| **priority_queue에서 cmp 사용** | min-heap 구성 가능 |
| **람다(lambda)** | Functor의 간결한 형태 (C++11 이후) |

---
