---
layout : post
title : 최단 경로
comments : true
categories :
- CodingTest
tags : [CodingTest, Dijkstra]
---

# 최단 경로

[https://www.acmicpc.net/problem/1753](https://www.acmicpc.net/problem/1753)


## 문제
방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.

## 입력
첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.

## 출력
첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.



## 풀이

```cpp

#include <iostream>
#include <vector>
#include <queue>
#include <climits>

#define MAX_LEN 20001
using namespace std;

typedef struct{
    int dest;
    int weight;
}edge_t;

struct compare{
    bool operator()(const edge_t& a, const edge_t& b) const {
        return a.weight > b.weight;
    }
};
int V, E, K;
vector<edge_t> graph[MAX_LEN];
int dist[MAX_LEN] = { 0 };

void input()
{
    cin >> V >> E;

    cin >> K;

    for(int i = 0; i < E; i++){
        int u, v, w;
        cin >> u >> v >> w;
        graph[u].push_back({v, w});
    }
}

void dijkstra(int start)
{
    priority_queue<edge_t, vector<edge_t>, compare> pq;
    pq.push({start, 0});
    dist[start] = 0;


    while(!pq.empty()){
        edge_t cur_node = pq.top();
        pq.pop();
        int cur_dest = cur_node.dest;
        int cur_weight = cur_node.weight;

        if(cur_weight > dist[cur_dest])
            continue;

        for(auto &next_node : graph[cur_dest]){
            int next_dest = next_node.dest;
            int next_weight = dist[cur_dest] + next_node.weight;

            if(next_weight < dist[next_dest]){
                pq.push({next_dest, next_weight});
                dist[next_dest] = next_weight;
            }
        }
    }

}
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();

    for(int i = 1; i < MAX_LEN; i++){
        dist[i] = INT_MAX;
    }

    dijkstra(K);

    for(int i = 1 ; i <= V; i++){
        if(dist[i] == INT_MAX)
            cout << "INF\n";
        else
            cout << dist[i] << "\n";
    }


    return 0;
}

```
