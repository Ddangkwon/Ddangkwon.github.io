---
layout : post
title : STL_Deque
comments : true
categories : 
- CodingTest
tags : [CodingTest, STL]
---


# 개요

**deque(Double-ended queue)** 는 양쪽 끝에서 삽입과 삭제가 모두 **상수 시간 평균**으로 가능한 시퀀스 컨테이너이다. 내부적으로는 **세그먼트 블록 배열 + 인덱스 테이블** 구조를 사용하여 앞과 뒤에서의 연산이 모두 빠르다. **vector** 와 달리 앞쪽 연산이 효율적이다.

---

# 헤더와 기본 선언

```cpp
#include <deque>
#include <iostream>
using namespace std;

int main() {
    deque<int> dq;              // 기본 생성
    deque<int> dq2(5, 7);       // 길이 5, 값 7로 초기화
    deque<int> dq3 = {1,2,3};   // 리스트 초기화
}
```

---

# 주요 특징 요약

- 앞뒤 양쪽 끝에서 **push/pop** 이 평균 O(1) 이다.
- 임의 접근(Random access) 지원. **operator[]**, **at** 사용 가능. (O(1))
- 중간 삽입/삭제는 요소 이동 비용으로 인해 O(n) 이다.
- 메모리 배치가 분절되어 있어 **vector** 보다 연속성이 떨어진다.
- iterator 무효화 규칙이 **vector** 와 다르다. 앞/뒤 삽입 시 더 자주 무효화될 수 있다.

---

# 멤버 함수 총정리

## 생성자와 대입

- deque()
- deque(size_type n)
- deque(size_type n, const T& value)
- deque(InputIt first, InputIt last)
- deque(const deque& other), deque(deque&& other)
- operator=, assign(count, value), assign(first, last), assign(init_list)

## 용량

- size(), empty(), max_size()
- resize(n), resize(n, value)
- shrink_to_fit()  메모리 회수 요청 (강제 보장 아님)

## 요소 접근

- at(pos)  범위 검사 후 예외 던짐
- front(), back()

## 수정

- push_back(value), emplace_back(args...)
- push_front(value), emplace_front(args...)
- pop_back(), pop_front()
- insert(pos, value), insert(pos, count, value), insert(pos, first, last), insert(pos, init_list)
- emplace(pos, args...)
- erase(pos), erase(first, last)
- clear(), swap(deque& other)

## 반복자

- begin(), end(), cbegin(), cend()
- rbegin(), rend(), crbegin(), crend()

---

# 사용 패턴과 예제

## 1. 양쪽 큐 동작

```cpp
#include <deque>
#include <iostream>
using namespace std;

int main() {
    deque<int> dq;
    dq.push_back(2);   // [2]
    dq.push_front(1);  // [1,2]
    dq.push_back(3);   // [1,2,3]

    cout << dq.front() << " " << dq.back() << "\n"; // 1 3

    dq.pop_front();    // [2,3]
    dq.pop_back();     // [2]

    cout << dq[0] << "\n"; // 2 (경계 체크 없음)
    return 0;
}
```

## 2. 슬라이딩 윈도우 최대값 O(n) (Monotonic deque)

```cpp
#include <bits/stdc++.h>
using namespace std;

// 윈도우 크기 k 에 대해 각 위치의 최대값을 계산한다.
vector<int> sliding_max(const vector<int>& a, int k) {
    deque<int> dq; // 인덱스를 저장, a[dq] 가 단조 감소
    vector<int> ans;
    for (int i = 0; i < (int)a.size(); ++i) {
        // 윈도우 범위 밖 인덱스 제거
        if (!dq.empty() && dq.front() <= i - k) dq.pop_front();
        // 새 원소보다 작은 값들은 뒤에서 제거(단조성 유지)
        while (!dq.empty() && a[dq.back()] <= a[i]) dq.pop_back();
        dq.push_back(i);
        if (i >= k - 1) ans.push_back(a[dq.front()]);
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    vector<int> a = {1, 3, -1, -3, 5, 3, 6, 7};
    auto res = sliding_max(a, 3);
    for (auto x : res) cout << x << " "; // 3 3 5 5 6 7
    cout << "\n";
}
```

## 3. 0-1 BFS (가중치 0 또는 1인 최단거리)

```cpp
#include <bits/stdc++.h>
using namespace std;

const int INF = 1e9;

int main() {
    int n, m; // 정점, 간선
    cin >> n >> m;
    vector<vector<pair<int,int>>> g(n); // (to, w) w in {0,1}
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w; // 0 또는 1
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    deque<int> dq;
    vector<int> dist(n, INF);
    int s = 0;
    dist[s] = 0;
    dq.push_front(s);
    while (!dq.empty()) {
        int u = dq.front(); dq.pop_front();
        for (auto [v, w] : g[u]) {
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                if (w == 0) dq.push_front(v);
                else dq.push_back(v);
            }
        }
    }
    for (int i = 0; i < n; ++i) cout << dist[i] << " ";
    cout << "\n";
    return 0;
}
```

## 4. 회전(rotate) 시뮬레이션 예시

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    deque<int> dq = {1,2,3,4,5};

    // 오른쪽으로 k 스텝 회전
    int k = 2;
    while (k--) {
        dq.push_front(dq.back());
        dq.pop_back();
    }
    for (auto x : dq) cout << x << " "; // 4 5 1 2 3
    cout << "\n";

    // 왼쪽으로 1 스텝 회전
    dq.push_back(dq.front());
    dq.pop_front();
    for (auto x : dq) cout << x << " "; // 5 1 2 3 4
    cout << "\n";
}
```

---

# vector 와의 비교

- **앞쪽 연산**  
  deque 의 push_front/pop_front 는 평균 O(1) 이다. vector 는 앞쪽 삽입이 O(n) 이다.
- **메모리 연속성**  
  vector 는 메모리가 연속이어서 캐시 지역성이 좋다. deque 는 블록 기반으로 연속성이 떨어진다.
- **중간 삽입/삭제**  
  둘 다 O(n) 이다. 빈번하면 list 또는 다른 자료구조 고려.
- **iterator 무효화**  
  deque 는 양끝 삽입/삭제로도 반복자가 무효화될 수 있다. 반복자 안정성이 필요하면 주의한다.

---

# 성능 및 주의사항

- **at** 은 경계 검사를 수행하므로 안전하지만 약간 느리다. operator[] 는 빠르지만 범위 체크를 하지 않는다.
- 자주 참조하는 데이터는 vector 가 더 빠를 수 있다. deque 는 **양쪽 끝 연산** 위주의 시나리오에 적합하다.
- 반복자 무효화 규칙에 유의한다. 특히 루프에서 erase/pop 을 섞을 때는 주의한다.
- shrink_to_fit 는 강제 보장이 아니다. 메모리 회수는 구현 의존적이다.

---

# 표준 시간복잡도 표

| 연산 | 복잡도 |
|------|--------|
| push_front / push_back | 평균 O(1) |
| pop_front / pop_back | 평균 O(1) |
| operator[] / at | O(1) |
| front / back | O(1) |
| insert / erase (중간) | O(n) |
| size / empty | O(1) |

---

# 마무리

deque 는 앞과 뒤에서의 삽입·삭제 성능이 요구되는 상황에서 최적의 선택이다. 슬라이딩 윈도우, 0-1 BFS, 시뮬레이션(회전, 덱 게임) 등에서 자주 사용한다. vector 가 기본값이라면, **앞쪽 연산이 많은 경우** deque 로 바꿔서 성능을 확보한다.


