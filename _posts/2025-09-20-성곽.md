---
layout : post
title : 성곽
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# 성곽

[https://www.acmicpc.net/problem/2234](#https://www.acmicpc.net/problem/2234)

## 문제


대략 위의 그림과 같이 생긴 성곽이 있다. 굵은 선은 벽을 나타내고, 점선은 벽이 없어서 지나다닐 수 있는 통로를 나타낸다. 이러한 형태의 성의 지도를 입력받아서 다음을 계산하는 프로그램을 작성하시오.

1. 이 성에 있는 방의 개수
2. 가장 넓은 방의 넓이
3. 하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기


위의 예에서는 방은 5개고, 가장 큰 방은 9개의 칸으로 이루어져 있으며, 위의 그림에서 화살표가 가리키는 벽을 제거하면 16인 크기의 방을 얻을 수 있다.

성은 M × N(1 ≤ M, N ≤ 50)개의 정사각형 칸으로 이루어진다. 성에는 최소 두 개의 방이 있어서, 항상 하나의 벽을 제거하여 두 방을 합치는 경우가 있다.

## 입력
첫째 줄에 두 정수 N, M이 주어진다. 다음 M개의 줄에는 N개의 정수로 벽에 대한 정보가 주어진다. 벽에 대한 정보는 한 정수로 주어지는데, 서쪽에 벽이 있을 때는 1을, 북쪽에 벽이 있을 때는 2를, 동쪽에 벽이 있을 때는 4를, 남쪽에 벽이 있을 때는 8을 더한 값이 주어진다. 참고로 이진수의 각 비트를 생각하면 쉽다. 따라서 이 값은 0부터 15까지의 범위 안에 있다.

## 출력
첫째 줄에 1의 답을, 둘째 줄에 2의 답을, 셋째 줄에 3의 답을 출력한다.

## 풀이

```cpp
#include <iostream>
#include <queue>
#include <algorithm>

#define ARR_MAX_LEN 55

using namespace std;

int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN][2] = { false };
int N, M, max_space = 0, num_area = 0, max_space_break_wall = 0;
// 서북동남
int dy[4] = { 0, -1, 0, 1 };
int dx[4] = { -1, 0, 1, 0 };

typedef struct {
    int y;
    int x;
}loc_t;

void input(void) {

    cin >> N >> M;

    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            cin >> arrmap[i][j];
        }
    }

}

int bfs(int y, int x) {
    int area_cnt = 0;
    queue<loc_t> q;

    q.push({ y, x });
    isvisited[y][x][0] = true;

    while (!q.empty()) {
        int cy = q.front().y;
        int cx = q.front().x;
        area_cnt++;

        q.pop();

        for (int dir = 0; dir < 4; dir++) {
            int ny = cy + dy[dir];
            int nx = cx + dx[dir];

            if (ny < 0 || ny >= M || nx < 0 || nx >= N)
                continue;

            if (!isvisited[ny][nx][0] && ((arrmap[cy][cx] & (1 << dir)) == 0)) {
                q.push({ ny, nx });
                isvisited[ny][nx][0] = true;
                //cout << ny << " " << nx << " " << dir << "\n";
            }

        }
    }

    return area_cnt;
}

int break_wall_bfs(int y, int x) {

    int area_cnt = 1;
    queue<loc_t> q;

    q.push({ y, x });
    isvisited[y][x][0] = true;

    while (!q.empty()) {
        int cy = q.front().y;
        int cx = q.front().x;

        q.pop();

        for (int dir = 0; dir < 4; dir++) {
            int ny = cy + dy[dir];
            int nx = cx + dx[dir];

            if (ny < 1 || ny > M || nx < 1 || nx > N)
                continue;

            // 



        }
    }

    return area_cnt;
}

int main(void) {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();


    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            if (!isvisited[i][j][0]) {
                // cout << "check\n";
                max_space = max(max_space, bfs(i, j));
                //break_wall_bfs(i, j)
                num_area++;
            }
        }
    }

    cout << num_area << "\n";
    cout << max_space << "\n";
    cout << max_space_break_wall << "\n";

    return 0;
}
```


