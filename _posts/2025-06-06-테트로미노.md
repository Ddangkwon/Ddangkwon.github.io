---
layout : post
title : 원자 소멸 시뮬레이션
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]

---

# 원자 소멸 시뮬레이션

## 문제
폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.

- 정사각형은 서로 겹치면 안 된다.
- 도형은 모두 연결되어 있어야 한다.

정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.
정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.



아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.

테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.

테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.

## 입력
첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)

둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.

## 출력
첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.

## 풀이


### 테트리미노 개수 및 고려사항

회전 및 대칭을 고려하면 예측 가능한 테트리미노의 총 개수는 **19개**이다.  
각 테트리미노의 모양을 고려하여 전체 입력 배열을 탐색하면서 해당 위치에 테트리미노가 놓일 수 있는지를 확인하고, 가능한 경우마다 그 위치에서의 합을 구해 최대값을 갱신한다.

### 배열 범위 초과에 대한 고려

일반적으로 테트리미노는 최대 4x4의 형태를 가지므로, 입력 배열에서 테트리미노를 놓을 수 있는 **모든 시작 지점**을 순회한다.  
이때 테트리미노 일부가 배열의 범위를 넘어가게 되면 **오류가 발생할 수 있으므로**, 아래와 같은 방식으로 방지할 수 있다:

- 입력 배열 외곽에 **여유 공간을 확보한 확장 배열**을 사용
- 또는 테트리미노가 놓일 때마다 해당 좌표가 **범위 내인지 확인하는 조건문**을 추가

이렇게 하면 테트리미노가 배열의 경계를 넘지 않도록 하면서도 **모든 가능한 위치**에 대해 최대 합을 계산할 수 있다.

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

#define ARR_MAX_LEN 550

using namespace std;

int N, M, answer = 0;
int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };

// 2 + 1 + 8 + 4 + 4
int tetrimino[19][4][4] = {
	// ----
	{
		{1, 1, 1, 1},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{1, 0, 0, 0},
		{1, 0, 0, 0},
		{1, 0, 0, 0},
		{1, 0, 0, 0},
	},
	// --
	// --
	{
		{1, 1, 0, 0},
		{1, 1, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},

	// -
	// -
	// --
	{
		{1, 0, 0, 0},
		{1, 0, 0, 0},
		{1, 1, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{1, 1, 1, 0},
		{1, 0, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},

	{
		{1, 1, 0, 0},
		{0, 1, 0, 0},
		{0, 1, 0, 0},
		{0, 0, 0, 0},
	},

	{
		{0, 0, 1, 0},
		{1, 1, 1, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},
	//  -
	//  -
	// --
	{
		{0, 1, 0, 0},
		{0, 1, 0, 0},
		{1, 1, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{1, 0, 0, 0},
		{1, 1, 1, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},

	{
		{1, 1, 0, 0},
		{1, 0, 0, 0},
		{1, 0, 0, 0},
		{0, 0, 0, 0},
	},

	{
		{1, 1, 1, 0},
		{0, 0, 1, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},

	// -
	// --
	//  -
	{
		{1, 0, 0, 0},
		{1, 1, 0, 0},
		{0, 1, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{0, 1, 1, 0},
		{1, 1, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},
	//  -
	// --
	// -
	{
		{0, 1, 0, 0},
		{1, 1, 0, 0},
		{1, 0, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{1, 1, 0, 0},
		{0, 1, 1, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},
	//  -
	// ---
	{
		{0, 1, 0, 0},
		{1, 1, 1, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{1, 0, 0, 0},
		{1, 1, 0, 0},
		{1, 0, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{1, 1, 1, 0},
		{0, 1, 0, 0},
		{0, 0, 0, 0},
		{0, 0, 0, 0},
	},
	{
		{0, 1, 0, 0},
		{1, 1, 0, 0},
		{0, 1, 0, 0},
		{0, 0, 0, 0},
	},
};


void input_func() {

	cin >> N >> M;
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> arrmap[i][j];
		}
	}
}


void simulate() {
	
	for (int k = 0; k < 19; k++) {
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				int temp_sum = 0;
				for (int y = 0; y < 4; y++) {
					for (int x = 0; x < 4; x++) {
						// 어차피 0, 아니면 1이기 때문에 이 방식도 사용 가능 (속도는 더 느릴듯..)
						// temp_sum += arrmap[i + y][j + x] * tetrimino[k][y][x];
						
						if (tetrimino[k][y][x] == 1)
							temp_sum += arrmap[i + y][j + x];
						
					}
				}
				answer = max(answer, temp_sum);
			}
		}
		
	}
}

int main() {
	
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	input_func();
	simulate();

	cout << answer << "\n";
	return 0;
}
```

