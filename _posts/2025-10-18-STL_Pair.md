---
layout : post
title : STL_Pair
comments : true
categories : 
- CodingTest
tags : [CodingTest, STL, Container]
---


# Pair (STL) 개요

# 개요

**pair** 는 두 개의 값을 하나의 단위로 묶는 **STL 컨테이너 어댑터(Container Adapter)** 이다. 서로 다른 타입을 조합할 수 있고, 가벼운 레코드 레벨 구조로 쓰인다. **정렬**, **우선순위 큐(priority_queue)**, **map**, **unordered_map** 에서 보조 키로 자주 쓰인다.

---

# 헤더와 기본 선언

```cpp
#include <iostream>
#include <utility>   // pair
using namespace std;

int main() {
    pair<int, string> p1;                // 기본 생성. first=0, second=""
    pair<int, string> p2(7, "seven");    // 생성자
    pair<int, string> p3 = make_pair(3, "three"); // make_pair
    pair<int, string> p4{10, "ten"};     // 중괄호 초기화(C++11+)

    cout << p2.first << " / " << p2.second << "\n"; // 7 / seven
}
```

포인트
- **make_pair** 는 템플릿 인자 추론을 위해 유용하다.
- C++11 이후 **중괄호 초기화**가 가장 간단하다.

---

# 값 접근과 수정

```cpp
#include <iostream>
#include <utility>
using namespace std;

int main() {
    pair<int, double> p{1, 3.14};
    p.first = 2;
    p.second = 6.28;
    cout << p.first << ", " << p.second << "\n"; // 2, 6.28
}
```

---

# 구조적 바인딩(Structured Binding)과 tie

```cpp
#include <iostream>
#include <utility>
#include <tuple>   // tie
using namespace std;

pair<int, string> get_user() { return {42, "alice"}; }

int main() {
    // 구조적 바인딩(C++17)
    auto [id, name] = get_user();
    cout << id << " " << name << "\n";

    // tie (C++11)
    int i; string s;
    tie(i, s) = get_user();
    cout << i << " " << s << "\n";
}
```

구조적 바인딩은 가독성이 좋다. 구 표준 호환이 필요하면 **tie** 를 쓴다.

---

# 비교 연산과 정렬 규칙

**pair** 는 사전식 비교(lexicographical order)를 지원한다.

규칙
- 먼저 **first** 를 비교한다.
- **first** 가 같으면 **second** 를 비교한다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<pair<int,int>> v = {{2,3}, {1,5}, {1,2}, {2,1}};
    sort(v.begin(), v.end()); // 사전식 오름차순
    // 결과: (1,2), (1,5), (2,1), (2,3)
    for (auto &x : v) cout << "(" << x.first << "," << x.second << ") ";
    cout << "\n";
}
```

- 내림차순은 비교자 사용

```cpp
#include <bits/stdc++.h>
using namespace std;

struct cmp_desc {
    bool operator()(const pair<int,int>& a, const pair<int,int>& b) const {
        if (a.first != b.first) return a.first > b.first;
        return a.second > b.second;
    }
};

int main() {
    vector<pair<int,int>> v = {{2,3}, {1,5}, {1,2}, {2,1}};
    sort(v.begin(), v.end(), cmp_desc());
    for (auto &x : v) cout << "(" << x.first << "," << x.second << ") ";
    cout << "\n";
}
```

---

# priority_queue 에서의 pair

기본 priority_queue 는 **최대 힙(max-heap)** 이다. pair 는 first 기준으로, 같으면 second 기준으로 비교한다.

**최소 힙(min-heap)** 으로 쓰려면 greater 사용

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    priority_queue<pair<int,int>,
                   vector<pair<int,int>>,
                   greater<pair<int,int>>> pq; // Min-Heap

    pq.push({5, 1});
    pq.push({3, 9});
    pq.push({3, 7});

    while (!pq.empty()) {
        auto t = pq.top(); pq.pop();
        cout << t.first << "," << t.second << "\n";
    }
    // 출력: 3,7 -> 3,9 -> 5,1
}
```

Dijkstra 에서 흔히 **(거리, 정점)** 형태로 사용한다.

---

# map 과 pair

**map<Key, T>** 에서 **value_type** 은 **pair<const Key, T>** 이다.

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    map<string, int> freq;
    freq["apple"]++;
    freq["banana"] += 2;

    for (const auto &kv : freq) { // kv: pair<const string, int>
        cout << kv.first << " -> " << kv.second << "\n";
    }
}
```

**vector** 로 데이터를 모은 뒤 **map** 으로 옮기는 패턴

```cpp
#include <bits/stdc++.h>
using namespace std;
using P = pair<string,int>;

int main() {
    vector<P> v = {{"a",2}, {"b",5}, {"a",3}};
    map<string,int> mp;
    for (auto &e : v) mp[e.first] += e.second;
    for (auto &kv : mp) cout << kv.first << ":" << kv.second << "\n";
}
```

---

# unordered_map 에서 pair 를 키로 쓰기

표준에는 **pair** 의 해시가 기본 제공되지 않는다. **사용자 정의 해시(Hash Function)** 가 필요하다.

```cpp
#include <bits/stdc++.h>
using namespace std;

struct pair_hash {
    size_t operator()(const pair<int,int>& p) const noexcept {
        // 간단한 조합 (Xor + shift). 충돌 분산을 위해 해시 합성 권장.
        return hash<int>()(p.first) ^ (hash<int>()(p.second) << 1);
    }
};

int main() {
    unordered_map<pair<int,int>, int, pair_hash> um;
    um[{1,2}] = 10;
    um[{2,3}] = 20;
    cout << um[{1,2}] << "\n"; // 10
}
```

주의
- **noexcept** 로 표시하면 컨테이너 예외 보장을 돕는다.
- 더 견고한 해시를 원하면 **boost::hash** 또는 커스텀 해시 합성 함수를 사용한다.

---

# make_pair vs 중괄호 초기화

```cpp
auto p1 = make_pair(1, 2);  // 타입 추론
pair<int,int> p2{1, 2};     // 명시적 타입 + 중괄호
```

C++14 이후에는 **중괄호 초기화**가 가독성이 좋아 선호된다. 템플릿 인자 추론이 필요한 컨텍스트에서는 **make_pair** 가 유용하다.

---

# move 와 piecewise_construct

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    string k = "key";
    string v = "value";
    pair<string,string> p1 = make_pair(move(k), move(v)); // 이동 시도

    // map 에 복잡한 생성자 인자를 전달할 때
    map<int, pair<string, string>> mp;
    mp.emplace(1, piecewise_construct,
                  forward_as_tuple(),
                  forward_as_tuple("A", "B")); // value의 pair를 직접 생성
}
```

**piecewise_construct** 는 pair 내부 멤버를 **각각의 생성자 인자 집합으로 직접 생성**하게 하여 불필요한 복사를 줄인다.

---

# 흔한 실수

1. pair 를 정렬할 때 사전식 비교 규칙을 잊는 실수  
2. priority_queue 에서 **Min-Heap** 을 만들지 않고 기본 비교자를 써서 **Max-Heap** 으로 잘못 동작  
3. unordered_map 키로 pair 를 쓰면서 **해시를 정의하지 않음**  
4. **pair<int,int>** 와 같이 의미가 불명확할 경우 **구조체** 로 바꾸어 가독성을 높이는 게 낫다

---

# 실전 스니펫 모음

## 1. 좌표 정렬: x 오름차순, y 오름차순

```cpp
#include <bits/stdc++.h>
using namespace std;
using P = pair<int,int>;

int main() {
    vector<P> pts = {{2,3},{1,5},{1,2},{2,1}};
    sort(pts.begin(), pts.end()); // (x,y) 오름차순
    for (auto &p : pts) 
        cout << p.first << " " << p.second << "\n";
}
```

## 2. 등장 횟수 상위 K개 (빈도, 값) 기준 Min-Heap

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> a = {1,1,1,2,2,3};
    unordered_map<int,int> cnt;
    for (int x : a) cnt[x]++;

    using P = pair<int,int>; // (빈도, 값)
    priority_queue<P, vector<P>, greater<P>> pq; // Min-Heap

    int K = 2;
    for (auto &kv : cnt) {
        pq.push({kv.second, kv.first});
        if ((int)pq.size() > K) pq.pop();
    }
    vector<int> ans;
    while (!pq.empty()) { ans.push_back(pq.top().second); pq.pop(); }
    reverse(ans.begin(), ans.end());
    for (int x : ans) cout << x << " ";
}
```

## 3. 그래프 간선 저장

```cpp
#include <bits/stdc++.h>
using namespace std;
using Edge = pair<int,int>; // (to, weight)

int main() {
    int N = 5;
    vector<vector<Edge>> g(N);
    auto add = [&](int u, int v, int w){
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    };
    add(0,1,2); add(0,2,5); add(1,2,1);
}
```

---

# 마무리

**pair** 는 두 값을 가볍게 묶어 전달, 정렬, 우선순위 큐, 연관 컨테이너의 값 표현 등 폭넓게 쓰인다. 의미가 불분명해질 때는 **구조체** 로 전환해 명시성을 확보한다. **pair** 의 비교 규칙, **priority_queue** 와의 조합, **unordered_map** 키 해시 정의 패턴을 익혀두면 실전 활용도가 높다.
