---
layout : post
title : 2차원 최대 증가 수열
comments : true
categories : 
- CodingTest
tags : [CodingTest, DP]
---

# 2차원 최대 증가 수열 

[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-longest-increasing-sequence-2d/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-longest-increasing-sequence-2d/description)


## 풀이


```cpp

#include <iostream>
#include <algorithm>
#include <climits>

using namespace std;

int n, m, answer = INT_MIN;
int grid[50][50];
int dp[50][50];


void dp_search(int y, int x){

    for(int i = 0; i < y; i++){
        for(int j = 0; j < x; j++){
            if(grid[y][x] > grid[i][j])
                dp[y][x] = max(dp[y][x], dp[i][j] + 1);
        }
    }

}

int main() {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> m;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
        }
    }

    dp[0][0] = 1;
    // 오른쪽으로 한 칸, 아래로 한 칸 이동한 지점 부터 탐색 시작
    for(int i = 1; i < n; i++){
        for(int j = 1; j < m; j++){
            // 현재탐색 좌표에서 grid[0][0] 이 더 클경우 dp search 할 필요 없음
            if(grid[i][j] > grid[0][0])
                dp_search(i, j);
        }
    }


    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            answer = max(answer, dp[i][j]);
        }
    }
    
    cout << answer << "\n";

    return 0;
}


```