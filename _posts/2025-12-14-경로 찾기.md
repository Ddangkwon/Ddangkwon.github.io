---
layout : post
title : 위성 사진
comments : true
categories : 
- CodingTest
tags : [CodingTest, Dijkstra]
---

# 경로 찾기

## 문제


길이가 같은 두 개의 이진수 코드 A와 B가 있다고 하자. 

이 두 코드 사이의 해밍 거리는 A와 B의 각 비트를 왼쪽부터 오른쪽으로 차례대로 비교할 때 서로 다른 값을 가진 비트의 수이다. 

예를 들어, A=010010, B=011011 이라고 하면, 세 번째 비트와 여섯 번째 비트만 서로 다르므로 이 두 코드 사이의 해밍 거리는 2이다.

우리는 총 N개의 이진 코드를 가지고 있고, 각 코드의 길이는 K로 같다. 

예를 들어, 다음과 같이 길이가 3인 5개의 이진 코드들이 있다. 

A=000, B=111, C=010, D=110, E=001 

두 코드 A와 B사이의 해밍 거리를 H(A,B)로 표현한다. 
그러면, H(A,B)=3, H(A,C)=1, H(A,D)=2, H(A,E)=1 이다.  

우리는 이진 코드들에 대해 해밍 경로를 찾고자 한다. 해밍 경로는 모든 인접한 두 코드사이의 해밍 거리가 1인 경로이다. 

위의 예에서 (A,C,D)는 코드 A와 C의 해밍 거리가 1이고, 코드 C와 D의 해밍 거리가 1이므로 해밍 경로이다. 

(A,E,B)는 코드 A와 E의 해밍 거리는 1이지만, 코드 E와 B의 해밍 거리가 2이므로 해밍 경로가 아니다. 

이 문제는 주어진 두 코드 사이에 가장 짧은 해밍 경로를 구하는 프로그램을 작성하는 것이다.


## 입력
첫째 줄에는 두 개의 정수 N과 K가 빈칸을 사이에 두고 주어진다(3≤N≤1,000, 2≤K≤30).

둘째 줄부터 N개의 줄에는 각 줄마다 길이가 K인 이진 코드가 하나씩 주어진다. 

하나의 코드는 빈칸이 없이 주어진다. 코드들은 주어진 순서대로 1부터 N까지의 번호로 구분된다. 

코드가 같은 경우는 없다. 

그 다음 줄에는 해밍 경로를 찾고자 하는 서로 다른 두 개의 코드 A와 B가 각각의 코드번호로 주어진다.


## 출력
입력으로 주어진 두 코드 사이에 해밍 경로가 존재하면 

그 경로 중 가장 짧은 경로를 코드 A부터 코드 B까지 경로상의 코드 번호로 출력한다.

코드 번호를 출력할 경우에는 코드 번호 사이에 하나의 빈칸을 사이에 두고 출력한다. 

만약 답이 여러 개 있으면 그 중에 하나만 출력하고, 경로가 존재하지 않으면 -1을 출력한다.


## 풀이

```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <queue>
#include <climits>
#include <algorithm>

#define ARR_ROW_MAX_LEN 1100
#define ARR_COL_MAX_LEN 33

using namespace std;


int N, K, A, B;
int arrmap[ARR_ROW_MAX_LEN][ARR_COL_MAX_LEN] = { 0 };
int dist[ARR_ROW_MAX_LEN] = { 0 };
int parent[ARR_ROW_MAX_LEN] = { 0 };
vector<pair<int, int> > graph[ARR_ROW_MAX_LEN];

struct compare{
    bool operator()(const pair<int, int> &a, const pair<int, int> &b) const {
        return a.second > b.second;
    }
};

void input()
{
    cin >> N >> K;
    
    for(int i = 0; i < N; i++){
        string str;
        cin >> str;

        for(int j = 0; j < K; j++){
            arrmap[i][j] = str[j];
        }
    }

    cin >> A >> B;
}


int calc_hamming_distance(int a, int b)
{
    int ret_dist = 0;
    for(int i = 0; i < K; i++){
        if(arrmap[a][i] ^ arrmap[b][i])
            ret_dist++;
    }
    
    return ret_dist;
}

void make_graph()
{
    for(int i = 1; i <= N - 1; i++){
        for(int j = i + 1; j <= N; j++){
            int dist = calc_hamming_distance(i - 1, j - 1);
            // 해밍거리 1인 point 들 사이(해밍 경로)만 연결을 수행
            if(dist == 1){
                graph[i].push_back({j, dist});
                graph[j].push_back({i, dist});
            }

        }
    }
}

bool dijkstra()
{
    priority_queue<pair<int, int>, vector<pair<int, int> >, compare> pq;
    // 거리 최대값으로 초기화
    for(int i = 0; i <= N; i++)
        dist[i] = INT_MAX;
    // 시작점 pq 에 push 및 dist 배열 업데이트
    pq.push({A, 0});
    dist[A] = 0;

    while(!pq.empty()){
        pair<int, int> cur = pq.top();
        int cur_point = cur.first;
        int cur_dist = cur.second;
        pq.pop();

        if(cur_point == B)
            return true;

        if(cur_dist > dist[cur_point])
            continue;
        
        for(auto next : graph[cur_point]){
            int next_point = next.first;
            int next_dist = cur_dist + next.second;

            if(next_dist < dist[next_point]){
                dist[next_point] = next_dist;
                parent[next_point] = cur_point;
                pq.push({next_point, next_dist});
            }

        }
    }
    return false;
}
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();
    make_graph();
    bool isfound = dijkstra();
    
    if(!isfound){
        cout << "-1\n";
        return 0;
    }
        
    vector<int> result_path;

    result_path.push_back(B);
    // B-A 사이 경로 parent 배열을 통해 탐색
    for(int i = parent[B]; i != A; i = parent[i]){
        result_path.push_back(i);
    }

    result_path.push_back(A);

    // 부모노드를 탐색해가면서 거꾸로 vector 에 값을 채웠기 때문에 print 할 때는 역순으로 출력 
    for(int i = result_path.size() - 1; i >= 0; i--){
        cout << result_path[i] << " ";
    }

    cout << "\n";

    return 0;
}
```