---
layout : post
title : AI 로봇 청소기
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# AI 로봇 청소기

[https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/ai-robot/solutions](https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/ai-robot/solutions)



## 풀이

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
using namespace std;

#define ARR_MAX_LEN 55
#define WALL (-1)

typedef struct{
    int y;
    int x;
}loc_t;

int N, K, L, answer = 0; // 격자 크기, 로봇 청소기 개수, 테스트 횟수
int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
// 0: 우, 1: 하, 2: 좌, 3: 상  (CodeTree 풀이와 동일 축 사용)
int dy[4] = { 0, 1, 0, -1 };
int dx[4] = { 1, 0, -1, 0 };

vector<loc_t> cleaner_loc;
bool check_pos[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; // 다른 청소기 위치 마스크

inline int min20(int v){ return v < 20 ? v : 20; }

void input(){
    cin >> N >> K >> L;

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= N; j++){
            cin >> arrmap[i][j]; // -1(벽/물건), 나머지=먼지
        }
    }
    int r, c;
    for(int i = 0; i < K; i++){
        cin >> r >> c;
        cleaner_loc.push_back({ r, c });
    }
}

// 가장 가까운 오염 칸 BFS (다른 청소기(check_pos) 금지, 같은 거리면 행→열 작은 순)
loc_t bfs(int y, int x){
    if(arrmap[y][x] > 0) return { y, x };

    queue<loc_t> q;
    bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };
    q.push({ y, x });
    isvisited[y][x] = true;

    loc_t ret = { -1, -1 };
    int found_dist = -1;
    int dist = 0;

    while(!q.empty()){
        int qs = q.size();
        // 같은 거리 레벨에서 행/열 오름차순 보장을 위해 수집 후 정렬 대신
        // 4방향 탐색 순서를 우,하,좌,상으로 고정하고,
        // 후보가 여러 개면 레벨 내에서 최소 y,x를 수동 비교한다.
        loc_t best = { INT_MAX, INT_MAX };
        bool found = false;

        while(qs--){
            int cy = q.front().y;
            int cx = q.front().x;
            q.pop();

            if(arrmap[cy][cx] > 0 && check_pos[cy][cx] == false){
                // 같은 거리 내 tie-break
                if(cy < best.y || (cy == best.y && cx < best.x)){
                    best = { cy, cx };
                }
                found = true;
            }

            for(int dir = 0; dir < 4; dir++){
                int ny = cy + dy[dir];
                int nx = cx + dx[dir];
                if(ny < 1 || ny > N || nx < 1 || nx > N)
                    continue;
                if(arrmap[ny][nx] == WALL) // 물건/벽
                    continue;
                if(check_pos[ny][nx])      // 다른 청소기 위치 금지
                    continue;
                if(isvisited[ny][nx])
                    continue;
                isvisited[ny][nx] = true;
                q.push({ ny, nx });
            }
        }

        if(found){
            ret = best;
            found_dist = dist;
            break;
        }
        dist++;
    }

    if(found_dist == -1) return { y, x }; // 이동 불가 시 제자리
    return ret;
}

// 이동 단계: check_pos 초기화→표시 후, 각 청소기 순서대로 이동
void move_cleaner(){
    // 0. 현재 청소기 좌표 체크
    for(int i = 1; i <= N; i++)
        for(int j = 1; j <= N; j++)
            check_pos[i][j] = false;
    for(auto &p : cleaner_loc)
        check_pos[p.y][p.x] = true;

    // 1. 이동
    for(int i = 0; i < (int)cleaner_loc.size(); i++){
        loc_t cur = cleaner_loc[i];
        loc_t dst = bfs(cur.y, cur.x);
        // 마스크 갱신
        check_pos[cur.y][cur.x] = false;
        check_pos[dst.y][dst.x] = true;
        cleaner_loc[i] = dst;
    }
}

// 방향 선택: “현재칸 + 4방향(min(칸,20)) 합”에서 **역방향 제외**가 최대가 되는 방향
int choose_dir_for_clean(int cy, int cx){
    // 우(0), 하(1), 좌(2), 상(3) 기준, 역방향 매핑
    int changeDir[4] = { 2, 3, 0, 1 };

    // total = 현재칸 + 4방향(min(,20), 벽 제외)
    int total = (arrmap[cy][cx] > 0 ? min20(arrmap[cy][cx]) : 0);
    for(int d = 0; d < 4; d++){
        int ny = cy + dy[d], nx = cx + dx[d];
        if(ny < 1 || ny > N || nx < 1 || nx > N) continue;
        if(arrmap[ny][nx] == WALL) continue;
        if(arrmap[ny][nx] > 0) total += min20(arrmap[ny][nx]);
    }

    int best_dir = 0, best_val = -1;
    for(int d = 0; d < 4; d++){
        int reverse = changeDir[d];
        int val = total;
        int ry = cy + dy[reverse], rx = cx + dx[reverse];
        if(ry >= 1 && ry <= N && rx >= 1 && rx <= N && arrmap[ry][rx] != WALL){
            if(arrmap[ry][rx] > 0) val -= min20(arrmap[ry][rx]);
        }
        if(val > best_val){
            best_val = val;
            best_dir = d;
        }
    }
    return best_dir;
}

// 청소: 선택된 방향의 **역방향만 제외**하고, 현재칸 포함 20씩 감산(하한 0)
void run_clean_process(){
    int changeDir[4] = { 2, 3, 0, 1 };

    for(auto &p : cleaner_loc){
        int cy = p.y, cx = p.x;
        int dir = choose_dir_for_clean(cy, cx);
        int reverse = changeDir[dir];

        // 4방향 중 역방향만 제외
        for(int d = 0; d < 4; d++){
            if(d == reverse) continue;
            int ny = cy + dy[d], nx = cx + dx[d];
            if(ny < 1 || ny > N || nx < 1 || nx > N) continue;
            if(arrmap[ny][nx] == WALL) continue;
            if(arrmap[ny][nx] > 0){
                arrmap[ny][nx] -= 20;
                if(arrmap[ny][nx] < 0) arrmap[ny][nx] = 0;
            }
        }
        // 현재 위치
        if(arrmap[cy][cx] > 0){
            arrmap[cy][cx] -= 20;
            if(arrmap[cy][cx] < 0) arrmap[cy][cx] = 0;
        }
    }
}

void accum_dust(){
    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= N; j++){
            if(arrmap[i][j] == WALL) continue;
            if(arrmap[i][j] > 0) arrmap[i][j] += 5;
        }
    }
}

// 0인 칸만 확산: 이웃 4칸의 먼지 합을 10으로 나눈 값을 더함(동시 갱신, WALL 제외)
void spread_dust(){
    static int next_map[ARR_MAX_LEN][ARR_MAX_LEN];
    for(int i = 1; i <= N; i++)
        for(int j = 1; j <= N; j++)
            next_map[i][j] = arrmap[i][j];

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= N; j++){
            if(arrmap[i][j] != 0) continue;
            if(arrmap[i][j] == WALL) continue;

            int sum = 0;
            for(int d = 0; d < 4; d++){
                int ny = i + dy[d], nx = j + dx[d];
                if(ny < 1 || ny > N || nx < 1 || nx > N) continue;
                if(arrmap[ny][nx] == WALL) continue;
                if(arrmap[ny][nx] > 0) sum += arrmap[ny][nx];
            }
            next_map[i][j] += (sum / 10);
        }
    }

    for(int i = 1; i <= N; i++)
        for(int j = 1; j <= N; j++)
            arrmap[i][j] = next_map[i][j];
}

int total_dust(){
    int s = 0;
    for(int i = 1; i <= N; i++)
        for(int j = 1; j <= N; j++)
            if(arrmap[i][j] > 0) s += arrmap[i][j];
    return s;
}

void simulate_one_step_and_print(){
    move_cleaner();
    run_clean_process();
    accum_dust();
    spread_dust();
    cout << total_dust() << "\n"; // 매 턴 출력
}

int main(void){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();
    for(int t = 0; t < L; t++){
        simulate_one_step_and_print();
    }
    return 0;
}

```
