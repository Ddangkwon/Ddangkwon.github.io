---
layout : post
title : ARM 강의(Cortex-M Software Development Fundamentals)
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---


# Arm 컴파일러 개요 및 사용법

## Arm 컴파일러 개요
이 슬라이드에서는 베어 시스템에서 Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴봅니다. Arm 라이선스 기간에는 두 가지 옵션을 사용할 수 있습니다:
1. **Arm 컴파일러 6**: 모든 A 프로파일, R 프로파일, M 프로파일 변형을 지원하며, 최신 아키텍처 기능 및 확장을 가장 강력하고 완벽하게 지원합니다.
2. **Arm 컴파일러 5**: 레거시 툴 체인으로, Armv4에서 Armv7까지의 아키텍처만 지원하며 수명이 거의 끝나가고 있습니다.

그 외에도 GCC와 같은 오픈 소스 컴파일러와 타사 도구 공급업체 컴파일러가 있습니다. 이러한 모든 컴파일러 도구 체인은 Arm 아키텍처용 ABI를 준수해야 합니다.

## 기능 안전을 위한 컴파일러 지원
기능 안전을 위한 컴파일러는 특정 기능 안전 표준에 따라 인증을 받아야 합니다. Arm에서는 이를 장기 유지 관리 릴리스(LTM)라고 합니다. LTM은 버그를 수정하는 데 중점을 두며, 기능 안전 시스템의 개발을 단순화하고 가속화할 수 있습니다. 기능 안전 릴리스에는 검증 키트가 포함되어 있으며, 이는 안전 매뉴얼, 철저히 테스트된 라이브러리 목록, 결함 보고서를 제공합니다.

## Arm 컴파일러 6 소개
Arm Compiler 6은 오픈 소스 LLVM Clang을 기반으로 하여 오픈 소스 세계와의 규정 준수를 보장하며, 최신 아키텍처 기능 및 확장을 가장 빠르고 완벽하게 지원합니다. Arm 컴파일러는 Arm DS 및 Keil-MDK와 함께 제공되며, 독립 실행형 버전은 웹사이트에서 다운로드할 수 있습니다. 기능 안전 버전이 아닌 경우 독립 실행형 라이선스가 없습니다.

### Arm Compiler 5에서 Arm Compiler 6으로 마이그레이션
Arm Compiler 5는 이제 레거시 툴 체인이므로, Arm Compiler 6으로 마이그레이션하는 것이 좋습니다. Arm Compiler 6은 Clang과 LLVM 기술을 기반으로 구축되어 있으며, 프로덕션 환경에서 사용하기에 적합한 제품 기능을 제공합니다. 커뮤니티 기능은 프로덕션 코드에서 사용하지 않는 것이 좋습니다.

## 언어 지원
Arm Compiler 6은 여러 언어 표준을 지원합니다:
- C 언어: c90, c99, c11, gnu90, gnu99, gnu11
- C++ 언어: C++03, C++11, C++14, C++17, GNU++03, GNU++11, GNU++14, GNU++17

### 데이터 유형
Cortex-M 프로세서는 AArch32 아키텍처를 사용하며, 다음과 같은 데이터 유형을 지원합니다:
- 32비트 정수: int, long
- 64비트 정수: long long
- 16비트 하프 워드: short
- 8비트 바이트: char
- 32비트 단정밀도 부동 소수점: float
- 64비트 배정밀도 부동 소수점: double
- C++에서는 불리언 및 wchar_t 타입도 지원됩니다.

## C++ 예외 처리
Arm Compiler 6에서 C++ 예외 처리는 기본적으로 활성화되어 있습니다. 예외를 사용하지 않는 경우, -fno-exception 옵션을 사용하여 예외를 비활성화하는 것이 좋습니다. 또한, 일부 C++ 라이브러리는 예외 처리가 활성화된 상태로 컴파일되어 있으므로 주의가 필요합니다.

### C++ 초기화 및 소멸자
C++ 객체 초기화 방식을 사용자 지정하려는 경우, _cpp_initialized_aeabi 및 aeabi_atexit 함수를 재정의할 수 있습니다. 힙을 사용하면서 자체 힙 관리 시스템을 구현하려는 경우, malloc과 free 함수를 리타겟팅하는 것이 좋습니다. 또한, C++ 라이브러리는 스레드 안전하지 않으므로 멀티스레딩 libc++를 사용할 경우 주의해야 합니다.


# Arm 아키텍처를 위한 코드 개발 고려 사항

## Arm 프로시저 호출 표준 (AAPCS)

### AAPCS 개요
AAPCS는 Arm용 API 아키텍처 및 모든 컴파일러의 일부로, ARM Aarch 32 기기가 이를 준수해야 합니다. 이 표준은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다. 이를 이해하면 더 효율적인 코드를 작성할 수 있습니다.

### 레지스터 사용
- **레지스터 r0-r3**: 함수에 인수를 전달하는 데 사용됩니다.
- **레지스터 r0-r1**: 반환되는 데이터의 크기에 따라 값을 반환하는 데 사용됩니다.
- **레지스터 r4-r11**: 레지스터 변수이며 보존해야 합니다. 함수 호출 시 이 레지스터들은 호출된 함수가 원래 값을 복원할 수 있도록 저장해야 합니다.
- **스택 포인터 (SP, r13)**: 스택의 다음 빈 공간을 가리킵니다.
- **링크 레지스터 (LR, r14)**: 함수를 호출할 때 반환 주소를 가리킵니다.
- **프로그램 카운터 (PC, r15)**: 실행할 다음 명령을 가리킵니다.

### 함수 호출 예제
- 레지스터 r0-r3과 r12는 함수 호출 시 손상될 수 있습니다.
- 함수 호출 전후에 필요한 레지스터를 저장 및 복원해야 합니다.
- 링크 레지스터는 함수 반환 주소를 가리키며, 호출자 함수가 다른 함수를 호출할 때는 값을 보존해야 합니다.
- 함수 반환 값이 단어 크기 이하인 경우 r0을 사용하여 반환하며, 64비트인 경우 r0과 r1의 조합을 사용합니다.

### 매개변수 전달
- 최대 4개의 단어 크기 매개변수를 함수 레지스터에 전달할 수 있습니다. 추가 매개변수는 스택으로 전달됩니다.
- 하위 단어 크기 인수도 전체 레지스터를 사용합니다.
- 64비트 인수는 짝수 레지스터와 연속된 홀수 레지스터 쌍을 사용합니다.
- C++ 비정적 멤버 함수에서는 레지스터 r0이 항상 객체 포인터를 포함하므로 실제로 세 개의 인수만 전달할 수 있습니다.

### 매개변수가 4개 이상일 때
- 매개변수가 4개 이상인 경우, 추가 매개변수는 스택에 전달됩니다.
- 함수가 반환될 때 스택 포인터를 복원해야 합니다.
- 블 (BL) 명령어는 다음 명령어의 주소를 링크 레지스터에 복사합니다.

### 64비트 인수와 매개변수 전달 예제
- 정수 a는 레지스터 r0을 사용하고, 64비트 double b는 r2와 r3을 사용하여 전달합니다.
- 정수 c는 스택 메모리를 사용해야 합니다.
- 정수, double, 정수의 순서로 전달되는 경우, 레지스터와 스택을 최적화하여 사용할 수 있습니다.

## 최적화 및 정렬
- 매개변수 전달 순서는 레지스터와 스택 사용 방식에 큰 영향을 미칩니다.
- 크기가 작은 매개변수를 먼저 배치하는 것이 좋습니다.
- 정적이 아닌 C++ 멤버 함수의 경우, r0에는 숨겨진 `this` 인수가 포함됩니다.

위 내용은 Arm 아키텍처에 맞춰 코드를 효율적으로 작성하는 데 필요한 고려 사항을 요약한 것입니다. AAPCS 표준을 이해하고 준수하면 더 나은 성능과 유지보수성을 가진 코드를 작성할 수 있습니다.

# Arm Custom Instructions 요약

---

## 개요
Arm Custom Instructions는 Armv8-M 및 Armv8.1-M 아키텍처를 위한 사용자 지정 데이터 경로 확장의 일부로, 프로세서 설계자가 Arm 프로세서에 자체 기능을 추가할 수 있도록 합니다.

## 명령어 클래스
사용자 지정 명령어는 여러 범주로 나뉘며, 각 클래스는 사용자 지정 명령어에 지정할 수 있는 입력 및 출력 피연산자의 유형을 기반으로 정의됩니다. 

### 클래스 1
- 출력 대상 레지스터 피연산자와 입력 즉시값 피연산자를 포함.
- 변형: 비누산기, 누산기.
   
### 클래스 2
- 출력 대상 레지스터와 소스 레지스터 피연산자를 추가.
- 변형: 비누산기, 누산기.

## 조건 코드 전달
조건 코드를 사용자 정의 명령어로 전달하기 위해 APSR_NZCV 레지스터를 사용하며, 이는 애플리케이션 프로세스 상태 레지스터를 의미합니다.

## 레지스터 피연산자
사용자 지정 명령어 클래스는 레지스터 피연산자를 사용할 수 있습니다. 각 클래스에 따라 레지스터 피연산자의 수와 유형이 다릅니다.

### 클래스 1
- 출력 대상 레지스터와 입력 즉시값.
- 변형: 비누산기, 누산기.
   
### 클래스 2
- 출력 대상 레지스터, 소스 레지스터, 입력 즉시값.
- 변형: 비누산기, 누산기.

## 사용자 지정 명령어의 인코딩
사용자 지정 명령어는 보조 프로세서 명령어와 동일한 인코딩 공간을 사용합니다. 특정 명령어를 Arm 사용자 지정 명령어로 전달하려면 자체 서명된 특정 코어 프로세서로 연결해야 합니다.

## 누산기 변형
각 클래스에는 몇 가지 변형이 있습니다. 결과만 계산하고 출력 레지스터를 사용하는 변형이 있으며, 등록된 값도 소비하는 누산기 변형도 있습니다.

---

# Armv8-M 메모리 모델

---

## 개요
Armv8-M 메인라인 아키텍처의 메모리 모델에 대해 알아보겠습니다. 이는 Armv8-M 주소 공간의 여러 파티션을 나열하고 메모리 유형을 구분하며, 주소 공간의 특정 파티션에 사용되는 이유를 설명합니다.

## 주소 공간
Armv8-M은 최대 4GB의 물리적 주소 공간을 포함하는 메모리 매핑 아키텍처입니다. 주소 공간은 물리적 메모리와 프로세서 제어 및 상태 레지스터 모두를 위한 공유 주소 공간입니다. 

## 메모리 영역
메모리는 8개의 512MB 세그먼트 또는 파티션으로 분할됩니다. 각 영역은 특정 용도로 사용됩니다.
1. **코드 섹션**: 명령어 저장.
2. **SRAM**: 고속 SRAM 메모리.
3. **주변 장치 영역**: 주변 장치 메모리.
4. **시스템 영역**: 프로세서 제어 및 상태 레지스터.

## 메모리 속성
각 메모리 영역은 다양한 메모리 속성을 가질 수 있습니다. 속성은 다음과 같습니다.
1. **액세스 권한**
2. **실행 권한**
3. **공유 가능성**
4. **캐시 가능성**

## 메모리 유형
메모리 영역에는 일반 메모리 또는 장치 메모리가 포함될 수 있습니다. 일반 메모리는 최상의 성능을 제공하며, 장치 메모리는 액세스에 부작용이 발생할 수 있는 영역에 사용됩니다.

---

# Arm 컴파일러

---

## 개요
Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴보겠습니다. 주요 컴파일러로는 Arm Compiler 6과 Arm Compiler 5가 있습니다.

## Arm Compiler 6
- 최신 Arm 아키텍처 기능 및 확장을 지원.
- 베어메탈 소프트웨어 개발에 중점을 둠.
- 오픈소스 LLVM Clang을 기반으로 구축.

## Arm Compiler 5
- 레거시 툴 체인으로 Armv4에서 Armv7까지 지원.
- 유지 관리만 이루어지며 수명이 거의 끝남.

## 기능 안전
일부 임베디드 시스템의 경우 기능 안전 요구 사항이 있습니다. Arm은 기능 안전 요구 사항을 충족하기 위해 장기 유지 관리 릴리스(LTM)를 제공합니다.

## 컴파일러 사용
Arm Compiler는 Arm DS 또는 Keil-MDK와 함께 제공되며, 웹 사이트에서 독립 실행형 버전으로 다운로드할 수 있습니다.

---

# AAPCS (Arm Procedure Call Standard)

---

## 개요
Arm 아키텍처를 위한 프로시저 호출 표준(AAPCS)은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다.

## 레지스터 사용
- **r0-r3**: 함수에 인수를 전달.
- **r4-r11**: 레지스터 변수로 사용되며 보존해야 함.
- **r12**: 임시 레지스터.
- **r13 (SP)**: 스택 포인터.
- **r14 (LR)**: 링크 레지스터.
- **r15 (PC)**: 프로그램 카운터.

## 스택 정렬
AAPCS에 따르면, 스택은 외부 가시 경계에서 8바이트로 정렬되어야 합니다. 이는 함수 호출 시 스택이 8바이트로 정렬되어야 함을 의미합니다.

## 함수 호출 예제
호출자 함수가 레지스터 값을 수정하지 않을 것으로 예상되면 호출자는 함수를 호출하기 전에 레지스터를 저장하고, 함수가 반환된 후 원래 값을 복원해야 합니다.

---

## 요약

- **Arm Custom Instructions**: 사용자 지정 명령어를 통해 프로세서 기능을 확장할 수 있습니다.
- **Armv8-M 메모리 모델**: 다양한 메모리 영역과 속성을 이해하여 최적의 성능을 제공합니다.
- **Arm 컴파일러**: 최신 아키텍처 기능을 지원하며, 기능 안전 요구 사항을 충족할 수 있습니다.
- **AAPCS**: 효율적인 함수 호출과 인수 전달을 위한 표준을 이해하면 더 나은 코드를 작성할 수 있습니다.


# Armv8-M Mainline Debug

## 학습 목표
이 모듈의 끝에서 다음을 할 수 있습니다:
- Debug, Trace 및 Profiling 요구 사항 및 기능 설정
- Invasive Debug와 Non-invasive Debug의 구분
- Armv8-M Mainline Debug 및 Trace 구성 요소 설명: FPB, DWT, ITM, MTB, ETM 및 TPIU
- 프로세서가 중단된 다양한 Debug 이벤트 감지
- Semihosting 호출과 표준 Breakpoints의 차이점 구별
- Profiling 기능 설명: DWT 및 Armv8.1-M Performance Monitoring Unit (PMU)

## 기본 Debug 요구 사항
- **Run Control**
  - 코드 단일 단계 실행
  - 명령어에 Breakpoints 설정
  - 데이터 접근에 Watchpoints 설정
- **State Control**
  - 프로세서 상태 읽기 및 쓰기
  - 시스템 메모리 접근
  - 주변기기 접근
- **Execution History**
  - 실행 추적 정보

## Armv8-M Mainline Debug 구성 요소
- **DAP**
- **ETM**
- **Trigger**
- **TPIU**
- **SW/JTAG**
- **Debug Agent**
- **FPB**
- **DWT**
- **ITM**
- **MTB**
- **ROM Table**
- **PIL**
- **CTI**
- **Bus Matrix**
- **MPU**
- **SAU**
- **IPPB**

## Invasive Debug vs. Non-invasive Debug
- **Invasive Debug**
  - 프로세서 제어: 코어 중단, 코드 단일 단계 실행, 코드 실행
  - 프로세서 레지스터 검사 및 변경: Debug 상태에서
  - 메모리와 메모리 매핑 레지스터 검사 및 변경: 프로세서 실행 중이나 중단 중
- **Non-invasive Debug**
  - 프로세서의 동작 관찰: 프로세서 중단 없이
  - 프로그램 실행에 비침입적일 수 있음
  - Non-invasive Debug는 MTB, ITM, ETM 및 PMU를 통해 제공됨

## Debug 상태 - 중단 Debug
Debug 상태가 프로세서에서 활성화되고 적격한 Debug 이벤트가 발생하면 프로세서는 Debug 상태로 들어갑니다. 이 상태에서는 프로세서가 멈추고, 명령어가 실행되지 않으며, 인터럽트가 서비스되지 않습니다. Debug 인터페이스를 통해 프로세서를 제어합니다.

## 중단 Debug를 위한 Debug 이벤트
- 전통적인 시작/중단 Debug
- PMU Sticky 플래그가 PMU 카운터가 오버플로우했음을 나타냄
- EXTERNAL EDBGRQ 입력이 다른 SoC 구성 요소에서 어서트됨
- VCATCH 벡터 캐치가 트리거됨
- DWTTRAP이 Watchpoints와 일치하는 주소로 데이터 접근
- BKPT 명령어가 실행되거나 FPB에서 Breakpoints가 일치
- 디버거로부터의 HALTED 중단 요청

## 셀프 호스팅 Debug
프로세서를 구성하여 중단 대신 DebugMonitor 예외를 받도록 할 수 있습니다. 이는 실시간 요구사항이 있는 시스템 디버깅에 적합합니다. DebugMonitor는 PMU 오버플로우를 처리하는 데 사용될 수 있습니다.

## 벡터 캐치
- 선택된 예외를 트랩하는 메커니즘
- 예외가 어서트되면 코어가 중단됨
- 디버거를 통해 선택
- 리셋, HardFault, UsageFault, BusFault, SecureFault와 같은 예외를 트랩할 수 있음

## FPB - Flash Patch 및 Breakpoints 유닛
FPB는 명령어 페치에 Breakpoints를 설정할 수 있도록 지원합니다. 소프트웨어 Breakpoints는 BKPT 명령어로 구현되며, 하드웨어 Breakpoints는 FPB 비교기를 통해 구현됩니다.

## Breakpoints vs. Watchpoints
- **Breakpoints**: 명령어 디버깅에 사용
- **Watchpoints**: 데이터 접근 디버깅에 사용

## DWT Watchpoints
DWT는 데이터 주소와 명령어 주소 비교기를 제공합니다. DWT는 데이터 값과 데이터 주소가 일치할 때 중단할 수 있습니다. DWT 레지스터는 디버거에 의해 사용될 수 있습니다.

## Semihosting
Semihosting은 라이브러리 코드가 Arm 타겟에서 실행되지만 저수준 I/O는 호스트에 의해 처리됩니다. BKPT 명령어가 호스트 접근을 시작합니다.

## Trace: 소개
Trace는 구성 요소가 어떻게 실행되고 성능을 발휘하는지 보여주는 데이터를 캡처하는 과정입니다. 주로 프로그램 Trace(명령어 Trace)나 응용 프로그램 Trace(도구 Trace)가 있습니다.

## MTB - Micro Trace Buffer
MTB는 간단한 실행 추적 기능을 제공하며, 실행 중의 분기를 온칩 RAM에 저장합니다.

## ITM - Instrumentation Trace Macrocell
ITM은 소프트웨어와 하드웨어가 생성하는 Trace 패킷을 생성하고 출력합니다.

## DWT - Trace 캡처
DWT는 주소 일치, 주기적 PC 샘플링, 데이터 값, 예외 입출 및 반환, 이벤트 카운터와 같은 이벤트에 대한 패킷을 생성합니다.

## ETM - Embedded Trace Macrocell
ETM은 명령어 Trace만 지원하는 비침입 Debug 구성 요소입니다. ETM 하드웨어는 프로세서의 활동을 모니터링합니다.

## TPIU - Trace Port Interface Unit
TPIU는 ETM과 ITM에서 데이터를 형식화하고 직렬화합니다. TPIU는 비동기적으로 코어 클럭과 TRACECLKIN에서 파생된 TRACECLK로 데이터를 클럭킹합니다.

## Trace Port와 대역폭
ETM은 거의 0에서 여러 바이트의 명령어까지 데이터 속도를 생성할 수 있습니다. TRACECLKIN이 코어 클럭 속도로 실행될 때 명령어 Trace에 대해 2-3개의 핀이 필요합니다.

## DWT - Performance Profiling
DWT는 주기(CYCCNT), 폴디드 명령어(FOLDCNT), 모든 로드 또는 저장 명령어를 실행하는 데 필요한 추가 주기(LSUCNT), 프로세서 수면 주기(SLEEPCNT), 다중 주기 명령어와 명령어 페치 지연을 실행하는 데 필요한 추가 주기(CPICNT), 예외 처리에 소비된 주기(EXCCNT)를 위한 카운터를 포함합니다.

## PMU - Performance Monitoring Unit
PMU는 이벤트 통계 정보를 수집하고 성능 분석을 위해 시스템 Debug에 사용됩니다. 31개의 16비트 이벤트 카운터와 하나의 32비트 주기 카운터를 지원합니다. PMU 카운터와 DWT 프로파일링 카운터의 작동은 상호 배타적입니다.

# M-profile 부팅 및 초기화

© 2022 Arm

## 학습 목표

이 모듈을 마치면 다음을 할 수 있습니다:
- 시작 및 초기화 코드를 개발합니다.
- 메모리 설명 파일을 작성합니다.
- C 라이브러리를 어떻게 활용할지 선택합니다.
- 기기에서 부팅할 수 있는 실행 파일 이미지를 생성합니다.

## 임베디드 개발 프로세스

### 개발 환경에서 독립 실행형 임베디드 애플리케이션으로 이동할 때 고려해야 할 사항:

- 애플리케이션 시작
- 타겟 메모리 맵
- 하드웨어 사용을 위한 C 라이브러리

## 목차

1. 기본 컴파일 도구 동작
2. 시작 및 초기화 코드 작성
   - CMSIS-Core를 사용한 초기 시작 및 시스템 초기화 코드
   - 시작 후 초기화
3. 디바이스에 맞게 이미지 메모리 맵 조정
   - 메모리 설명 파일 작성 (스캐터 파일/링커 스크립트)
   - 스택 및 힙 배치
   - 추가 메모리 맵 고려 사항
4. 시스템에 맞게 C 라이브러리 동작 재설정
5. 부팅 준비 이미지 빌드

## 기본 컴파일 도구 동작

### Arm Compiler의 기본 시작 및 초기화 시퀀스

- `main()` 함수는 라이브러리 초기화 코드를 링크하도록 Arm Linker (armlink)에 지시합니다.
- `__main` 함수는 C 라이브러리의 진입점입니다.
  - `__main`은 `__scatterload`와 `__rt_entry`를 호출합니다.
  - `__scatterload`는 실행 시간 영역을 초기화합니다.
  - `__rt_entry`는 다양한 초기화 함수를 호출한 다음 사용자 레벨의 `main()`을 호출합니다.

## 기본 메모리 맵 - Arm Compiler

기본적으로 Arm Compiler는 코드를 0x8000에서 로드하고 실행하도록 링크합니다.
- 힙은 데이터 영역 바로 위에 배치됩니다.
- 스택 기본 위치는 링크 시 정의되고 리셋 시 프로세서에 의해 구성됩니다.

## 기본 C 라이브러리 - Arm Compiler

- Arm Compiler는 여러 준비된 T32 (이전 Thumb) C 라이브러리를 제공하며, '세미호스팅' 지원을 포함합니다.
- `c_w.l` - 리틀 엔디안 C 라이브러리
- `h_w.b` - 빅 엔디안 헬퍼 라이브러리
- `f_ws.l/.b` - 소프트웨어 부동 소수점 라이브러리

## 리셋 및 초기화

실제 시스템에서는 애플리케이션의 진입점을 컴파일러 특정 라이브러리 함수(`__main` 또는 `_start`)로 설정하지 않으려 할 수 있습니다.
- M-profile 프로세서는 특권 모드로 시작합니다. 시스템 초기화는 특권 모드에서만 실행할 수 있습니다.
- `SystemInit` 함수는 `__main` 전에 호출되며, 벡터 테이블 오프셋 레지스터(VTOR), 부동 소수점 유닛(FPU), 마이크로컨트롤러 벡터 확장(MVE), 보안 속성 유닛(SAU)을 초기화합니다.

## CMSIS-Core: 시작 파일

- `startup_<device>.c` 또는 `startup_<device>.s` 파일은 다음을 포함합니다:
  - 벡터 테이블
    - M-profile 예외 벡터
    - 디바이스 특정 인터럽트 벡터
    - 기본 루틴을 구현하는 약한 함수들
  - 리셋 핸들러
    - `SystemInit`을 호출한 후 `__PROGRAM_START()` 매크로를 호출합니다.

## 메모리 맵 설명 파일 작성

CMSIS-Core는 Arm Compiler 스캐터 파일, GNU 링커 스크립트, IAR 링커 구성 파일 템플릿을 제공합니다.
- 각각의 파일은 기본/필수 메모리 영역/세그먼트를 설명합니다.
  - RO/XO 코드 및 데이터
  - RW 및 ZI 데이터
  - 메인 스택

## 런타임 메모리 관리

C 라이브러리 런타임 메모리 모델을 재설정해야 합니다.
- 스택과 힙을 단일 메모리 영역(단일 영역 모델) 또는 별도의 영역(두 영역 모델)에 배치할지 결정해야 합니다.
- 기본적으로 단일 영역 모델이 사용됩니다.
- 두 영역 모델을 구현하려면 `__use_two_region_memory`를 가져와야 합니다.

## 메모리 맵 추가 고려 사항

M-profile 시스템에서 주변 장치는 메모리 매핑됩니다.
- CMSIS-Core 헤더는 장치의 주변 레지스터에 액세스하는 권장 방법입니다.

## C 라이브러리 재설정

C 라이브러리의 디바이스 드라이버 수준 기능을 타겟 하드웨어에 맞게 구현으로 교체할 수 있습니다.
- 예: `printf()`는 디버거 콘솔이 아닌 LCD 화면으로 출력해야 합니다.
- 세미호스팅을 사용하는 C 라이브러리 함수를 시스템에 맞게 구현으로 교체합니다.

## 디버깅 ROM 이미지

- 링커는 디버깅에 적합한 ELF/DWARF 이미지를 생성합니다.
- ELF 이미지를 바이너리 형식으로 변환하려면 `fromelf` 유틸리티를 사용합니다.
  - 예: `fromelf --bin -o <output> image.axf`
- ELF 이미지에서 DWARF 디버그 정보를 로드하여 ROM 이미지를 디버깅할 수 있습니다.


# Cortex-M3 Startup & Exception Handling


## Tarmac Trace
- Arm 전용 추적 형식
- Fast Models / FVPs (Fixed Virtual Platforms)에서 수집 가능
- RTL (Register Transfer Level) 시뮬레이션에서 수집 가능
- 실행된 명령어, 전송된 레지스터 값, 메모리 접근 및 발생한 예외를 보여줌
- Arm Fast Models 문서에 문서화됨: [Tarmac Trace Documentation](https://developer.arm.com/docs/100964/1161/plug-ins-for-fast-models/tarmactrace)

## Tarmac Trace 예제
```
8004 clk IT (8004) 0000061c 6801 T thread : LDR      r1,[r0,#0]
8004 clk MR4 20000170 00000000
8004 clk R r1 00000000
```

## 시작 예제
- CMSIS 시작 코드 사용
- C에서 인터럽트 핸들러 설정
- CMSIS 함수를 사용하여 인터럽트를 활성화하고 트리거

```c
Hello, world!
Enabled device-specific timer 0
Hello from TIM0_IRQHandler()!
```

## 리셋 단계

### 리셋 핸들러
```assembly
Reset_Handler   PROC
EXPORT  Reset_Handler             [WEAK]
IMPORT  SystemInit
IMPORT  __main
LDR     R0, =SystemInit
BLX     R0
LDR     R0, =__main
BX      R0
ENDP
```

### 리셋 과정
1. 리셋 예외 발생
2. 스택 포인터 값 설정
3. 프로세서가 T32 상태에 있음을 나타내는 CPSR 값 설정
4. 리셋 핸들러의 첫 번째 명령어 실행 시작

### 벡터 테이블
리셋 핸들러 주소는 벡터 테이블에 지정됨

```assembly
__Vectors       DCD     __initial_sp              ; Top of Stack
DCD     Reset_Handler             ; Reset Handler
```

## __main() 함수
- 스캐터 로딩
- C 라이브러리 초기화
- 애플리케이션 코드 실행 시작

## main() 함수의 애플리케이션 코드

```c
int main(void)
{
    printf("Hello, world!\n");
    /* Initialize TIM0_IRQn */
    NVIC_SetPriority(TIM0_IRQn, 1);
    NVIC_EnableIRQ(TIM0_IRQn);
    printf("Enabled device-specific timer 0\n");
    /* Set TIM0_IRQn to pending */
    NVIC_SetPendingIRQ(TIM0_IRQn);
    return 0;
}
```

## 예외 처리

### 소프트웨어에서 예외 트리거

```c
/* Set “pending” bit for the interrupt to 1. */
/* Processor takes exception and branches to exception handler. */
NVIC_SetPendingIRQ(TIM0_IRQn);
```

### 예외 처리 과정
- 프로세서는 필요한 레지스터를 스택에 자동으로 저장

```assembly
5484 clk E 00000cd0 00000012 CoreEvent_EXT_INT2
5485 clk IT (5485) 00000c7c a001 T handler : ADR      r0,{pc}+8 ; 0xc84
```

## 요약

### 핸들러 모드
- 벡터 테이블 사용
- 예외 처리 과정에서 스택 업데이트
- 핸들러로 분기
- 스택 레지스터 업데이트
- 핸들러에서 복귀