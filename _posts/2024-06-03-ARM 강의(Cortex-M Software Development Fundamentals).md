---
layout : post
title : ARM 강의(Cortex-M Software Development Fundamentals)
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---


# Arm 컴파일러 개요 및 사용법

## Arm 컴파일러 개요
이 슬라이드에서는 베어 시스템에서 Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴봅니다. Arm 라이선스 기간에는 두 가지 옵션을 사용할 수 있습니다:
1. **Arm 컴파일러 6**: 모든 A 프로파일, R 프로파일, M 프로파일 변형을 지원하며, 최신 아키텍처 기능 및 확장을 가장 강력하고 완벽하게 지원합니다.
2. **Arm 컴파일러 5**: 레거시 툴 체인으로, Armv4에서 Armv7까지의 아키텍처만 지원하며 수명이 거의 끝나가고 있습니다.

그 외에도 GCC와 같은 오픈 소스 컴파일러와 타사 도구 공급업체 컴파일러가 있습니다. 이러한 모든 컴파일러 도구 체인은 Arm 아키텍처용 ABI를 준수해야 합니다.

## 기능 안전을 위한 컴파일러 지원
기능 안전을 위한 컴파일러는 특정 기능 안전 표준에 따라 인증을 받아야 합니다. Arm에서는 이를 장기 유지 관리 릴리스(LTM)라고 합니다. LTM은 버그를 수정하는 데 중점을 두며, 기능 안전 시스템의 개발을 단순화하고 가속화할 수 있습니다. 기능 안전 릴리스에는 검증 키트가 포함되어 있으며, 이는 안전 매뉴얼, 철저히 테스트된 라이브러리 목록, 결함 보고서를 제공합니다.

## Arm 컴파일러 6 소개
Arm Compiler 6은 오픈 소스 LLVM Clang을 기반으로 하여 오픈 소스 세계와의 규정 준수를 보장하며, 최신 아키텍처 기능 및 확장을 가장 빠르고 완벽하게 지원합니다. Arm 컴파일러는 Arm DS 및 Keil-MDK와 함께 제공되며, 독립 실행형 버전은 웹사이트에서 다운로드할 수 있습니다. 기능 안전 버전이 아닌 경우 독립 실행형 라이선스가 없습니다.

### Arm Compiler 5에서 Arm Compiler 6으로 마이그레이션
Arm Compiler 5는 이제 레거시 툴 체인이므로, Arm Compiler 6으로 마이그레이션하는 것이 좋습니다. Arm Compiler 6은 Clang과 LLVM 기술을 기반으로 구축되어 있으며, 프로덕션 환경에서 사용하기에 적합한 제품 기능을 제공합니다. 커뮤니티 기능은 프로덕션 코드에서 사용하지 않는 것이 좋습니다.

## 언어 지원
Arm Compiler 6은 여러 언어 표준을 지원합니다:
- C 언어: c90, c99, c11, gnu90, gnu99, gnu11
- C++ 언어: C++03, C++11, C++14, C++17, GNU++03, GNU++11, GNU++14, GNU++17

### 데이터 유형
Cortex-M 프로세서는 AArch32 아키텍처를 사용하며, 다음과 같은 데이터 유형을 지원합니다:
- 32비트 정수: int, long
- 64비트 정수: long long
- 16비트 하프 워드: short
- 8비트 바이트: char
- 32비트 단정밀도 부동 소수점: float
- 64비트 배정밀도 부동 소수점: double
- C++에서는 불리언 및 wchar_t 타입도 지원됩니다.

## C++ 예외 처리
Arm Compiler 6에서 C++ 예외 처리는 기본적으로 활성화되어 있습니다. 예외를 사용하지 않는 경우, -fno-exception 옵션을 사용하여 예외를 비활성화하는 것이 좋습니다. 또한, 일부 C++ 라이브러리는 예외 처리가 활성화된 상태로 컴파일되어 있으므로 주의가 필요합니다.

### C++ 초기화 및 소멸자
C++ 객체 초기화 방식을 사용자 지정하려는 경우, _cpp_initialized_aeabi 및 aeabi_atexit 함수를 재정의할 수 있습니다. 힙을 사용하면서 자체 힙 관리 시스템을 구현하려는 경우, malloc과 free 함수를 리타겟팅하는 것이 좋습니다. 또한, C++ 라이브러리는 스레드 안전하지 않으므로 멀티스레딩 libc++를 사용할 경우 주의해야 합니다.


# Arm 아키텍처를 위한 코드 개발 고려 사항

## Arm 프로시저 호출 표준 (AAPCS)

### AAPCS 개요
AAPCS는 Arm용 API 아키텍처 및 모든 컴파일러의 일부로, ARM Aarch 32 기기가 이를 준수해야 합니다. 이 표준은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다. 이를 이해하면 더 효율적인 코드를 작성할 수 있습니다.

### 레지스터 사용
- **레지스터 r0-r3**: 함수에 인수를 전달하는 데 사용됩니다.
- **레지스터 r0-r1**: 반환되는 데이터의 크기에 따라 값을 반환하는 데 사용됩니다.
- **레지스터 r4-r11**: 레지스터 변수이며 보존해야 합니다. 함수 호출 시 이 레지스터들은 호출된 함수가 원래 값을 복원할 수 있도록 저장해야 합니다.
- **스택 포인터 (SP, r13)**: 스택의 다음 빈 공간을 가리킵니다.
- **링크 레지스터 (LR, r14)**: 함수를 호출할 때 반환 주소를 가리킵니다.
- **프로그램 카운터 (PC, r15)**: 실행할 다음 명령을 가리킵니다.

### 함수 호출 예제
- 레지스터 r0-r3과 r12는 함수 호출 시 손상될 수 있습니다.
- 함수 호출 전후에 필요한 레지스터를 저장 및 복원해야 합니다.
- 링크 레지스터는 함수 반환 주소를 가리키며, 호출자 함수가 다른 함수를 호출할 때는 값을 보존해야 합니다.
- 함수 반환 값이 단어 크기 이하인 경우 r0을 사용하여 반환하며, 64비트인 경우 r0과 r1의 조합을 사용합니다.

### 매개변수 전달
- 최대 4개의 단어 크기 매개변수를 함수 레지스터에 전달할 수 있습니다. 추가 매개변수는 스택으로 전달됩니다.
- 하위 단어 크기 인수도 전체 레지스터를 사용합니다.
- 64비트 인수는 짝수 레지스터와 연속된 홀수 레지스터 쌍을 사용합니다.
- C++ 비정적 멤버 함수에서는 레지스터 r0이 항상 객체 포인터를 포함하므로 실제로 세 개의 인수만 전달할 수 있습니다.

### 매개변수가 4개 이상일 때
- 매개변수가 4개 이상인 경우, 추가 매개변수는 스택에 전달됩니다.
- 함수가 반환될 때 스택 포인터를 복원해야 합니다.
- 블 (BL) 명령어는 다음 명령어의 주소를 링크 레지스터에 복사합니다.

### 64비트 인수와 매개변수 전달 예제
- 정수 a는 레지스터 r0을 사용하고, 64비트 double b는 r2와 r3을 사용하여 전달합니다.
- 정수 c는 스택 메모리를 사용해야 합니다.
- 정수, double, 정수의 순서로 전달되는 경우, 레지스터와 스택을 최적화하여 사용할 수 있습니다.

## 최적화 및 정렬
- 매개변수 전달 순서는 레지스터와 스택 사용 방식에 큰 영향을 미칩니다.
- 크기가 작은 매개변수를 먼저 배치하는 것이 좋습니다.
- 정적이 아닌 C++ 멤버 함수의 경우, r0에는 숨겨진 `this` 인수가 포함됩니다.

위 내용은 Arm 아키텍처에 맞춰 코드를 효율적으로 작성하는 데 필요한 고려 사항을 요약한 것입니다. AAPCS 표준을 이해하고 준수하면 더 나은 성능과 유지보수성을 가진 코드를 작성할 수 있습니다.
