---
layout : post
title : 꿀꿀이 축제
comments : true
categories :
- CodingTest
tags : [CodingTest, Dijkstra]
---

# 꿀꿀이 축제

## 문제


N개의 마을에 꿀꿀이들이 한 마리씩 살고 있다.



이 N마리의 꿀꿀이들이 X (1 ≤ X ≤ N)번 마을에 모여 축제를 열기로 했다. 마을 사이에는 총 M개의 단방향 도로들이 있고 i번 길을 걸어서 통과하는데 Ti(1 ≤ Ti ≤ 100)의 시간이 소비된다.



각 꿀꿀이들은 파티에 참석하기 위해 X번 마을까지 걸어가서 축제를 즐긴 후 다시 자신의 마을로 돌아온다.

걷는 것이 힘든 꿀꿀이들은 가능한 짧은 시간에 오고 가기를 원한다.



도로들은 단방향이기 때문에 꿀꿀이들이 오고 가는 길이 다를 수 있다.

N마리의 꿀꿀이들 중 오고 가는데 가장 많은 시간이 걸리는 꿀꿀이의 소요시간을 구하시오.




## 입력
첫째 줄에 N(1 <= N <= 1,000), M(1 <= M <= 10,000), X가 공백으로 구분되어 입력된다.

두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다.


## 출력
첫 번째 줄에 N명의 꿀꿀이들 중 오고 가는데 가장 오래 걸리는 꿀꿀이의 소요시간을 출력한다

## 풀이

```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    #include <climits>

    #define ARR_MAX_LEN 1001

    using namespace std;

    typedef struct{
        int pos;
        int cost;
    }data_t;

    struct compare{
        bool operator()(const data_t &a, const data_t &b) const{
            return a.cost > b.cost;
        }
    };
    int N, M, X;

    vector<data_t> graph[ARR_MAX_LEN];
    vector<data_t> rgraph[ARR_MAX_LEN];
    int dist[ARR_MAX_LEN] = { 0 };
    int rdist[ARR_MAX_LEN] = { 0 };

    void input(void)
    {
        cin >> N >> M >> X;

        for(int i = 0; i < M; i++){
            int start, end, time;
            cin >> start >> end >> time;
            graph[start].push_back({end, time});
            rgraph[end].push_back({start, time});
        }
    }

    void dijkstra(int *pdist, vector<data_t> *pgraph)
    {
        priority_queue<data_t, vector<data_t>, compare> pq;

        for(int i = 0; i <= N; i++)
            pdist[i] = INT_MAX;

        pdist[X] = 0;
        pq.push({X, 0});

        while(!pq.empty()){
            data_t cur_data = pq.top();
            int cur_pos = cur_data.pos;
            int cur_cost = cur_data.cost;

            pq.pop();
            // 갱신된 최소 거리가 아닐 경우 skip
            if(cur_cost != pdist[cur_pos])
                continue;

            for(auto& next_data : pgraph[cur_pos]){
                int next_pos = next_data.pos;
                int next_cost = pdist[cur_pos] + next_data.cost;

                if(next_cost < pdist[next_pos]){
                    pdist[next_pos] = next_cost;
                    pq.push({next_pos, next_cost});
                }
            }



        }


    }
    int main(void)
    {
        int answer = INT_MIN;
        ios::sync_with_stdio(false);
        cin.tie(NULL);
        cout.tie(NULL);

        input();
        // 왕복거리를 각각 graph 에 업데이트 해둔 값을 바탕으로 계산
        dijkstra(dist, graph);
        dijkstra(rdist, rgraph);

        // 왕복이 가능하고, 왕복 거리 중 가장 큰 값을 정답 값으로 저장하고 출력
        for(int i = 1; i <= N; i++){
            if (i == X)
                continue;
            if((dist[i] != INT_MAX && rdist[i] != INT_MAX) && ((dist[i] + rdist[i]) > answer))
                answer = (dist[i] + rdist[i]);
        }

        cout << answer << "\n";
        return 0;
    }

```
