---
layout : post
title : 조합 순열 개념 정리
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---


# 조합 DFS 구현 및 재귀 호출 흐름

## 개요
조합(combination)을 생성하기 위해 DFS(Depth First Search) 방식을 사용한 C++ 코드 예제와, 이 코드의 재귀 호출 흐름을 ASCII 다이어그램으로 정리했다.

## C++ 코드
```cpp
    #include <iostream>
    #include <vector>

    using namespace std;

    int N, M;                         // 전체 원소 개수(N)와 선택할 개수(M)
    vector<int> arr;                  // 원소를 담은 배열
    vector<int> pick;                 // 현재 선택된 원소를 담는 배열
    vector<vector<int>> result;       // 완성된 조합을 저장하는 배열

    // start: 다음에 선택할 인덱스, depth: 현재까지 선택한 개수
    void combinationDFS(int start, int depth) {
        if (depth == M) {
            result.push_back(pick);
            return;
        }
        for (int i = start; i < N; ++i) {
            pick.push_back(arr[i]);
            combinationDFS(i + 1, depth + 1);
            pick.pop_back();
        }
    }

    int main() {
        // 예시 입력
        N = 5;
        M = 3;
        arr = {1, 2, 3, 4, 5};

        combinationDFS(0, 0);

        // 결과 출력
        cout << "조합 결과:\n";
        for (const auto& comb : result) {
            for (int x : comb) cout << x << ' ';
            cout << '\n';
        }
        return 0;
    }
```

- **using namespace std;** 지시문을 사용하여 std:: 생략.
- **vector** 컨테이너 사용.

## 재귀 호출 흐름

아래 다이어그램은 N=5, M=3, arr={1,2,3,4,5}일 때 combinationDFS(0,0)에서 시작하여 완전 탐색하는 과정을 간략화한 것이다.
```
    combinationDFS(0,0)
    ├─ pick 1 → combinationDFS(1,1)
    │   ├─ pick 2 → combinationDFS(2,2)
    │   │   ├─ pick 3 → combinationDFS(3,3) → 저장 [1,2,3]
    │   │   ├─ pick 4 → combinationDFS(4,3) → 저장 [1,2,4]
    │   │   └─ pick 5 → combinationDFS(5,3) → 저장 [1,2,5]
    │   ├─ pick 3 → combinationDFS(3,2)
    │   │   ├─ pick 4 → … → 저장 [1,3,4]
    │   │   └─ pick 5 → … → 저장 [1,3,5]
    │   ├─ pick 4 → … → [1,4,5]
    │   └─ pick 5 → … → (불가능, 남은 원소 부족)
    ├─ pick 2 → combinationDFS(2,1)
    │   ├─ pick 3 → … → [2,3,4], [2,3,5], [2,4,5]
    │   └─ …
    ├─ pick 3 → combinationDFS(3,1)
    │   └─ …
    └─ pick 4 → combinationDFS(4,1)
        └─ pick 5 → … → [4,5] 선택 불가 (M=3)
```


위 구조에서 깊이(depth)가 M에 도달하면 pick 내용이 result에 저장된다.  



# 순열(DFS) 구현 및 재귀 호출 흐름

## 개요  
이 문서에서는 DFS(Depth First Search) 기반 순열(permutation) 생성 방법과 재귀 호출 흐름을 정리했다. backtracking 기법을 사용해 중복 없이 모든 순열을 생성하는 방식이다.

## C++ 코드  

```cpp
    #include <iostream>
    #include <vector>

    using namespace std;

    int N;                                      // 전체 원소 개수
    vector<int> arr;                           // 원소 배열
    vector<bool> used;                         // 사용 여부 체크 배열
    vector<int> perm;                          // 현재 순열
    vector<vector<int>> result;                // 완성된 순열 결과

    // depth: 현재까지 채워진 위치
    void permutationDFS(int depth) {
        if (depth == N) {
            result.push_back(perm);
            return;
        }
        for (int i = 0; i < N; ++i) {
            if (used[i]) continue;
            used[i] = true;
            perm.push_back(arr[i]);
            permutationDFS(depth + 1);
            perm.pop_back();
            used[i] = false;
        }
    }

    int main() {
        N = 3;
        arr = {1, 2, 3};
        used.assign(N, false);

        permutationDFS(0);

        cout << "순열 결과:\n";
        for (auto &p : result) {
            for (int x : p) cout << x << ' ';
            cout << '\n';
        }
        return 0;
    }
```
## 재귀 호출 흐름 예시 (N=3, arr={1,2,3})  

```
    permutationDFS(0)
    ├─ pick 1 → used[0]=true, perm={1} → permutationDFS(1)
    │   ├─ pick 2 → used[1]=true, perm={1,2} → permutationDFS(2)
    │   │   ├─ pick 3 → used[2]=true, perm={1,2,3} → permutationDFS(3) 저장 [1,2,3]
    │   │   └ backtrack(3) → used[2]=false, perm={1,2}
    │   └ backtrack(2) → used[1]=false, perm={1}
    ├─ pick 2 → used[1]=true, perm={2} → permutationDFS(1)
    │   ├─ pick 1 → used[0]=true, perm={2,1} → permutationDFS(2) 저장 [2,1,3]
    │   ├─ pick 3 → used[2]=true, perm={2,3} → permutationDFS(2) 저장 [2,3,1]
    │   └ backtrack → used[0]=false, used[2]=false, perm={2}
    └─ pick 3 → used[2]=true, perm={3} → permutationDFS(1)
        ├─ pick 1 → used[0]=true, perm={3,1} → permutationDFS(2) 저장 [3,1,2]
        ├─ pick 2 → used[1]=true, perm={3,2} → permutationDFS(2) 저장 [3,2,1]
        └ backtrack → used[0]=false, used[1]=false, perm={3}
```


각 단계에서 아직 사용되지 않은 원소를 선택한 뒤 DFS로 다음 깊이를 탐색한다. 탐색이 끝나면 상태를 되돌리는 backtracking을 수행해 다른 분기를 탐색할 수 있도록 한다.
