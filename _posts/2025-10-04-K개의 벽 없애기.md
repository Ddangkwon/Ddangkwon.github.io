---
layout : post
title : K개의 벽 없애기
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# K개의 벽 없애기

[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-remove-k-walls/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-remove-k-walls/description)


## 풀이

```cpp

#include <iostream>
#include <queue>
#include <algorithm>
#include <climits>
using namespace std;

int n, k, answer = INT_MAX;
int arrmap[101][101];
int timemap[101][101][10];
bool isvisited[101][101][10];

int start_y, start_x, end_y, end_x;

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

typedef struct{
    int y;
    int x;
    int state;
}loc_t;

void bfs(int y, int x){
    queue<loc_t> q;

    q.push({y, x, 0});

    while(!q.empty()){
        int cy = q.front().y;
        int cx = q.front().x;
        int cstate = q.front().state;
        q.pop();

        if (cy == end_y && cx == end_x && cstate == k)
            return ;

        for(int dir = 0; dir < 4; dir++){
            int ny = cy + dy[dir];
            int nx = cx + dx[dir];

            if(ny < 1 || ny > n || nx < 1 || nx > n || cstate > k)
                continue;
            
            // 그냥 진행이 가능한 경우
            if(arrmap[ny][nx] == 0){
                if(timemap[ny][nx][cstate] == 0){
                    q.push({ny, nx, cstate});
                    timemap[ny][nx][cstate] = timemap[cy][cx][cstate] + 1;
                }
            }
            // 벽을 부수고 진행해야하는 경우 
            else{
                if(timemap[ny][nx][cstate] == 0){
                    int nstate = cstate + 1;
                    q.push({ny, nx, nstate});
                    timemap[ny][nx][nstate] = timemap[cy][cx][cstate] + 1;
                }
            }
        }
    }
}
int main() {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> n >> k;

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> arrmap[i][j];
        }
    }

    cin >> start_y >> start_x;
    cin >> end_y >> end_x;

    bfs(start_y, start_x);

    bool check_flag = false;
    for(int i = 0; i <= k; i++){
        if(timemap[end_y][end_x][i] != 0){
            answer = min(answer, timemap[end_y][end_x][i]);
            check_flag = true;
        }
    }
    if (check_flag){
        cout << answer << "\n";
    }
    else
        cout << "-1\n";

    return 0;
}


```