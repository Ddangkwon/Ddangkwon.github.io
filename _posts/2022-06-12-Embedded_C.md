---
layout : post
title : Embedded C 프로그래밍
comments : true
categories : 
- Embedded Engineering
tags : [Embedded Engineering]
---
# Embedded C 프로그래밍


## ISR(Interrupt Service Routine)

Interrupt handler 라고도 불리고 주로 외부 하드웨어적 요인이나 설정한 소프트웨어적 변경사항에 의해 발생하는 것을 사용자가 정의하고,
그 일이 발생할 경우 현재의 작업을 중단하고 우선 처리하는 작업을 말한다.
반대의 경우로는 폴링(Polling)이 있으며 폴링의 경우 해당 이벤트가 발생할 때까지 계속 확인하다가 발생하면 이벤트를 수행하는 것을 말한다.

이러한 인터럽트가 걸렸다는 신호로 IRQ(Interrput Request)라는 것이 있고, 이 IRQ가 어떤 Interrupt에 해당하는지를 구별해준다.

이러한 인터럽트에 관련된 플래그, 변수 등은 volatile로 선언된다.
=> 컴파일러 최적화 옵션에서 제외하여, 불분명한 결과를 야기하는 것을 피하기 위해서
### ISR 실행 과정

1. 주 프로그램 실행
2. 인터럽트 발생
3. 복귀주소(PC) 저장
4. 인터럽트 벡터로 점프
5. 인터럽트 처리
6. 인터럽트 처리 완료
7. 복귀주소 로드
8. 마지막에 실행된 주소로 점프
9. 1번 과정 다음 PC 위치로 이동

 
### 인터럽트 구성요소

1. 우선순위
=> 2개 이상의 요청이 동시에 들어올 경우 어떤 우선 순위로 서비스를 실행하는가?
2. 인터럽트 벡터(Interrput Vector)
=> 인터럽트 벡터는 인터럽트가 발생했을 때 할 일을 적어 놓은 것으로 ISR의 시작주소를 말한다.
3. 발원지
=> 인터럽트가 발생한 지점이 어디인가?

## 부트(Boot)에 대해..
전원 동작 후 BIOS가 불러오는 것으로 커널을 메모리에 로드하고 본격적인 동작을 위해 필요한 작업을 수행
플래시 메모리(rom)에서 시작되는 시스템 소프트웨어로서 하드웨어 초기화 커널을 RAM에 적재
이 후 인터럽트, GPIO 등을 점검 및 실행 가능한 상태로 만들어준다.

## 부트로더(BootLoader)
부트로더란 운영체제가 시동되기 이전에 미리 실행되면서 커널이 올바르게 시동되기 위해 필요한 모든 관련 작업을 마무리하고 최종적으로 운영체제를 시동시키기 위한 목적을 가진 프로그램을 말한다.

기본적인 OS 실행 순서는 다음고 같다. 

BIOS -> 1차 부트로더 -> 2차 부트로더 -> 커널 -> 운영체제

 

컴퓨터가 실행되면 BIOS가 로드되고 BIOS에 연결된 저장 매체에서 설정된 부팅 순서대로 부트로더들을 불러온다.

BIOS는 MBR에 존재하는 하드디스크 파티션 테이블을 읽은 후 활성화되어있는 파티션의 PBR을 읽어 그 데이터로 부팅하게 된다. 여기서 MBR, PBR이 바로 1차 부트로더이다.

 

윈도우와 같은 큰 용량이 필요한 운영체제는 2차 부트로더가 필요하며 1차 부트로더가 2차 부트로더를 로드하고 다시 2차 부트로더가 커널을 로드하는 방식이다.

2차 부트로더에는 GRUB(리눅스, 윈도우), SYSLINUX(리눅스), LILO(리눅스) 등이 있다.

## 커널(Kernel)에 대해..

컴퓨터 운영체제 중 핵심이 되는 프로그램으로 시스템 자원의 효율적 관리(스케쥴링), 하드웨어 추상화 등을 통해 Application S/W 개발을 도움

커널은 컴퓨터의 운영체제의 핵심이 되는 컴퓨터 프로그램의 하나로 운영체제의 전체적인 시스템을 통제하고 시스템 자원을 효율적으로 관리하여 응용 프로그램 수행에 필요한 서비스를 제공
 

커널이 하는 일

프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 환경 제공

메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공

파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공

입출력 관리 : 필요한 입력과 출력 서비스 제공

프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 제공




## 매크로 함수 장단점

### 매크로 함수 장점

1. 상대적으로 실행속도가 빠르다.
=> 호출과 동시에 함수의 생성부터(스택메모리 할당) 함수의 종료(return 문을 통한 값 반환)까지 이루어진다.(선행처리기에서 처리)
=> 즉 전체 프로그램의 실행 속도에는 영향을 주지 않는다.

2. 자료형에 구애받지 않는다.
=> 전달인자의 자료형은 알아서 치환된다(묵시적 형변환)

### 매크로 함수 단점

1. 디버깅이 어렵다.

2. 매크로 함수의 길이가 길어질수록 가독성이 떨어진다.

## C언어 매크로 연산자

### # 연산자
문자열로 변환시켜주는 연산자로 매크로 변수를 문자열로 바꿔주는 역할을 한다.
매크로 함수의 전달인자를 다른 대상(전달인자, 숫자, 문자, 문자열 등)과 이어줄 때 사용하는 매크로 연산자
```c
#define PRINT_FUNC(s)      printf(#s)

int main()
{
    PRINT_FUNC(HELLO WORLD)

    return 0;
}

```

### ## 연산자
여러 코드를 붙이는 매크로 연산자(concat)

```c
#define CONCAT_FUNC(a, b)   a##b

int take = 1;
int word = 2;

int takeword = 10;
int main()
{
    CONCAT_FUNC(take, word);

    return 0;
}

```

결과 값으로 10이 출력된다.



