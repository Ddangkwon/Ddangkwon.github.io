---
layout : post
title : 활주로 건설
comments : true
categories : 
- CodingTest
tags : [CodingTest, Simulation]
---
# 순열과 조합

## 순열정복 1 (중복 순열)

## 문제 설명

양의 정수 **N**과 **M**이 주어졌을 때,  
**1부터 N까지의 정수를 M번 나열할 수 있는 모든 경우**를 출력하는 프로그램을 작성하시오.  

나열되는 숫자는 **중복해서 사용이 가능하다**.

## 입력

양의 정수 **N**과 **M**이 공백을 사이에 두고 주어진다.  
**(1 ≤ N ≤ 6, 1 ≤ M ≤ 6)**

## 출력

**1부터 N까지의 자연수**를 **M번 나열**하는 **모든 경우**를 출력한다.  
출력은 **사전 순(앞 자리 오름차순)**으로 출력한다.


## 풀이

```cpp
#include <iostream>

using namespace std;

int N, M;
int answer[6] = { 0 };
void dfs(int cnt){
    if(cnt == M){
        for(int i = 0; i < M; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';
        return ;
    }

    for(int i = 1; i <= N; i++){
        answer[cnt] = i;
        dfs(cnt + 1);
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    cin >> N >> M;

    dfs(0);
    
    return 0;
}
```


## 순열(중복 없이)

## 문제 설명

1부터 **N**까지의 정수들을 **M번 나열**하는 모든 경우를 출력하는 프로그램을 작성하시오.  
단, **중복되는 숫자는 사용할 수 없다**.

## 입력

한 줄에 두 자연수 **N**과 **M**이 공백을 사이에 두고 주어진다.  
**(1 ≤ M ≤ N ≤ 7)**

## 출력

**1부터 N까지의 자연수**를 **중복 없이 M개 나열**한 모든 경우를 출력한다.  
출력은 **사전 순으로 증가하는 순서**로 출력해야 한다.


```cpp
#include <iostream>

using namespace std;

// N: 1부터 N까지의 숫자 사용
// M: M개를 선택하여 나열
int N, M;

// 정답 배열: 현재 선택된 수열을 저장
int answer[7] = { 0 };

// 방문 여부 체크 배열: 같은 숫자를 중복해서 사용하지 않도록 하기 위해 사용
bool isvisited[7] = { 0 };

// 깊이 우선 탐색 함수
// cnt: 현재까지 선택한 수의 개수 (depth)
void dfs(int cnt){

    // M개의 수를 모두 선택한 경우 출력
    if(cnt == M){
        for(int i = 0; i < M; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';
        return ;
    }

    // 1부터 N까지의 수 중 하나 선택
    for(int i = 1; i <= N; i++){
        // 이미 방문한 숫자면 건너뛴다 (중복 방지)
        if(isvisited[i])
            continue;

        // 현재 위치(cnt)에 숫자 i 저장
        answer[cnt] = i;

        // 숫자 i를 사용했으므로 방문 표시
        isvisited[i] = true;

        // 다음 위치(cnt + 1)를 채우기 위해 재귀 호출
        dfs(cnt + 1);

        // 재귀가 끝나고 돌아오면, i를 다시 사용할 수 있도록 방문 해제
        // → 백트래킹의 핵심: 선택을 원상복구해서 다음 경우 탐색
        isvisited[i] = false;
    }
}

int main(){
    // 입출력 최적화
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // 입력 받기
    cin >> N >> M;

    // DFS 시작 (0개 선택된 상태에서 시작)
    dfs(0);
    
    return 0;
}

```



## 입력을 따로 받는 순열(중복 없이)

## 문제 설명

이번 문제는 1부터 N까지의 자연수를 자동으로 쓰는 게 아니라,  
**사용자가 직접 입력한 N개의 서로 다른 자연수** 중에서  
**중복 없이 M개를 나열**하는 모든 경우를 출력하는 것이다.

> 단, 같은 수는 한 번만 사용할 수 있고,  
> 출력 순서는 **사전 순(오름차순)**이어야 한다.

---

## 입력

- 첫째 줄: 두 자연수 **N**, **M**이 주어진다  
  (1 ≤ M ≤ N ≤ 7)

- 둘째 줄: 오름차순으로 정렬된 서로 다른 **N개의 자연수**가 주어진다  
  (1 ≤ ai ≤ 100)

---

## 출력

- N개의 자연수 중에서 **M개를 중복 없이 나열한 모든 경우**를 출력한다  
- 각 수열은 한 줄에 출력하며, 출력 순서는 **사전 순(오름차순)**이다

---



```cpp
#include <iostream>

using namespace std;

int N, M;
int answer[7] = { 0 };
int input_arr[7] = { 0 };
bool isvisited[7] = { false }; 
void dfs(int cnt){

    if(cnt == M){
        for(int i =0; i < M; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';

        return ;
    }

    for(int i = 0; i < N; i++){
        if(isvisited[i])
            continue;
        answer[cnt] = input_arr[i];
        isvisited[i] = true;
        dfs(cnt + 1);
        isvisited[i] = false;
    }

}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M;

    for(int i = 0; i < N; i++){
        cin >> input_arr[i];
    }    

    dfs(0);
    
    return 0;
}
```


## 순열정복 4 (중복 조합)
## 문제


여러분은 세상에서 제일 재밌기로 소문난 순열정복 과정을 진행중이다.

오늘의 목표는 두구두구두구두구....

1..N까지의 자연수를 중복을 허용하여 M번 나열하는데, 같은 조합은 한 번만 출력되게 하는 것이다.


예를 들어 1 1 2, 1 2 1, 2 1 1 는 모두 같은 조합이다.

즉, 1 1 2만 출력되고 나머지 두 경우는 출력되지 않아야 한다.


## 입력
자연수 N과 M이 주어진다. (1≤N≤7 , 1≤M≤7)

 


## 출력
N개의 자연수를 중복을 허용하여 M번 나열하는 경우를 모두 출력하되, 같은 조합은 한 번만 출력되게 하라.

당연히 출력순서는 오름차순이다.

## 풀이

내 풀이

```cpp
#include <iostream>

using namespace std;

int N, M;
int answer[8] = { 0 };
bool isvisited[8] = { false }; 

void dfs(int cnt){

    if(cnt == M){
        // 같은 조합은 한번만 출력되도록 그리고 오름차순으로만 출력되도록 조건 추가 
        for(int i = 0; i < M - 1; i++){
            if(answer[i] > answer[i + 1])
                return ;
        }
        for(int i = 0; i < M; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';
        return ;
    }

    for(int i = 1; i <= N; i++){
        answer[cnt] = i;
        dfs(cnt + 1);
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M;


    dfs(0);
    
    return 0;
}
```

정석 풀이
```cpp
#include <iostream>

using namespace std;

int N, M;
int answer[8] = { 0 };
bool isvisited[8] = { false }; 

void dfs(int cnt, int start){

    if(cnt == M){
        for(int i = 0; i < M; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';
        return ;
    }
	// 시작 포인트를 매개변수로 받아 
    for(int i = start; i <= N; i++){
        answer[cnt] = i;
        dfs(cnt + 1, i);
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M;

	// 시작 숫자는 1부터 시작하므로 0, 1 을 입력으로 넣어준다.
    dfs(0, 1);
    
    return 0;
}
```



## 순열정복 5

## 문제


여러분들이 가장 좋아하는 바로 그 시간, 순열정복 과정 5탄!


오늘의 목표는 1..N까지의 숫자를 중복을 허용하여 M개를 나열하되, 합이 정확히 S가 되는 경우를 출력하는 것이다.

 

 


## 입력
첫 줄에 자연수 N,M,S가 주어진다. (1≤N≤​6 , 1≤​M≤​6 , 1≤​S≤​N*M )

 


## 출력
문제의 조건에 맞는 모든 경우를 오름차순으로 출력한다.

	
## 풀이

내 풀이 (71ms)
```cpp
#include <iostream>

using namespace std;

int answer[7] = { 0 };
int N, M, S;
void dfs(int cnt){

    if(cnt == M){
        int sum = 0;
        for(int i =0; i < M; i++)
            sum += answer[i];
        if(sum != S)
            return ;
        for(int i =0; i < M; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';

        return ;
    }

    for(int i = 1; i <= N; i++){
        answer[cnt] = i;
        dfs(cnt + 1);
    }
}
int main(){

    cin >> N >> M >> S;

    dfs(0);

    return 0;
}
```

정석 풀이

```cpp
#include <iostream>

using namespace std;

int N, M, S;
int seq[8]; 

void dfs(int depth, int sum) {
    // M개를 모두 선택한 경우
    if (depth == M) {
        if (sum == S) {
            for (int i = 0; i < M; i++) {
                cout << seq[i] << " ";
            }
            cout << "\n";
        }
        return;
    }

    for (int i = 1; i <= N; i++) {
        if (sum + i > S) continue; // 합이 초과되면 가지치기
        seq[depth] = i;
        dfs(depth + 1, sum + i);
        // 배열은 덮어쓰므로 별도 백트래킹 필요 없음
    }
}

int main() {
    cin >> N >> M >> S;
    dfs(0, 0);
    return 0;
}


```


## 순열 정복 6

## 문제

사실 진짜 재밌는 순열정복은 지금부터 시작이다.

참고로 너무 재밌어서 둘이 풀다가 하나가 죽어도 정올에서는 책임지지 않는다.
 

오늘은 자연수 S만 입력받는다.

여러분은 합이 S가 되는 모든 자연수들의 조합을 출력하면 된다.

 

이미 알고 있겠지만, "조합"이라고 하면 같은 구성으로 된 순열은 하나로 친다. 

예를 들어, 아래의 순열들은 하나의 조합이므로, 헷갈리지 말자

1 1 2 2

1 2 2 1

1 2 1 2

2 2 1 1

2 1 2 1

2 1 1 2

 

 


## 입력
첫 줄에 자연수 S가 주어진다. (1 ≤ S ≤ 20)

 


## 출력
합이 S가 되는 모든 자연수 조합을 출력한다.

같은 조합중에서는 ... 엄... 맨날 오름차순만 하면 재미없으니깐 오늘은 내림차순으로 먼저 나오는 조합만 출력한다.

자세한 사항은 출력예시를 보면 이해하기 쉬울 것이다.

 
```cpp
#include <iostream>

using namespace std;

// 결과를 저장할 배열 (최대 20개 정도로 충분)
int answer[21] = { 0 };

// 목표 합
int S;

// DFS 함수
// cnt  : 현재까지 선택한 수의 개수 (깊이)
// sum  : 현재까지 선택된 수들의 합
// start: 다음 선택할 수의 최대값 (내림차순 유지하기 위해 사용)
void dfs(int cnt, int sum, int start){
    // 종료 조건 1: 정확히 합이 S가 되었을 때 → 출력
    if(sum == S){
        for(int i = 0; i < cnt; i++){
            cout << answer[i] << " ";
        }
        cout << '\n';
        return ;
    }

    // 종료 조건 2: 현재 합이 S를 넘었거나, 너무 많이 선택한 경우
    if(cnt == S || sum > S)
        return ;

    // 1부터 start까지 수 중 선택 (내림차순)
    for(int i = start; i >= 1; i--){
        // i를 현재 위치에 넣고 누적합 업데이트
        answer[cnt] = i;
        sum += i;

        // 다음 숫자도 i 이하만 선택 (중복 허용, 내림차순 유지)
        dfs(cnt + 1, sum, i);

        // 백트래킹: 원상복구
        sum -= i;
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    // 입력: 목표 합 S
    cin >> S;

    // DFS 시작 (깊이 0, 현재 합 0, 최대 선택값 S)
    dfs(0, 0, S);

    return 0;
}

```