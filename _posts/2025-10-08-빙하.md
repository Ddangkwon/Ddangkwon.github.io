---
layout : post
title : 빙하
comments : true
categories : 
- CodingTest
tags : [CodingTest, BFS]
---

# 빙하

[https://www.codetree.ai/ko/trails/complete/chttps://www.codetree.ai/ko/trails/complete/curated-cards/challenge-glacier/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-glacier/description)


## 풀이

```cpp

#include <iostream>
#include <queue>
#include <cstring>

using namespace std;

#define MAX_N 200
#define MAX_M 200
#define DIR_NUM 4

enum ELEMENT {
    WATER = 0,
    GLACIER = 1
};

typedef struct{
    int y;
    int x;
} loc_t;

int N, M;
int arrmap[MAX_N][MAX_M] = {0};

bool isvisited[MAX_N][MAX_M] = {false};  // 외곽 물 표시용
int dy[DIR_NUM] = { -1, 1, 0, 0 };
int dx[DIR_NUM] = { 0, 0, -1, 1 };

queue<loc_t> q;               // 외곽 물 BFS 큐
int elapsed_time = 0;         // 총 소요 시간
int last_melt_cnt = 0;        // 마지막에 녹은 빙하 개수

inline bool in_range(int y, int x){
    return (0 <= y && y < N && 0 <= x && x < M);
}

inline bool can_go_water(int y, int x){
    return in_range(y, x) && (arrmap[y][x] == WATER) && (!isvisited[y][x]);
}

// 외곽 물(경계와 연결된 물)들을 모두 isvisited=true 로 표시한다.
void bfs_outside_water(){

    // 방문 배열 초기화
    for(int i = 0; i < N; i++)
        for(int j = 0; j < M; j++)
            isvisited[i][j] = false;

    // 큐 비우기
    while(!q.empty()) 
        q.pop();

    // 경계의 물(0)들을 전부 시작점으로 넣는다.
    for(int i = 0; i < N; i++){
        if(arrmap[i][0] == WATER && !isvisited[i][0]){
            isvisited[i][0] = true;
            loc_t t; t.y = i; t.x = 0;
            q.push(t);
        }
        if(arrmap[i][M - 1] == WATER && !isvisited[i][M - 1]){
            isvisited[i][M - 1] = true;
            loc_t t; t.y = i; t.x = M - 1;
            q.push(t);
        }
    }
    for(int j = 0; j < M; j++){
        if(arrmap[0][j] == WATER && !isvisited[0][j]){
            isvisited[0][j] = true;
            loc_t t; t.y = 0; t.x = j;
            q.push(t);
        }
        if(arrmap[N - 1][j] == WATER && !isvisited[N - 1][j]){
            isvisited[N - 1][j] = true;
            loc_t t; t.y = N - 1; t.x = j;
            q.push(t);
        }
    }

    // 물(0)만 따라가며 외곽 물 전부 방문 표시
    while(!q.empty()){
        loc_t cur = q.front(); q.pop();
        int cy = cur.y, cx = cur.x;

        for(int d = 0; d < DIR_NUM; d++){
            int ny = cy + dy[d];
            int nx = cx + dx[d];
            if(can_go_water(ny, nx)){
                isvisited[ny][nx] = true;
                loc_t nxt; nxt.y = ny; nxt.x = nx;
                q.push(nxt);
            }
        }
    }
}

// 외곽 물과 인접한 빙하를 찾아 한 번에 녹인다. 녹인 개수를 리턴한다.
int melt_once(){

    // 좌표를 먼저 모아두고, 한 번에 갱신한다.
    static loc_t to_melt[MAX_N * MAX_M];
    int tm_sz = 0;

    for(int i = 0; i < N; i++){
        for(int j = 0; j < M; j++){
            if(arrmap[i][j] != GLACIER) continue;

            bool touch_outside = false;
            for(int d = 0; d < DIR_NUM; d++){
                int ny = i + dy[d];
                int nx = j + dx[d];
                if(in_range(ny, nx) && isvisited[ny][nx]){ // 외곽 물과 인접
                    touch_outside = true;
                    break;
                }
            }
            if(touch_outside){
                loc_t t; t.y = i; t.x = j;
                to_melt[tm_sz++] = t;
            }
        }
    }

    for(int k = 0; k < tm_sz; k++){
        int y = to_melt[k].y;
        int x = to_melt[k].x;
        arrmap[y][x] = WATER;
    }

    return tm_sz;
}

// 빙하 존재 여부 확인
bool glacier_exist(){
    for(int i = 0; i < N; i++)
        for(int j = 0; j < M; j++)
            if(arrmap[i][j] == GLACIER) return true;
    return false;
}

int main(){

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M;
    for(int i = 0; i < N; i++)
        for(int j = 0; j < M; j++)
            cin >> arrmap[i][j];

    do{
        bfs_outside_water();           // 이번 단계 외곽 물 표시
        last_melt_cnt = melt_once();   // 외곽 물과 접한 빙하 녹임
        elapsed_time++;                // 시간 +1
    }while(glacier_exist());           // 빙하가 남아 있으면 반복

    cout << elapsed_time << " " << last_melt_cnt << "\n";
    return 0;
}

```

- 0-1 BFS 로 문제 해결
```cpp
#include <iostream>
#include <deque>
#include <climits>
#include <cstring>
using namespace std;

int N, M;
int arrmap[200][200];
int distv[200][200]; // 바깥 공기까지 도달하기 위해 지나야 하는 1(cheese) 최소 개수
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

typedef struct {
    int y;
    int x;
} loc_t;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> N >> M;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            cin >> arrmap[i][j];
        }
    }

    // dist 초기화
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            distv[i][j] = INT_MAX / 4;
        }
    }

    deque<loc_t> dq;

    // 경계 0을 모두 시작점으로 push
    for (int i = 0; i < N; i++) {
        if (arrmap[i][0] == 0 && distv[i][0] > 0) {
            distv[i][0] = 0;
            loc_t t = {i, 0};
            dq.push_front(t);
        }
        if (arrmap[i][M - 1] == 0 && distv[i][M - 1] > 0) {
            distv[i][M - 1] = 0;
            loc_t t = {i, M - 1};
            dq.push_front(t);
        }
    }
    for (int j = 0; j < M; j++) {
        if (arrmap[0][j] == 0 && distv[0][j] > 0) {
            distv[0][j] = 0;
            loc_t t = {0, j};
            dq.push_front(t);
        }
        if (arrmap[N - 1][j] == 0 && distv[N - 1][j] > 0) {
            distv[N - 1][j] = 0;
            loc_t t = {N - 1, j};
            dq.push_front(t);
        }
    }

    // 0-1 BFS
    while (!dq.empty()) {
        loc_t cur = dq.front();
        dq.pop_front();

        int cy = cur.y;
        int cx = cur.x;

        for (int d = 0; d < 4; d++) {
            int ny = cy + dy[d];
            int nx = cx + dx[d];
            if (ny < 0 || ny >= N || nx < 0 || nx >= M) continue;

            int w = (arrmap[ny][nx] == 1) ? 1 : 0;
            if (distv[ny][nx] > distv[cy][cx] + w) {
                distv[ny][nx] = distv[cy][cx] + w;
                loc_t next = {ny, nx};
                if (w == 0)
                    dq.push_front(next);
                else
                    dq.push_back(next);
            }
        }
    }

    // 정답 계산
    int ans_time = 0;
    int ans_size = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (arrmap[i][j] != 1) continue;
            if (distv[i][j] == INT_MAX / 4) continue;
            if (distv[i][j] > ans_time) {
                ans_time = distv[i][j];
                ans_size = 1;
            } else if (distv[i][j] == ans_time) {
                ans_size++;
            }
        }
    }

    cout << ans_time << " " << ans_size << "\n";
    return 0;
}

```