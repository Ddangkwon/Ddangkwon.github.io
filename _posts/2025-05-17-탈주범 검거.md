---
layout : post
title : 탈주범 검거
comments : true
categories : 
- CodingTest
tags : [CodingTest, DFS]

---

# 탈주범 검거 

## 📘 문제 개요

탈주범이 지하 터널을 통해 도주 중입니다. 경찰은 터널 구조가 주어진 맵에서 탈주범을 추적하려고 합니다. 주어진 시간 L 이내에 **도달할 수 있는 위치의 개수**를 구하는 것이 목표입니다.

## 🧩 입력 조건

- 맵은 N x M 크기의 2차원 배열입니다.
- 각 셀에는 터널의 **타입**이 들어 있습니다 (0~7).
- 각 타입에 따라 이동 가능한 방향이 다릅니다.
- 시작 지점 (x, y)에서 출발하여, **최대 L시간 동안 이동**할 수 있습니다.
- 이동은 터널이 양방향 연결된 경우에만 가능합니다.

## 🔀 터널 타입 및 이동 가능 방향

| 타입 | 설명         | 이동 가능 방향 (상:0, 하:1, 좌:2, 우:3) |
|------|--------------|------------------------------------------|
| 0    | 없음         | []                                       |
| 1    | 상하좌우     | [0, 1, 2, 3]                              |
| 2    | 상하         | [0, 1]                                   |
| 3    | 좌우         | [2, 3]                                   |
| 4    | 상우         | [0, 3]                                   |
| 5    | 하우         | [1, 3]                                   |
| 6    | 하좌         | [1, 2]                                   |
| 7    | 상좌         | [0, 2]                                   |

> 연결 가능 방향은 양방향이어야 이동할 수 있습니다.

---

## 💡 BFS 핵심 로직

1. 시작점에서 BFS 탐색 시작
2. 현재 위치에서 연결 가능한 방향으로 이동
3. 이동할 위치의 터널도 해당 방향에서 진입 가능해야 함
4. 시간(L)이 초과되면 탐색 종료

```cpp
#include <iostream>
#include <vector>
#include <queue>

using namespace std;

#define ARR_MAX_LEN 55
int T, N, M, R, C, L, answer = 0;
int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
int time[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };

typedef struct {
	int y;
	int x;
}cord;

queue<cord> q;

// 상하좌우
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

// vector 도 아래와 같이 배열처럼 초기화 가능

vector<vector<int> > tunnel = {

	{},
	{0, 1, 2, 3},
	{0, 1},
	{2, 3},
	{0, 3},
	{1, 3},
	{1, 2},
	{0, 2}
};
 void input_func() {
	cin >> N >> M >> R >> C >> L;

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			cin >> arrmap[i][j]; 
		}
	}
}

void init_func() {

	answer = 0;

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			isvisited[i][j] = false;
		}
	}
}

void answer_update_func() {
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < M; j++) {
			if (isvisited[i][j])
				answer++;
		}
	}

}

void bfs(int y, int x) {

	while (!q.empty()) {
		int cy = q.front().y;
		int cx = q.front().x;
		vector<int> type = tunnel[arrmap[cy][cx]];
		q.pop();
		for (int dir = 0; dir < type.size(); dir++) {
			int ny = cy + dy[dir];
			int nx = cx + dx[dir];
			if (ny >= 0 && ny < N && nx >= 0 && nx < M) {
				if (!isvisited[ny][nx] && arrmap[ny][nx] != 0) {
					q.push({ ny, nx });
					isvisited[ny][nx] = true;
				}
			}
		}
	}
}

int main() {

	cin >> T;

	for (int tc = 1; tc <= T; tc++) {
		
		input_func();

		init_func();

		bfs(R, C);

		answer_update_func();

		cout << "#" << tc << " " << answer << "\n";
	}

	return 0;
}
```