---
layout : post
title : 파이썬 중고급문법
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---
# 알고리즘 정리


## 1차원 배열 구간합

- 일반적인 생각으로 구간합을 계산할 경우 n^2의 시간복잡도가 나타난다.
- 이를 위해 sum 값을 구간합만큼 계산하고 슬라이딩 윈도우처럼 한칸씩 움직이며 새롭게 추가되는 값은 +를 빠지는 값은 -를 하여
sum 값을 업데이트 하고 max 값과 비교한다.
- 이를 통해 시간 복잡도를 n까지 줄일 수 있다.

```cpp
#include<cstdio>
#include<vector>
using namespace std;			
int main(){
	int n, k, i, sum=0, result = 0;
	scanf("%d %d", &n, &k);
	vector<int> a(n);
	for(i=0; i<n; i++){
		scanf("%d", &a[i]);
	}
	for(i = 0; i < k; i++){
		sum=sum+a[i];
	}
	res=sum;
	for(i=k; i<n; i++){
		sum=sum+(a[i]-a[i-k]);
		if(sum>res) 
            result=sum;
	}
	printf("%d\n", result);
	return 0;
}

```

## 재귀함수의 이해

재귀함수와 스택프레임에 대해서 이해하기 위해서 가장 좋은 예시로 이진수 계산을 재귀로 구현하는 방법이 있다.
우리가 이진수로의 변환을 위해서 2로 숫자를 계속 나눠주고 나머지를 표시하고 최종적으로 몫이 0이 됐을 때 나머지들을 거꾸로 읽어나간다.

이 때 스택의 개념을 사용할 수 있는데, 스택의 경우 LIFO(Last in First out) 방식을 사용하기 때문이다.
재귀함수가 호출 되는 시점을 기준으로 이전은 스택에 넣기 전, 스택에 넣기 후로 표현할 수 있다.
보통 재귀로 표현하는 경우 이러한 스택의 특징을 활용하는 경우가 많기 때문에 목표하는 동작을 스택에 넣은 후,
즉, 재귀함수를 호출하고 동작을 넣는다.
```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;	

void recur(int x)
{
	if(x==0) 
		return;
	else
	{
		printf("%d", x%2); // 1101 
		D(x/2);
		// recur(1) 1 = > recur(2) 0 = > recur(5) 1 => recur(11) 1
		printf("%d", x%2); // 1011 => 목표하는 동작
	}
}	
int main(){
	int n;

	scanf("%d", &n);

	recur(n);

	return 0;
}
```