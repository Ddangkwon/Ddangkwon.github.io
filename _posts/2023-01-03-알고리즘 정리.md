---
layout : post
title : íŒŒì´ì¬ ì¤‘ê³ ê¸‰ë¬¸ë²•
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---
# ì•Œê³ ë¦¬ì¦˜ ì •ë¦¬


## 1ì°¨ì› ë°°ì—´ êµ¬ê°„í•©

- ì¼ë°˜ì ì¸ ìƒê°ìœ¼ë¡œ êµ¬ê°„í•©ì„ ê³„ì‚°í•  ê²½ìš° n^2ì˜ ì‹œê°„ë³µì¡ë„ê°€ ë‚˜íƒ€ë‚œë‹¤.
- ì´ë¥¼ ìœ„í•´ sum ê°’ì„ êµ¬ê°„í•©ë§Œí¼ ê³„ì‚°í•˜ê³  ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ì²˜ëŸ¼ í•œì¹¸ì”© ì›€ì§ì´ë©° ìƒˆë¡­ê²Œ ì¶”ê°€ë˜ëŠ” ê°’ì€ +ë¥¼ ë¹ ì§€ëŠ” ê°’ì€ -ë¥¼ í•˜ì—¬
sum ê°’ì„ ì—…ë°ì´íŠ¸ í•˜ê³  max ê°’ê³¼ ë¹„êµí•œë‹¤.
- ì´ë¥¼ í†µí•´ ì‹œê°„ ë³µì¡ë„ë¥¼ nê¹Œì§€ ì¤„ì¼ ìˆ˜ ìˆë‹¤.

```cpp
#include<cstdio>
#include<vector>
using namespace std;			
int main(){
	int n, k, i, sum=0, result = 0;
	scanf("%d %d", &n, &k);
	vector<int> a(n);
	for(i=0; i<n; i++){
		scanf("%d", &a[i]);
	}
	for(i = 0; i < k; i++){
		sum=sum+a[i];
	}
	res=sum;
	for(i=k; i<n; i++){
		sum=sum+(a[i]-a[i-k]);
		if(sum>res) 
            result=sum;
	}
	printf("%d\n", result);
	return 0;
}

```

## ì¬ê·€í•¨ìˆ˜ì˜ ì´í•´

ì¬ê·€í•¨ìˆ˜ì™€ ìŠ¤íƒí”„ë ˆì„ì— ëŒ€í•´ì„œ ì´í•´í•˜ê¸° ìœ„í•´ì„œ ê°€ì¥ ì¢‹ì€ ì˜ˆì‹œë¡œ ì´ì§„ìˆ˜ ê³„ì‚°ì„ ì¬ê·€ë¡œ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì´ ìˆë‹¤.
ìš°ë¦¬ê°€ ì´ì§„ìˆ˜ë¡œì˜ ë³€í™˜ì„ ìœ„í•´ì„œ 2ë¡œ ìˆ«ìë¥¼ ê³„ì† ë‚˜ëˆ ì£¼ê³  ë‚˜ë¨¸ì§€ë¥¼ í‘œì‹œí•˜ê³  ìµœì¢…ì ìœ¼ë¡œ ëª«ì´ 0ì´ ëì„ ë•Œ ë‚˜ë¨¸ì§€ë“¤ì„ ê±°ê¾¸ë¡œ ì½ì–´ë‚˜ê°„ë‹¤.

ì´ ë•Œ ìŠ¤íƒì˜ ê°œë…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ”ë°, ìŠ¤íƒì˜ ê²½ìš° LIFO(Last in First out) ë°©ì‹ì„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì´ë‹¤.
ì¬ê·€í•¨ìˆ˜ê°€ í˜¸ì¶œ ë˜ëŠ” ì‹œì ì„ ê¸°ì¤€ìœ¼ë¡œ ì´ì „ì€ ìŠ¤íƒì— ë„£ê¸° ì „, ìŠ¤íƒì— ë„£ê¸° í›„ë¡œ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
ë³´í†µ ì¬ê·€ë¡œ í‘œí˜„í•˜ëŠ” ê²½ìš° ì´ëŸ¬í•œ ìŠ¤íƒì˜ íŠ¹ì§•ì„ í™œìš©í•˜ëŠ” ê²½ìš°ê°€ ë§ê¸° ë•Œë¬¸ì— ëª©í‘œí•˜ëŠ” ë™ì‘ì„ ìŠ¤íƒì— ë„£ì€ í›„,
ì¦‰, ì¬ê·€í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê³  ë™ì‘ì„ ë„£ëŠ”ë‹¤.

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;	

void recur(int x)
{
	if(x==0) 
		return;
	else
	{
		printf("%d", x%2); // 1101 
		D(x/2);
		// recur(1) 1 = > recur(2) 0 = > recur(5) 1 => recur(11) 1
		printf("%d", x%2); // 1011 => ëª©í‘œí•˜ëŠ” ë™ì‘
	}
}	
int main(){
	int n;

	scanf("%d", &n);

	recur(n);

	return 0;
}
```

## íˆ¬ í¬ì¸í„° ì•Œê³ ë¦¬ì¦˜

- ë¦¬ìŠ¤íŠ¸ì— ìˆœì°¨ì ìœ¼ë¡œ ì ‘ê·¼í•´ì•¼ í•  ë•Œ ë‘ ê°œì˜ ì ì˜ ìœ„ì¹˜ë¥¼ ê¸°ë¡í•˜ë©´ì„œ ì²˜ë¦¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜
- ì£¼ë¡œ ë‹¨ìˆœ Brute Force ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼ ì‹œ ì‹œê°„ ì´ˆê³¼ê°€ ê±¸ë¦¬ëŠ” ê²½ìš° íˆ¬ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ë©”ëª¨ë¦¬ì™€ ì‹œê°„ íš¨ìœ¨ì„±ì„ ë†’ì´ëŠ”ë° ì“´ë‹¤.

í¬ì¸í„°ì˜ ê²½ìš° í¬ê²Œ 2ê°€ì§€ ë°©ì‹ìœ¼ë¡œ ì“´ë‹¤.

1. ì•ì—ì„œ ì‹œì‘í•˜ëŠ” í¬ì¸í„°ì™€ ëì—ì„œ ì‹œì‘í•˜ëŠ” í¬ì¸í„°ê°€ ì–´ëŠ í•œ ì§€ì ì—ì„œ ë§Œë‚˜ê³  ì¢…ë£Œí•˜ëŠ” ë°©ì‹
2. ë¹ ë¥¸ í¬ì¸í„°ê°€ ëŠë¦° í¬ì¸í„° ë³´ë‹¤ ì•ì„œëŠ” ë°©ì‹

ì‹œê°„ ë³µì¡ë„ì˜ ê²½ìš° ë§¤ ë£¨í”„ë§ˆë‹¤ í•­ìƒ ë‘ í¬ì¸í„° ì¤‘ í•˜ë‚˜ëŠ” 1ì”© ì¦ê°€í•˜ê³  ê° í¬ì¸í„°ê°€ në²ˆ ëˆ„ì  ì¦ê°€í•˜ë©´ ì¢…ë£Œ
=>  O(N)

ì˜ˆì‹œë¬¸ì œ : ê³µí†µì›ì†Œ ì°¾ê¸°
1. ì •ë ¬í•˜ì—¬ ê³µí†µì›ì†Œë¥¼ ì°¾ê¸° ìš©ì´í•˜ë„ë¡ í•œë‹¤.
2. ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬ëœ ìˆ˜ì—´ì„ íˆ¬ í¬ì¸í„°ë¥¼ ì‚¬ìš©í•´ì„œ ê³µí†µì›ì†Œë¥¼ ê²€ìƒ‰í•œë‹¤.
3. ê³µí†µì›ì†Œë¥¼ ì •ë‹µ ë¦¬ìŠ¤íŠ¸ì— ë„£ê³  ë¦¬í„´

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

int main()
{
	int n, m, i, p1=0, p2=0, p3=0;
	scanf("%d", &n);
	
	vector<int> a(n);

	for(i = 0; i < n; i++)
	{
		scanf("%d", &a[i]);
	}
	sort(a.begin(), a.end());
	
	scanf("%d", &m);

	vector<int> b(m);
	vector<int> c;

	for(i = 0; i < m; i++)
	{
		scanf("%d", &b[i]);
	}
	sort(b.begin(), b.end());
	// ë‘ ë²¡í„° ëª¨ë‘ ì •ë ¬ ì™„ë£Œ
	// íˆ¬í¬ì¸í„° ì•Œê³ ë¦¬ì¦˜
	while(p1 < n && p2 < m)
	{
		// ê³µí†µ ì›ì†Œë¥¼ ì°¾ì•˜ì„ ë•Œ
		if(a[p1] == b[p2])
		{
			c.push_back(a[p1++]);
			p2++;
		}
		//bì˜ ì›ì†Œê°€ ë” í´ ê²½ìš° p1 í¬ì¸í„° ì¦ê°€
		else if(a[p1] < b[p2])
		{
			p1++;
		}
		//aì˜ ì›ì†Œê°€ ë” í´ ê²½ìš° p2 í¬ì¸í„° ì¦ê°€
		else 
			p2++;
	}
	for(i = 0; i < p3; i++)
	{
		printf("%d ", c[i]);
	}
	return 0;
}
```

## ì´ë¶„ ê²€ìƒ‰(Binary Search) ì•Œê³ ë¦¬ì¦˜

- ê²€ìƒ‰í•  ë²”ìœ„ë¥¼ ì ˆë°˜ì”© ì¤„ì—¬ê°€ë©°(mid) ëª©í‘œê°’ì„ ì°¾ì•„ê°€ëŠ” ê²€ìƒ‰ ë°©ë²•
- ì •ë ¬ ì´í›„ í•´ë‹¹ ê²€ìƒ ë°©ë²•ì„ ì‚¬ìš©í•œë‹¤.

ì¤‘ê°„ ìœ„ì¹˜(mid)ê°’ì„ ì°¾ì„ ë•ŒëŠ” (ì‹œì‘ ìœ„ì¹˜ + ì¢…ë£Œ ìœ„ì¹˜) /2ì˜ ê²°ê³¼ê°€ ì¤‘ê°„ ìœ„ì¹˜ ê°’
ì´ ì¤‘ê°„ ìœ„ì¹˜ì˜ ê°’ì„ í‚¤ ê°’(ì°¾ì„ ë°ì´í„°)ê³¼ ë¹„êµí•˜ì—¬ ê°™ë‹¤ë©´ ê²€ìƒ‰ ì¢…ë£Œ, ì‘ë‹¤ë©´ ì™¼ìª½ ë°ì´í„°ë¥¼ ë‹¤ì‹œ ê²€ì‚¬, í¬ë‹¤ë©´ ì˜¤ë¥¸ìª½ ë°ì´í„°ë¥¼ ë‹¤ì‹œ ê²€ì‚¬

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

int main()
{
    int n, key, lt=0, rt = 0, mid = 0, tmp = 0;
    vector<int> a;
    scanf("%d %d", &n, &key);
    
    for(int i = 0; i < n; i++)
    {
        scanf("%d", &tmp);
        a.push_back(tmp);   
    }
    // ê²€ìƒ‰ì— ì•ì„œ ì •ë ¬ ìˆ˜í–‰
    sort(a.begin(), a.end());
    rt=n-1;
    while(lt <= rt)
    {
        mid=(lt + rt)/2;
        // ëª©í‘œê°’ íƒìƒ‰ ì™„ë£Œí•œ ê²½ìš°
        if(a[mid]==key)
        {
            printf("%d\n", mid+1);
            break;
        }
        // ì¤‘ê°„ê°’ì´ í‚¤ ê°’ë³´ë‹¤ í° ê²½ìš° => ì¤‘ê°„ ê°’ì´ ì™¼ìª½ìœ¼ë¡œ í•œì¹¸ ì´ë™í•˜ê¸° ìœ„í•´ rt = mid - 1
        else if(a[mid] > key) 
            rt=mid-1;
        // ì¤‘ê°„ê°’ì´ í‚¤ ê°’ë³´ë‹¤ ì‘ì€ ê²½ìš° => ì¤‘ê°„ ê°’ì´ ì˜¤ë¥¸ìª½ìœ¼ë¡œ í•œì¹¸ ì´ë™í•˜ê¸° ìœ„í•´ lt = mid + 1
        else 
            lt=mid+1;
    }
    return 0;
}

```


## ë°˜ì˜¬ë¦¼ì„ í•˜ëŠ” í•˜ë‚˜ì˜ ë°©ë²•

ë°˜ì˜¬ë¦¼ì„ ìˆ˜í–‰í•˜ë ¤ëŠ” íƒ€ê²Ÿ ê°’ì— 0.5ë¥¼ ë”í•˜ê³  ê·¸ ê°’ì„ (int) ë¥¼ ë¶™ì—¬ int í˜•ìœ¼ë¡œ ëª…ì‹œì  í˜•ë³€í™˜ì„ ìˆ˜í–‰í•œë‹¤.
=> int í˜•ì„ ì·¨í•˜ë©´ ì†Œìˆ˜ì ì´ ë²„ë ¤ì§€ëŠ” ì„±ì§ˆ í™œìš©


## ë³‘í•©ì •ë ¬, Divde and Conquer

ë¶„í•  ì •ë³µ(divide and conquer) ë°©ë²•
- ë¬¸ì œë¥¼ ì‘ì€ 2ê°œì˜ ë¬¸ì œë¡œ ë¶„ë¦¬í•˜ê³  ê°ê°ì„ í•´ê²°í•œ ë‹¤ìŒ, ê²°ê³¼ë¥¼ ëª¨ì•„ì„œ ì›ë˜ì˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ì „ëµ
- ë¶„í•  ì •ë³µ ë°©ë²•ì€ ëŒ€ê°œ ì¬ê·€ë¥¼ ì‚¬ìš©í•˜ì—¬ êµ¬í˜„

ë³‘í•©ì •ë ¬ì˜ ë‹¨ê³„

1. ë¶„í• (Divide): ì…ë ¥ ë°°ì—´ì„ ê°™ì€ í¬ê¸°ì˜ 2ê°œì˜ ë¶€ë¶„ ë°°ì—´ë¡œ ë¶„í• í•œë‹¤.
2. ì •ë³µ(Conquer): ë¶€ë¶„ ë°°ì—´(ì†Œë¬¸ì œ)ì„ ì •ë ¬í•œë‹¤. ë¶€ë¶„ ë°°ì—´ì˜ í¬ê¸°ê°€ ì¶©ë¶„íˆ ì‘ì§€ ì•Šìœ¼ë©´ ìˆœí™˜ 3. í˜¸ì¶œ ì„ ì´ìš©í•˜ì—¬ ë‹¤ì‹œ ë¶„í•  ì •ë³µ ë°©ë²•ì„ ì ìš©í•œë‹¤.
3. ê²°í•©(Combine): ì •ë ¬ëœ ë¶€ë¶„ ë°°ì—´ë“¤ì„ í•˜ë‚˜ì˜ ë°°ì—´ì— í•©ë³‘í•œë‹¤.


```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int a[101], tmp[101];
void divide(int lt, int rt)
{
	int mid;
	int p1, p2, p3;
	if(lt<rt)
	{
		mid=(lt+rt) / 2;
		// ë¶„í•  ë‹¨ê³„ í›„ìœ„ ìˆœíšŒì˜ ê°œë…, ìì‹ ë…¸ë“œ 2ê°œ ëª¨ë‘ ë™ì‘ ì´í›„ ë¶€ëª¨ ë…¸ë“œì˜ í• ì¼ ìˆ˜í–‰
		divide(lt, mid);
		divide(mid+1, rt);
		p1 = lt; 
		p2 = mid+1;
		p3 = lt;
		// ì •ë³µ ë‹¨ê³„ : ê° ë°°ì—´ì˜ ê°’ì„ ë¹„êµí•˜ë©´ì„œ í•˜ë‚˜ì˜ ë°°ì—´ë¡œ í†µí•© ë° ì •ë ¬ ìˆ˜í–‰
		while(p1 <= mid && p2 <= rt)
		{
			if(a[p1] < a[p2]) 
				tmp[p3++]=a[p1++];
			else 
				tmp[p3++]=a[p2++];
		}
		// í•˜ë‚˜ì˜ ë°°ì—´ì´ í¬ì¸íŠ¸ê°€ ëë‚¬ì„ ë•Œ, ë‚˜ë¨¸ì§€ ë°°ì—´ì˜ ê°’ë“¤ì€ ë‹¨ìˆœ ëŒ€ì… ìˆ˜í–‰
		while(p1<=mid) 
			tmp[p3++]=a[p1++];
		while(p2<=rt) 
			tmp[p3++]=a[p2++];
		// ê²°í•© ë‹¨ê³„ : ë¶€ë¶„ ë°°ì—´ë“¤ì˜ ì •ë ¬ì´ ëë‚˜ë©´ ì›ë³¸ì— ë®ì–´ì“°ê¸° ìˆ˜í–‰
		for(int i=lt; i<=rt; i++)
		{
			a[i]=tmp[i];
		}
	}
}

int main() {
\
	int n, i;
	scanf("%d", &n);
	for(i=1; i<=n; i++)
	{
		scanf("%d", &a[i]);
	}
	divide(1, n);
	for(i=1; i<=n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
```


## ìˆœì—´, ì¡°í•©

- ê¸°ì´ˆì ì¸ ì¤‘ë³µ ìˆœì—´ ì˜ˆì œ
```cpp
#include <iostream>
#include <cstdio>
int n, k;
int arr[5] = { 0, };
void perm(int idx, int cnt)
{
    if (cnt == k)
    {
        for (int i = 0; i < k; i++)
        {
            printf("%d ", arr[i]);
        }
        printf("\n");
        
        return;
    }
    for (int i = n; i >= 1; i--)
    {
        arr[idx] = i;
        perm(idx + 1, cnt + 1);
        
    }
    return;
}
int main() 
{
    scanf("%d %d", &n, &k);
    perm(0, 0);
    return 0;
}
```

- ì¤‘ë³µë˜ì§€ ì•ŠëŠ” ìˆœì—´ ì½”ë“œ

ìˆœì—´ ë¬¸ì œë¡œ ì¬ê·€ì™€ ë°±íŠ¸ë˜í‚¹ì„ ì‚¬ìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.

ì¤‘ë³µë˜ëŠ” ìˆœì—´ì„ ì¶œë ¥í•´í•´ì„œëŠ” ì•ˆëœë‹¤. => ë°©ë¬¸ ì—¬ë¶€ ì²´í¬
ì‚¬ì „ ìˆœ ì¦ê°€í•˜ëŠ” ìˆœì„œë¡œ ì¶œë ¥í•´ì•¼í•œë‹¤. => ë°°ì—´ ì •ë ¬

Nê°œì˜ ìˆ«ìë¡œ ì¤‘ë³µë˜ì§€ ì•Šì€ ìˆœì—´ì„ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
int N, M;
int arr[9] = { 0, };
int ansarr[9] = { 0, };
bool isvisited[10001] = { false, };

void dfs(int cnt)
{
	if (cnt == M)
	{

		for (int i = 0; i < M; i++)
		{
			printf("%d ", ansarr[i]);
		}
		printf("\n");
		return;
	}

	for (int i = 1; i <= N; i++)
	{	
		if (isvisited[arr[i]] == true)
			continue;
		else
			ansarr[cnt] = arr[i];
		isvisited[arr[i]] = true;
		dfs(cnt + 1);
		isvisited[arr[i]] = false;
	}
	return;
}
int main()
{
	scanf("%d %d", &N, &M);

	for (int i = 1; i <= N; i++)
	{
		scanf("%d", &arr[i]);
	}
	sort(arr, arr + (N + 1));
	dfs(0);
	return 0;
}
```
nPrì˜ ìˆœì—´ êµ¬í•˜ëŠ” ì˜ˆì œ
```cpp
#include<cstdio>
using namespace std;
int n, r, cnt=0;
int arr[20], res[20], isvisited[20];
void DFS(int L)
{
	if(L == r)
	{
		for(int j = 0; j < L; j++)
		{
			printf("%d ", res[j]);
		}
		cnt++;
		printf("\n");
	}
	else
	{
		for(int i=1; i<=n; i++)
		{
			if(isvisited[i]==0)
			{
				res[L]=arr[i];
				isvisited[i]=1;
				DFS(L+1);
				isvisited[i]=0;
			}
		}
	}
}

int main()
{
	
	scanf("%d %d", &n, &r);
	for(int i=1; i<=n; i++){
		scanf("%d", &arr[i]);
	}
	DFS(0);
	printf("%d\n", cnt);
	return 0;
}
```



## cout, cin, scanf, printf

c++ ì˜ í‘œì¤€ ì…ì¶œë ¥ ìŠ¤íŠ¸ë¦¼ cout, cin í•¨ìˆ˜ì˜ ê²½ìš° scanf, printf ì— ë¹„í•´ ëŠë¦¬ë‹¤.

ì´ë¥¼ ìœ„í•´

ios_base::sync_with_stdio(false);
cin..tie(NULL);

ì½”ë“œë¥¼ ì¶”ê°€í•˜ì—¬  Cì™€ C++ì˜ í‘œì¤€ streamì˜ ë™ê¸°í™”ë¥¼ ëŠê³  ì†ë„ë¥¼ ë†’ì¸ë‹¤.
ì´ë ‡ê²Œ ë™ê¸°í™”ë¥¼ ëŠê²Œ ë˜ë©´ ëŒ€ì‹  scanf, printf í•¨ìˆ˜ì˜ ì‚¬ìš©ì´ ë¶ˆê°€í•´ì§„ë‹¤.

## êµ¬ì¡°ì²´ì™€ vectorë¥¼ ì´ìš©í•œ ì •ë ¬
 
êµ¬ì¡°ì²´ ìƒì„±ìë¥¼ ì‚¬ìš©í•´ì„œ êµ¬ì¡°ì²´ ì„ì‹œë³€ìˆ˜ë¥¼ í•˜ë‚˜ ì„ ì–¸í•´ ë†“ê³  ê°’ì„ ë„£ì€ í›„
ìë£Œêµ¬ì¡°ì— ë„£ì–´ì¤˜ì•¼í•˜ëŠ” ë¶ˆí•„ìš”í•œ ì‘ì—…ì„ ì¤„ì¸ë‹¤.
```cpp
#include <iostream>
#include <vector>

struct loc_t
{
	int x, y, z;
	loc_t(int a, b, c)
	{
		x = a;
		y = b;
		z = c;
	}
	bool operator<(const loc_t &b)const
	{
		if(x != b.x)
			return x < b.x;
		if(y != b.y)
			return y < b.y;
		if(z != b.z)
			return z < b.z;
	}
}

int main()
{
	vector<loc_t> xyz;
	xyz.push_back(loc_t(1, 2, 3));
	xyz.push_back(loc_t(4, 3, 6));
	xyz.push_back(loc_t(2, 5, 9));
	xyz.push_back(loc_t(5, 2, 1));
	sort(xyz.begin(), xyz.end());
}
```


## ë¯¸ë¡œíƒìƒ‰ ë¡œì§(DFS)

ë¯¸ë¡œ íƒìƒ‰ì—ì„œ ê²½ë¡œì˜ ê°€ì§€ìˆ˜ë¥¼ ëª¨ë‘ ì²´í¬í•˜ëŠ” ë¬¸ì œì˜ ê²½ìš° DFSë¥¼ í™œìš©í•œë‹¤.
isvisited ë¼ëŠ” ì²´í¬ ë°°ì—´ì„ í™œìš© ë° í•´ì œí•˜ëŠ” ê²ƒ ìŠì§€ ë§ê¸°

```cpp
#include<cstdio>
int map[10][10] = {0,};
int isvisited[10][10] = {0,};
int dx[4]={1, 0, -1, 0};
int dy[4]={0, 1, 0, -1};

int cnt=0;

void DFS(int x, int y){	

	if(x==7 && y==7){
		cnt++;
	}
	else{
		for(i=0; i<4; i++){
			int nx = x + dx[i];
			int ny = y + dy[i];
			if(nx < 1 || nx > 7 || ny < 1 || ny > 7)
				continue;
			if(map[nx][ny]==0 && isvisited[nx][ny]==0){
				isvisited[nx][ny]=1;
				DFS(xx, yy);
				isvisited[nx][ny]=0;
			}		
		}
	}
}

int main(){
	freopen("input.txt", "r", stdin);
	int i, j;
	for(i = 1; i< = 7; i++)
	{
		for(j = 1; j< = 7; j++)
		{
			scanf("%d", &map[i][j]);
		}
	}
	isvisited[1][1]=1;
	DFS(1, 1);
	printf("%d\n", cnt);
	return 0;
}
```

ë¯¸ë¡œ íƒìƒ‰ì—ì„œ ìµœë‹¨ê±°ë¦¬ë¡œ ì´ë™í•˜ëŠ” ë¬¸ì œì˜ ê²½ìš° DFSë¥¼ í™œìš©í•œë‹¤.
isvisited ë¼ëŠ” ì²´í¬ ë°°ì—´ì„ í™œìš© ë° í•´ì œí•˜ëŠ” ê²ƒ ìŠì§€ ë§ê¸° 

```cpp
#include<cstdio>

using namespace std;
int dx[4]={-1, 0, 1, 0};
int dy[4]={0, 1, 0, -1};
int dis[7][7] = { 0 };
int board[7][7] = { 0 };

void bfs(int y, int x)
{
	queue<pair<int, int> > q;

	q.push(make_pair(0, 0));
	
	while(!q.empty()) {
		int cy = q.front().first;
		int cx = q.second().second;
		q.pop();
		for(int i = 0; i < 4; i++) 
		{
			int ny = cy + dy[i];
			int nx = cx + dx[i];
			
			if(x >= 0 && x < 7 && y >= 0 && y < 7 && board[x][y] == 0) 
			{
				q.push(make_pair(x, y));
				board[ny][nx] = 1;
				dis[ny][nx] = dis[cy][cx] + 1;
			}
		}
	}
	

	return ;
}
int main(){


	
	for(int i=0; i<7; i++) 
	{
		for(int j=0; j<7; j++) 
		{
			scanf("%d", &board[i][j]);
		}
	}
	
	board[0][0]=1;
	bfs(0, 0);

	if(dis[6][6]==0) 
		printf("-1\n");	
	else 
		printf("%d\n", dis[6][6]);

	return 0;
}
```

## ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ìµœë‹¨ê±°ë¦¬(ìµœì†Œ ë¹„ìš©)ë¬¸ì œ

- ê·¸ë˜í”„ DFS(ê°€ì¤‘ì¹˜ ë°©í–¥ê·¸ë˜í”„)

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int n, cost=87654321;
int map[30][30] = { 0 };
int isvisited[30] = { 0 }; //vertex ë“¤ì˜ ë°©ë¬¸ì—¬ë¶€ ì²´í¬

void DFS(int v, int sum){
	
	if(v==n)
	{
		// ìµœì†Œë¹„ìš© ì—…ë°ì´íŠ¸
		if(sum < cost) 
			cost = sum;
		return;
	}
	
	for(int i = 1; i <= n; i++)
	{
		if(map[v][i] > 0 && isvisited[i] == 0)
		{
			isvisited[i]=1;
			DFS(i, sum+map[v][i]);
			// ë°©ë¬¸ ì—¬ë¶€ ì´ˆê¸°í™”
			isvisited[i]=0;
		}
	}
	return;
}
int main()
{

	int m, i, a, b, c;
	scanf("%d %d", &n, &m);
	for(i=1; i<=m; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		map[a][b]=c;
	}
	isvisited[1]=1;
	DFS(1, 0);
	printf("%d\n", cost);
	
	return 0;
}
```

- ê°™ì€ ë¬¸ì œì˜ ë‹¤ë¥¸í’€ì´(vector, pair ìë£Œêµ¬ì¡° í™œìš©)

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int n, cost=87654321;
vector<pair<int, int> > map[30];
int isvisited[30] = { 0 }; //vertex ë“¤ì˜ ë°©ë¬¸ì—¬ë¶€ ì²´í¬

void DFS(int v, int sum)
{
	
	if(v==n)
	{
		// ìµœì†Œë¹„ìš© ì—…ë°ì´íŠ¸
		if(sum < cost) 
			cost = sum;
		return;
	}
	
	for(i = 0; i < map[v].size(); i++)
	{
			if(isvisited[map[v][i].first()] == 0)
			{
				isvisited[map[v][i].first()]=1;
				DFS(map[v][i].first(), sum + isvisited[v][i].second());
				isvisited[map[v][i].first()]=0;
			}
		}
	return;
}
int main()
{

	int m, i, a, b, c;
	scanf("%d %d", &n, &m);
	for(i=1; i<=m; i++)
	{
		scanf("%d %d %d", &a, &b, &c);
		map[a].push_back(make_pair(b, c));// b : ì—°ê²°ì •ë³´, c ê°€ì¤‘ì¹˜ ê°’
	}
	isvisited[1]=1;
	DFS(1, 0);
	printf("%d\n", cost);
	
	return 0;
}
```

## ì¡°ì„¸í¼ìŠ¤

1ë²ˆë¶€í„° Në²ˆê¹Œì§€ Nëª…ì˜ ì‚¬ëŒì´ ì›ì„ ì´ë£¨ë©´ì„œ ì•‰ì•„ìˆê³ , ì–‘ì˜ ì •ìˆ˜ M(â‰¤ N)ì´ ì£¼ì–´ì§„ë‹¤. ì´ì œ ìˆœì„œëŒ€ë¡œ Më²ˆì§¸ ì‚¬ëŒì„ ì œê±°í•œë‹¤. í•œ ì‚¬ëŒì´ ì œê±°ë˜ë©´ ë‚¨ì€ ì‚¬ëŒë“¤ë¡œ ì´ë£¨ì–´ì§„ ì›ì„ ë”°ë¼ ì´ ê³¼ì •ì„ ê³„ì†í•´ ë‚˜ê°„ë‹¤. ì´ ê³¼ì •ì€ Nëª…ì˜ ì‚¬ëŒì´ ëª¨ë‘ ì œê±°ë  ë•Œê¹Œì§€ ê³„ì†ëœë‹¤. ì›ì—ì„œ ì‚¬ëŒë“¤ì´ ì œê±°ë˜ëŠ” ìˆœì„œë¥¼ (N, M)-ì¡°ì„¸í¼ìŠ¤ ìˆœì—´ì´ë¼ê³  í•œë‹¤. 

```cpp
#include<cstdio>
#include<vector>
#include<queue>
#include<algorithm>
using namespace std;
int main() 
{

	int N, K;
	queue<int> q;

	scanf("%d %d", &N, &K);

	for (int i = 1; i <= N; i++)
	{
		q.push(i);
	}
	printf("<");
	if (q.size() == 1)
	{
		printf("1>");
		return 0;
	}
	while (!q.empty())
	{
		for (int i = 1; i < K; i++)
		{
			q.push(q.front());
			q.pop();
		}
		printf("%d, ", q.front());
		q.pop();
		if (q.size() == 1)
		{
			printf("%d>", q.front());
			break;
		}

	}
	
	return 0;
}

```


## ìµœëŒ€ í™
- ìµœëŒ€ íŠ¸ë¦¬(Max Tree)ëŠ” ê° ë…¸ë“œì˜ í‚¤(Key)ê°’ì´ (ìì‹ ë…¸ë“œê°€ ìˆë‹¤ë©´) ê·¸ ìì‹ì˜ í‚¤(Key)ê°’ë³´ë‹¤ ì‘ì§€ ì•Šì€(=í¬ê±°ë‚˜ ê°™ì€) íŠ¸ë¦¬


```cpp
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
int main()
{
	int num;
	priority_queue<int> pq;
	while(true)
	{
		scanf("%d",&num);
		if(num==-1) 
			break;
		if(num==0)
		{
			if(pq.empty()) 
				printf("-1\n");
			else{
				printf("%d\n", pq.top());
				pq.pop();
			}
		}
		else 
			pq.push(num);
	}
	return 0;
}
```

## ìµœì†Œ í™

- ìµœì†Œ íŠ¸ë¦¬(Min Tree)ëŠ” ê° ë…¸ë“œì˜ í‚¤(Key)ê°’ì´ (ìì‹ ë…¸ë“œê°€ ìˆë‹¤ë©´) ê·¸ ìì‹ì˜ í‚¤(Key)ê°’ë³´ë‹¤ í¬ì§€ ì•Šì€(=ì‘ê±°ë‚˜ ê°™ì€) íŠ¸ë¦¬

ìµœì†Œí™ì€ C++ì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

priority_queue<int, vector<int>, greater<int>> q;

í˜¹ì€ ì£¼ì–´ì§„ ìˆ«ìì— ìŒìˆ˜ë¥¼ ê³±í•˜ê³  ì´ë¥¼ ê¸°ì¡´ ìµœëŒ€ í™ì— ë„£ì–´ ìµœì†Œ í™ì˜ ì—­í• ì„ í•  ìˆ˜ ìˆë„ë¡ ëŒ€ì‹ í•˜ëŠ” ë°©ë²•ë„ ìˆë‹¤.

ìµœëŒ€ í™, ìµœì†Œ í™ ëª¨ë‘ ì™„ì „ ì´ì§„ íŠ¸ë¦¬ (Complete Binary Tree)


```cpp
#include<cstdio>
#include<queue>
#include<vector>
using namespace std;
int main()
{
	int num;
	priority_queue<int> pq;
	// í˜¹ì€ ìµœì†Œí™ìœ¼ë¡œ ë¬¸ì œ í•´ê²°
	//priority_queue<int, vector<int>, greater<int>> q;
	while(true)
	{
		scanf("%d",&num);
		if(num == -1) 
			break;
		if(num == 0)
		{
			if(pq.empty()) 
				printf("-1\n");
			else
			{
				printf("%d\n", -1 * pq.top());
				pq.pop();
			}
		}
		else 
			pq.push(-1 * num);
	}
	return 0;
}
```

## ë™ì  ê³„íšë²•(Dynamic Programming)

ë™ì  ê³„íšë²•(Dynamic programming)ì´ë€ ë³µì¡í•œ ë¬¸ì œë¥¼ ê°„ë‹¨í•œ ì—¬ëŸ¬ ê°œì˜ ë¬¸ì œë¡œ ë‚˜ëˆ„ì–´ í‘¸ëŠ” ë°©ë²•ì„ ë§í•œë‹¤. 

ì²˜ìŒ ì£¼ì–´ì§„ ë¬¸ì œë¥¼ ë” ì‘ì€ ë¬¸ì œë“¤ë¡œ ë‚˜ëˆˆ ë’¤ ê° ì¡°ê°ì˜ ë‹µì„ ê³„ì‚°í•˜ê³ , ì´ ë‹µë“¤ë¡œë¶€í„° ì›ë˜ ë¬¸ì œì— ëŒ€í•œ ë‹µì„ ê³„ì‚°í•´ë‚¸ë‹¤ëŠ” ì ì—ì„œ ë¶„í•  ì •ë³µ(Divide & Conquer)ê³¼ ë¹„ìŠ·í•˜ì§€ë§Œ, ë™ì  ê³„íšë²•ì—ì„œëŠ” ìª¼ê°œì§„ ì‘ì€ ë¬¸ì œê°€ ì¤‘ë³µë˜ì§€ë§Œ, ë¶„í•  ì •ë³µì€ ì ˆëŒ€ë¡œ ì¤‘ë³µë  ìˆ˜ê°€ ì—†ë‹¤ëŠ” ì°¨ì´ì ì´ ìˆë‹¤. 

DP ë¬¸ì œì˜ íŠ¹ì„±
1. Overlapping Subproblem (ë¶€ë¶„ ë¬¸ì œê°€ ê²¹ì¹œë‹¤.)
2. Optimal Substructure (ìµœì  ë¶€ë¶„ êµ¬ì¡°)

DP ë¬¸ì œì˜ í’€ì´ë°©ë²• 2ê°€ì§€
### 1. Top-Down(ì¬ê·€, ë©”ëª¨ì´ì œì´ì…˜(Memoization))
í° ë¬¸ì œë¥¼ ì‘ì€ ë¬¸ì œë¡œ ë‚˜ëˆˆë‹¤.
F(n-1), F(n-2)ë¡œ ë‚˜ëˆˆë‹¤.

ì‘ì€ ë¬¸ì œë¥¼ í‘¼ë‹¤.
F(n-1) + F(n-2)

- ì½”ë“œë¡œ í‘œí˜„
```cpp
#include<iostream>
using namespace std;
int dy[50];
int DFS(int n)
{
	if(dy[n] > 0) 
		return dy[n];
	if(n==1 || n==2) 
		return n;
	else 
		// ë©”ëª¨ì´ì œì´ì…˜ ê¸°ë²• ì‚¬ìš©
		return dy[n] = DFS(n-1) + DFS(n-2);
}
int main()
{
	ios_base::sync_with_stdio(false);
	int n;
	cin >> n;
	cout << DFS(n);
	return 0;
}
```
ì¬ê·€í˜¸ì¶œì„ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í‘¼ë‹¤. 
ì‹œê°„ ì œì•½ì´ í´ ê²½ìš° ë©”ëª¨ì´ì œì´ì…˜ì„ ì‚¬ìš©í•´ì„œ í•´ê²°í•œë‹¤.


** ë©”ëª¨ì´ì œì´ì…˜(Memoization)
- ì»´í“¨í„° í”„ë¡œê·¸ë¨ì´ ë™ì¼í•œ ê³„ì‚°ì„ ë°˜ë³µí•´ì•¼ í•  ë•Œ, ì´ì „ì— ê³„ì‚°í•œ ê°’ì„ ë©”ëª¨ë¦¬ì— ì €ì¥(ë°°ì—´ ë“±)í•¨ìœ¼ë¡œì¨ ë™ì¼í•œ ê³„ì‚°ì˜ ë°˜ë³µ ìˆ˜í–‰ì„ ì œê±°í•˜ì—¬ í”„ë¡œê·¸ë¨ ì‹¤í–‰ ì†ë„ë¥¼ ë¹ ë¥´ê²Œ í•˜ëŠ” ê¸°ìˆ 



###  2. Bottom-Up
ë¬¸ì œë¥¼ í¬ê¸°ê°€ ì‘ì€ ë¬¸ì œë¶€í„° ì°¨ë¡€ëŒ€ë¡œ ì“´ë‹¤.
ë¬¸ì œì˜ í¬ê¸°ë¥¼ ì¡°ê¸ˆì”© í¬ê²Œ ë§Œë“¤ë©´ì„œ ë¬¸ì œë¥¼ í‘¼ë‹¤.
ì‘ì€ ë¬¸ì œë¥¼ í’€ë©´ì„œ í° ë¬¸ì œì˜ ë‹µì„ êµ¬í•œë‹¤.

F(n-1) + F(n-2)

- ì½”ë“œë¡œ í‘œí˜„
```cpp
#include<iostream>
using namespace std;
int dy[50];
int main(){
	ios_base::sync_with_stdio(false);

	int n;
	cin >> n;
	dy[1] = 1;
	dy[2] = 2;
	for(int i=3; i<=n; i++)
	{
		dy[i] = dy[i-1] + dy[i-2];
	}
	cout << dy[n];
	return 0;
}
```
ì£¼ë¡œ, ì í™”ì‹ì„ ì„¸ì›Œì„œ ë¬¸ì œ í•´ê²°
- ì˜ˆì‹œ ë¬¸ì œ
2ì°¨ì› ë°°ì—´ì˜ ì˜ì—­ ì¤‘ ë¶€ë¶„ 2ì°¨ì› ì˜ì—­ ë‚´ ì›ì†Œ í•©ì˜ ìµœëŒ“ê°’ì´ ë˜ëŠ” ìœ„ì¹˜ì˜ ìµœëŒ“ê°’ ì¶œë ¥í•˜ëŠ” ë¬¸ì œ

ê° ë°°ì—´ í¬ì¸íŠ¸(y, x)ì— a[0][0]~a[y][x] ì˜ì—­ì˜ ì´í•©ì„ ì €ì¥í•˜ëŠ” ë°°ì—´ dyë¥¼ ì„ ì–¸í•˜ê³ 
ì í™”ì‹ì„ ìƒˆì›Œ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤.

dy ë°°ì—´ì„ ì—…ë°ì´íŠ¸ í•˜ëŠ” ì í™”ì‹

dy[i][j] = dy[i-1][j] + dy[i][j-1] - dy[i-1][j-1] + a[i][j];

ë¶€ë¶„ ë°°ì—´ì˜ ì´í•©ì„ êµ¬í•˜ëŠ” ì‹

tmp = dy[i][j] - dy[i-n][j] - dy[i][j-m] + dy[i-n][j-m];


```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int a[701][701] = { 0 };
int dy[701][701] = { 0 };
int main(){
	int h, w, n, m, i, j, tmp, max_num = -8765432;
	scanf("%d %d", &h, &w);
	for(i = 1; i <= h; i++)
	{
		for(j = 1; j <= w; j++)
		{
			scanf("%d", &a[i][j]);
			dy[i][j] = dy[i-1][j] + dy[i][j-1] - dy[i-1][j-1] + a[i][j];
		}
	}
	scanf("%d %d", &n, &m);
	for(i = n; i <= h; i++)
	{
		for(j = m; j <= w; j++)
		{
			// ì¤‘ë³µë˜ì„œ ë¹ ì§€ëŠ” a[0][0]~a[i-n][j-m] ê¹Œì§€ì˜ ì˜ì—­ í•œë²ˆ ë”í•´ì¤€ë‹¤.
			tmp = dy[i][j] - dy[i-n][j] - dy[i][j-m] + dy[i-n][j-m];
			if(tmp > max_num) 
				max_num=tmp;		
		}
	}
	printf("%d\n", max_num);
	return 0;
}
```





## ìˆ˜ì‹ë§Œë“¤ê¸° ë¬¸ì œ(DFS)


```cpp

#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

int a[20], op[5], n, maxi = -8765432, mini = 8765432;

void DFS(int L, int res)
{
	if(L == n)
	{
		if(res > maxi) 
			maxi = res;
		if(res < mini) 
			mini = res;
	}
	else
	{
		if(op[0] > 0)
		{
			op[0]--;
			DFS(L + 1, res + a[L]);
			op[0]++;
		}
		if(op[1] > 0)
		{
			op[1]--;
			DFS(L + 1, res - a[L]);
			op[1]++;
		}
		if(op[2] > 0)
		{
			op[2]--;
			DFS(L + 1, res * a[L]);
			op[2]++;
		}
		if(op[3] > 0)
		{
			op[3]--;
			DFS(L + 1, res / a[L]);
			op[3]++;
		}
	}
	return ;
}
	

int main()
{

	scanf("%d", &n);
	//ìˆ«ì ì…ë ¥
	for(int i = 0; i < n; i++)
	{
		scanf("%d", &a[i]);
	}
	//ì—°ì‚°ì ê°€ìš© íšŸìˆ˜ ì…ë ¥(+, - *, /)
	for(int i = 0; i < 4; i++)
	{
		scanf("%d", &op[i]);
	}

	DFS(1, a[0]);

	printf("%d\n%d\n", maxi, mini);
	return 0;
}
```


## ìµœëŒ€ ë¶€ë¶„ ì¦ê°€ìˆ˜ì—´(LIS : Longest Increasing Subsequence)

ì›ì†Œê°€ nê°œì¸ ë°°ì—´ì˜ ì¼ë¶€ ì›ì†Œë¥¼ ê³¨ë¼ë‚´ì„œ ë§Œë“  ë¶€ë¶„ ìˆ˜ì—´ ì¤‘, ê° ì›ì†Œê°€ ì´ì „ ì›ì†Œë³´ë‹¤ í¬ë‹¤ëŠ” ì¡°ê±´ì„ ë§Œì¡±í•˜ê³ , ê·¸ ê¸¸ì´ê°€ ìµœëŒ€ì¸ ë¶€ë¶„ ìˆ˜ì—´ì„ ìµœì¥ ì¦ê°€ ë¶€ë¶„ ìˆ˜ì—´ì´ë¼ê³  í•œë‹¤.
ì´ ë¬¸ì œì˜ ê²½ìš° ê° ë°°ì—´ì˜ í¬ì¸íŠ¸ë§ˆë‹¤ ìµœëŒ€ ë¶€ë¶„ ì¦ê°€ìˆ˜ì—´ì˜ ì›ì†Œ ê°¯ìˆ˜ë¥¼ ì €ì¥í•˜ê³  ì´ë¥¼ í™œìš©í•˜ì—¬ ë¬¸ì œë¥¼ í•´ê²°í•œë‹¤. (DP ë¬¸ì œ)

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int main()
{
	ios_base::sync_with_stdio(false);
	freopen("input.txt", "rt", stdin);
	int n, res=0;
	cin>>n;
	vector<int> arr(n+1), dy(n+1);
	for(int i=1; i<=n; i++)
	{
		cin>>arr[i];
	}
	dy[1]=1;
	for(int i=2; i<=n; i++)
	{
		int max=0;
		for(int j=i-1; j>=1; j--)
		{
			//arr[i] : íƒìƒ‰í•˜ë ¤ëŠ” í•­, arr[j] ëŠ” arr[i] ì•ë“¤ì˜ í•­ 
			if(arr[j] < arr[i] && dy[j] > max)
			{
				max = dy[j];
			}
		}
		// ì•ì˜ í•­ ì¤‘ ìµœëŒ“ê°’(ìµœëŒ€ ì¦ê°€ìˆ˜ì—´)ì„ ì°¾ê³  ê·¸ ê°’ì— +1ì„ í•˜ì—¬ ì €ì¥í•œë‹¤.
		dy[i] = max+1;
		//ìµœëŒ“ê°’ íƒìƒ‰
		if(dy[i] > res) 
			res=dy[i];
	}
	cout << res;
	return 0;
}
```

## ëƒ…ìƒ‰ ì•Œê³ ë¦¬ì¦˜(Knapsack Algorithm)

ex)
ê°€ë°©ì— j ë¬´ê²Œ ë§Œí¼ ë‹´ì„ ìˆ˜ ìˆì„ ë•Œ ë³´ì„ì˜ ìµœëŒ€ ê°€ì¹˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œ

=> DPë¡œ ë¬¸ì œë¥¼ í•´ê²°

ê° ë¬´ê²Œì˜ ë³´ì„ì„ ë„£ì–´ê°€ë©´ì„œ ì§€ê¸ˆ í˜„ì¬ ê°€ë°© ë¬´ê²Œë³„ ìµœëŒ€ ê°€ì¹˜ë¥¼ ì—…ë°ì´íŠ¸ ì‹œì¼œë‚˜ê°„ë‹¤.

```cpp
#include<cstdio>

using namespace std;
int dy[1001] = { 0 };
int main()
{
	int n, m, w, v;// n: ë³´ì„ ì¢…ë¥˜ ìˆ˜, m: ìµœëŒ€ ë¬´ê²Œ,  w : ë¬´ê²Œ, v ê°€ì¹˜
	scanf("%d %d", &n, &m);
	
	for(int i= 0 ; i < n; i++)
	{
		scanf("%d %d", &w, &v);
		for(int j = w; j <= m; j++)
		{
			dy[j] = max(dy[j], dy[j-w]+v);
		}
	}
	printf("%d\n", dy[m]);
	return 0;
}
```

## Union & Find ì•Œê³ ë¦¬ì¦˜

Disjoint-Set : ê³µí†µ ì›ì†Œê°€ ì—†ëŠ” ì§‘í•©ì„ ë§í•¨.

ì—¬ëŸ¬ ë…¸ë“œ ì¤‘ ë‘ ë…¸ë“œë¥¼ ì„ íƒí•˜ì—¬ ê°™ì€ ê·¸ë˜í”„ì— ì†í•´ ìˆëŠ” ì§€ í™•ì¸í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜.

â‘  Find(x) : ì›ì†Œ ğ‘¥ê°€ ì†í•œ ë¶€ë¶„ì§‘í•©ì„ ì°¾ëŠ”ë‹¤. ë³´í†µ ğ‘¥ê°€ ì†í•œ ë¶€ë¶„ì§‘í•©ì˜ ëŒ€í‘œ ì›ì†Œë¥¼ ë˜ëŒë ¤ì¤€ë‹¤.

â‘¡ Union(x, y) : ì›ì†Œ ğ‘¥ê°€ ì†í•œ ë¶€ë¶„ì§‘í•©ê³¼ ì›ì†Œ ğ‘¦ê°€ ì†í•œ ë¶€ ë¶„ì§‘í•©ì˜ í•©ì§‘í•©ì„ êµ¬í•œë‹¤.

* ê° ë¶€ë¶„ì§‘í•©ì€ íŠ¸ë¦¬ë¡œ ë‚˜íƒ€ë‚¸ë‹¤.

3) êµ¬í˜„(ë°°ì—´ ì´ìš©)

- ë¯¸ë¦¬ í•´ì•¼í•  ê³¼ì • 

ë…¸ë“œì˜ ê°œìˆ˜ ë§Œí¼ ë°°ì—´ì„ ì„ ì–¸í•œë‹¤.

ê° ë…¸ë“œì˜ ë£¨íŠ¸ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ëŠ” ë°°ì—´ì„ ì„ ì–¸í•˜ê³ , ì´ˆê¸°í™” í•œë‹¤. (parentë°°ì—´)

ì£¼ì–´ì§„ ì¡°ê±´ì— ë§ê²Œ ê° ë…¸ë“œì˜ parent ë°°ì—´ì˜ ê°’ì€ ê·¸ ë…¸ë“œê°€ ê°€ë¥´í‚¤ëŠ” ë…¸ë“œë¡œ ë°”ê¿”ì¤€ë‹¤.
 

â“ Find : ë£¨íŠ¸ ë…¸ë“œë¥¼ ì°¾ëŠ” í•¨ìˆ˜ì´ë¯€ë¡œ ë£¨íŠ¸ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ê³„ì† ë¶€ëª¨ë…¸ë“œë¥¼ ì°¾ì•„ ì˜¬ë¼ê°„ë‹¤.

â“‘ Union : ğ‘¥ë¥¼ (í˜¹ì€ ğ‘¦ë¥¼) í¬í•¨í•˜ëŠ” ë¶€ë¶„ì§‘í•©ì„ ë‚˜íƒ€ë‚´ëŠ” íŠ¸ë¦¬ë¥¼ ë‹¤ë¥¸ ê²ƒì˜ ë¶€íŠ¸ë¦¬ë¡œ ë§Œë“¤ë©´ ëœë‹¤.


```cpp


#include<cstdio>
#include<algorithm>
#include<queue>
#include<vector>

using namespace std;

int unf[1001];

int Find(int v)
{
	if(v == unf[v]) 
		return v;
	else 
		return unf[v] = Find(unf[v]);//ë©”ëª¨ì´ì œì´ì…˜(ê²½ë¡œ ì••ì¶•)
}

void Union(int a, int b)
{
	a = Find(a);
	b = Find(b);
	if(a != b) 
		unf[a] = b;
}

int main(){
	int i, n, m, a, b, fa, fb, j;
	scanf("%d %d", &n, &m);
	for(i = 1; i <= n; i++)
	{
		unf[i] = i;
	}
	for(i = 1; i <= m; i++)
	{
		scanf("%d %d", &a, &b);
		Union(a, b);
	}
	scanf("%d %d", &a, &b);
	fa = Find(a);
	fb = Find(b);
	// ê°™ì€ ì§‘í•©ì•ˆì— ì›ì†Œì¸ì§€ í™•ì¸(ë£¨íŠ¸ë…¸ë“œê°€ ê°™ì€ì§€)
	if(fa == fb) 
		printf("YES\n");
	else 
		printf("NO\n");
	return 0;
}
```