---
layout : post
title : 파이썬 중고급문법
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---
# 알고리즘 정리


## 1차원 배열 구간합

- 일반적인 생각으로 구간합을 계산할 경우 n^2의 시간복잡도가 나타난다.
- 이를 위해 sum 값을 구간합만큼 계산하고 슬라이딩 윈도우처럼 한칸씩 움직이며 새롭게 추가되는 값은 +를 빠지는 값은 -를 하여
sum 값을 업데이트 하고 max 값과 비교한다.
- 이를 통해 시간 복잡도를 n까지 줄일 수 있다.

```cpp
#include<cstdio>
#include<vector>
using namespace std;			
int main(){
	int n, k, i, sum=0, result = 0;
	scanf("%d %d", &n, &k);
	vector<int> a(n);
	for(i=0; i<n; i++){
		scanf("%d", &a[i]);
	}
	for(i = 0; i < k; i++){
		sum=sum+a[i];
	}
	res=sum;
	for(i=k; i<n; i++){
		sum=sum+(a[i]-a[i-k]);
		if(sum>res) 
            result=sum;
	}
	printf("%d\n", result);
	return 0;
}

```

## 재귀함수의 이해

재귀함수와 스택프레임에 대해서 이해하기 위해서 가장 좋은 예시로 이진수 계산을 재귀로 구현하는 방법이 있다.
우리가 이진수로의 변환을 위해서 2로 숫자를 계속 나눠주고 나머지를 표시하고 최종적으로 몫이 0이 됐을 때 나머지들을 거꾸로 읽어나간다.

이 때 스택의 개념을 사용할 수 있는데, 스택의 경우 LIFO(Last in First out) 방식을 사용하기 때문이다.
재귀함수가 호출 되는 시점을 기준으로 이전은 스택에 넣기 전, 스택에 넣기 후로 표현할 수 있다.
보통 재귀로 표현하는 경우 이러한 스택의 특징을 활용하는 경우가 많기 때문에 목표하는 동작을 스택에 넣은 후,
즉, 재귀함수를 호출하고 동작을 넣는다.

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;	

void recur(int x)
{
	if(x==0) 
		return;
	else
	{
		printf("%d", x%2); // 1101 
		D(x/2);
		// recur(1) 1 = > recur(2) 0 = > recur(5) 1 => recur(11) 1
		printf("%d", x%2); // 1011 => 목표하는 동작
	}
}	
int main(){
	int n;

	scanf("%d", &n);

	recur(n);

	return 0;
}
```

## 투 포인터 알고리즘

- 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘
- 주로 단순 Brute Force 방식으로 접근 시 시간 초과가 걸리는 경우 투 포인터를 사용하여 메모리와 시간 효율성을 높이는데 쓴다.

포인터의 경우 크게 2가지 방식으로 쓴다.

1. 앞에서 시작하는 포인터와 끝에서 시작하는 포인터가 어느 한 지점에서 만나고 종료하는 방식
2. 빠른 포인터가 느린 포인터 보다 앞서는 방식

시간 복잡도의 경우 매 루프마다 항상 두 포인터 중 하나는 1씩 증가하고 각 포인터가 n번 누적 증가하면 종료
=>  O(N)

예시문제 : 공통원소 찾기
1. 정렬하여 공통원소를 찾기 용이하도록 한다.
2. 오름차순으로 정렬된 수열을 투 포인터를 사용해서 공통원소를 검색한다.
3. 공통원소를 정답 리스트에 넣고 리턴

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

int main()
{
	int n, m, i, p1=0, p2=0, p3=0;
	scanf("%d", &n);
	
	vector<int> a(n);

	for(i = 0; i < n; i++)
	{
		scanf("%d", &a[i]);
	}
	sort(a.begin(), a.end());
	
	scanf("%d", &m);

	vector<int> b(m);
	vector<int> c;

	for(i = 0; i < m; i++)
	{
		scanf("%d", &b[i]);
	}
	sort(b.begin(), b.end());
	// 두 벡터 모두 정렬 완료
	// 투포인터 알고리즘
	while(p1 < n && p2 < m)
	{
		// 공통 원소를 찾았을 때
		if(a[p1] == b[p2])
		{
			c.push_back(a[p1++]);
			p2++;
		}
		//b의 원소가 더 클 경우 p1 포인터 증가
		else if(a[p1] < b[p2])
		{
			p1++;
		}
		//a의 원소가 더 클 경우 p2 포인터 증가
		else 
			p2++;
	}
	for(i = 0; i < p3; i++)
	{
		printf("%d ", c[i]);
	}
	return 0;
}
```

## 이분 검색(Binary Search) 알고리즘

- 검색할 범위를 절반씩 줄여가며(mid) 목표값을 찾아가는 검색 방법
- 정렬 이후 해당 검생 방법을 사용한다.

중간 위치(mid)값을 찾을 때는 (시작 위치 + 종료 위치) /2의 결과가 중간 위치 값
이 중간 위치의 값을 키 값(찾을 데이터)과 비교하여 같다면 검색 종료, 작다면 왼쪽 데이터를 다시 검사, 크다면 오른쪽 데이터를 다시 검사

```cpp
#include<cstdio>
#include<vector>
#include<algorithm>

using namespace std;

int main()
{
    int n, key, lt=0, rt = 0, mid = 0, tmp = 0;
    vector<int> a;
    scanf("%d %d", &n, &key);
    
    for(int i = 0; i < n; i++)
    {
        scanf("%d", &tmp);
        a.push_back(tmp);   
    }
    // 검색에 앞서 정렬 수행
    sort(a.begin(), a.end());
    rt=n-1;
    while(lt <= rt)
    {
        mid=(lt + rt)/2;
        // 목표값 탐색 완료한 경우
        if(a[mid]==key)
        {
            printf("%d\n", mid+1);
            break;
        }
        // 중간값이 키 값보다 큰 경우 => 중간 값이 왼쪽으로 한칸 이동하기 위해 rt = mid - 1
        else if(a[mid] > key) 
            rt=mid-1;
        // 중간값이 키 값보다 작은 경우 => 중간 값이 오른쪽으로 한칸 이동하기 위해 lt = mid + 1
        else 
            lt=mid+1;
    }
    return 0;
}

```


## 반올림을 하는 하나의 방법

반올림을 수행하려는 타겟 값에 0.5를 더하고 그 값을 (int) 를 붙여 int 형으로 명시적 형변환을 수행한다.
=> int 형을 취하면 소수점이 버려지는 성질 활용


## 병합정렬, Divde and Conquer

분할 정복(divide and conquer) 방법
- 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략
- 분할 정복 방법은 대개 재귀를 사용하여 구현

병합정렬의 단계

1. 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다.
2. 정복(Conquer): 부분 배열(소문제)을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 3. 호출 을 이용하여 다시 분할 정복 방법을 적용한다.
3. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.


```cpp
#include<cstdio>
#include<vector>
#include<algorithm>
using namespace std;
int a[101], tmp[101];
void divide(int lt, int rt)
{
	int mid;
	int p1, p2, p3;
	if(lt<rt)
	{
		mid=(lt+rt) / 2;
		// 분할 단계 후위 순회의 개념, 자식 노드 2개 모두 동작 이후 부모 노드의 할일 수행
		divide(lt, mid);
		divide(mid+1, rt);
		p1 = lt; 
		p2 = mid+1;
		p3 = lt;
		// 정복 단계 : 각 배열의 값을 비교하면서 하나의 배열로 통합 및 정렬 수행
		while(p1 <= mid && p2 <= rt)
		{
			if(a[p1] < a[p2]) 
				tmp[p3++]=a[p1++];
			else 
				tmp[p3++]=a[p2++];
		}
		// 하나의 배열이 포인트가 끝났을 때, 나머지 배열의 값들은 단순 대입 수행
		while(p1<=mid) 
			tmp[p3++]=a[p1++];
		while(p2<=rt) 
			tmp[p3++]=a[p2++];
		// 결합 단계 : 부분 배열들의 정렬이 끝나면 원본에 덮어쓰기 수행
		for(int i=lt; i<=rt; i++)
		{
			a[i]=tmp[i];
		}
	}
}

int main() {
\
	int n, i;
	scanf("%d", &n);
	for(i=1; i<=n; i++)
	{
		scanf("%d", &a[i]);
	}
	divide(1, n);
	for(i=1; i<=n; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}
```
## 인접 행렬(가중치 존재, 방향 존재)



## 순열, 조합

- 기초적인 중복 순열 예제
```cpp
#include <iostream>
#include <cstdio>
int n, k;
int arr[5] = { 0, };
void perm(int idx, int cnt)
{
    if (cnt == k)
    {
        for (int i = 0; i < k; i++)
        {
            printf("%d ", arr[i]);
        }
        printf("\n");
        
        return;
    }
    for (int i = n; i >= 1; i--)
    {
        arr[idx] = i;
        perm(idx + 1, cnt + 1);
        
    }
    return;
}
int main() 
{
    scanf("%d %d", &n, &k);
    perm(0, 0);
    return 0;
}
```

## cout, cin, scanf, printf

c++ 의 표준 입출력 스트림 cout, cin 함수의 경우 scanf, printf 에 비해 느리다.

이를 위해

ios_base::sync_with_stdio(false);
cin..tie(NULL);

코드를 추가하여  C와 C++의 표준 stream의 동기화를 끊고 속도를 높인다.
이렇게 동기화를 끊게 되면 대신 scanf, printf 함수의 사용이 불가해진다.

## 구조체와 vector를 이용한 정렬
 
구조체 생성자를 사용해서 구조체 임시변수를 하나 선언해 놓고 값을 넣은 후
자료구조에 넣어줘야하는 불필요한 작업을 줄인다.
```cpp
#include <iostream>
#include <vector>

struct loc_t
{
	int x, y, z;
	loc_t(int a, b, c)
	{
		x = a;
		y = b;
		z = c;
	}
	bool operator<(const loc_t &b)const
	{
		if(x != b.x)
			return x < b.x;
		if(y != b.y)
			return y < b.y;
		if(z != b.z)
			return z < b.z;
	}
}

int main()
{
	vector<loc_t> xyz;
	xyz.push_back(loc_t(1, 2, 3));
	xyz.push_back(loc_t(4, 3, 6));
	xyz.push_back(loc_t(2, 5, 9));
	xyz.push_back(loc_t(5, 2, 1));
	sort(xyz.begin(), xyz.end());
}
```