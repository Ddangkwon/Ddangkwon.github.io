---
layout : post
title : 등산로 찾기
comments : true
categories :
- CodingTest
tags : [CodingTest, Dijkstra]
---

# 등산로 찾기

## 문제

N × N 행렬로 지형도가 표시된 산이 있다.
행렬의 각 원소 값은 해당 위치의 **높이(양의 정수)**를 의미한다.

등산가들은 산의 **바깥 지역(높이 0)**에서 출발하여 **정상**에 도달하기 위한 가장 경제적인 루트를 찾으려고 한다.
경제적인 경로란 정상까지 올라가는데 필요한 **힘의 총합이 최소**가 되는 경로를 의미한다.

산의 바깥 지역은 행렬 밖의 모든 위치이며, 높이는 모두 0이라고 가정한다.
출발 위치는 바깥 지역 어디든 가능하다.

---

## 이동 규칙

등산가는 현재 위치에서 **상, 하, 좌, 우 4방향** 인접한 위치로만 이동할 수 있다.

현재 위치의 높이를 h1, 이동할 위치의 높이를 h2라고 할 때,
이동에 필요한 힘은 다음과 같이 계산된다.

### 1. 평지 이동 (같은 높이)

- 조건: h1 = h2
- 필요한 힘: 0

### 2. 내리막 이동

- 조건: h1 > h2
- 필요한 힘: h1 - h2

예시
높이 5에서 높이 3으로 이동하면 필요한 힘은 2이다.

### 3. 오르막 이동

- 조건: h1 < h2
- 필요한 힘: (h2 - h1)²

예시
높이 2에서 높이 4로 이동하면 필요한 힘은 4이다.

---

## 입력

- 첫 줄: 산의 크기 N
- 둘째 줄: 정상의 위치 i, j
- 다음 N줄: 산의 지형을 나타내는 N × N 행렬

제한 조건

- N ≤ 100
- 각 지형의 최대 높이 ≤ 50
- 바깥 지역의 높이는 0으로 가정한다

---

## 출력

정상까지 도달하는 가장 경제적인 경로를 따라 이동할 때 사용되는
**최소 힘의 합**을 출력한다.


## 풀이

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

#define ARR_MAX_LEN 105
using namespace std;

typedef struct{
    int y;
    int x;
    int cost;
}data_t;

struct compare{
    bool operator()(const data_t& a, const data_t& b) const {
        return a.cost > b.cost; // min-heap
    }
};

int N;
int mount[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
int dist[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int topy, topx;

void input(void)
{
    cin >> N;
    cin >> topy >> topx;

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= N; j++){
            cin >> mount[i][j];
        }
    }
}

int dijkstra(int sy, int sx)
{
    priority_queue<data_t, vector<data_t>, compare> pq;

    for(int i = 0; i <= N + 1; i++){
        for(int j = 0; j <= N + 1; j++){
            dist[i][j] = INT_MAX;
        }
    }

    dist[sy][sx] = 0;
    pq.push({sy, sx, 0});

    while(!pq.empty()){
        data_t cur = pq.top();
        pq.pop();

        int cy = cur.y;
        int cx = cur.x;
        int ccost = cur.cost;

        if(ccost > dist[cy][cx])
            continue;

        // 경계 바깥 좌표로 벗어나면 종료
        if(cy < 1 || cy > N || cx < 1 || cx > N)
            return ccost;

        for(int dir = 0; dir < 4; dir++){
            int ny = cy + dy[dir];
            int nx = cx + dx[dir];

            // diff/cost 정의 (다익스트라 임으로 음수 가중치가 나오지 않도록 함)
            int diff = mount[cy][cx] - mount[ny][nx];
            int ncost = (diff > 0) ? (diff * diff) : diff * -1;

            if(dist[ny][nx] > dist[cy][cx] + ncost){
                dist[ny][nx] = dist[cy][cx] + ncost;
                pq.push({ny, nx, dist[ny][nx]});
            }
        }
    }

    return -1;
}

int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();
    cout << dijkstra(topy, topx) << "\n";
    return 0;
}

```
