---
layout : post
title : 주사위 윷놀이
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# 달팽이

[https://www.acmicpc.net/problem/17825](#https://www.acmicpc.net/problem/17825)

## 문제
홀수인 자연수 N이 주어지면, 다음과 같이 1부터 N2까지의 자연수를 달팽이 모양으로 N×N의 표에 채울 수 있다.

```
9	2	3
8	1	4
7	6	5
```
```
25	10	11	12	13
24	9	2	3	14
23	8	1	4	15
22	7	6	5	16
21	20	19	18	17
```
N이 주어졌을 때, 이러한 표를 출력하는 프로그램을 작성하시오. 또한 N2 이하의 자연수가 하나 주어졌을 때, 그 좌표도 함께 출력하시오. 예를 들어 N=5인 경우 6의 좌표는 (4,3)이다.

## 입력
첫째 줄에 홀수인 자연수 N(3 ≤ N ≤ 999)이 주어진다. 둘째 줄에는 위치를 찾고자 하는 N2 이하의 자연수가 하나 주어진다.

## 출력
N개의 줄에 걸쳐 표를 출력한다. 각 줄에 N개의 자연수를 한 칸씩 띄어서 출력하면 되며, 자릿수를 맞출 필요가 없다. N+1번째 줄에는 입력받은 자연수의 좌표를 나타내는 두 정수를 한 칸 띄어서 출력한다.
## 풀이

```cpp
#include <iostream>

#define ARR_MAX_LEN 1001
using namespace std;

int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
int N;
int dy[4] = { -1, 0, 1, 0 };
int dx[4] = { 0, 1, 0, -1 };
int main(void) {

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int input_num = 0, ans_y = 0, ans_x = 0;

    cin >> N;
    cin >> input_num;
    int cur_y, cur_x;
    cur_y = cur_x = N / 2 + 1;
    int mov_point = 1, cur_num = 1, dir = 0, mov_cnt = 0;

    arrmap[cur_y][cur_x] = cur_num;

    
    // 움직이는 칸 수는 방향이 두 번 바뀐 후 1 증가한다
    // 마지막의 경우 방향이 세 번 바뀌고 (1, 1) 포인트에 도착하는데, 무시하고 2번 움직이고 칸 수를 1 증가시키더라도 현재 좌표가 (1, 1) 이면 break 하는 코드가 있어 문제가 없음

    while (true) {

        // 현재 위치가 입력한 숫자이면 정답 좌표값 업데이트 
        if (cur_num == input_num) {
            ans_y = cur_y;
            ans_x = cur_x;
        }
        // 현재 좌표에 넣을 값 업데이트 (+1)
        cur_num++;
        mov_cnt++;

        // 마지막 지점이면 break
        if (cur_y == 1 && cur_x == 1)
            break;
        
        // 다음 이동위치 결정 
        int ny = cur_y + dy[dir];
        int nx = cur_x + dx[dir];

        // 좌표와 좌표에 넣을 값 업데이트
        cur_y = ny;
        cur_x = nx;
        arrmap[cur_y][cur_x] = cur_num;
        
        // 디버그 로그
        //cout << "cur_y : " << cur_y << " " << "cur_x : " << cur_x << " " << "cur_num : " << cur_num << "\n";

        // 한 방향으로 움직여야 하는 거리를 증가시켜야 할 조건
        if (mov_cnt == mov_point) {            
            mov_cnt = 0;
            // 두 번 방향을 바꿨다면 이동 거리 +1 
            if ((dir % 2) == 1)
                mov_point++;
            // 이후 방향정보 업데이트
            dir = (dir + 1) % 4;
        }


    }

    // 정답 출력
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            cout << arrmap[i][j] << " ";
        }
        cout << "\n";
    }
    cout << ans_y << " " << ans_x << "\n";


    return 0;
}
```


