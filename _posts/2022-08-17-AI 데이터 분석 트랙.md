---
layout : post
title : AI 데이터 분석 트랙
comments : true
categories : 
- Python, Machine Learning
tags : [Python, Machine Learning]
---
# AI 데이터 분석 트랙

## [AI 데이터 분석] 핵심 파이썬 기초 프로그래밍

print() 함수의 경우 콤마(,)를 이용하여 여러 자료형을 동시에 출력할 수 있음

```Python

print() 

print(3, "Hello!") 
```

기본 자료형

1. 숫자형

2. 문자열
=> 큰 따옴표와 작은 따옴표로 구별

3. 리스트(List)
여러 자료를 보관하는 자료형
다른 종류 자료형의 자료들을 함께 담을 수 있다.
자료 안의 순서가 존재

cf) 주석

```Python

# 주석 

'''
주석 주석
'''

```

변수 사용방법

변수 이름 = 자료
```Python

# 주석 

num = 1
num = "hello"
answer = ['1', 2, 3]
```

예약어, 공백문자, 연산자 등은 변수 이름에 들어갈 수 없다.


논리 자료형

참 또는 거짓을 나타내는 자료형
=> 비교 연산자(<, >=, != ...)

&& => and
|| => or
! => not

조건문
if~elif~else statement로 표현한다.

반복문

for idx in range(a, b):

for idx in range(a):

리스트 활용

1. list.append(d)
자료 d를 리스트 마지막 원소 뒤에 추가

2. list.insert(i, d)
인덱스 id에 자료 d를 추가, 오직 한 개의 자료만 넣을 수 있음

3. list.remove(d)
처음 나오는 자료 d를 제거(중복 시 인덱스가 작은 원소가 제거됨)

4. list.sort()
리스트를 정렬
숫자형은 오름차순, 문자열은 사전순
=>리스트에 원소가 모두 같은 자료형이어야 한다.

시퀀스 자료형
순서가 있는 자료형
리스트, 문자열, 튜플 등이 이에 속함 

시퀀스의 특징
1. 원소 간의 순서가 존재
=> 인덱싱/슬라이싱이 가능함

인덱싱/슬라이싱 할 때 음수를 넣거나 자리를 비우는 것도 가능
```Python

ex)
lista[-1], listb[:3]
```
2. 멤버 조회

in 연산자로 시퀀스 안에 원소가 있는지 확인가능
```Python
ex)
arr = ['a', 'b', 'c']
print('a' in arr) # True 반환

```

3. 길이 확인

len 연산자로 시퀀스 안에 원소가 몇 개 있는지 확인 가능
```Python
ex)
arr = ['a', 'b', 'c']
print(len(arr)) # 3 반환

```

4. 연결 연산
+ 연산자로 같은 시퀀스 두개를 이어 붙일 수 있다.

```Python
a = [1, 2, 3]
b = [4, 5]
c = a + b # [1, 2, 3, 4, 5]

```

5. 반복 연산

* 연산자로 시퀀스를 반복할 수 있다.
```Python
ch = "arr" * 3 # arrarrarr
```

딕셔너리(Dictionary)
짝꿍(인덱스, 데이터)이 있는 자료형
{} 중괄호로 묶어 표현
{key : value} 형식 : key를 알면 value를 조회할 수 있음


Dict[key]
=> 딕셔너리에서 키 값을 통해 value 값을 다음과 같이 추출할 수 있음
=> 마찬가치로 이 방식으로 딕셔너리에 자료를 추가할 수 있음

del
del 함수로 딕셔너리의 원소를 삭제할 수 있다.

```Python
del Dict[key]
```

딕셔너리의 특징
1. Key는 변할 수 없는 자료형이어야 한다.
=> 리스트는 안되고, 튜플은 된다.

dict.keys() : dict의 key 값들을 모두 반환한다.
dict.values() : dict의 value 값들을 모두 반환한다.
```Python
data = {[1, 2, 3] : 'check'} # error

data = {(1, 2, 3) : 'check'} # ok
```
함수의 종류

1. 내장함수
파이썬 개발자들이 이미 만들어 둔 함수

2, 사용자 지정 함수
사용자가 여러 코들르 묶어서 새로 만든 함수


```Python
def 함수이름(매개변수):
    <수행할 명령>
    .
    .
    .

    return 반환값

```

메서드(Method)
특정 자료에 대해 특정 기능을 하는 코드

함수 vs 메서드
함수는 특정 기능을 한다.
메서드는 특정 자료와 연관지어 기능을 한다
(자료 뒤에 .을 찍어 사용한다)


## [AI 데이터 분석] 데이터 분석을 위한 라이브러리

## 모듈

특정 목적을 가진 함수, 자료의 모임

import 키워드를 이용하여 모듈 사용
.(dot) 을 쓴 후 모듈 속 함수/변수를 사용한다.

패키지
모듈을 폴더(Directory)로 구분하여 관리하는 것

## Numpy 모듈
Numerical Python : 파이썬에서 대규모 다차원 배열을 다룰 수 있게 해주는 라이브러리

반복문 없이 배열 처리 가능
파이썬 리스트에 비해, 빠른 연산을 지원하고 메모리를 효율적으로 사용

list, numpy 배열 차이점

list의 경우 콤마(,) 로 배열 원소 구분
numpy 의 경우 공백( )으로 배열 원소 구분

파이썬 리스트와 달리 같은 데이터 타입만 저장 가능(dtype = 'int64' 와 같이 데이터 형 설정 가능)

ndarray의 차원관련 속성 : ndim & shape

indexing : 인덱스로 값을 찾아냄
slicing : 인덱스의 값으로 배열의 일부분을 가져옴

Boolean indexing :  배열의 각 요소의 선택여부를 Boolean mask를 이용하여 지정하는 방식
Fancy indexing :  배열의 각 요소 선택을 index 배열을 전달하여 지정하는 방식

원하는 요소를 지정하기 위해 indexing과 slicing을 혼합해서 사용 가능
```Python
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]

# 1. Indexing을 통해 값 2를 출력해보세요.
answer1 = matrix[0, 1] # 2는 0행 1열에 있습니다.

# 2. Slicing을 통해 매트릭스 일부인 9, 10을 가져와 출력해보세요.
answer2 = matrix[2:, :2] # 2행 첫 두 개 열에 9, 10 이 있습니다. (2:, :2)

# 3. Boolean indexing을 통해 5보다 작은 수를 찾아 출력해보세요.
answer3 = matrix[matrix < 5]

# 4. Fancy indexing을 통해 두 번째 행만 추출하여 출력해보세요.
answer4 = matrix[ [ 1 ] ] # 두번째 행의 인덱스는 1입니다.
```
## Pandas 모듈

Pandas 란?
구조화된 데이터를 효과적으로 처리하고 저장
Array 계산에 특화된 Numpy 기반으로 설계됨

1. Series
Numpy의 array 가 보강된 형태
Data와 Index를 가지고 있음

Series 는 값(value)을 ndarray 형태로 가지고 있음
=> numpy.ndarray class 

dtype 인자로 데이터 타입을 지정할 수 있음

```Python
data = pd.Series([1,2,3,4], dtype = "float")`
```

인덱스를 지정할 수 있고 인덱스로 접근 가능

```Python
data = pd.Series([1,2,3,4], index = ['a','b','c','d'])
```

Dictionary와 형태가 비슷하고 이를 활용하여 Series를 생성할 수 있다.

```Python
fruit_dict = {
    'apple' = 1,
    'banana' = 2,
    'pineapple' = 3
}
fruit_series = pd.Series(fruit_dict)
```

2. DataFrame

여러 개의 Series가 모여서 행과 열을 이룬 데이터


```Python
fruit_dict = {
    'apple' = 1,
    'banana' = 2,
    'pineapple' = 3
}
fruit_series = pd.Series(fruit_dict)


country = pd.DataFrame({
    'fruit' : fruit_series
    'vegetable' : vegetable_series
})
```

마찬가지로 Dictionary를 활용하여 DataFrame을 생성할 수 있다.

set_index로 함수로 특정 Dict key 값을 DataFrame의 인덱스로 삼을 수 있다.

DataFrame 속성

shape : 데이터 shape을 표현한다.(인덱스 제외)
size : 데이터 size를 표현한다.
ndim :  데이터가 몇 차원지를 표현한다.
values : 데이터 값들을 출력한다.

DataFrame의 index와 column에 이름을 지정할 수 있다.


## 데이터 선택 및 변경하기

데이터 선택 indexing/Slicing

1. loc : 명시적
2. iloc : 암묵적

```Python
country.loc['china'] # 인덱싱
country.loc['japan' : 'korea', : 'population'] # 슬라이싱 (index, column)
```

.iloc : 파이썬 스타일의 정수 인덱스 인덱싱 슬라이싱
```Python
country.iloc[0] # 인덱싱
country.iloc[1:3, :2] # 슬라이싱 (index, column)
```

컬럼명을 활용하여 DataFrame에서 데이터 선택 가능

```Python
country['gdp'] # 컬럼 즉 Series Class
country[['gdp']] # DataFreme
```

Masking 연산이나 query 함수를 활용하여 조건에 맞는 DataFrame 행 추출 가능
```Python
country[country['population'] < 10000]
country.query("population > 10000")
```

Series도 numpy array 처럼 연산자 활용 가능


데이터 추가/수정

리스트로 추가하거나 딕셔너리로 추가할 수 있음

NaN 값으로 초기화 한 새로운 커럼 추가 가능

```Python 
country['gdp'] = np.nan # 새로운 컬럼 추가후 nan 값으로 초기화
```
DataFrame 에서 컬럼 삭제 후 원본 변경`

```Python 
country.drop('gdp', axis = 1, inplace = True) 
# axis = 1 열 방향 / axis = 0 횡방향
# inplace = True : 원본 변경 /  inplace = False : 원본 변겯 X
```


## Matplotlib 모듈
```Python 
ax.legend(
    loc='upper left', # legend 위치 설정
    shadow=True, # 음영
    fancybox=True, # legend border를 둥글게 변경
    borderpad=2 # legend border size 크기 조절
)
```

## [AI 데이터 분석] 머신 러닝 시작하기

### 머신러닝

명시적으로 프로그래밍을 하지 않고도 컴퓨터가 학습할 수 있는 능력을 갖게 하는 것

지도학습, 비지도학습, 강화학습으로 나눌 수 있음

### 지도학습, 비지도학습

예측해야 할 결과에 대한 정답 데이터가 있는 경우 지도학습 없는 경우 비지도 학습으로 나뉜다.

강화학습의 경우 기계가 데이터를 스스로 생성하여 학습하는 것을 말한다.


### 자료의 형태

자료의 형태를 파악함으로써 머신러닝 모델을 결정하거나 데이터 전 처리를 어떤 방식으로 수행할지를 결정할 수 있다.

1. 수치형 자료
=> 양적 자료
=> 수치로 측정이 가능한 자료

2. 범주형 자료
=> 질적 자료
=> 수치로 측정이 불가능한 자료

수치형 자료의 특징

범주형 자료와 달리 수치로 구성되어 있기에 통계값을 사용한 요약이 가능함
시각적 자료로는 이론적 근거 제시가 쉽지 않는 단점을 보완함

### 머신러닝을 위한 데이터 전 처리 이해하기

머신러닝 과정

데이터 수집 => 데이터 분석 및 전 처리 => 머신러닝 학습 => 머신러닝 평가

데이터 전 처리의 역할

1. 머신러닝의 입력 형태로 데이터 변환(특성 엔지니어링)
2. 결측값 및 이상치를 처리하여 데이터 정제
3. 학습용 및 평가용 데이터 분리

전 처리를 통하여 데이터의 결측값 및 이상치를 처리하고 학습용과 평가용 데이터를 분리한다.


범주형 자료 변환 방식

1. 명목형 자료
수치 매핑 방식 => 범주를 0 or 1로 매핑
더미 기법 => 더미 기법을 사용하여 각 범주를 0 or 1로 변환(변수를 범주에 따라 만들어 매핑)

2. 순서형 자료
수치 매핑 방식 => 수치에 매핑하여 변환하지만 수치 간 크기 차이는 커스텀 가능, 이 크기 차이는 머신 러닝 결과에 영향을 끼친다.

수치형 자료 변환 방식

1. 정규화 방식

데이터 스케일링
변수간 범위 차이가 많이 나면 사용

정규화, 표준화, 범주화(=> 변수의 값보다 범주가 중요한 경우 사용)


결측값 처리하기

일반적인 머신러닝 모델의 입력 값으로 결측값을 사용할 수 없음
따라서 Null, None, NaN 등의 결측값 처리 필요

1) 결측값이 존재하는 샘플 삭제
2) 결측값이 많이 존재하는 변수 삭제
3) 결측값을 다른 값으로 대체

이상치 처리하기

이상치가 있으면 모델의 성능의 저하를 초래
이상치는 일반적으로 전 처리 과정에서 제거하고 어떤 값이 이상치인지 판단하는 기준이 중요함

이상치 판단 기준 방법
1) 통계 지표(카이제곱 검정,  IQR 지표) 를 사용하여 판단
2) 데이터 분포를 보고 직접 판단
3) 머신러닝 기법을 사용하여 이상치 분류

머신러닝 모델 평가를 위해서 학습에 사용하지 않은 평가용 데이터를 필요하고 보통 전체 데이터 량의 7:3~8:2 정도의 비율로 학습용, 평가용 데이터를 분리한다.

지도학습 데이터 분리

feature 데이터 : label을 예측하기 위한 입력 값
label 데이터 : 예측해야할 대상이 되는 데이터

### 회귀 분석이란?

데이터를 가장 잘 설명하는 모델을 찾아 입력값에 따른 미래 결과값을 예측하는 알고리즘
=> 완벽한 예측은 불가능하므로 최대한 잘 근사하도록 하는 선형 회귀 모델을 찾아야 한다.

단순 선형 회귀
=> 데이터를 설명하는 모델을 직선 형태(1차 함수)로 가정
=> 이를 위해 y절편 값과 기울기를 구해야한다.

Loss 함수
=> 실제 값과 예측 값의 차이의 제곱의 합으로 Loss 함수를 정의한다.
Loss 함수에서 주어진 값은 입력 값과 실제 값이다.
Loss 함수 크기 값을 줄이기 위해
1) 경사 하강법, least squraes 등의 방법이 있다.

이러한 단순 선형 회귀의 특징으로는,

입력값이 1개인 경우에만 적용이 가능
입력값과 결과값의 관계를 알아보는 데 용이함
입력값이 결과값에 얼마나 영향을 미치는지 알 수 있음
두 변수 간의 관계를 직관적으로 해석하고자 하는 경우 활용


다중 선형 회귀
=> 입력 값이 여러 개인 경우 활용할 수 있는 회귀 알고리즘

여러 개의 입력값과 결과값 간의 관계 확인 가능
어떤 입력값이 결과값에 어떠한 영향을 미치는지 알 수 있음
여러 개의 입력값 사이 간의 상관 관계가 높은 경우 결과에 대한 신뢰성을 잃을 가능성이 있음


회귀 평가 지표

RSS - 단순 오차

실제 값과 예측 값의 단순 오차 제곱의 합

MSE - 평균 제곱 오차

RSS 에서 데이터 수 만큼 나눈 값, 작을 수록 모델의 성능이 높다고 평가 가능

MAE - 평균 절대 오차

절댓값을 씌운 오차 값

MSE의 경우 Outlier에 민감하고 MAE의 경우 변동성이 큰 지표와 낮은 지표를 같이 예측할 시 유용

R^2(결정 계수)
회귀 모델의 설명력을 표현하는 지표
1에 가까울수록 높은 성능의 모델이라고 해석할 수 있음

TSS는 데이터 평균 값과 실제 값의 차이의 제곱

오차가 없을수록 1에 가까운 값을 갖음
값이 0인 경우, 데이터의 평균 값을 출력하는 직선 모델을 의미함
음수 값이 나온 경우, 평균 값 예측보다 성능이 좋지 않음



## [AI 데이터 분석] 딥러닝 시작하기


### 퍼셉트론

인공지능 << 머신러닝 << 딥러닝

머신러닝 기술 중 대표적인 한 가지 기술로 머신러닝을 꼽을 수 있다.

인공 신경망이란 생물학의 신경망에서 영감을 얻은 학습 알고리즘으로 사람의 신경 시스템을 모방했다.

생물의 신경 세포를 본따 입력에 따라 actiivation function, weight, bias 값 등을 통해 출력값을 도출한다.

퍼셉트론은 선형 분류기로써 데이터 분류가 가능함

단일 퍼셉트론으로는 선형 분류기 이상의 문제 해결이 어려움 => 다층 퍼셉트론의 등장

단층 퍼셉트론을 여러 개 쌓아 다층 퍼셉트론을 구현한다.

입력층과 출력층 사이의 모든 layer 명칭 => Hidden layer

다층 퍼셉트론의 경우
장점으로는 분류의 성능이 올라가지만 단점으로 가중치의 개수가 늘어나고 그 가중치를 모두 구해야한다는 단점이 있다.

어떠한 클래스에 속할지 값을 도출하는 알고리즘 => 분류 알고리즘
ex)트리 구조 기반, 확률 모델 기반, 결정 경계 기반, 인공신경망

의사 결정 나무란?
스무고개 처럼 여러 질문들을 통해 정답을 찾아가는 모델을 말한다.

혼동 행렬
=> 분류 모델의 성능을 평가하기 위해 사용함

 Negative가 중요한 경우 
=> 잘못 예측하는 상황이 더 큰 영향을  미침

 Positive가 중요한 경우 
=> 악성 종양을 양성 종양으로 오판정하는 것과 같이 에러를 검출하는 것을 실패하는 것이 크리티컬 한 경우
재현율(Recall, TPR)
실제로 Positive 인 데이터 중에서 모델이 Positive 인 데이터를 Negative로 판단하면 안되는 경우 사용하는 지표
## 딥러닝 모델

예측값과 실제값 간 오차를 최소화하는 모델의 파라미터 등을 찾고 loss function 을 최소화하는 가중치를 찾는다.

Forward propagation
입력 값을 바탕으로 출력 값을 계산

가중치를 loss function 값이 작아지도록 업데이트 하기 위해 경사 하강법과 같은 방식을 사용한다.

### 이미지 데이터를 위한 딥러닝 모델

이미지 데이터의 경우 모두 같은 크기를 갖는 이미지로 통일한다.(해상도 통일)
또한 색을 표현 하는 방식도 통일한다.

합성곱 신경망(CNN)
특징 위주로 학습을 하기 때문에 이미지 학습에 적절한다.

CNN + FC
=> Convolution layer + Pooling layer 조합으로 특징을 추출하고 Fully-Connnected Layer 분류를 수행한다.

Convolution layer 은 필터(커널)를 통해 이미지를 이동하며 새로운 이미지(피쳐맵)을 생성한다.

피쳐 맵의 크기 변경(Padding, Striding)

Padding : 원본 이미지의 상화좌우에 더미 값 추가
Striding : 필터 이동거리(Stride) 설정

Pooling layer
: 이미지의 왜곡(noise) 영향을 축소하는 과정
Max Pooling
Average Pooling

Fully Connected Layer
: 추출된 특징을 사용하여 이미지를 분류

### 자연어 처리를 위한 데이터 전처리

과정
1. 자연어 전 처리
2. 단어 표현
3. 모델 적용하기

자연어 전처리에는 Noise canceling, Tokenizing, StopWord removal 등이 있다.

Noise Canceling(오류 교정)
자연어 문장의 스펠링 체크 및 띄어쓰기 교정

Tokenizing(토큰화)
문장을 토큰으로 나눔, 토큰은 어절 단어 등으로 목적에 따라 다르게 정의한다.

StopWord removal(불용어 제거)
불필요한 단어를 의미하는 불용어를 제거하는 방법