---
layout : post
title : 최적의 십자 모양 폭발
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# 최적의 십자 모양 폭발

[https://www.codetree.ai/ko/trails/complete/curated-cards/test-best-cross-shape-bomb/description](https://www.codetree.ai/ko/trails/complete/curated-cards/test-best-cross-shape-bomb/description)



## 풀이

```cpp

#include <iostream>
#include <cstring>
#include <climits>

using namespace std;

int n, answer = INT_MIN;
int grid[50][50];
int temp_grid[50][50];
int dy[4] = {-1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

void find_block_pair(){

    int temp_cnt = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if(temp_grid[i][j] != 0){
                for(int dir = 0; dir < 4; dir++){
                    int ny = i + dy[dir];
                    int nx = j + dx[dir];

                    if(ny < 0 || ny >= n || nx < 0 || nx >= n)
                        continue;
                    
                    if(temp_grid[i][j] == temp_grid[ny][nx])
                        temp_cnt++;

                }
            }

        }
    }

    answer = max(answer, temp_cnt / 2);
}
void drop_block(){
    for(int c = 0; c < n; c++){
        int end_idx = -1;
        // 최상단 0번 인덱스 탐색은 의미가 없음
        for(int r = n - 1; r > 0; r--){
            if(temp_grid[r][c] == 0){
                end_idx = r;
                break;
            }

        }

        // 0을 채울 곳이 없을 때, 즉 Drop 되어 상태가 변경될 일이 없을 때
        if(end_idx == -1)
            continue;
        
        // Drop 되어 0 자리에 들어갈 값 찾아서 값 입력
        for(int r = end_idx - 1; r >= 0; r--){
            if(temp_grid[r][c] != 0){
                temp_grid[end_idx][c] = temp_grid[r][c];
                temp_grid[r][c] = 0;
                end_idx--;
            }
        }
    }
}

void explode_block(int y, int x){
    int explos_coverage = temp_grid[y][x] - 1;

    temp_grid[y][x] = 0;
    for(int i = 0; i < explos_coverage; i++){

        for(int dir = 0; dir < 4; dir++){
            int ny = y + ((i + 1) * dy[dir]);
            int nx = x + ((i + 1) * dx[dir]);

            if(ny < 0 || ny >= n || nx < 0 || nx >= n)
                continue;

            temp_grid[ny][nx] = 0;
        }
    }
}

int main() {
    cin >> n;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> grid[i][j];
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // 2D MAP 을 포인트마다 업데이트 하여 사용하기 위해 임시 배열에 복사
            memcpy(temp_grid, grid, sizeof(grid));

            // 1. 해당 포인트 블록 폭파 결과 업데이트
            explode_block(i, j);
            // 2. 중력에 따라 Block Drop 되는 것 구현
            drop_block();
            // 3. Block Pair 탐색
            find_block_pair();
        }
    }

    cout << answer << "\n";
    return 0;
}


```
