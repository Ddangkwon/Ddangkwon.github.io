---
layout : post
title : 합쳐지는 구슬들
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# 합쳐지는 구슬들

[https://www.codetree.ai/ko/trails/complete/curated-cards/test-merge-marbles/description](https://www.codetree.ai/ko/trails/complete/curated-cards/test-merge-marbles/description)



## 풀이

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

int n, m, t, max_weight = INT_MIN;
int arrmap[51][51] = { 0 };
// 좌상우하
int dy[4] = { 0, -1, 0, 1 };
int dx[4] = { -1, 0, 1, 0 };

typedef struct{
    int idx;
    int y;
    int x;
    int dir;
    int weight;
}info_t;

vector<info_t> marble_lst;

void move_marble(){

    for(int i = 0; i < marble_lst.size(); i++){
        int cy = marble_lst[i].y;
        int cx = marble_lst[i].x;
        int dir = marble_lst[i].dir;
        int ny = cy, nx = cx;
        
        int ty = cy + dy[dir];
        int tx = cx + dx[dir];
        if(ty < 1 || ty > n || tx < 1 || tx > n){
            dir = (dir + 2) % 4;
            // 방향 바꾸는데 1초의 시간이 소모됨

        }
        else{
            ny += dy[dir];
            nx += dx[dir];
        }



        marble_lst[i].y = ny;
        marble_lst[i].x = nx;
        marble_lst[i].dir = dir;
        arrmap[ny][nx]++;
        arrmap[cy][cx]--;
        
    }

}

void merge_marble(int y, int x){

    vector<info_t> temp_marble_lst;
    vector<int> merge_idx_lst;
    int merge_dir = 0, merge_weight = 0, merge_cnt = 0, max_num = 0;
    for(int i = 0; i < marble_lst.size(); i++){
        if(y == marble_lst[i].y && x == marble_lst[i].x){
            if(max_num < marble_lst[i].idx){
                max_num = marble_lst[i].idx;
                merge_dir = marble_lst[i].dir;
            }
            merge_cnt++;
            merge_weight += marble_lst[i].weight;
            merge_idx_lst.push_back(i);

        } 
    }

    // 합쳐진 구슬들 삭제하고 다시 원 리스트에 복사
    for(int i = 0; i < marble_lst.size(); i++){
        bool check_flag = true;
        for(int j = 0; j < merge_idx_lst.size(); j++){
            if(i == merge_idx_lst[j])
                check_flag = false;
        }

        if(check_flag)
            temp_marble_lst.push_back(marble_lst[i]);
    }

    marble_lst.clear();

    for(int i = 0; i < temp_marble_lst.size(); i++){
        marble_lst.push_back(temp_marble_lst[i]);
    }
    // 새롭게 합쳐진 구슬 정보 추가
    marble_lst.push_back({max_num, y, x, merge_dir, merge_weight});
    // 구슬 개수 업데이트
    m -= (merge_cnt - 1);
    // 해당 칸에 구슬 개수 업데이트
    arrmap[y][x] = 1;
}
void simulate(){


    move_marble();

    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){

            if(arrmap[i][j] > 1){
                merge_marble(i, j);
            }
        }
    }
}
int main() {
    cin >> n >> m >> t;

    for (int i = 0; i < m; i++) {
        int r, c, w, dir;
        char d;

        cin >> r >> c >> d >> w;

        if(d == 'L')
            dir = 0;
        else if(d == 'U')
            dir = 1;
        else if(d == 'R')
            dir = 2;
        else
            dir = 3;

        marble_lst.push_back({(i + 1), r, c, dir, w});
        arrmap[r][c]++;
    }

    for(int i = 0; i < t; i++){
        simulate();
    }

    for(int i = 0; i < marble_lst.size(); i++){
        max_weight = max(max_weight, marble_lst[i].weight);
    }
    cout << m << " " << max_weight << "\n";
    return 0;
}


```
