---
layout : post
title : 벽 부수고 이동하기 4
comments : true
categories : 
- CodingTest
tags : [CodingTest, BFS]
---

# 벽 부수고 이동하기 4

## 문제
N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.

각각의 벽에 대해서 다음을 구해보려고 한다.

- 벽을 부수고 이동할 수 있는 곳으로 변경한다.
- 그 위치에서 이동할 수 있는 칸의 개수를 세어본다.
한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.

## 입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.

## 출력
맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.

## 풀이


- 일반적으로 bfs 로 돌렸던 풀이, 시간초과 발생
```cpp
#include <iostream>
#include <cstring>
#include <string>
#include <queue>
#include <algorithm>

#define ARR_MAX_LEN 1005

using namespace std;


int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };

int answermap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

int N, M;

typedef struct{
	int y;
	int x;
}loc_t;

void input(){
    cin >> N >> M;
	for(int i = 1; i <= N; i++){
		string str;
		cin >> str;
		for(int j = 1; j <= M; j++){
			arrmap[i][j] = str[j - 1] - '0';
		}
	}
}

int bfs(int y, int x){
	int cnt = 0;
	queue<loc_t> q;
	bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };
	q.push({y, x});
	isvisited[y][x] = true;
	while(!q.empty()){
		int cy = q.front().y;
		int cx = q.front().x;
		q.pop();
		cnt++;
		for(int dir = 0; dir < 4; dir++){
			int ny = cy + dy[dir];
			int nx = cx + dx[dir];

			if(ny < 1 || ny > N || nx < 1 || nx > M)
				continue;
			if(arrmap[ny][nx] == 0 && !isvisited[ny][nx]){
				q.push({ny, nx});
				isvisited[ny][nx] = true;
			}
		}
	}
    cnt = cnt 
	return cnt;
}

int main(){

	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	int answer = 0;

	input();

	for(int i = 1; i <= N; i++){	
		for(int j = 1; j <= M; j++){
			if(arrmap[i][j] == 1)
				answermap[i][j] = bfs(i, j);
		}
	}

	
	
	for(int i = 1; i <= N; i++){	
		for(int j = 1; j <= M; j++){
			cout << answermap[i][j];
		}
		cout << "\n";
	}
	return 0;
}
```

벽 기준(1) 으로 생각하지 않고 빈 공간(0)을 먼저 labeling 을 해서 벽마다 갈 수 있는 빈 공간을 미리 계산해두면 중복 계산이 많이 줄어듦. 아래 페이지의 풀이를 참조

https://yabmoons.tistory.com/216

```cpp
#include <iostream>
#include <cstring>
#include <queue>
#include <vector>

#define ARR_MAX_LEN 1005

using namespace std;

int N, M;

int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };     // 입력 맵 (0: 빈칸, 1: 벽)
int answermap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };  // 출력 맵
int comp_id[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };    // 0-컴포넌트 ID mapping 수행 (벽은 0)
bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; // 방문 체크 배열

int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

typedef struct{
    int y;
    int x;
} loc_t;

// ID 방문 체크용
int used_id[ARR_MAX_LEN * ARR_MAX_LEN]; 
int used_ver[ARR_MAX_LEN * ARR_MAX_LEN]; 


// 전역 각 0-컴포넌트 영역 크기 저장
vector<int> comp_size;

void input(){
    cin >> N >> M;
    for(int i = 1; i <= N; i++){
        string str;
        cin >> str;
        for(int j = 1; j <= M; j++){
            arrmap[i][j] = str[j - 1] - '0';
        }
    }
}


void bfs(int y, int x, int id){
	int cnt = 0;
	queue<loc_t> q;
	q.push({y, x});
	isvisited[y][x] = true;
	comp_id[y][x] = id;

	while(!q.empty()){
		int cy = q.front().y;
		int cx = q.front().x;
		q.pop();
		cnt++;

		for(int dir = 0; dir < 4; dir++){
			int ny = cy + dy[dir];
			int nx = cx + dx[dir];
			if(ny < 1 || ny > N || nx < 1 || nx > M)
				continue;
			if(arrmap[ny][nx] != 0 || isvisited[ny][nx])
				continue;
			isvisited[ny][nx] = true;
            // component id map 에 값 업데이트 
			comp_id[ny][nx] = id;
			q.push({ny, nx});
		}
	}
	comp_size.push_back(cnt); // comp_size[id] = cnt
}

// 0-컴포넌트 라벨링

void label_components(){
    comp_size.clear();
    comp_size.push_back(0); // ID 0 에는 dummy 값(0)
    int cur_id = 0;

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= M; j++){
            if(arrmap[i][j] == 0 && !isvisited[i][j]){
                cur_id++;
				bfs(i, j, cur_id);
            }
        }
    }
}

// 벽 칸 처리
void build_answer(){
    // comp_id 값을 비교할 변수
    int cur_ver = 0;

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= M; j++){
            // 벽칸에 대해서 이동 가능한 칸 탐색 (미리 업데이트 해둔 0-component 활용)
            if(arrmap[i][j] == 1){
                int sum = 1; // 벽 칸 포함
                // 0-component 관련 comp_id 값 비교하는 변수
                cur_ver++;   
                for(int dir = 0; dir < 4; dir++){
                    int ny = i + dy[dir];
                    int nx = j + dx[dir];

                    if(ny < 1 || ny > N || nx < 1 || nx > M)
                        continue;

                    int id = comp_id[ny][nx];
                    // 더미 값은 pass
                    if(id == 0) 
                        continue;
                    if(used_ver[id] == cur_ver) 
                        continue; // 이미 더한 ID
                    // 해당 0-component 영역은 방문 처리
                    used_ver[id] = cur_ver;
                    sum += comp_size[id];
                }
                // 벽이 있는 포인트 별 정답값 업데이트
                answermap[i][j] = sum % 10;
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();

    label_components();
    build_answer();

    for(int i = 1; i <= N; i++){
        for(int j = 1; j <= M; j++){
            cout << answermap[i][j];
        }
        cout << "\n";
    }
    return 0;
}

```