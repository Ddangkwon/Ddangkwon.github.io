---
layout : post
title : ARM 강의
comments : true
categories : 
- Embedded Engineering
tags : [Embedded Engineering]
---


# ARM 아키텍처의 발전

## 개요
ARM 아키텍처는 수년에 걸쳐 개발 및 발전해 왔으며, 모든 ARM 프로세서의 기반입니다. 이 요약에서는 아키텍처 버전 V4T부터 V8 및 V9까지의 주요 내용을 다룹니다.

## 주요 내용

### 초기 버전 (V1, V2, V3)
- **초기 버전**: 아키텍처 버전 1, 2, 3이 있었으나, Thumb 명령어 세트가 도입되면서 ARM이 대중화되었습니다.

### 아키텍처 버전 4T
- **Thumb 명령어 세트 도입**: 16비트 명령어 세트가 도입되어 ARM7TDMI와 같은 인기 프로세서가 개발되었습니다. 그 전에는 32비트 명령어만 사용할 수 있었습니다.

### 아키텍처 버전 5
- **향상된 수학 명령어**: Count Leading Zeros (CLZ)와 같은 향상된 수학 명령어가 추가되었습니다.
- **DSP 명령어**: DSP 연산을 효율적으로 수행할 수 있는 명령어가 추가되었습니다.

### 아키텍처 버전 6
- **Thumb-2**: 16비트와 32비트 명령어를 혼합하여 사용할 수 있는 Thumb-2 명령어가 도입되었습니다.
- **TrustZone**: 보안 확장 기능인 TrustZone이 도입되었습니다.
- **멀티코어 지원**: 추가 커널 및 멀티코어 지원이 포함되었습니다.

### 아키텍처 버전 7
- **가상화**: 일부 A-profile 시스템에서 가상화 기능이 도입되었습니다.
- **NEON SIMD 명령어 세트**: 매우 강력한 NEON SIMD 명령어 세트가 도입되었습니다.

### 아키텍처 버전 8
- **64비트 레지스터**: 64비트 레지스터와 새로운 예외 모델 및 메모리 모델이 도입되었습니다.
- **호환성 모드**: 이전 아키텍처 코드와의 호환성을 유지하며, 새로운 프로세서에서도 실행이 가능했습니다.

### 아키텍처 버전 9
- **통합 및 정리**: V8의 다양한 포인트 버전을 통합 및 정리한 버전입니다.
- **최신 버전**: V8-M 프로파일과 비교할 때 TrustZone을 지원하는 것이 주요 특징입니다.

## Cortex-M 프로세서
- **예외 처리 메커니즘**: Cortex-M 프로세서는 매우 우수한 예외 처리 메커니즘을 갖추고 있습니다.
- **파이프라인 길이**: 프로세서 파이프라인의 길이는 아키텍처에서 지정하지 않으며, 예로 Cortex-M3와 Cortex-M7을 들 수 있습니다.

이 요약을 통해 ARM 아키텍처의 발전 과정을 이해하고, 각 버전에서 도입된 주요 기능을 알 수 있습니다.

### Cortex-M 프로세서 개요
- **Cortex-M 제품군**: Arm의 다양한 프로세서 중 한 부분으로, Linux 및 Windows와 같은 운영 체제를 지원하는 애플리케이션 프로파일, 고성능 임베디드 제어 애플리케이션을 목표로 하는 실시간 프로파일, 그리고 저전력, 비용 민감한 장치를 위한 마이크로컨트롤러 프로파일로 나뉩니다.
- **고성능 기능**: 일부 Cortex-M 프로세서는 물리적 변조 방지 기능과 사이드 채널 완화 기능을 추가하여 보안에 민감한 애플리케이션에 적합합니다.

### 주요 Cortex-M 프로세서
- **Cortex-M0과 Cortex-M0+**: 가장 작은 최저 전력 대역에 속하며, Armv6-M 명령어 세트를 구현합니다. 단일 사이클 저지연 I/O 포트를 제공합니다.
- **Cortex-M23**: Cortex-M0+에서 개발된 것으로, Armv8-M 명령어 세트를 기반으로 합니다. TrustZone 보안 기능이 추가되었습니다.
- **Cortex-M3 및 Cortex-M4**: Armv7-M 명령어 세트를 기반으로 하며, 다양한 32비트 연산 코드를 지원합니다. Cortex-M4는 DSP 명령어 세트와 단정밀도 부동 소수점 연산을 추가로 지원합니다.
- **Cortex-M33 및 Cortex-M35P**: Armv8-M 명령어 세트를 기반으로 하며, 변조 방지 기능을 포함합니다.
- **Cortex-M7**: Cortex-M 제품군 중 가장 고성능으로, 6단계 파이프라인과 이중 이슈 처리 기능을 갖추고 있습니다. 단정밀도 및 배정밀도 부동 소수점 연산을 지원합니다.

### 보안 기능
- **TrustZone**: Cortex-M35P와 같은 일부 프로세서는 Armv8-M TrustZone 보안 기능을 제공합니다.
- **변조 방지**: 보안에 민감한 애플리케이션을 위한 물리적 변조 방지 기능을 포함합니다.

### 디버깅 및 개발 지원
- **디버그 인터페이스**: 각 Cortex-M 프로세서에는 독립형 프로세서 시스템으로 디버깅할 수 있도록 디버그 액세스 포트(DAP)가 제공됩니다.
- **CoreSight 지원**: 칩 레벨에서 스트리밍 트레이스 출력 또는 전용 트레이스 핀을 제공하여, 프로세서 활동을 외부 디버그 도구에 지속적으로 보고할 수 있습니다.

### 최신 버전
- **Armv8-M**: 최신 M 프로파일 아키텍처 버전으로, 보안 확장과 M 프로파일 벡터 확장(MVE)을 포함합니다.

이 요약은 Cortex-M 프로세서의 다양한 기능과 각 모델의 특징을 이해하는 데 도움이 됩니다.

# Armv8-M 프로세서 및 마이크로컨트롤러 프로파일 개요

## 개요
Armv8-M 프로세서는 마이크로컨트롤러 시장을 지원하도록 설계되었습니다. 실제로 Armv8-M의 M은 마이크로컨트롤러의 약자입니다. 이 문서에서는 Armv8-M 프로세서의 주요 특징과 다른 두 가지 주요 아키텍처 프로필인 A 프로파일과 R 프로파일을 간단히 살펴봅니다.

## 주요 내용

### Arm 프로파일
- **A 프로파일**: A는 Applications를 의미합니다. 메모리 용량이 크고 주파수가 높은 복잡한 시스템에 적합합니다. 이러한 시스템에는 Linux나 Android 등과 같은 운영 체제가 포함될 수 있습니다.
- **R 프로파일**: R은 실시간(Real-time)을 의미합니다. 실시간 시스템 전용으로, 자동차 시스템 등에서 사용됩니다.
- **M 프로파일**: M은 마이크로컨트롤러를 의미합니다. IoT 시스템에서 베어메탈 시스템에 이르기까지 다양한 임베디드 시스템에 사용됩니다. 실시간 요구 사항이 있는 시스템에도 적합합니다.

### M-프로파일의 특징
- **단순화된 아키텍처**: 대부분의 명령어가 단일 사이클로 실행되며, RISC 아키텍처를 기반으로 합니다. RISC는 축소된 명령어 세트 컴퓨터(Reduced Instruction Set Computer)의 약자입니다.
- **전력 효율성**: 전력 소비가 적어 배터리 수명이 중요한 마이크로컨트롤러 시스템에 적합합니다.
- **프로그래밍 용이성**: C 또는 C++로 프로그래밍할 수 있으며, 특정 루틴에 대해 어셈블리 언어를 사용할 수도 있습니다.
- **단순한 메모리 보호 모델**: 가상 주소를 물리적 주소로 변환할 수 있는 메모리 관리 장치(MMU)가 포함된 애플리케이션 프로세서와 달리, 더 간단한 메모리 보호 모델을 사용합니다.

### 실행 모드
- **스레드 모드**: 재설정 후 사용되며, 운영 체제에서 생성되는 프로세스와 스레드에 사용됩니다.
- **핸들러 모드**: 예외를 처리하는 데 사용됩니다.

### 예외 처리
- **벡터 테이블**: 명령어가 아닌 주소로 구성됩니다. 이는 더 유연한 접근 방식을 제공합니다.
- **컨텍스트 저장**: 예외 발생 시 자동으로 컨텍스트를 저장하여 안전하게 반환할 수 있습니다.

### 데이터 유형
- **로드 및 저장 아키텍처**: 32비트 로드 및 저장 아키텍처로, 메모리 액세스는 로드 및 저장 명령을 통해 이루어집니다.
- **지원되는 데이터 유형**: 바이트(8비트), 하프 워드(16비트), 워드(32비트), 더블 워드(64비트)를 지원합니다.

이 문서는 Armv8-M 프로세서의 다양한 기능과 각 프로파일의 특징을 이해하는 데 도움이 됩니다.

# ARMv8-M 코어 레지스터 소개

## R0-R7 레지스터
- 대부분의 명령에서 접근 가능
- 데이터 처리 및 메모리 액세스 명령에 사용

## R8-R12 레지스터 (하이 레지스터)
- 32비트 명령어에 주로 사용
- 일부 16비트 명령어에도 사용 가능

## 스택 포인터와 링크 레지스터, 프로그램 카운터
- R13 (스택 포인터): 스택에 접근하는 데 사용
  - 메인 스택 포인터와 프로세스 스택 포인터의 두 가지 버전 존재
- R14 (링크 레지스터): 함수 호출에서 리턴 주소를 저장
  - 서브루틴 호출 시 사용
- 프로그램 카운터: 명령어를 단계별로 실행

## XPSR (프로그램 상태 레지스터)
- 응용 프로그램 상태 레지스터, 실행 프로그램 상태 레지스터, 인터럽트 프로그램 상태 레지스터로 구성
- 제어 레지스터에는 다양한 특수 비트 존재

## Armv8.1 추가 기능
- 포인터 인증 브랜치 (PACBTI)와 같은 확장 기능 추가
- 여러 활성화 및 비활성화 비트가 컨트롤 레지스터에 포함됨

## 스택 포인터 사용 예제
- 풀 디센딩 스택 모델: 스택은 메모리에서 아래로 확장되고 스택 포인터는 마지막 위치를 가리킴
- 푸시 및 팝 연산을 통해 스택 포인터가 메모리의 위치를 가리킴

## 링크 레지스터 사용 예제
- 함수 호출 시 링크 레지스터를 사용하여 리턴 주소를 저장
- BL 명령어를 사용하여 함수로 분기
- BX 명령어를 사용하여 링크 레지스터의 값으로 분기

## 프로그램 카운터
- 명령어를 단계별로 실행하며 분기 명령어에서 암시적으로 사용됨
- C 언어에서 함수 호출 시 적절한 점프 명령어를 생성

## 프로그램 상태 레지스터 (XPSR)
- ALU 플래그: N (음수), Z (0), C (캐리), V (오버플로우)
- 인터럽트 프로그램 상태 레지스터: 현재 활성화된 인터럽트 또는 예외 번호 표시
- 실행 프로그램 상태 레지스터: T 비트 및 IT 필드 포함

## 제어 레지스터
- 최대 8비트까지 확장 가능
- NPriv 필드와 SPSEL 필드: 스레드 모드에서 실행 권한 및 스택 포인터 선택
- 부동 소수점 컨텍스트 활성 필드 (FPCA)
- 부동 소수점 확장 및 보안 확장과 관련된 비트

## 스택 제한 레지스터
- 메인 스택 및 프로세스 스택에 대한 제한 설정 가능
- 스택 제한 값을 초과할 경우 UsageFault 발생
- 보안 확장을 사용할 경우 추가 레지스터 존재

## 예외 처리 관련 레지스터
- 특수 용도의 레지스터: 인터럽트와 오류를 마스킹하는 방법 제공
- BASEPRI 레지스터: 현재 스레드를 중단할 수 있는 인터럽트 결정

이 문서는 ARMv8-M 코어 레지스터에 대한 개요를 제공하며, 각 레지스터의 기능과 사용 방법에 대해 설명합니다. ARM 아키텍처의 다양한 명령어와 예외 처리 메커니즘을 이해하는 데 도움이 됩니다.


# Armv8-M 명령어 세트 소개

## 개요
Armv8-M 아키텍처는 다양한 명령어 세트를 제공합니다. 이 문서에서는 주요 명령어 세트와 그 특성에 대해 설명합니다. 자세한 내용은 나중에 어셈블리 언어를 다룰 때 더 깊이 다루겠습니다.

## 명령어 세트 개요
- **T32 명령어 세트**: Thumb 명령어 세트로, Armv7-M 명령어 세트에서 파생되었습니다.
- **16비트 및 32비트 명령어**: 두 가지 명령어를 혼합하여 사용 가능. 16비트 명령어는 코드 밀도를 높이고 메모리 사용량을 줄이기 위해 도입되었습니다.

## 명령어 예시
- **ADD 명령어**: 16비트 ADD와 32비트 ADD 명령어가 있으며, 컴파일러나 어셈블리 프로그램이 적절한 버전을 선택할 수 있습니다.
- **LSLS 명령어**: 논리적 전환 명령어로, 비트를 왼쪽으로 이동시키는 곱셈 연산도 포함됩니다.

## 새로운 명령어
- **로드-획득 및 스토어-릴리즈 명령어**: 동기화 및 세마포어 관리에 사용됩니다.
- **보안 확장 명령어**: 보안 격리를 돕기 위한 SG 명령어와 NS명령어 등이 있습니다.
- **TT 명령어**: 특정 주소의 메모리 속성을 테스트하는 명령어입니다.

## 다이어그램 요약
- **기본 아키텍처 명령어**: 모든 기본 명령어를 포함.
- **DSP 확장 명령어**: 7개의 추가 명령어 포함.
- **부동 소수점 확장 명령어**: 부동 소수점 연산을 위한 명령어 포함.

## 메모리 액세스 명령어
- **STR 명령어**: 레지스터의 값을 메모리 주소에 저장.
- **LDR 명령어**: 메모리 주소에서 레지스터로 데이터 로드.
- **로드-획득 및 스토어-릴리즈 명령어**: 암묵적 장벽 연산 포함.

## 프로그램 흐름 명령어
- **브랜치 명령어**: 레이블로 직접 이동하거나 서브루틴 호출에 사용.
- **BX 명령어**: 레지스터 값으로 브랜치.
- **BLX 명령어**: 서브루틴 호출에 사용.

## 결론
Armv8-M 명령어 세트는 다양한 명령어를 통해 효율적이고 유연한 프로그래밍을 가능하게 합니다. 어셈블리 언어와 함께 사용하면 더 깊이 있는 프로그래밍이 가능합니다.



# 프로그래밍 표준 및 CMSIS 개요

## Arm 아키텍처 프로시저 호출 표준 (AAPCS)

### 개요
AAPCS는 Arm 아키텍처에서 함수 호출 시 레지스터와 메모리의 사용 규칙을 정의하는 표준입니다. 이는 컴파일러와 어셈블러 프로그래머가 서로 호환되는 객체와 이미지를 만들기 위해 준수해야 하는 중요한 문서입니다.

### 주요 내용
- **레지스터 사용**: 함수 인수는 `r0`~`r3` 레지스터를 사용하며, 추가 인수는 스택에 저장됩니다.
- **보존 레지스터**: `r4`~`r11` 레지스터는 함수 내에서 보존해야 하며, 사용 전에 스택에 푸시되어야 합니다.
- **8바이트 스택 정렬 규칙**: 스택은 항상 8바이트로 정렬되어야 합니다.
- **위치 독립적 데이터**: `r9`는 위치 독립적 데이터의 기본 포인터로 사용될 수 있습니다.
- **디버깅**: `r11`은 디버깅용 프레임 포인터로 예약될 수 있습니다.

### 예제
호출자 함수가 `foo` 함수를 호출할 때, 인수는 `r0`에서 `r3` 레지스터로 전달됩니다. 호출자 함수는 `r0`에서 `r3` 레지스터를 보존할 필요는 없으나, `r4`에서 `r11` 레지스터는 보존해야 합니다. `foo` 함수가 반환될 때, 결과는 `r0`에 저장됩니다.

## 공통 마이크로컨트롤러 소프트웨어 인터페이스 (CMSIS)

### 개요
CMSIS는 Cortex-M 마이크로컨트롤러의 표준 소프트웨어 인터페이스입니다. CMSIS는 다양한 구성 요소로 구성되어 있으며, 각 구성 요소는 특정 기능을 제공합니다.

### 주요 구성 요소
- **CMSIS-DSP**: DSP 기능을 위한 무료 라이브러리.
- **CMSIS-NN**: 신경망 기능을 위한 라이브러리.
- **CMSIS-DAP**: 소형 마이크로컨트롤러를 디버깅하기 위한 펌웨어.
- **CMSIS-RTOS**: 운영 체제와 주변 장치 액세스를 위한 코드.
- **CMSIS-Driver**: 주변 장치 액세스를 위한 드라이버.
- **CMSIS-Core**: 프로세서의 주변 장치에 표준 방식으로 액세스하는 데 유용한 명령 내장 및 기능 제공.

### CMSIS-Core 기능
- **명령어 내장 함수**: C 프로그램에서 Arm 아키텍처의 특수 명령어를 사용하기 쉽게 함.
- **시작 코드**: 리셋 핸들러 코드, 스택 포인터 초기화 코드, 벡터 테이블 및 표준 인터럽트 핸들러 포함.
- **SIMD 명령어**: 단일 명령어로 여러 작업을 수행할 수 있는 명령어.
- **NVIC 및 SyStick 타이머 구성**: 중첩 벡터 인터럽트 컨트롤러와 시스템 타이머 구성.
- **인터럽트 마스킹**: 특정 인터럽트를 비활성화하는 기능 제공.

### 사용 예시
CMSIS-Core를 사용하면 Cortex-M 프로세서 또는 M-profile 구현을 표준화된 방법으로 프로그래밍할 수 있습니다. 이는 Arm Compiler, GNU 도구, IAR 컴파일러 등 다양한 툴체인에서 작동하는 내장 함수를 제공합니다.

### 유용한 리소스
- **developer.arm.com**: CMSIS와 관련된 다양한 참조 자료와 블로그 제공.
- **GitHub**: CMSIS 소스 코드와 설명서 제공.
- **Keil MDK**: CMSIS 지원 및 패키지가 사전 설치된 제품.

### 결론
CMSIS는 프로세서의 주변 장치에 표준화된 방식으로 액세스할 수 있도록 도와주며, 오픈 소스 프로젝트로서 개발자들이 기여할 수 있습니다. 이를 통해 Arm 마이크로컨트롤러 시스템의 개발을 용이하게 합니다.

## 참고 자료
- [developer.arm.com](https://developer.arm.com)
- [GitHub - CMSIS](https://github.com/ARM-software/CMSIS_5)
- [Arm 아키텍처 참조 설명서](https://developer.arm.com/documentation)


# Armv8-M Mainline 어셈블리 언어 프로그래밍

## 개요
이 모듈에서는 Armv8-M Mainline 장치에서 어셈블리 언어 프로그래밍이 유용한 이유와 사용 가능한 어셈블리 언어 명령어 유형을 살펴봅니다. 데이터 처리 명령, 로드/스토어 명령, 흐름 제어 명령, 기타 유용한 명령어 및 Armv8.1-M 사용자 지정 데이터 경로 확장(CDE)에 포함된 명령어를 다룹니다.

### 어셈블리 언어 프로그래밍의 필요성
- **시스템 레지스터 접근**: C 언어로는 시스템 레지스터에 직접 접근할 수 없으므로 어셈블리 명령어를 사용해야 합니다.
- **특정 명령 시퀀스 테스트**: 매우 구체적인 명령 시퀀스의 동작을 테스트하거나, 컴파일러가 자동으로 수행할 수 없는 경우 직접 코드를 최적화할 때 유용합니다.
- **디버깅**: 컴파일러의 출력을 디버깅할 때 어셈블리 명령어를 이해하면 유용합니다.

### T32 명령어 세트
- **이전 명칭**: Thumb 명령어 세트
- **명령어 길이**: 16비트와 32비트 명령어가 혼합되어 있습니다.
- **목적**: 코드 크기를 최소화하고, 다양한 명령어 너비를 혼합하여 메모리 효율성을 높이는 데 도움.

### 어셈블리 명령어 구문
- **명령어 형식**: 
  - `opcode`는 명령어 이름
  - 한정어, 조건 코드, 레지스터 피연산자 등을 포함할 수 있음
  - 대상 레지스터 `Rd`, 두 번째 레지스터 피연산자 `Rn`, 선택적 피연산자 `Rm`
- **UAL 구문**: 통합 어셈블러 언어 구문으로, 모든 Arm 아키텍처와 프로세서에 적용.

## 주요 어셈블리 명령어

### 데이터 처리 명령어
- **MOV**: 데이터를 한 레지스터에서 다른 레지스터로 이동.
- **ADD**: 두 레지스터의 값을 더하여 결과를 레지스터에 저장.
- **SUB**: 한 레지스터의 값에서 다른 레지스터의 값을 빼서 결과를 레지스터에 저장.

### 로드/스토어 명령어
- **LDR**: 메모리에서 데이터를 레지스터로 로드.
- **STR**: 레지스터의 데이터를 메모리에 저장.

### 흐름 제어 명령어
- **B**: 조건 없이 분기.
- **BL**: 서브루틴 호출 및 링크 레지스터에 반환 주소 저장.
- **BX**: 레지스터의 값으로 분기.

### 기타 명령어
- **NOP**: 아무 작업도 하지 않음.
- **WFI**: 인터럽트 대기.

### 사용자 지정 명령어
- **CDE 명령어**: Armv8.1-M 사용자 지정 데이터 경로 확장에 포함된 명령어.

## 조건 코드 및 플래그
- **APSR**: 애플리케이션 프로그램 상태 레지스터, 조건 플래그 포함.
  - **N**: 네거티브 플래그
  - **Z**: 제로 플래그
  - **C**: 캐리 플래그
  - **V**: 오버플로 플래그

## 어셈블리 언어 프로그래밍의 예
- **루프 예제**: 조건 플래그를 사용하여 루프의 종료를 제어.
  - 카운터를 감소시키고, Z 플래그가 설정되면 루프를 종료.

## 참고 문서
- **Armv8-M 아키텍처 참조 매뉴얼**: 어셈블리 명령어와 그 사용법에 대한 자세한 정보 제공.
- **Arm Compiler 툴체인 문서**: Arm 컴파일러에서 지원하는 어셈블러와 그 사용법 설명.

# Armv8-M Assembly Language Programming Overview

---

## 데이터 처리 명령 (Data Processing Instructions)
이 섹션에서는 Armv8-M Mainline 아키텍처의 일부로 사용할 수 있는 다양한 유형의 데이터 처리 명령을 살펴보겠습니다.

- **산술 연산 (Arithmetic Operations)**: ADD, SUB, ADCS, RSB 등의 명령이 있으며, 이들은 레지스터 간의 산술 연산을 수행합니다.
- **논리 연산 (Logical Operations)**: AND, ORR, BIC 등이 있으며, 비트 단위 논리 연산을 수행합니다.
- **조건 플래그 (Conditional Flags)**: 대부분의 데이터 처리 명령은 S 접미사를 사용하여 조건 플래그를 업데이트할 수 있습니다.

### 데이터 처리 명령 예제 (Examples)
#### ADD 명령 예제:
- **구문**: `ADD{S} {Rd}, Rn, Rm`
- **예**: `ADDS r0, r1, r2` - r1과 r2의 합을 r0에 저장하고 플래그를 업데이트합니다.

## 비교 명령 (Compare Instructions)
- **CMP 명령**: 두 레지스터 값을 비교하여 조건 플래그를 설정합니다.
- **구문**: `CMP Rn, Rm`
- **예**: `CMP r1, r2` - r1과 r2를 비교하고 플래그를 설정합니다.

## 논리 연산 (Logical Operations)
논리 연산 명령 예제:
- **AND**: 비트 단위 AND 연산
- **ORR**: 비트 단위 OR 연산
- **BIC**: 비트 지우기 연산
- **구문**: `AND{S} {Rd}, Rn, Rm`
- **예**: `ANDS r0, r1, r2` - r1과 r2의 AND 결과를 r0에 저장하고 플래그를 업데이트합니다.

## 시프트 및 회전 명령 (Shift and Rotate Instructions)
Armv8-M Mainline 아키텍처의 시프트 명령:
- **ASR**: Arithmetic Shift Right
- **LSL**: Logical Shift Left
- **LSR**: Logical Shift Right
- **구문**: `ASR {Rd}, Rn, #imm`
- **예**: `ASR r0, r1, #2` - r1을 오른쪽으로 2비트 산술 이동하여 r0에 저장합니다.

## 곱셈 및 나눗셈 명령 (Multiplication and Division Instructions)
### 곱셈 명령:
- **MUL**: 32비트 곱셈
- **SMULL**: 64비트 부호 있는 곱셈
- **구문**: `MUL {Rd}, Rn, Rm`
- **예**: `MUL r0, r1, r2` - r1과 r2를 곱하여 r0에 저장합니다.

## 비트 조작 명령 (Bit Manipulation Instructions)
비트 조작 명령:
- **UBFX**: 부호 없는 비트 필드 추출
- **BFI**: 비트 필드 삽입
- **구문**: `UBFX {Rd}, Rn, #lsb, #width`
- **예**: `UBFX r0, r1, #8, #8` - r1의 8번 비트부터 8비트를 추출하여 r0에 저장합니다.

## C와 어셈블리 간의 변환 (Transformations between C and Assembly)
C 코드에서 어셈블리 코드로 변환 예제:
- **C 코드**: `dest1 = op1 + op2; dest2 = op3 - op4;`
- **어셈블리 코드**:

## 상수 로드 명령 (Constant Load Instructions)
상수 값을 레지스터에 로드하는 방법:
- **MOV**: 상수를 레지스터에 로드
- **구문**: `MOV {Rd}, #imm`
- **예**: `MOV r0, #0x2543` - 0x2543 값을 r0에 로드합니다.

## 나눗셈 명령 (Division Instructions)
### 나눗셈 명령:
- **SDIV**: 부호 있는 나눗셈
- **UDIV**: 부호 없는 나눗셈
- **구문**: `SDIV {Rd}, Rn, Rm`
- **예**: `SDIV r0, r1, r2` - r1을 r2로 나누어 r0에 저장합니다.



## 메모리 액세스 명령 (Memory Access Instructions)

### 메모리에서 데이터 로드 및 저장
이 섹션에서는 메모리에서 데이터를 로드하고 저장하는 데 사용할 수 있는 명령 유형을 살펴봅니다. 특히, Armv8-M 메인라인 아키텍처의 일부인 명령어 세트에서 메모리 액세스 크기와 데이터를 로드하거나 저장하는 주소가 계산되는 방식에 대해 다룹니다.

#### 명령어 유형
- **LDR (Load Register)**: 단어(word) 데이터를 메모리에서 로드합니다.
- **STR (Store Register)**: 단어 데이터를 메모리에 저장합니다.
- **LDRB (Load Register Byte)**: 바이트 데이터를 메모리에서 로드합니다.
- **STRB (Store Register Byte)**: 바이트 데이터를 메모리에 저장합니다.
- **LDRH (Load Register Halfword)**: 하프워드 데이터를 메모리에서 로드합니다.
- **STRH (Store Register Halfword)**: 하프워드 데이터를 메모리에 저장합니다.
- **LDRSB (Load Register Signed Byte)**: 부호 있는 바이트 데이터를 메모리에서 로드합니다.
- **LDRSH (Load Register Signed Halfword)**: 부호 있는 하프워드 데이터를 메모리에서 로드합니다.

메모리 로드 명령어는 메모리에서 데이터를 로드하면 대상 레지스터의 최하위 비트를 차지하고 나머지 공간은 0으로 채워집니다. 부호 확장을 수행하는 경우 가장 중요한 비트를 다른 모든 비트에 복사합니다.

### 오프셋 주소 지정 모드 (Offset Addressing Modes)
다양한 오프셋 주소 지정 모드를 지원하여 메모리 액세스 시 유연성을 제공합니다.

- **기본 레지스터 오프셋 (Register Offset)**: 기본 레지스터에 상수를 더하거나 뺀 값을 사용합니다.
  - 예: `LDR r0, [r1, #8]` - r1 값에 8을 더한 주소에서 r0으로 로드합니다.
- **레지스터 시프트 오프셋 (Register Shifted Offset)**: 레지스터 값을 시프트하여 오프셋으로 사용합니다.
  - 예: `LDR r0, [r1, r2, LSL #2]` - r2 값을 왼쪽으로 2비트 시프트하고 r1에 더한 주소에서 r0으로 로드합니다.

### 주소 지정 모드
네 가지 주소 지정 모드를 지원합니다.
- **단순 주소 지정 모드 (Simple Addressing Mode)**: 기본 레지스터에서 단순히 로드하거나 저장합니다.
  - 예: `LDR r0, [r1]` - r1 주소에서 r0으로 로드합니다.
- **오프셋 주소 지정 모드 (Offset Addressing Mode)**: 기본 레지스터에 오프셋을 더하여 주소를 계산합니다.
  - 예: `LDR r0, [r1, #12]` - r1 값에 12를 더한 주소에서 r0으로 로드합니다.
- **사전 인덱스 주소 지정 모드 (Pre-indexed Addressing Mode)**: 오프셋을 더한 후 로드하거나 저장합니다.
  - 예: `LDR r0, [r1, #12]!` - r1 값에 12를 더한 주소에서 r0으로 로드하고, r1을 갱신합니다.
- **사후 인덱스 주소 지정 모드 (Post-indexed Addressing Mode)**: 로드나 저장 후 오프셋을 더합니다.
  - 예: `LDR r0, [r1], #12` - r1 주소에서 r0으로 로드한 후 r1 값에 12를 더합니다.

### 다중 레지스터 로드 및 저장 (Multiple Register Load and Store)
- **LDM (Load Multiple)**: 여러 레지스터를 한 번에 로드합니다.
- **STM (Store Multiple)**: 여러 레지스터를 한 번에 저장합니다.
  - 예: `LDM r10!, {r0, r1, r4}` - r10 주소에서 r0, r1, r4에 로드한 후 r10을 갱신합니다.

### 스택 액세스 (Stack Access)
- **PUSH**: 스택에 레지스터를 저장합니다.
  - 예: `STMFD sp!, {r4-r7, lr}` - r4에서 r7 및 링크 레지스터를 스택에 푸시합니다.
- **POP**: 스택에서 레지스터를 로드합니다.
  - 예: `LDMFD sp!, {r4-r7, pc}` - r4에서 r7 및 프로그램 카운터를 스택에서 팝합니다.

### 메모리 복사 작업
메모리 복사 작업을 수행하는 어셈블리 명령 시퀀스:
- **소스에서 로드**: `LDRB r0, [r1], #1` - r1 주소에서 바이트를 로드하고, r1 값을 1 증가시킵니다.
- **목적지에 저장**: `STRB r0, [r2], #1` - r0 값을 r2 주소에 저장하고, r2 값을 1 증가시킵니다.
- **반복 루프**: 문자열 복사 작업을 반복합니다.
  - 예: 
    ```assembly
    loop:
      LDRB r0, [r1], #1
      STRB r0, [r2], #1
      CMP r0, #0
      BNE loop
    ```


# Armv8-M Assembly Language Programming - Control Flow Instructions

## 흐름 제어 명령어 (Control Flow Instructions)

### 개요
어셈블리 언어 프로그램이 실행될 때, 프로세서는 기본적으로 사용 가능한 다음 주소에서 다음 명령을 계속 실행합니다. 흐름 제어 명령어를 사용하면 이러한 동작을 변경하여 특정 명령을 건너뛰거나 코드의 다른 지점으로 이동할 수 있습니다. 이 섹션에서는 ARMv8-M 아키텍처의 다양한 흐름 제어 명령어를 살펴봅니다.

### 분기 명령어 (Branch Instructions)
분기 명령어는 프로그램 카운터(PC)를 변경하여 코드의 다른 부분으로 이동할 수 있게 합니다. 분기 명령어는 일반적으로 레이블과 함께 사용됩니다.

- **B**: 기본 분기 명령어로, 지정된 레이블로 분기합니다.
  - 예: `B label`
- **BL**: 링크 명령이 있는 분기 명령어로, 서브루틴이나 함수를 호출할 때 사용됩니다. 현재 주소를 링크 레지스터(LR)에 저장한 후 지정된 레이블로 분기합니다.
  - 예: `BL func`

### 조건부 분기 (Conditional Branch)
조건부 분기 명령어는 특정 조건이 참일 때만 분기합니다. 조건은 상태 플래그(N, Z, C, V)에 따라 결정됩니다.

- **BEQ**: Z 플래그가 설정되어 있을 때 분기 (equal).
  - 예: `BEQ label`
- **BNE**: Z 플래그가 설정되지 않았을 때 분기 (not equal).
  - 예: `BNE label`
- **BGT**: N 플래그와 V 플래그가 같을 때 분기 (greater than).
  - 예: `BGT label`
- **BLT**: N 플래그와 V 플래그가 다를 때 분기 (less than).
  - 예: `BLT label`

### 비교 및 분기 명령어 (Compare and Branch Instructions)
ARMv8-M 메인라인 아키텍처는 비교와 분기를 하나의 명령어로 결합한 명령어를 제공합니다.

- **CBZ (Compare and Branch on Zero)**: 지정된 레지스터의 값이 0일 때 분기.
  - 예: `CBZ r0, label`
- **CBNZ (Compare and Branch on Non-Zero)**: 지정된 레지스터의 값이 0이 아닐 때 분기.
  - 예: `CBNZ r0, label`

### 조건부 실행 블록 (Conditional Execution Blocks)
if-then 블록을 사용하여 여러 명령어를 조건부로 실행할 수 있습니다. IT (If-Then) 명령어를 사용하여 최대 4개의 후속 명령어를 조건부로 실행할 수 있습니다.

- **IT**: if-then 블록의 시작을 정의합니다.
  - 예: `IT EQ`
- **ITE**: if-then-else 블록의 시작을 정의합니다.
  - 예: `ITE EQ`

#### 예제
다음은 if-then 블록을 사용하는 예제입니다.

```assembly
CMP r0, #0      // r0을 0과 비교
IT EQ           // if-then 블록 시작
MOVEQ r1, #2    // r0이 0이면 r1에 2를 이동
MOVNE r1, #4    // r0이 0이 아니면 r1에 4를 이동
```

# ARM 어셈블리 지침 요약

## 어셈블리 구문의 이해
어셈블리 지침 및 구문은 ARM 컴파일러와 GNU 어셈블러에서 다르게 사용됩니다. 이 섹션에서는 두 가지 구문의 차이점을 이해하고, 어떤 컴파일러가 사용되었는지 구분할 수 있는 방법을 학습합니다. 또한, Armv8-M 메인라인 특수 목적 레지스터의 값을 변경하는 간단한 읽기-수정-쓰기 시퀀스를 작성하는 방법을 배웁니다.

## 어셈블러 비교
레거시 armasm 어셈블러와 ARM 컴파일러 6의 armclang 통합 어셈블러를 비교합니다. 이 두 어셈블러는 통합 어셈블리 언어(UAL) 구문 규칙을 준수하지만, 디렉티브와 표현식을 작성하는 방식에서 차이가 있습니다. 
- **armasm 어셈블러**는 이전 ARM 컴파일러 5의 일부였으며 ARMV8-M 아키텍처의 모든 기능을 지원하지는 않습니다.
- **armclang 어셈블러**는 ARM 컴파일러 6의 일부이며 ARMV8-M 아키텍처의 모든 기능을 지원합니다.

## 명령어 및 디렉티브
두 어셈블러는 동일한 명령 시퀀스를 사용하지만, 지침에서는 차이가 발생합니다.
- **섹션 정의**: armasm에서는 `area` 지시문을 사용하고, armclang에서는 `section` 지시문을 사용합니다.
- **상수 정의**: armasm에서는 `EQU` 지시문을 사용하고, armclang에서는 `.equ` 지시문을 사용합니다.
- **32비트 값 정의**: armasm에서는 `DCD` 지시문을 사용하고, armclang에서는 `.word` 지시문을 사용합니다.
- **파일 종료**: armasm에서는 `END` 지시문을 사용하고, armclang에서는 `.end` 지시문을 사용합니다.

## 디지털 신호 처리(DSP) 명령어
DSP 애플리케이션에서 포화 연산을 수행하는 방법을 설명합니다. 포화 연산은 값을 특정한 2의 거듭제곱으로 제한하는 연산입니다. ARMv8-M 아키텍처는 하드웨어에서 이 작업을 수행하기 위한 USAT 및 SSAT 명령을 제공합니다.

## 바이트 리버설 명령
다른 주변 장치를 다루기 위해 바이트 리버설 지침을 사용할 수 있습니다. `rev` 명령을 사용하여 레지스터의 바이트 순서를 뒤집을 수 있습니다.

## 카운트 리딩 제로 명령어
CLZ 또는 카운트 리딩 제로 명령어는 최상위 비트에서 시작하여 설정되지 않은 0의 수를 세고 해당 값을 레지스터에 반환합니다.

## 특수 용도의 레지스터 프로그래밍
특수 용도의 레지스터를 사용하여 Cortex-M 장치를 프로그래밍하는 방법을 설명합니다. 
- **MRS 명령어**: 특수 목적 레지스터에서 범용 레지스터로 이동하는 명령어입니다.
- **MSR 명령어**: 범용 레지스터에서 특수 목적 레지스터로 이동하는 명령어입니다.

## 전원 관리 명령어
프로세서를 저전력 상태로 전환하거나 멀티코어 시스템의 다른 프로세서에 이벤트를 알리는 데 사용할 수 있는 몇 가지 전원 관리 명령이 있습니다.
- **WFI 명령어**: 프로세서를 저전력 상태로 전환합니다.
- **WFE 명령어**: 송신 이벤트에 대한 응답으로 깨어납니다.

## 기타 유용한 명령어
- **NOP 명령어**: 코드에서 자리 표시자로 자주 사용됩니다. 컴파일러에서 명령을 특정 경계에 정렬하는 데 사용할 수 있습니다.

## ARMv8-M 아키텍처의 추가 지침
- **보안 상태 지침**: ARMv8-M 보안 확장 교육 모듈에서 다루는 지침입니다.
- **장벽 명령**: 작업 발생 순서를 제어하고 잘못된 실행을 방지하는 데 사용됩니다.
- **관리자 호출 명령(SVC)**: 운영 체제에 작업을 수행하도록 요청하는 데 사용됩니다.



# ARM 사용자 지정 명령어 요약

## 개요
이 모듈의 마지막 부분에서는 Arm Custom Instructions 기능에 대해 알아봅니다. 이는 Armv8-M 및 Armv8.1-M 아키텍처를 위한 사용자 지정 데이터 경로 확장의 일부로, 프로세서 설계자가 Arm 프로세서에 자체 기능을 추가할 수 있도록 합니다.

## 사용자 지정 명령어의 구문
사용자 지정 명령어는 여러 명령어 클래스로 나뉘며, 각 클래스는 지정할 수 있는 입력 및 출력 피연산자의 유형에 따라 정의됩니다.
- **클래스 1**: 출력 대상 레지스터와 입력 즉시값 피연산자.
- **클래스 2**: 출력 대상 레지스터, 입력 즉시값 피연산자, 추가 소스 레지스터 피연산자.
- **클래스 3**: 여러 소스 레지스터 피연산자.

## 조건 코드 전달
사용자 정의 명령어로 조건 코드를 전달하려면 APSR_NZCV라는 이름을 사용해야 합니다. 이는 애플리케이션 프로세스 상태 레지스터를 의미하며, Negative, Zero, Carry, Overflow 플래그를 포함합니다.

## SIMD 및 부동 소수점 레지스터
사용 중인 프로세서에 따라 사용자 지정 명령어에 SIMD 및 부동 소수점 레지스터를 전달할 수도 있습니다. 예를 들어, Cortex-M33은 SIMD 레지스터 전달을 지원하지 않습니다.

## 사용자 지정 명령어의 인코딩
사용자 지정 명령어는 보조 프로세서 명령어와 동일한 인코딩 공간을 사용합니다. 특정 명령어를 Arm 사용자 지정 명령어로 전달하려면 코어 프로세서에 연결해야 합니다. 

## 사용자 지정 명령어 클래스의 변형
각 명령어 클래스에는 몇 가지 변형이 있습니다.
- **일반 변형**: 결과를 계산하고 출력 레지스터를 사용.
- **누산기 변형**: 등록된 값을 소비하여 연산.
- **이중 변형**: 결과를 두 개의 레지스터에 저장.

## 명령어 클래스 1
명령어 클래스 1은 다음과 같은 형태로 나타납니다:
- CX로 시작하여 사용자 지정 명령어임을 나타냅니다.
- 보조 프로세서 이름(P0 등).
- 대상 레지스터(범용 레지스터 또는 특수 이름).
- 즉시값(최대 13비트).

### 비누산기 변형
레지스터만 출력으로 사용하며, 실제 값은 코프로세서에 전달되지 않습니다.

### 누산기 변형
레지스터 또는 플래그와 즉시값을 코어 프로세서로 전달하여 레지스터를 업데이트합니다.

## 명령어 클래스 2
명령어 클래스 2는 다음과 같은 형태로 나타납니다:
- CX로 시작하여 사용자 지정 명령어임을 나타냅니다.
- 보조 프로세서 이름(P1 등).
- 두 개의 대상 레지스터.
- 소스 레지스터 및 즉시값(최대 9비트).

### 비누산기 변형
두 개의 대상 레지스터를 입력으로 사용하지 않고 즉시값과 opcode를 코어 프로세서로 전송하여 업데이트.

### 누산기 변형
두 개의 대상 레지스터 값을 받아 코어 프로세서로 확장하여 모든 값을 사용할 수 있게 합니다.

## 참고 사항
- 누산기 변형이라는 용어는 보조 프로세서가 대상 레지스터 값을 사용하는 방식을 의미하며, 단순히 더하기 또는 빼기 연산을 수행하는 것은 아닙니다. 원하는 연산을 수행할 수 있습니다.

# Armv8-M 메모리 모델 요약

## 개요
안녕하세요, 여러분. 저는 Arm에서 일하는 애플리케이션 엔지니어 Yang Song입니다. 오늘은 Armv8-M 메인라인 아키텍처의 중요한 주제인 메모리 모델에 대해 알아보겠습니다.

## 학습 목표
이 모듈을 마치면 다음을 할 수 있습니다:
- Armv8-M 메인라인 주소 공간의 여러 파티션을 나열
- Arm 아키텍처 메모리 유형 구분
- 주소 공간의 특정 파티션에 사용되는 이유 구분
- 다양한 메모리 속성과 해당 속성이 로드 및 저장에 미치는 영향 식별
- Endianness가 Armv8-M 프로세서에 미치는 영향 특성화
- 다양한 Barrier 명령 인식 및 사용 이유 설명

## 메모리 주소 공간
Armv8-M은 최대 4GB의 물리적 주소 공간을 포함하는 메모리 매핑 아키텍처입니다. 주소 공간은 물리적 메모리와 프로세서 제어 및 상태 레지스터 모두를 위한 공유 주소 공간입니다. 메모리는 8개의 512MB 세그먼트 또는 파티션으로 분할됩니다:
- 코드 섹션
- SRAM
- 주변기기
- 2개의 RAM 영역
- 2개의 장치 영역
- 시스템 영역

시스템 영역에는 프로세서 제어 및 상태 레지스터가 포함됩니다.

## 메모리 유형과 속성
메모리 영역에는 일반 메모리 또는 장치 메모리가 포함될 수 있습니다. 메모리 유형은 프로세서가 해당 메모리에 액세스하는 방식을 결정합니다. 각 메모리 유형에는 추가 속성(액세스 권한, 실행 권한, 공유 가능성, 캐시 가능성)이 있습니다.

### 일반 메모리
- **정상 메모리**: 코드 및 대부분의 데이터 영역에 사용. 최상의 성능을 제공하며, CPU가 액세스를 재정렬하거나 병합할 수 있음.
- **추측적 액세스**: 일반 메모리는 순서가 약한 메모리 모델을 구현하여 다른 일반 액세스 및 장치 액세스와 관련하여 액세스를 순서대로 완료할 필요가 없음.

### 장치 메모리
- **장치 유형 메모리**: 액세스에 부작용이 발생할 수 있는 영역에 사용. 예를 들어, 주변 장치의 제어 레지스터에 기록하면 인터럽트가 발생할 수 있음. 
- **장치 메모리 변형**: NGNRNE (가장 제한적), NGNRE, GRE (가장 제한이 적음).

## Endianness
- **리틀 엔디안**: 기본 설정. 단어의 최하위 바이트가 가장 낮은 주소를 가리킴.
- **빅 엔디안**: 구성 가능. 단어의 최상위 바이트가 가장 낮은 주소를 가리킴.
- **BE-8 모델**: Arm Cortex-M 프로파일 코어에서 지원. 

## Barrier 명령어
- **DMB (Data Memory Barrier)**: DMB 이전의 모든 명시적 메모리 액세스가 DMB 이후의 명시적 메모리 액세스 전에 완료되도록 보장.
- **DSB (Data Synchronization Barrier)**: DSB가 완료되기 전에 모든 명시적 메모리 트랜잭션이 완료되도록 보장. DSB는 매우 제한적이며 명령어 실행을 차단.
- **ISB (Instruction Synchronization Barrier)**: 시스템 제어 레지스터의 변경 사항을 동기화하여 새로운 체계를 설정.


# 메모리 보호 (Memory Protection)

## 학습 목표

이 모듈을 완료하면 다음을 할 수 있습니다:
- 메모리 보호 장치(MPU)의 필요성 설명
- Armv8-M MPU가 이전 Armv7-M 및 Arm6-M MPU와 어떻게 다른지 이해
- 다양한 메모리 맵핑된 MPU 레지스터 설명
- MPU 레지스터를 프로그래밍하여 메모리 영역 구성

## 메모리 보호의 동기

메모리 보호는 주소 공간 접근을 제어합니다.
- 코어가 다양한 보안 및 특권 상태에서 작동할 수 있기 때문에 필요하며, 민감한 데이터를 특정 상태로 제한하는 것이 중요합니다.

## 메모리 보호와 보안 속성

메모리 보호는 다음으로 구성됩니다:
- 선택적 메모리 보호 장치(MPU)
  - 보호 메모리 시스템 아키텍처(PMSAv8)를 기반으로 함
- 선택적 보안 속성 장치(SAU)
  - 보안 확장이 구현된 경우 사용 가능

MPU는 다음을 완전히 지원합니다:
- 보호 영역, 접근 권한 및 시스템에 메모리 속성 내보내기
- MPU 불일치 및 권한 위반은 MemManage 핸들러를 호출

## 기본 시스템 주소 맵

기본적으로 주소 공간은 8개의 0.5GB 영역을 정의합니다.
- MPU가 구현되지 않은 경우 기본 시스템 주소 맵이 적용됩니다.
- MPU가 구현되었지만 비활성화된 경우
- 시스템이 PPB 주소 공간에 접근하는 경우 등

## 메모리 보호 장치(MPU)

MPU는 기본 메모리 관리를 제공합니다.
- 주소 영역에 속성을 적용할 수 있도록 함
- 모든 접근은 MPU 영역에 대해 검사됩니다.

각 영역은 다음으로 구성됩니다:
- 기본 주소
- 한계 주소
- 속성(예: 유형, 크기, 접근 권한)

## MPU 레지스터

| 주소       | 이름       | 유형  | 설명                  |
|------------|------------|-------|-----------------------|
| 0xE000ED90 | MPU_TYPE   | RO    | MPU 유형 레지스터      |
| 0xE000ED94 | MPU_CTRL   | RW    | MPU 제어 레지스터      |
| 0xE000ED98 | MPU_RNR    | RW    | MPU 영역 번호 레지스터 |
| 0xE000ED9C | MPU_RBAR   | RW    | MPU 영역 기본 주소 레지스터 |
| 0xE000EDA0 | MPU_RLAR   | RW    | MPU 영역 한계 주소 레지스터 |
| 0xE000EDC0 | MPU_MAIR0  | RW    | MPU 메모리 속성 간접 레지스터 0 |
| 0xE000EDC4 | MPU_MAIR1  | RW    | MPU 메모리 속성 간접 레지스터 1 |

## MPU 제어 레지스터 (MPU_CTRL)

| 비트 위치 | 이름        | 설명                                                                                       |
|-----------|-------------|--------------------------------------------------------------------------------------------|
| [2]       | PRIVDEFENA  | MPU가 활성화된 경우 기본 메모리 맵을 백그라운드 영역으로 사용하도록 허용                      |
| [1]       | HFNMIENA    | 하드폴트 및 NMI 핸들러가 MPU를 활성화된 상태로 메모리에 접근할 수 있도록 제어               |
| [0]       | ENABLE      | MPU 활성화/비활성화 (1: 활성화, 0: 비활성화)                                               |

## MPU 영역 기본 주소 레지스터 (MPU_RBAR)

- XN: 실행 불가 여부 (0: 실행 가능, 1: 실행 불가)
- SH: 공유 가능성 (00: 공유 불가, 01: 예약됨, 10: 외부 공유 가능, 11: 내부 공유 가능)
- AP: 접근 권한 (00: 특권 코드만 읽기/쓰기, 01: 모든 특권 레벨에서 읽기/쓰기, 10: 특권 코드만 읽기, 11: 모든 특권 레벨에서 읽기)

## MPU 영역 한계 주소 레지스터 (MPU_RLAR)

- LIMIT: 선택된 MPU 메모리 영역의 상한 한계 주소
- AttrIndx: MPU_MAIR0/1 필드에서 속성 세트를 연결
- EN: 영역 활성화 여부 (0: 비활성화, 1: 활성화)

## MPU 메모리 속성 간접 레지스터 (MPU_MAIR0/1)

- Attr<n>: 속성 (예: 0000: 디바이스 메모리, 00RW: 외부 쓰기-스루 일시적, 0100: 외부 비캐시)

## MPU 구성

1. MPU_TYPE 읽기: 사용 가능한 영역 수 확인
2. MPU_RBAR에 기본 주소, 공유 가능성 및 접근 권한 쓰기
3. MPU_RLAR에 한계 주소, 추가 메모리 속성 및 영역 활성화 비트 쓰기
4. MPU_MAIRn에 Attr<n> 값에 해당하는 메모리 속성 인코딩 쓰기
5. MPU_CTRL 레지스터에 쓰기하여 Hardfault/NMI 동작 및 특권 접근 구성 후 MPU 활성화
6. MPU_RNR에 영역 번호 쓰기

## MemManage faults (Armv8-M Mainline 전용)

- 데이터 접근 위반 (DACCVIOL)
- 명령어 접근 위반 (IACCVIOL)
- 예외 엔트리 스택 메모리 작업 실패 (MSTKERR)
- 예외 반환 스택 메모리 작업 실패 (MUNSTKERR)
- 게으른 상태 보존 오류 플래그 (MLSPERR)

# Armv8-M 아키텍처의 예외 처리

## 학습 목표
이 모듈을 완료하면 다음을 수행할 수 있습니다:
- M-프로파일 예외 모델 설명
  - 내장된 중첩 벡터 인터럽트 컨트롤러(NVIC) 및 임베디드 시스템에 최적화된 방식
  - 예외 유형
  - 벡터 테이블
  - 리셋 동작
  - 기본 예외 처리 메커니즘
- 리셋 동작 설명
- 예외 진입 및 예외 반환 시 발생하는 일 설명
- 예외 대기 시간과 예외 처리 속도를 높이기 위한 아키텍처 최적화 논의

## 목차
1. 소개
2. 예외 모델
  - 예외 진입 및 종료 동작
  - 우선순위와 제어
  - 인터럽트 민감도
3. 벡터 테이블 및 인터럽트 핸들러 작성
4. 내부 예외 및 RTOS 지원
5. 오류 예외
6. 참고 자료

## 개요
Arm 마이크로컨트롤러 프로파일 아키텍처 버전의 예외 아키텍처는 다른 Arm 아키텍처와 매우 다릅니다. 마이크로컨트롤러 응용 프로그램을 위해 설계되었습니다.
- 많은 인터럽트 소스를 지원
- 중첩 인터럽트의 효율적인 처리
- 유연한 인터럽트 아키텍처 (높은 구성 가능성)
- RTOS 지원 내장

### 주요 기능
- 중첩 벡터 인터럽트 컨트롤러(NVIC)
- 마이크로 코드 아키텍처가 "더티 작업" 처리
  - 인터럽트 진입/종료 및 인터럽트 중첩에 대한 소프트웨어 오버헤드 없음
- 모든 예외 처리를 위한 단일 모드 및 단일 스택
  - 핸들러 모드 / 메인 스택
- 프로그래밍이 용이
  - 어셈블리어로 핸들러 코드를 작성할 필요 없음

## 마이크로 코드 인터럽트 메커니즘
- 저지연을 위한 인터럽트 아키텍처 설계
- NVIC에 내장된 인터럽트 우선순위 메커니즘
- 인터럽트 진입/종료는 하드웨어 제어로 "마이크로 코드화"
  - 프로세서 컨텍스트를 자동으로 저장 및 복원
  - 가장 높은 우선순위 대기 인터럽트의 늦은 결정 허용
  - 프로세서 상태의 전체 복원/저장 없이 다른 대기 인터럽트 서비스 허용 (테일 체이닝)
  - 인터럽트 서비스 루틴(ISR)은 전적으로 C 언어로 작성 가능
- 일부 다중 사이클 명령어는 개선된 인터럽트 대기 시간을 위해 인터럽트 가능

## 예외 유형
예외는 다양한 이벤트로 인해 발생할 수 있습니다:
- 내부
- 외부

### 프로세서 모드 사용 예
스레드 모드에서 예외가 발생하면 프로세서 모드가 변경됩니다. 핸들러 모드에서 예외가 발생하면 모드가 변경되지 않습니다.

## 외부 인터럽트
- NVIC에 의해 처리되는 외부 인터럽트
- 프로세서 코어와 긴밀하게 결합
- 하나의 비마스킹 인터럽트(NMI) 지원
- 외부 인터럽트의 수는 구현에 따라 다름 (최대 496개 인터럽트 지원)

## 선점
선점은 예외를 처리하기 위해 태스크가 일시 중단될 때 발생합니다. 동일한 우선순위의 여러 예외가 대기 중인 경우 고정된 순서로 처리됩니다. 활성화된 예외는 높은 우선순위 예외만 선점할 수 있습니다.

## 예외 처리 모델
프로세서는 "기본 실행 우선순위 수준"으로 실행을 시작합니다. 리셋 시 모든 인터럽트가 비활성화됩니다. 기본 실행 우선순위는 가장 낮은 프로그래밍 가능한 우선순위보다 낮으므로 활성화된 모든 인터럽트가 코어를 선점합니다.

## 벡터 테이블
벡터 테이블의 첫 번째 항목은 초기 메인 스택 포인터를 포함합니다. 나머지 항목은 예외 핸들러의 주소입니다. 벡터 테이블은 최대 496개의 외부 인터럽트를 가질 수 있습니다.

## 예외 진입 동작
예외를 받을 때 프로세서는 대부분의 명령어에서 현재 명령어 스트림을 완료합니다. 프로세서 상태는 현재 스택에 자동으로 저장됩니다. ISR 주소는 벡터 테이블에서 읽어옵니다. 링크 레지스터는 인터럽트 반환을 위해 수정됩니다. 예외 핸들러 루틴은 핸들러 모드에서 메인 스택을 사용하여 실행됩니다.

## 예외 반환
예외에서 반환할 때 프로세서는 특정 "매직" 값(0xFFFF_FFXX)으로 PC가 로드될 때 다음 명령어를 실행합니다. 대기 중인 인터럽트가 없는 경우 포어그라운드 상태가 복원됩니다. 다른 인터럽트가 대기 중인 경우 가장 높은 우선순위가 서비스될 수 있습니다.

## 내부 예외 및 RTOS 지원
### SysTick 타이머
- RTOS 또는 사용자 정의 프로그램 실행을 위한 시스템 하트비트 제공
- 주기적 인터럽트는 시스템 태스크 스케줄링을 구동

### Supervisor Call (SVC)
- 비특권 소프트웨어가 시스템 호출을 할 수 있도록 허용
- RTOS 서비스 요청 처리

### Pended System Call (PendSV)
- RTOS 개발을 용이하게 함

## 오류 예외
### 일반 오류의 세 가지 클래스
- BusFault: 메모리 액세스 오류 (프리페치 또는 데이터 액세스)
- MemManage: MPU 권한 불일치
- UsageFault: 정의되지 않은 명령어, CP 액세스, 불법 상태 전환 등

### 오류 처리
단순 시스템은 HardFault 핸들러만 사용합니다. 별도의 오류 핸들러를 활성화하는 것은 필요한 경우에만 해야 합니다. 각 오류에는 연관된 상태 레지스터가 있습니다.

### Lockup 상태
회복 불가능한 예외의 경우 Lockup 상태에 진입합니다. NMI 예외 또는 디버그 이벤트, 리셋 시 Lockup 상태에서 벗어날 수 있습니다.

### 동기 및 비동기 예외
동기 예외는 명령어 스트림과 고정된 관계가 있습니다. 비동기 예외는 명령어 스트림과 고정된 관계가 없습니다.

## 참고 자료
- Armv8-M 아키텍처 레퍼런스 매뉴얼
- 애플리케이션 노트: AN209 - Cortex-M3/M4/M7 오류 예외 사용
- 도서: The Definitive Guide to the Cortex-M3 and Cortex-M4 Processors (ISBN: 978-0124080829) - Yiu
