---
layout : post
title : 구슬의 이동
comments : true
categories : 
- CodingTest
tags : [CodingTest, simulation]
---

# 구슬의 이동

[https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-marble-movement/description](https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-marble-movement/description)



## 풀이

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

#define ARR_MAX_LEN 51
using namespace std;

int n, m, t, k;

int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };

// 0, 1, 2, 3 상, 하, 좌, 우
int dy[4] = { -1, 1, 0, 0 };
int dx[4] = { 0, 0, -1, 1 };

typedef struct{
    int idx;
    int y;
    int x;
    int dir;
    int vel;
}info_t;

vector<info_t> marble_lst;

// 1. 구슬의 이동
// 2. 같은 좌표에 구슬이 K 개 이하인지 확인하고, k개 초과이면 우선 순위에 따라 구슬을 삭제 
// 3. 

bool compare(const info_t & v1, const info_t & v2){
    if (v1.vel != v2.vel) 
        return v1.vel > v2.vel;
    return v1.idx > v2.idx;  // ← 큰 idx 우선
}

void move_marble(){
    
    for(int i = 0; i < marble_lst.size(); i++){
        int cy = marble_lst[i].y;
        int cx = marble_lst[i].x;
        int cvel = marble_lst[i].vel;
        int dir = marble_lst[i].dir;

        int ny = cy, nx = cx;
        for(int j = 0; j < cvel; j++){
            int ty = ny + dy[dir];
            int tx = nx + dx[dir];

            if(ty < 1 || ty > n || tx < 1 || tx > n){
                if(dir == 0) dir = 1;
                else if(dir == 1) dir = 0;
                else if(dir == 2) dir = 3;
                else dir = 2;

            ty = ny + dy[dir];
            tx = nx + dx[dir];
            }
            ny = ty;
            nx = tx;
        }

        // 구슬 위치 좌표 업데이트
        marble_lst[i].y = ny;
        marble_lst[i].x = nx;
        marble_lst[i].dir = dir;
        arrmap[cy][cx]--;
        arrmap[ny][nx]++;
    }

}


void simulate(){

    vector<info_t> temp_marble_lst;
    vector<int> erase_lst;
    move_marble();

    sort(marble_lst.begin(), marble_lst.end(), compare);

    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            int remove_cnt = 0;
            if(arrmap[i][j] > k){
                
                int temp_cnt = 0;
                for(int idx = 0; idx < marble_lst.size(); idx++){
                    if(i == marble_lst[idx].y && j == marble_lst[idx].x){
                        temp_cnt++;
                        if(temp_cnt > k){
                            erase_lst.push_back(idx);
                            remove_cnt++;
                            m--; 
                        }
                    }

                }

            }
            // 좌표에 구슬 개수 업데이트
            arrmap[i][j] -= remove_cnt;
        }
    }


    // 지워야 하는 구슬 빼고 모두 업데이트

    for(int i = 0; i < marble_lst.size(); i++){
        bool temp_flag = false;
        for(int j = 0; j < erase_lst.size(); j++){
            if(i == erase_lst[j]){
                temp_flag = true;
            }
        }
        if(!temp_flag){
            temp_marble_lst.push_back(marble_lst[i]);
        }
    }
    marble_lst.clear();
    for(int i = 0; i < temp_marble_lst.size(); i++){
        marble_lst.push_back(temp_marble_lst[i]);
    }
}

int main() {
    // n 격자 크기, m 구슬 개수, t 시간, k 각 칸에 살아남을 수 있는 최대 구슬 수
    cin >> n >> m >> t >> k;

    for (int i = 0; i < m; i++) {
        int r, c, v;
        char d;
        int dir = 0;
        cin >> r >> c >> d >> v;
        // 0, 1, 2, 3 상, 하, 좌, 우
        if(d == 'U'){
            dir = 0;
        }
        else if(d == 'D'){
            dir = 1;
        }
        else if(d == 'L'){
            dir = 2;
        }
        else{
            dir = 3;
        }
        marble_lst.push_back({i + 1, r, c, dir, v});
        arrmap[r][c]++;

    }

    for(int i = 0; i < t; i++){
        simulate();
    }

    cout << m << "\n";

    return 0;
}



```
