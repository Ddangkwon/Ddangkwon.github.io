---
layout : post
title : 로봇 청소기
comments : true
categories : 
- CodingTest
tags : [CodingTest, DFS]
---
# 로봇 청소기

## 로봇 청소기 작동 방식

현재 위치를 청소한다.
현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.
왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.
왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.
네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.


DFS 로 해결했고 기본적인 탐색 문제에 방향 전환이 추가된 문제이다.
다만 방향을 표현하는 d 변수가 실제 반시계로 회전했을 때 인덱스와 맞춰주는 과정이 필요하다.
또한 종료 조건으로는 후진한 상태에서 4. 종료조건을 만났을 때 결과 출력 후 뒤이은 재귀 호출 잆이 프로세스를 종료하도록 exit(0) 함수를 사용한다.

## return 문과 exit(0), exit(1)의 차이
exit 함수는 c언어 에서는 stdlib.h 헤더파일에 존재하는 함수로 C언어로 작성된 프로세스 내 파일 입출력 중인 것을 저장하고 프로세스 종료하여 운영체제로 권한을 넘기는 것을 의미한다.
이 때 exit(0) 함수는 정상종료를, exit(1) 은 비정상 에러메시지 종료를 의미한다.

return 문의 경우 함수 속에서 함수를 종료하는 함수로 exit와 같이 그 프로세스를 종료하는 것은 아니다.

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int map[51][51] = { 0, };
// 왼쪽부터 회전 서 => 남 => 동 => 북
// 방향 번호 북 => 동 => 남 => 서
int dx[4] = { -1, 0, 1, 0 };
int dy[4] = { 0, 1, 0, -1 };
int N, M;
int answer = 0;
void dfs(int cx, int cy, int cd)
{
    if (map[cx][cy] == 0)
    {
        // 방문 처리 => 청소가 되었음을 표현
        map[cx][cy] = 2;
        answer++;
    }
    for (int i = 0; i < 4; i++)
    {
        int nd = (cd + 3 - i) % 4;
        int nx = cx + dx[nd];
        int ny = cy + dy[nd];
        // 북동남서 순을 서남동북 순으로 변환하기 위해 +3 을 해주고 순서가 정 반대이므로 -i 를 하여 뒤집어준다.
        
        if (nx >= 0 && ny >= 0 && nx < N && ny < M)
        {
            if (map[nx][ny] == 0)
            {
                dfs(nx, ny, nd);
            }
        }
        
    }
    // 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.
    // 뒤집기 즉 후진 하기 위해서는 방향을 반대로 바꿔야한다.

    int nd = (cd + 2) % 4;
    int nx = cx + dx[nd];
    int ny = cy + dy[nd];
    // 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.
    // 뒤쪽 방향이 모두 벽인 경우 바로 프로세스 종료
    if (map[nx][ny] == 1)
    {
        printf("%d\n", answer);
        exit(0);
    }
    // 바라보는 방향 유지
    dfs(nx, ny, cd);
}
int main()
{
    int r, c, d;
    scanf("%d %d", &N, &M);
    scanf("%d %d %d", &r, &c, &d);

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < M; j++)
        {
            scanf("%d", &map[i][j]);
        }
    }
    dfs(r, c, d);
    
    return 0;
}

```