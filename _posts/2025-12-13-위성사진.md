---
layout : post
title : 위성 사진
comments : true
categories : 
- CodingTest
tags : [CodingTest, DFS]
---

# 위성 사진


## 문제

농부 창호는 자신의 농장을 위성을 이용해 찍은 사진을 얻게 되었다. 

이 사진은 W*H 크기의 픽셀로 이루어진 사진이다. 

창호는 이렇게 찍힌 사진들 중에서 가장 많이 연속되어 연결된 목장의 크기가 알고 싶어 한다. 

목장이란 사진에 비어있지 않은 곳을 가정하며, 하나의 픽셀은 하나의 목장이 될 수 있다. 

연결된 목장이란 다른 목장과 가로 혹은 세로방향으로 맞닿아 있는 것을 뜻한다. 

또한 연속되어 연결 되었다는 것은 연결되었다고 가정한 목장들의 집합 안 에서 모든 두 지점에 대해, 

상하좌우로 목장만을 이동경로로 둘 경우 모든 두 지점에 대한 경로가 존재할 경우 이 집합 안의 목장들은 연속되어 연결 되었다고 이야기 한다.

각 위성사진은 2개의 문자로 이루어져 있는데 '*' 표시는 목장, '.' 은 비어있는 곳을 의미한다. 

아래는 이러한 위성사진의 예이다.​

 
```
..*.....**
.**..*****
.*...*....
..****.***
..****.***
``` 

위의 그림에서 4, 16, 6개의 픽셀로 이루어진 연속된 목장이 존재한다. 

그리고 이 경우는 16이 창호가 찾고자 하는 답이 된다.

 


## 입력
첫 번째 줄에는 W와 H가 공백을 사이에 두고 입력 된다 (1≤W≤80, 1≤H≤1,000). 그 다음 줄부터 H의 줄에 W개의 문자 '*', '.'로 이루어진 위성 사진의 한 줄이 입력된다.


## 출력
입력된 위성사진에서 나타나는 가장 많은 연속된 목장의 개수를 출력한다.

## 풀이

```cpp
#include <iostream>
#include <string>

#define ARR_MAX_LEN 1001
using namespace std;

int W, H, cnt = 0, answer = 0;

char arrmap[ARR_MAX_LEN][ARR_MAX_LEN];
bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };
int dy[4] = { -1, 1, 0 , 0 };
int dx[4] = { 0, 0, -1, 1 };

void dfs(int y, int x)
{
    isvisited[y][x] = true;
    cnt++;
    for(int dir = 0; dir < 4; dir++){
        int ny = y + dy[dir];
        int nx = x + dx[dir];
        
        if(ny < 0 || ny >= H || nx < 0 || nx >= W)
            continue;
        if(!isvisited[ny][nx] && arrmap[ny][nx] == '*')
            dfs(ny, nx);
    }
}
int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    cin >> W >> H;

    for(int i = 0; i < H; i++){
        string str;
        cin >> str;

        for(int j = 0; j < str.length(); j++){
            arrmap[i][j] = str[j]; 
        }
    }

    for(int i = 0; i < H; i++){
        for(int j = 0; j < W; j++){
            if(arrmap[i][j] == '*' && !isvisited[i][j]){
                cnt = 0;
                dfs(i, j);
                answer = max(answer, cnt);
            }
        }
    }

    cout << answer << "\n";
    return 0;
}
```