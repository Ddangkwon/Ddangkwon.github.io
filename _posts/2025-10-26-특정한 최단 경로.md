---
layout : post
title : 특정한 최단 경로
comments : true
categories : 
- CodingTest
tags : [CodingTest, Dijkstra]
---

# 특정한 최단 경로

[https://www.acmicpc.net/problem/1504](https://www.acmicpc.net/problem/1504)



## 문제
방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.

세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.

## 입력
첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.

## 출력
첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.

## 풀이

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>
#include <algorithm>

using namespace std;

#define MAX_LEN 810

typedef struct{
    int node;
    int weight;
}edge_t;

int N, E, V1, V2, answer = -1;
vector<vector<edge_t> > graph(MAX_LEN);
vector<int> dist(MAX_LEN, INT_MAX);

struct compare{
    bool operator()(const edge_t &a, const edge_t &b) const {
        return a.weight > b.weight;
    }
};

void input(){
    cin >> N >> E;

    int a, b, c;

    for(int i = 0; i < E; i++){
        cin >> a >> b >> c;
        graph[a].push_back({b, c});
        graph[b].push_back({a, c});
    }
    cin >> V1 >> V2;
}

void dijkstra(int start){
    priority_queue<edge_t, vector<edge_t>, compare> pq;
    // 호출할 때마다 dist 전체를 초기화하지 않고, 호출 전/후에 호출자가 초기화하는 패턴 유지
    dist[start] = 0;
    pq.push({start, 0});

    while(!pq.empty()){
        edge_t cur_edge = pq.top();
        pq.pop();

        if(cur_edge.weight > dist[cur_edge.node])
            continue;

        for(auto &next_edge : graph[cur_edge.node]){
            int update_weight = cur_edge.weight + next_edge.weight;
            if(update_weight < dist[next_edge.node]){
                dist[next_edge.node] = update_weight;
                pq.push({next_edge.node, update_weight});
            } 
        }
    }
}

void init_lst(vector<int> &arr){
    for(int i = 1; i <= N; ++i){
        arr[i] = INT_MAX;
    }
}

// 1 -> V1 -> V2 -> N
// 1 -> V2 -> V1 -> N
void simulate(){
    bool flag1 = true, flag2 = true;

    // dist 초기화 (1..N)
    init_lst(dist);
    // 1 -> V1, 1 -> V2
    dijkstra(1);
    int route1 = dist[V1];
    int route2 = dist[V2];

    // 도달 가능 여부 정확히 판정
    if(dist[V1] == INT_MAX)
        flag1 = false;
    if(dist[V2] == INT_MAX)
        flag2 = false;

    // 두 경로 모두 도달 불가일 경우 answer 값 업데이트 후 return
    if(!flag1 && !flag2){
        answer = -1;
        return ;
    }
        
    // dist 초기화
    init_lst(dist);

    // V1 -> V2 (무방향이므로 V1→V2와 V2→V1 비용 동일)
    dijkstra(V1);
    if(flag1 && dist[V2] != INT_MAX) 
        route1 += dist[V2];
    else 
        flag1 = false;
    if(flag2 && dist[V2] != INT_MAX) 
        route2 += dist[V2]; // 1→V2 경로에서 V2→V1 비용 추가(대칭)
    else 
        flag2 = false;

    // dist 초기화
    init_lst(dist);
    // V2 -> N (route1 마무리)
    dijkstra(V2);
    if(flag1 && dist[N] != INT_MAX) 
        route1 += dist[N];
    else 
        flag1 = false;

    // dist 초기화
    init_lst(dist);
    // V1 -> N (route2 마무리)
    dijkstra(V1);
    if(flag2 && dist[N] != INT_MAX) 
        route2 += dist[N];
    else 
        flag2 = false;

    if(!flag1 && !flag2) 
        answer = -1;
        
    else if(!flag1)      
        answer = route2;
    else if(!flag2)      
        answer = route1;
    else                 
        answer = min(route1, route2);
}

int main(void){
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    input();
    simulate();
    cout << answer << "\n";
    return 0;
}

```
