---
layout : post
title : STL_Set
comments : true
categories : 
- CodingTest
tags : [CodingTest]
---

# Set (STL) 개요

`std::set` 컨테이너는 **중복 없이(unique)**, **정렬된 상태(sorted)** 로 요소를 보관하는 연관 컨테이너(associative container)다.  
즉, 값 자체가 키(key)가 되며, 삽입·검색·삭제 등이 모두 **로그(logarithmic)** 시간 복잡도를 갖는다.  
주로 설정값 집합(configuration set), 유니크한 식별자 집합(ID set) 등을 다룰 때 유용하다.

- 특성상 속도가 조금 느릴 수 있고, 이를 감안하여 사용해야 한다.

---

## 1. 헤더 및 기본 문법

```cpp
#include <set>

std::set<T> s;
```

여기서 `T` 는 요소 타입이다.  
기본 비교 객체(comparator)로 `std::less<T>` 가 사용되어 오름차순 정렬을 갖는다.  
내림차순 등 커스텀 정렬이 필요하면 다음처럼 지정할 수 있다.

```cpp
std::set<int, std::greater<int>> descSet = {5, 1, 3, 2};
```

---

## 2. 주요 특징

- **유일한 요소 유지**: 동일한 값이 둘 이상 존재할 수 없다. 삽입 시 이미 존재하면 동작이 무시된다.  
- **자동 정렬 유지**: 삽입할 때마다 내부적으로 정렬이 유지된다. 이 때문에 인덱스 연산(`[]`)은 지원되지 않는다.  
- **값 수정 불가(불변 요소)**: 컨테이너에 저장된 값은 직접 수정할 수 없고, 수정하려면 삭제 후 재삽입해야 한다.  
- **로그 시간 복잡도**: 삽입, 삭제, 탐색 모두 평균적으로 O(log n)이다. 내부 구현은 보통 **레드‑블랙 트리(Red‑Black Tree)** 형태다.

---

## 3. 사용 예시

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s = {4, 2, 5, 2, 1};
    // 중복 2가 한 번만 저장
    for (auto x : s) {
        cout << x << " ";  // 출력: 1 2 4 5
    }
    cout << endl;

    // 삽입
    auto [it, inserted] = s.insert(3);
    if (inserted) {
        cout << "3 inserted\n";
    }

    // 탐색
    if (s.find(4) != s.end()) {
        cout << "4 exists\n";
    }

    // 삭제
    s.erase(1);

    return 0;
}
```

- **insert** 와 **erase** 를 활용하는 예시 

```cpp
#include <iostream>
#include <set>


using namespace std;

int Q;

set<int> s;
int main(void){

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int val;
    char ch;
    cin >> Q;

    for(int i = 0; i < Q; i++){
        cin >> ch >> val;
        if(ch == 'i'){
            s.insert(val);
        }
        else if(ch == 'r'){
            s.erase(val);
        }
        
    }

    for(const auto & data : s){
        cout << data << " ";
    }
    cout << "\n";
    return 0;
}

```

- Set 함수 인덱스 참조하고 싶을 때 (vector 로 copy 하는 방법도 있음)

```cpp
#include <iostream>
#include <set>
using namespace std;

int Q;
set<long long> s;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> Q;
    for (int i = 0; i < Q; i++) {
        char ch; long long val;
        cin >> ch >> val;
        if (ch == 'i') 
            s.insert(val);
        else if (ch == 'r')
             s.erase(val);
    }

    long long x; // 1-based
    cin >> x;

    if (s.empty() || x < 1 || x > s.size()) {
        cout << "OVER\n";
        return 0;
    }

    long long idx = 1; // 1-based
    for (auto it = s.begin(); it != s.end(); ++it, ++idx) {
        if (idx == x) {
            cout << *it << '\n';
            break;
        }
    }


    // 다른 풀이
    // **set → vector 복사**
    vector<long long> v(s.begin(), s.end());

    cout << v[x - 1] << '\n'; // 1-based index → 0-based로 변환

    return 0;
}


```

- find() 활용법

```cpp
#include <iostream>
#include <set>
#include <cmath>
#include <climits>
using namespace std;

int Q;
set<int> s;

int main(void) {
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    int val;
    char ch;
    cin >> Q;

    for (int i = 0; i < Q; i++) {
        cin >> ch >> val;

        if (ch == 'i') {
            s.insert(val);
        }
        else if (ch == 'r') {
            s.erase(val);
        }
        else if (ch == 'f') {
            // 존재 확인: 반드시 find() 사용
            auto it = s.find(val);
            if (it == s.end()) {
                cout << "NOPE\n";
                continue;
            }

            // 집합에 유일한 원소이면 UNIQUE
            if (s.size() == 1) {
                cout << "UNIQUE\n";
                continue;
            }

            long long search_num = val;
            long long diff_min = LLONG_MAX;
            int answer = 0; // s.size() >= 2 이므로 최소 하나는 후보가 생김

            for (const auto &num : s) {
                if (num == val) 
                    continue; // 자기 자신 제외

                long long temp_diff = llabs(search_num - (long long)num);

                if (temp_diff < diff_min) {
                    diff_min = temp_diff;
                    answer = num;
                } 
                else if (temp_diff == diff_min && num < answer) {
                    // 차이가 같으면 더 작은 수
                    answer = num;
                }
            }

            cout << answer << "\n";
        }
    }

    return 0;
}

```

- lower_bound, upper_bound 활용법


```cpp
#include <iostream>
#include <set>


using namespace std;

int Q;

set<int> s;
int main(void){

    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int val;
    char ch;
    cin >> Q;

    for(int i = 0; i < Q; i++){
        cin >> ch >> val;
        if(ch == 'i'){
            s.insert(val);
        }
        else if(ch == 'r'){
            s.erase(val);
        }
        //lower_bound(x) 는 첫 번째 값 ≥ x 의 iterator 를 준다.
        // val 이상 원소 중 가장 작은 값 

        else if(ch == 'b'){
            if(s.lower_bound(val) != s.end()){
                auto iter = s.lower_bound(val);
                cout << *iter << "\n";
            }
        }
        //upper_bound(x) 는 첫 번째 값 > x 의 iterator 를 준다. 
        //upper_bound(x) → x 초과 첫 값
        else if(ch == 's'){
            if(s.upper_bound(val) != s.begin()){
                auto iter = s.upper_bound(val);
                // val 이하 원소 중 가장 큰 값
                iter--;
                cout << *iter << "\n";
            }
        }
    }


    cout << "\n";
    return 0;
}

```

---

## 4. 주요 멤버 함수 및 연산자

| 함수/연산자                     | 설명 |
|-------------------------------|------|
| insert(value)               | 값 삽입 (존재하면 삽입 안됨) |
| erase(value)                | 값 삭제 |
| find(key)                   | 키 탐색, iterator 반환 |
| count(key)                  | 키와 동일한 요소 개수 (Set은 0 또는 1) |
| lower_bound(key) / upper_bound(key) | 키 이상(이상)/키 초과 첫 위치 iterator 반환 |
| size() / empty()          | 크기 조회 / 비었는지 확인 |
| begin() / end()           | 순회용 iterator |
| 비교 연산자 ==, != 지원   | 두 Set의 동일 여부 비교 가능 |

---

## 5. 커스텀 비교 및 정렬 순서 변경

```cpp
// 내림차순 정렬
std::set<int, std::greater<int>> sDesc = {1, 5, 3, 2};
for (auto x : sDesc) {
    cout << x << " ";  // 출력: 5 3 2 1
}
```

또한 커스텀 비교 함수 객체를 만들면 복잡한 기준으로 정렬 가능하다.  
예를 들어 구조체를 키로 사용할 때 비교 기준을 직접 정의하면, 정렬된 유일 요소 집합을 구성할 수 있다.

---

## 6. 성능 및 내부 구현 고려사항 

- 삽입·삭제가 빈번하고 요소 수가 많으면 O(log n) 구조인 Set이 성능 병목이 될 수 있다. 이 경우 `std::unordered_set` (평균 O(1)) 고려 가능하다.  
- 정렬된 상태가 필요 없다면 `unordered_set` 또는 `vector + sort + unique` 전략이 더 효율적이다.  
- Sorted 상태 유지가 필요하고, 범위 탐색(range query), 순서 기반 작업이 많다면 Set이 유리하다. 예: 주파수 대역 세트, 활성 RF 채널 세트 등.  
- 탐색 외에 인덱스 기반 접근이나 랜덤 접근이 필요하다면 `std::vector` + 이진 탐색이나 `std::deque` 등을 고려해야 한다.

---

## 7. 주의사항 및 한계

- 인덱스 연산(`s[0]`)이 없고, 순회는 iterator 기반으로만 가능하다.  
- 저장된 요소의 값을 직접 변경할 수 없다. 값 변경이 필요하면 삭제 후 삽입해야 한다.  
- 반복자(iterator) 유효성(invalidation)에 주의해야 한다. Set의 삽입/삭제는 기존 반복자를 무효화하지 않는 경우가 많지만, erase로 제거된 iterator는 무효하다.  
- 대량 삽입/삭제가 반복되는 실시간 시스템에서는 GC‑like 비용이나 메모리 단편화(fragmentation)를 고려해야 한다.

---

## 8. 요약

- `std::set`은 **유일한 요소 + 정렬된 상태**를 유지하는 연관 컨테이너다.  
- 설정값, ID 집합, 구성요소 목록 등 **정렬과 고유성**이 중요한 곳에 적합하다.  
- 반면, **정렬이 필요 없거나 랜덤 접근이 많은 경우**에는 다른 자료구조가 더 적합하다.  
- 통신/RF SW 맥락에서는 주파수 대역, 활성 채널 리스트, 식별자 집합 등으로 많이 활용될 수 있으며, 삽입/삭제/탐색 요구사항에 맞춰 선택해야 한다.