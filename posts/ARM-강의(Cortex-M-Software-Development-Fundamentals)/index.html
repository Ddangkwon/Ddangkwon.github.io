<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="ARM 강의(Cortex-M Software Development Fundamentals)" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Arm 컴파일러 개요 및 사용법" /><meta property="og:description" content="Arm 컴파일러 개요 및 사용법" /><link rel="canonical" href="/posts/ARM-%EA%B0%95%EC%9D%98(Cortex-M-Software-Development-Fundamentals)/" /><meta property="og:url" content="/posts/ARM-%EA%B0%95%EC%9D%98(Cortex-M-Software-Development-Fundamentals)/" /><meta property="og:site_name" content="DK’s Software Engineering Knowledge Storage" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-06-03T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ARM 강의(Cortex-M Software Development Fundamentals)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="k9n3TqutGkNvqf7uv9HP04BF1yRBxsowePxu32o6gBk" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-28T12:49:37+09:00","datePublished":"2024-06-03T00:00:00+09:00","description":"Arm 컴파일러 개요 및 사용법","headline":"ARM 강의(Cortex-M Software Development Fundamentals)","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/ARM-%EA%B0%95%EC%9D%98(Cortex-M-Software-Development-Fundamentals)/"},"url":"/posts/ARM-%EA%B0%95%EC%9D%98(Cortex-M-Software-Development-Fundamentals)/"}</script><title>ARM 강의(Cortex-M Software Development Fundamentals) | DK's Software Engineering Knowledge Storage</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="DK's Software Engineering Knowledge Storage"><meta name="application-name" content="DK's Software Engineering Knowledge Storage"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/green_galaxy.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">DK's Software Engineering Knowledge Storage</a></div><div class="site-subtitle font-italic">Software Engineering Knowledge Repo.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>ARM 강의(Cortex-M Software Development Fundamentals)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>ARM 강의(Cortex-M Software Development Fundamentals)</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1717340400" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2024-06-03 </em> </span> <span> 업데이트 <em class="" data-ts="1722138577" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2024-07-28 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">DK</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7026 단어"> <em>39 분</em>읽는 시간</span></div></div></div><div class="post-content"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9717042333563257" crossorigin="anonymous"></script><h1 id="arm-컴파일러-개요-및-사용법">Arm 컴파일러 개요 및 사용법</h1><h2 id="arm-컴파일러-개요"><span class="mr-2">Arm 컴파일러 개요</span><a href="#arm-컴파일러-개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 슬라이드에서는 베어 시스템에서 Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴봅니다. Arm 라이선스 기간에는 두 가지 옵션을 사용할 수 있습니다:</p><ol><li><strong>Arm 컴파일러 6</strong>: 모든 A 프로파일, R 프로파일, M 프로파일 변형을 지원하며, 최신 아키텍처 기능 및 확장을 가장 강력하고 완벽하게 지원합니다.<li><strong>Arm 컴파일러 5</strong>: 레거시 툴 체인으로, Armv4에서 Armv7까지의 아키텍처만 지원하며 수명이 거의 끝나가고 있습니다.</ol><p>그 외에도 GCC와 같은 오픈 소스 컴파일러와 타사 도구 공급업체 컴파일러가 있습니다. 이러한 모든 컴파일러 도구 체인은 Arm 아키텍처용 ABI를 준수해야 합니다.</p><h2 id="기능-안전을-위한-컴파일러-지원"><span class="mr-2">기능 안전을 위한 컴파일러 지원</span><a href="#기능-안전을-위한-컴파일러-지원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>기능 안전을 위한 컴파일러는 특정 기능 안전 표준에 따라 인증을 받아야 합니다. Arm에서는 이를 장기 유지 관리 릴리스(LTM)라고 합니다. LTM은 버그를 수정하는 데 중점을 두며, 기능 안전 시스템의 개발을 단순화하고 가속화할 수 있습니다. 기능 안전 릴리스에는 검증 키트가 포함되어 있으며, 이는 안전 매뉴얼, 철저히 테스트된 라이브러리 목록, 결함 보고서를 제공합니다.</p><h2 id="arm-컴파일러-6-소개"><span class="mr-2">Arm 컴파일러 6 소개</span><a href="#arm-컴파일러-6-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm Compiler 6은 오픈 소스 LLVM Clang을 기반으로 하여 오픈 소스 세계와의 규정 준수를 보장하며, 최신 아키텍처 기능 및 확장을 가장 빠르고 완벽하게 지원합니다. Arm 컴파일러는 Arm DS 및 Keil-MDK와 함께 제공되며, 독립 실행형 버전은 웹사이트에서 다운로드할 수 있습니다. 기능 안전 버전이 아닌 경우 독립 실행형 라이선스가 없습니다.</p><h3 id="arm-compiler-5에서-arm-compiler-6으로-마이그레이션"><span class="mr-2">Arm Compiler 5에서 Arm Compiler 6으로 마이그레이션</span><a href="#arm-compiler-5에서-arm-compiler-6으로-마이그레이션" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Arm Compiler 5는 이제 레거시 툴 체인이므로, Arm Compiler 6으로 마이그레이션하는 것이 좋습니다. Arm Compiler 6은 Clang과 LLVM 기술을 기반으로 구축되어 있으며, 프로덕션 환경에서 사용하기에 적합한 제품 기능을 제공합니다. 커뮤니티 기능은 프로덕션 코드에서 사용하지 않는 것이 좋습니다.</p><h2 id="언어-지원"><span class="mr-2">언어 지원</span><a href="#언어-지원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm Compiler 6은 여러 언어 표준을 지원합니다:</p><ul><li>C 언어: c90, c99, c11, gnu90, gnu99, gnu11<li>C++ 언어: C++03, C++11, C++14, C++17, GNU++03, GNU++11, GNU++14, GNU++17</ul><h3 id="데이터-유형"><span class="mr-2">데이터 유형</span><a href="#데이터-유형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Cortex-M 프로세서는 AArch32 아키텍처를 사용하며, 다음과 같은 데이터 유형을 지원합니다:</p><ul><li>32비트 정수: int, long<li>64비트 정수: long long<li>16비트 하프 워드: short<li>8비트 바이트: char<li>32비트 단정밀도 부동 소수점: float<li>64비트 배정밀도 부동 소수점: double<li>C++에서는 불리언 및 wchar_t 타입도 지원됩니다.</ul><h2 id="c-예외-처리"><span class="mr-2">C++ 예외 처리</span><a href="#c-예외-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm Compiler 6에서 C++ 예외 처리는 기본적으로 활성화되어 있습니다. 예외를 사용하지 않는 경우, -fno-exception 옵션을 사용하여 예외를 비활성화하는 것이 좋습니다. 또한, 일부 C++ 라이브러리는 예외 처리가 활성화된 상태로 컴파일되어 있으므로 주의가 필요합니다.</p><h3 id="c-초기화-및-소멸자"><span class="mr-2">C++ 초기화 및 소멸자</span><a href="#c-초기화-및-소멸자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>C++ 객체 초기화 방식을 사용자 지정하려는 경우, _cpp_initialized_aeabi 및 aeabi_atexit 함수를 재정의할 수 있습니다. 힙을 사용하면서 자체 힙 관리 시스템을 구현하려는 경우, malloc과 free 함수를 리타겟팅하는 것이 좋습니다. 또한, C++ 라이브러리는 스레드 안전하지 않으므로 멀티스레딩 libc++를 사용할 경우 주의해야 합니다.</p><h1 id="arm-아키텍처를-위한-코드-개발-고려-사항">Arm 아키텍처를 위한 코드 개발 고려 사항</h1><h2 id="arm-프로시저-호출-표준-aapcs"><span class="mr-2">Arm 프로시저 호출 표준 (AAPCS)</span><a href="#arm-프로시저-호출-표준-aapcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="aapcs-개요"><span class="mr-2">AAPCS 개요</span><a href="#aapcs-개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>AAPCS는 Arm용 API 아키텍처 및 모든 컴파일러의 일부로, ARM Aarch 32 기기가 이를 준수해야 합니다. 이 표준은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다. 이를 이해하면 더 효율적인 코드를 작성할 수 있습니다.</p><h3 id="레지스터-사용"><span class="mr-2">레지스터 사용</span><a href="#레지스터-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>레지스터 r0-r3</strong>: 함수에 인수를 전달하는 데 사용됩니다.<li><strong>레지스터 r0-r1</strong>: 반환되는 데이터의 크기에 따라 값을 반환하는 데 사용됩니다.<li><strong>레지스터 r4-r11</strong>: 레지스터 변수이며 보존해야 합니다. 함수 호출 시 이 레지스터들은 호출된 함수가 원래 값을 복원할 수 있도록 저장해야 합니다.<li><strong>스택 포인터 (SP, r13)</strong>: 스택의 다음 빈 공간을 가리킵니다.<li><strong>링크 레지스터 (LR, r14)</strong>: 함수를 호출할 때 반환 주소를 가리킵니다.<li><strong>프로그램 카운터 (PC, r15)</strong>: 실행할 다음 명령을 가리킵니다.</ul><h3 id="함수-호출-예제"><span class="mr-2">함수 호출 예제</span><a href="#함수-호출-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레지스터 r0-r3과 r12는 함수 호출 시 손상될 수 있습니다.<li>함수 호출 전후에 필요한 레지스터를 저장 및 복원해야 합니다.<li>링크 레지스터는 함수 반환 주소를 가리키며, 호출자 함수가 다른 함수를 호출할 때는 값을 보존해야 합니다.<li>함수 반환 값이 단어 크기 이하인 경우 r0을 사용하여 반환하며, 64비트인 경우 r0과 r1의 조합을 사용합니다.</ul><h3 id="매개변수-전달"><span class="mr-2">매개변수 전달</span><a href="#매개변수-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>최대 4개의 단어 크기 매개변수를 함수 레지스터에 전달할 수 있습니다. 추가 매개변수는 스택으로 전달됩니다.<li>하위 단어 크기 인수도 전체 레지스터를 사용합니다.<li>64비트 인수는 짝수 레지스터와 연속된 홀수 레지스터 쌍을 사용합니다.<li>C++ 비정적 멤버 함수에서는 레지스터 r0이 항상 객체 포인터를 포함하므로 실제로 세 개의 인수만 전달할 수 있습니다.</ul><h3 id="매개변수가-4개-이상일-때"><span class="mr-2">매개변수가 4개 이상일 때</span><a href="#매개변수가-4개-이상일-때" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>매개변수가 4개 이상인 경우, 추가 매개변수는 스택에 전달됩니다.<li>함수가 반환될 때 스택 포인터를 복원해야 합니다.<li>블 (BL) 명령어는 다음 명령어의 주소를 링크 레지스터에 복사합니다.</ul><h3 id="64비트-인수와-매개변수-전달-예제"><span class="mr-2">64비트 인수와 매개변수 전달 예제</span><a href="#64비트-인수와-매개변수-전달-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>정수 a는 레지스터 r0을 사용하고, 64비트 double b는 r2와 r3을 사용하여 전달합니다.<li>정수 c는 스택 메모리를 사용해야 합니다.<li>정수, double, 정수의 순서로 전달되는 경우, 레지스터와 스택을 최적화하여 사용할 수 있습니다.</ul><h2 id="최적화-및-정렬"><span class="mr-2">최적화 및 정렬</span><a href="#최적화-및-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>매개변수 전달 순서는 레지스터와 스택 사용 방식에 큰 영향을 미칩니다.<li>크기가 작은 매개변수를 먼저 배치하는 것이 좋습니다.<li>정적이 아닌 C++ 멤버 함수의 경우, r0에는 숨겨진 <code class="language-plaintext highlighter-rouge">this</code> 인수가 포함됩니다.</ul><p>위 내용은 Arm 아키텍처에 맞춰 코드를 효율적으로 작성하는 데 필요한 고려 사항을 요약한 것입니다. AAPCS 표준을 이해하고 준수하면 더 나은 성능과 유지보수성을 가진 코드를 작성할 수 있습니다.</p><h1 id="arm-custom-instructions-요약">Arm Custom Instructions 요약</h1><hr /><h2 id="개요"><span class="mr-2">개요</span><a href="#개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm Custom Instructions는 Armv8-M 및 Armv8.1-M 아키텍처를 위한 사용자 지정 데이터 경로 확장의 일부로, 프로세서 설계자가 Arm 프로세서에 자체 기능을 추가할 수 있도록 합니다.</p><h2 id="명령어-클래스"><span class="mr-2">명령어 클래스</span><a href="#명령어-클래스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용자 지정 명령어는 여러 범주로 나뉘며, 각 클래스는 사용자 지정 명령어에 지정할 수 있는 입력 및 출력 피연산자의 유형을 기반으로 정의됩니다.</p><h3 id="클래스-1"><span class="mr-2">클래스 1</span><a href="#클래스-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>출력 대상 레지스터 피연산자와 입력 즉시값 피연산자를 포함.<li>변형: 비누산기, 누산기.</ul><h3 id="클래스-2"><span class="mr-2">클래스 2</span><a href="#클래스-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>출력 대상 레지스터와 소스 레지스터 피연산자를 추가.<li>변형: 비누산기, 누산기.</ul><h2 id="조건-코드-전달"><span class="mr-2">조건 코드 전달</span><a href="#조건-코드-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>조건 코드를 사용자 정의 명령어로 전달하기 위해 APSR_NZCV 레지스터를 사용하며, 이는 애플리케이션 프로세스 상태 레지스터를 의미합니다.</p><h2 id="레지스터-피연산자"><span class="mr-2">레지스터 피연산자</span><a href="#레지스터-피연산자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용자 지정 명령어 클래스는 레지스터 피연산자를 사용할 수 있습니다. 각 클래스에 따라 레지스터 피연산자의 수와 유형이 다릅니다.</p><h3 id="클래스-1-1"><span class="mr-2">클래스 1</span><a href="#클래스-1-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>출력 대상 레지스터와 입력 즉시값.<li>변형: 비누산기, 누산기.</ul><h3 id="클래스-2-1"><span class="mr-2">클래스 2</span><a href="#클래스-2-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>출력 대상 레지스터, 소스 레지스터, 입력 즉시값.<li>변형: 비누산기, 누산기.</ul><h2 id="사용자-지정-명령어의-인코딩"><span class="mr-2">사용자 지정 명령어의 인코딩</span><a href="#사용자-지정-명령어의-인코딩" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용자 지정 명령어는 보조 프로세서 명령어와 동일한 인코딩 공간을 사용합니다. 특정 명령어를 Arm 사용자 지정 명령어로 전달하려면 자체 서명된 특정 코어 프로세서로 연결해야 합니다.</p><h2 id="누산기-변형"><span class="mr-2">누산기 변형</span><a href="#누산기-변형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>각 클래스에는 몇 가지 변형이 있습니다. 결과만 계산하고 출력 레지스터를 사용하는 변형이 있으며, 등록된 값도 소비하는 누산기 변형도 있습니다.</p><hr /><h1 id="armv8-m-메모리-모델">Armv8-M 메모리 모델</h1><hr /><h2 id="개요-1"><span class="mr-2">개요</span><a href="#개요-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M 메인라인 아키텍처의 메모리 모델에 대해 알아보겠습니다. 이는 Armv8-M 주소 공간의 여러 파티션을 나열하고 메모리 유형을 구분하며, 주소 공간의 특정 파티션에 사용되는 이유를 설명합니다.</p><h2 id="주소-공간"><span class="mr-2">주소 공간</span><a href="#주소-공간" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M은 최대 4GB의 물리적 주소 공간을 포함하는 메모리 매핑 아키텍처입니다. 주소 공간은 물리적 메모리와 프로세서 제어 및 상태 레지스터 모두를 위한 공유 주소 공간입니다.</p><h2 id="메모리-영역"><span class="mr-2">메모리 영역</span><a href="#메모리-영역" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>메모리는 8개의 512MB 세그먼트 또는 파티션으로 분할됩니다. 각 영역은 특정 용도로 사용됩니다.</p><ol><li><strong>코드 섹션</strong>: 명령어 저장.<li><strong>SRAM</strong>: 고속 SRAM 메모리.<li><strong>주변 장치 영역</strong>: 주변 장치 메모리.<li><strong>시스템 영역</strong>: 프로세서 제어 및 상태 레지스터.</ol><h2 id="메모리-속성"><span class="mr-2">메모리 속성</span><a href="#메모리-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>각 메모리 영역은 다양한 메모리 속성을 가질 수 있습니다. 속성은 다음과 같습니다.</p><ol><li><strong>액세스 권한</strong><li><strong>실행 권한</strong><li><strong>공유 가능성</strong><li><strong>캐시 가능성</strong></ol><h2 id="메모리-유형"><span class="mr-2">메모리 유형</span><a href="#메모리-유형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>메모리 영역에는 일반 메모리 또는 장치 메모리가 포함될 수 있습니다. 일반 메모리는 최상의 성능을 제공하며, 장치 메모리는 액세스에 부작용이 발생할 수 있는 영역에 사용됩니다.</p><hr /><h1 id="arm-컴파일러">Arm 컴파일러</h1><hr /><h2 id="개요-2"><span class="mr-2">개요</span><a href="#개요-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴보겠습니다. 주요 컴파일러로는 Arm Compiler 6과 Arm Compiler 5가 있습니다.</p><h2 id="arm-compiler-6"><span class="mr-2">Arm Compiler 6</span><a href="#arm-compiler-6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>최신 Arm 아키텍처 기능 및 확장을 지원.<li>베어메탈 소프트웨어 개발에 중점을 둠.<li>오픈소스 LLVM Clang을 기반으로 구축.</ul><h2 id="arm-compiler-5"><span class="mr-2">Arm Compiler 5</span><a href="#arm-compiler-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>레거시 툴 체인으로 Armv4에서 Armv7까지 지원.<li>유지 관리만 이루어지며 수명이 거의 끝남.</ul><h2 id="기능-안전"><span class="mr-2">기능 안전</span><a href="#기능-안전" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>일부 임베디드 시스템의 경우 기능 안전 요구 사항이 있습니다. Arm은 기능 안전 요구 사항을 충족하기 위해 장기 유지 관리 릴리스(LTM)를 제공합니다.</p><h2 id="컴파일러-사용"><span class="mr-2">컴파일러 사용</span><a href="#컴파일러-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm Compiler는 Arm DS 또는 Keil-MDK와 함께 제공되며, 웹 사이트에서 독립 실행형 버전으로 다운로드할 수 있습니다.</p><hr /><h1 id="aapcs-arm-procedure-call-standard">AAPCS (Arm Procedure Call Standard)</h1><hr /><h2 id="개요-3"><span class="mr-2">개요</span><a href="#개요-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm 아키텍처를 위한 프로시저 호출 표준(AAPCS)은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다.</p><h2 id="레지스터-사용-1"><span class="mr-2">레지스터 사용</span><a href="#레지스터-사용-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>r0-r3</strong>: 함수에 인수를 전달.<li><strong>r4-r11</strong>: 레지스터 변수로 사용되며 보존해야 함.<li><strong>r12</strong>: 임시 레지스터.<li><strong>r13 (SP)</strong>: 스택 포인터.<li><strong>r14 (LR)</strong>: 링크 레지스터.<li><strong>r15 (PC)</strong>: 프로그램 카운터.</ul><h2 id="스택-정렬"><span class="mr-2">스택 정렬</span><a href="#스택-정렬" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>AAPCS에 따르면, 스택은 외부 가시 경계에서 8바이트로 정렬되어야 합니다. 이는 함수 호출 시 스택이 8바이트로 정렬되어야 함을 의미합니다.</p><h2 id="함수-호출-예제-1"><span class="mr-2">함수 호출 예제</span><a href="#함수-호출-예제-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>호출자 함수가 레지스터 값을 수정하지 않을 것으로 예상되면 호출자는 함수를 호출하기 전에 레지스터를 저장하고, 함수가 반환된 후 원래 값을 복원해야 합니다.</p><hr /><h2 id="요약"><span class="mr-2">요약</span><a href="#요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Arm Custom Instructions</strong>: 사용자 지정 명령어를 통해 프로세서 기능을 확장할 수 있습니다.<li><strong>Armv8-M 메모리 모델</strong>: 다양한 메모리 영역과 속성을 이해하여 최적의 성능을 제공합니다.<li><strong>Arm 컴파일러</strong>: 최신 아키텍처 기능을 지원하며, 기능 안전 요구 사항을 충족할 수 있습니다.<li><strong>AAPCS</strong>: 효율적인 함수 호출과 인수 전달을 위한 표준을 이해하면 더 나은 코드를 작성할 수 있습니다.</ul><h1 id="armv8-m-mainline-debug">Armv8-M Mainline Debug</h1><h2 id="학습-목표"><span class="mr-2">학습 목표</span><a href="#학습-목표" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈의 끝에서 다음을 할 수 있습니다:</p><ul><li>Debug, Trace 및 Profiling 요구 사항 및 기능 설정<li>Invasive Debug와 Non-invasive Debug의 구분<li>Armv8-M Mainline Debug 및 Trace 구성 요소 설명: FPB, DWT, ITM, MTB, ETM 및 TPIU<li>프로세서가 중단된 다양한 Debug 이벤트 감지<li>Semihosting 호출과 표준 Breakpoints의 차이점 구별<li>Profiling 기능 설명: DWT 및 Armv8.1-M Performance Monitoring Unit (PMU)</ul><h2 id="기본-debug-요구-사항"><span class="mr-2">기본 Debug 요구 사항</span><a href="#기본-debug-요구-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Run Control</strong><ul><li>코드 단일 단계 실행<li>명령어에 Breakpoints 설정<li>데이터 접근에 Watchpoints 설정</ul><li><strong>State Control</strong><ul><li>프로세서 상태 읽기 및 쓰기<li>시스템 메모리 접근<li>주변기기 접근</ul><li><strong>Execution History</strong><ul><li>실행 추적 정보</ul></ul><h2 id="armv8-m-mainline-debug-구성-요소"><span class="mr-2">Armv8-M Mainline Debug 구성 요소</span><a href="#armv8-m-mainline-debug-구성-요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>DAP</strong><li><strong>ETM</strong><li><strong>Trigger</strong><li><strong>TPIU</strong><li><strong>SW/JTAG</strong><li><strong>Debug Agent</strong><li><strong>FPB</strong><li><strong>DWT</strong><li><strong>ITM</strong><li><strong>MTB</strong><li><strong>ROM Table</strong><li><strong>PIL</strong><li><strong>CTI</strong><li><strong>Bus Matrix</strong><li><strong>MPU</strong><li><strong>SAU</strong><li><strong>IPPB</strong></ul><h2 id="invasive-debug-vs-non-invasive-debug"><span class="mr-2">Invasive Debug vs. Non-invasive Debug</span><a href="#invasive-debug-vs-non-invasive-debug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Invasive Debug</strong><ul><li>프로세서 제어: 코어 중단, 코드 단일 단계 실행, 코드 실행<li>프로세서 레지스터 검사 및 변경: Debug 상태에서<li>메모리와 메모리 매핑 레지스터 검사 및 변경: 프로세서 실행 중이나 중단 중</ul><li><strong>Non-invasive Debug</strong><ul><li>프로세서의 동작 관찰: 프로세서 중단 없이<li>프로그램 실행에 비침입적일 수 있음<li>Non-invasive Debug는 MTB, ITM, ETM 및 PMU를 통해 제공됨</ul></ul><h2 id="debug-상태---중단-debug"><span class="mr-2">Debug 상태 - 중단 Debug</span><a href="#debug-상태---중단-debug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Debug 상태가 프로세서에서 활성화되고 적격한 Debug 이벤트가 발생하면 프로세서는 Debug 상태로 들어갑니다. 이 상태에서는 프로세서가 멈추고, 명령어가 실행되지 않으며, 인터럽트가 서비스되지 않습니다. Debug 인터페이스를 통해 프로세서를 제어합니다.</p><h2 id="중단-debug를-위한-debug-이벤트"><span class="mr-2">중단 Debug를 위한 Debug 이벤트</span><a href="#중단-debug를-위한-debug-이벤트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>전통적인 시작/중단 Debug<li>PMU Sticky 플래그가 PMU 카운터가 오버플로우했음을 나타냄<li>EXTERNAL EDBGRQ 입력이 다른 SoC 구성 요소에서 어서트됨<li>VCATCH 벡터 캐치가 트리거됨<li>DWTTRAP이 Watchpoints와 일치하는 주소로 데이터 접근<li>BKPT 명령어가 실행되거나 FPB에서 Breakpoints가 일치<li>디버거로부터의 HALTED 중단 요청</ul><h2 id="셀프-호스팅-debug"><span class="mr-2">셀프 호스팅 Debug</span><a href="#셀프-호스팅-debug" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>프로세서를 구성하여 중단 대신 DebugMonitor 예외를 받도록 할 수 있습니다. 이는 실시간 요구사항이 있는 시스템 디버깅에 적합합니다. DebugMonitor는 PMU 오버플로우를 처리하는 데 사용될 수 있습니다.</p><h2 id="벡터-캐치"><span class="mr-2">벡터 캐치</span><a href="#벡터-캐치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>선택된 예외를 트랩하는 메커니즘<li>예외가 어서트되면 코어가 중단됨<li>디버거를 통해 선택<li>리셋, HardFault, UsageFault, BusFault, SecureFault와 같은 예외를 트랩할 수 있음</ul><h2 id="fpb---flash-patch-및-breakpoints-유닛"><span class="mr-2">FPB - Flash Patch 및 Breakpoints 유닛</span><a href="#fpb---flash-patch-및-breakpoints-유닛" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>FPB는 명령어 페치에 Breakpoints를 설정할 수 있도록 지원합니다. 소프트웨어 Breakpoints는 BKPT 명령어로 구현되며, 하드웨어 Breakpoints는 FPB 비교기를 통해 구현됩니다.</p><h2 id="breakpoints-vs-watchpoints"><span class="mr-2">Breakpoints vs. Watchpoints</span><a href="#breakpoints-vs-watchpoints" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Breakpoints</strong>: 명령어 디버깅에 사용<li><strong>Watchpoints</strong>: 데이터 접근 디버깅에 사용</ul><h2 id="dwt-watchpoints"><span class="mr-2">DWT Watchpoints</span><a href="#dwt-watchpoints" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DWT는 데이터 주소와 명령어 주소 비교기를 제공합니다. DWT는 데이터 값과 데이터 주소가 일치할 때 중단할 수 있습니다. DWT 레지스터는 디버거에 의해 사용될 수 있습니다.</p><h2 id="semihosting"><span class="mr-2">Semihosting</span><a href="#semihosting" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Semihosting은 라이브러리 코드가 Arm 타겟에서 실행되지만 저수준 I/O는 호스트에 의해 처리됩니다. BKPT 명령어가 호스트 접근을 시작합니다.</p><h2 id="trace-소개"><span class="mr-2">Trace: 소개</span><a href="#trace-소개" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Trace는 구성 요소가 어떻게 실행되고 성능을 발휘하는지 보여주는 데이터를 캡처하는 과정입니다. 주로 프로그램 Trace(명령어 Trace)나 응용 프로그램 Trace(도구 Trace)가 있습니다.</p><h2 id="mtb---micro-trace-buffer"><span class="mr-2">MTB - Micro Trace Buffer</span><a href="#mtb---micro-trace-buffer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>MTB는 간단한 실행 추적 기능을 제공하며, 실행 중의 분기를 온칩 RAM에 저장합니다.</p><h2 id="itm---instrumentation-trace-macrocell"><span class="mr-2">ITM - Instrumentation Trace Macrocell</span><a href="#itm---instrumentation-trace-macrocell" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>ITM은 소프트웨어와 하드웨어가 생성하는 Trace 패킷을 생성하고 출력합니다.</p><h2 id="dwt---trace-캡처"><span class="mr-2">DWT - Trace 캡처</span><a href="#dwt---trace-캡처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DWT는 주소 일치, 주기적 PC 샘플링, 데이터 값, 예외 입출 및 반환, 이벤트 카운터와 같은 이벤트에 대한 패킷을 생성합니다.</p><h2 id="etm---embedded-trace-macrocell"><span class="mr-2">ETM - Embedded Trace Macrocell</span><a href="#etm---embedded-trace-macrocell" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>ETM은 명령어 Trace만 지원하는 비침입 Debug 구성 요소입니다. ETM 하드웨어는 프로세서의 활동을 모니터링합니다.</p><h2 id="tpiu---trace-port-interface-unit"><span class="mr-2">TPIU - Trace Port Interface Unit</span><a href="#tpiu---trace-port-interface-unit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>TPIU는 ETM과 ITM에서 데이터를 형식화하고 직렬화합니다. TPIU는 비동기적으로 코어 클럭과 TRACECLKIN에서 파생된 TRACECLK로 데이터를 클럭킹합니다.</p><h2 id="trace-port와-대역폭"><span class="mr-2">Trace Port와 대역폭</span><a href="#trace-port와-대역폭" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>ETM은 거의 0에서 여러 바이트의 명령어까지 데이터 속도를 생성할 수 있습니다. TRACECLKIN이 코어 클럭 속도로 실행될 때 명령어 Trace에 대해 2-3개의 핀이 필요합니다.</p><h2 id="dwt---performance-profiling"><span class="mr-2">DWT - Performance Profiling</span><a href="#dwt---performance-profiling" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DWT는 주기(CYCCNT), 폴디드 명령어(FOLDCNT), 모든 로드 또는 저장 명령어를 실행하는 데 필요한 추가 주기(LSUCNT), 프로세서 수면 주기(SLEEPCNT), 다중 주기 명령어와 명령어 페치 지연을 실행하는 데 필요한 추가 주기(CPICNT), 예외 처리에 소비된 주기(EXCCNT)를 위한 카운터를 포함합니다.</p><h2 id="pmu---performance-monitoring-unit"><span class="mr-2">PMU - Performance Monitoring Unit</span><a href="#pmu---performance-monitoring-unit" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>PMU는 이벤트 통계 정보를 수집하고 성능 분석을 위해 시스템 Debug에 사용됩니다. 31개의 16비트 이벤트 카운터와 하나의 32비트 주기 카운터를 지원합니다. PMU 카운터와 DWT 프로파일링 카운터의 작동은 상호 배타적입니다.</p><h1 id="m-profile-부팅-및-초기화">M-profile 부팅 및 초기화</h1><p>© 2022 Arm</p><h2 id="학습-목표-1"><span class="mr-2">학습 목표</span><a href="#학습-목표-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈을 마치면 다음을 할 수 있습니다:</p><ul><li>시작 및 초기화 코드를 개발합니다.<li>메모리 설명 파일을 작성합니다.<li>C 라이브러리를 어떻게 활용할지 선택합니다.<li>기기에서 부팅할 수 있는 실행 파일 이미지를 생성합니다.</ul><h2 id="임베디드-개발-프로세스"><span class="mr-2">임베디드 개발 프로세스</span><a href="#임베디드-개발-프로세스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="개발-환경에서-독립-실행형-임베디드-애플리케이션으로-이동할-때-고려해야-할-사항"><span class="mr-2">개발 환경에서 독립 실행형 임베디드 애플리케이션으로 이동할 때 고려해야 할 사항:</span><a href="#개발-환경에서-독립-실행형-임베디드-애플리케이션으로-이동할-때-고려해야-할-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>애플리케이션 시작<li>타겟 메모리 맵<li>하드웨어 사용을 위한 C 라이브러리</ul><h2 id="목차"><span class="mr-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>기본 컴파일 도구 동작<li>시작 및 초기화 코드 작성<ul><li>CMSIS-Core를 사용한 초기 시작 및 시스템 초기화 코드<li>시작 후 초기화</ul><li>디바이스에 맞게 이미지 메모리 맵 조정<ul><li>메모리 설명 파일 작성 (스캐터 파일/링커 스크립트)<li>스택 및 힙 배치<li>추가 메모리 맵 고려 사항</ul><li>시스템에 맞게 C 라이브러리 동작 재설정<li>부팅 준비 이미지 빌드</ol><h2 id="기본-컴파일-도구-동작"><span class="mr-2">기본 컴파일 도구 동작</span><a href="#기본-컴파일-도구-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="arm-compiler의-기본-시작-및-초기화-시퀀스"><span class="mr-2">Arm Compiler의 기본 시작 및 초기화 시퀀스</span><a href="#arm-compiler의-기본-시작-및-초기화-시퀀스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><code class="language-plaintext highlighter-rouge">main()</code> 함수는 라이브러리 초기화 코드를 링크하도록 Arm Linker (armlink)에 지시합니다.<li><code class="language-plaintext highlighter-rouge">__main</code> 함수는 C 라이브러리의 진입점입니다.<ul><li><code class="language-plaintext highlighter-rouge">__main</code>은 <code class="language-plaintext highlighter-rouge">__scatterload</code>와 <code class="language-plaintext highlighter-rouge">__rt_entry</code>를 호출합니다.<li><code class="language-plaintext highlighter-rouge">__scatterload</code>는 실행 시간 영역을 초기화합니다.<li><code class="language-plaintext highlighter-rouge">__rt_entry</code>는 다양한 초기화 함수를 호출한 다음 사용자 레벨의 <code class="language-plaintext highlighter-rouge">main()</code>을 호출합니다.</ul></ul><h2 id="기본-메모리-맵---arm-compiler"><span class="mr-2">기본 메모리 맵 - Arm Compiler</span><a href="#기본-메모리-맵---arm-compiler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>기본적으로 Arm Compiler는 코드를 0x8000에서 로드하고 실행하도록 링크합니다.</p><ul><li>힙은 데이터 영역 바로 위에 배치됩니다.<li>스택 기본 위치는 링크 시 정의되고 리셋 시 프로세서에 의해 구성됩니다.</ul><h2 id="기본-c-라이브러리---arm-compiler"><span class="mr-2">기본 C 라이브러리 - Arm Compiler</span><a href="#기본-c-라이브러리---arm-compiler" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Arm Compiler는 여러 준비된 T32 (이전 Thumb) C 라이브러리를 제공하며, ‘세미호스팅’ 지원을 포함합니다.<li><code class="language-plaintext highlighter-rouge">c_w.l</code> - 리틀 엔디안 C 라이브러리<li><code class="language-plaintext highlighter-rouge">h_w.b</code> - 빅 엔디안 헬퍼 라이브러리<li><code class="language-plaintext highlighter-rouge">f_ws.l/.b</code> - 소프트웨어 부동 소수점 라이브러리</ul><h2 id="리셋-및-초기화"><span class="mr-2">리셋 및 초기화</span><a href="#리셋-및-초기화" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>실제 시스템에서는 애플리케이션의 진입점을 컴파일러 특정 라이브러리 함수(<code class="language-plaintext highlighter-rouge">__main</code> 또는 <code class="language-plaintext highlighter-rouge">_start</code>)로 설정하지 않으려 할 수 있습니다.</p><ul><li>M-profile 프로세서는 특권 모드로 시작합니다. 시스템 초기화는 특권 모드에서만 실행할 수 있습니다.<li><code class="language-plaintext highlighter-rouge">SystemInit</code> 함수는 <code class="language-plaintext highlighter-rouge">__main</code> 전에 호출되며, 벡터 테이블 오프셋 레지스터(VTOR), 부동 소수점 유닛(FPU), 마이크로컨트롤러 벡터 확장(MVE), 보안 속성 유닛(SAU)을 초기화합니다.</ul><h2 id="cmsis-core-시작-파일"><span class="mr-2">CMSIS-Core: 시작 파일</span><a href="#cmsis-core-시작-파일" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><code class="language-plaintext highlighter-rouge">startup_&lt;device&gt;.c</code> 또는 <code class="language-plaintext highlighter-rouge">startup_&lt;device&gt;.s</code> 파일은 다음을 포함합니다:<ul><li>벡터 테이블<ul><li>M-profile 예외 벡터<li>디바이스 특정 인터럽트 벡터<li>기본 루틴을 구현하는 약한 함수들</ul><li>리셋 핸들러<ul><li><code class="language-plaintext highlighter-rouge">SystemInit</code>을 호출한 후 <code class="language-plaintext highlighter-rouge">__PROGRAM_START()</code> 매크로를 호출합니다.</ul></ul></ul><h2 id="메모리-맵-설명-파일-작성"><span class="mr-2">메모리 맵 설명 파일 작성</span><a href="#메모리-맵-설명-파일-작성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CMSIS-Core는 Arm Compiler 스캐터 파일, GNU 링커 스크립트, IAR 링커 구성 파일 템플릿을 제공합니다.</p><ul><li>각각의 파일은 기본/필수 메모리 영역/세그먼트를 설명합니다.<ul><li>RO/XO 코드 및 데이터<li>RW 및 ZI 데이터<li>메인 스택</ul></ul><h2 id="런타임-메모리-관리"><span class="mr-2">런타임 메모리 관리</span><a href="#런타임-메모리-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>C 라이브러리 런타임 메모리 모델을 재설정해야 합니다.</p><ul><li>스택과 힙을 단일 메모리 영역(단일 영역 모델) 또는 별도의 영역(두 영역 모델)에 배치할지 결정해야 합니다.<li>기본적으로 단일 영역 모델이 사용됩니다.<li>두 영역 모델을 구현하려면 <code class="language-plaintext highlighter-rouge">__use_two_region_memory</code>를 가져와야 합니다.</ul><h2 id="메모리-맵-추가-고려-사항"><span class="mr-2">메모리 맵 추가 고려 사항</span><a href="#메모리-맵-추가-고려-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>M-profile 시스템에서 주변 장치는 메모리 매핑됩니다.</p><ul><li>CMSIS-Core 헤더는 장치의 주변 레지스터에 액세스하는 권장 방법입니다.</ul><h2 id="c-라이브러리-재설정"><span class="mr-2">C 라이브러리 재설정</span><a href="#c-라이브러리-재설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>C 라이브러리의 디바이스 드라이버 수준 기능을 타겟 하드웨어에 맞게 구현으로 교체할 수 있습니다.</p><ul><li>예: <code class="language-plaintext highlighter-rouge">printf()</code>는 디버거 콘솔이 아닌 LCD 화면으로 출력해야 합니다.<li>세미호스팅을 사용하는 C 라이브러리 함수를 시스템에 맞게 구현으로 교체합니다.</ul><h2 id="디버깅-rom-이미지"><span class="mr-2">디버깅 ROM 이미지</span><a href="#디버깅-rom-이미지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>링커는 디버깅에 적합한 ELF/DWARF 이미지를 생성합니다.<li>ELF 이미지를 바이너리 형식으로 변환하려면 <code class="language-plaintext highlighter-rouge">fromelf</code> 유틸리티를 사용합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">fromelf --bin -o &lt;output&gt; image.axf</code></ul><li>ELF 이미지에서 DWARF 디버그 정보를 로드하여 ROM 이미지를 디버깅할 수 있습니다.</ul><h1 id="cortex-m3-startup--exception-handling">Cortex-M3 Startup &amp; Exception Handling</h1><h2 id="tarmac-trace"><span class="mr-2">Tarmac Trace</span><a href="#tarmac-trace" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Arm 전용 추적 형식<li>Fast Models / FVPs (Fixed Virtual Platforms)에서 수집 가능<li>RTL (Register Transfer Level) 시뮬레이션에서 수집 가능<li>실행된 명령어, 전송된 레지스터 값, 메모리 접근 및 발생한 예외를 보여줌<li>Arm Fast Models 문서에 문서화됨: <a href="https://developer.arm.com/docs/100964/1161/plug-ins-for-fast-models/tarmactrace">Tarmac Trace Documentation</a></ul><h2 id="tarmac-trace-예제"><span class="mr-2">Tarmac Trace 예제</span><a href="#tarmac-trace-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>8004 clk IT (8004) 0000061c 6801 T thread : LDR      r1,[r0,#0]
8004 clk MR4 20000170 00000000
8004 clk R r1 00000000
</pre></table></code></div></div><h2 id="시작-예제"><span class="mr-2">시작 예제</span><a href="#시작-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>CMSIS 시작 코드 사용<li>C에서 인터럽트 핸들러 설정<li>CMSIS 함수를 사용하여 인터럽트를 활성화하고 트리거</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">Hello</span><span class="p">,</span> <span class="n">world</span><span class="o">!</span>
<span class="n">Enabled</span> <span class="n">device</span><span class="o">-</span><span class="n">specific</span> <span class="n">timer</span> <span class="mi">0</span>
<span class="n">Hello</span> <span class="n">from</span> <span class="n">TIM0_IRQHandler</span><span class="p">()</span><span class="o">!</span>
</pre></table></code></div></div><h2 id="리셋-단계"><span class="mr-2">리셋 단계</span><a href="#리셋-단계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="리셋-핸들러"><span class="mr-2">리셋 핸들러</span><a href="#리셋-핸들러" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><pre><code class="language-assembly">Reset_Handler   PROC
EXPORT  Reset_Handler             [WEAK]
IMPORT  SystemInit
IMPORT  __main
LDR     R0, =SystemInit
BLX     R0
LDR     R0, =__main
BX      R0
ENDP
</code></pre><h3 id="리셋-과정"><span class="mr-2">리셋 과정</span><a href="#리셋-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>리셋 예외 발생<li>스택 포인터 값 설정<li>프로세서가 T32 상태에 있음을 나타내는 CPSR 값 설정<li>리셋 핸들러의 첫 번째 명령어 실행 시작</ol><h3 id="벡터-테이블"><span class="mr-2">벡터 테이블</span><a href="#벡터-테이블" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>리셋 핸들러 주소는 벡터 테이블에 지정됨</p><pre><code class="language-assembly">__Vectors       DCD     __initial_sp              ; Top of Stack
DCD     Reset_Handler             ; Reset Handler
</code></pre><h2 id="__main-함수"><span class="mr-2">__main() 함수</span><a href="#__main-함수" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>스캐터 로딩<li>C 라이브러리 초기화<li>애플리케이션 코드 실행 시작</ul><h2 id="main-함수의-애플리케이션-코드"><span class="mr-2">main() 함수의 애플리케이션 코드</span><a href="#main-함수의-애플리케이션-코드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, world!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="cm">/* Initialize TIM0_IRQn */</span>
    <span class="n">NVIC_SetPriority</span><span class="p">(</span><span class="n">TIM0_IRQn</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">NVIC_EnableIRQ</span><span class="p">(</span><span class="n">TIM0_IRQn</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Enabled device-specific timer 0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="cm">/* Set TIM0_IRQn to pending */</span>
    <span class="n">NVIC_SetPendingIRQ</span><span class="p">(</span><span class="n">TIM0_IRQn</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="예외-처리"><span class="mr-2">예외 처리</span><a href="#예외-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="소프트웨어에서-예외-트리거"><span class="mr-2">소프트웨어에서 예외 트리거</span><a href="#소프트웨어에서-예외-트리거" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="cm">/* Set “pending” bit for the interrupt to 1. */</span>
<span class="cm">/* Processor takes exception and branches to exception handler. */</span>
<span class="n">NVIC_SetPendingIRQ</span><span class="p">(</span><span class="n">TIM0_IRQn</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="예외-처리-과정"><span class="mr-2">예외 처리 과정</span><a href="#예외-처리-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>프로세서는 필요한 레지스터를 스택에 자동으로 저장</ul><pre><code class="language-assembly">5484 clk E 00000cd0 00000012 CoreEvent_EXT_INT2
5485 clk IT (5485) 00000c7c a001 T handler : ADR      r0,{pc}+8 ; 0xc84
</code></pre><h2 id="요약-1"><span class="mr-2">요약</span><a href="#요약-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="핸들러-모드"><span class="mr-2">핸들러 모드</span><a href="#핸들러-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>벡터 테이블 사용<li>예외 처리 과정에서 스택 업데이트<li>핸들러로 분기<li>스택 레지스터 업데이트<li>핸들러에서 복귀</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/embedded-engineering/'>Embedded Engineering</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/embedded-engineering/" class="post-tag no-text-decoration" >Embedded Engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=ARM+%EA%B0%95%EC%9D%98%28Cortex-M+Software+Development+Fundamentals%29+-+DK%27s+Software+Engineering+Knowledge+Storage&url=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Cortex-M-Software-Development-Fundamentals%29%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=ARM+%EA%B0%95%EC%9D%98%28Cortex-M+Software+Development+Fundamentals%29+-+DK%27s+Software+Engineering+Knowledge+Storage&u=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Cortex-M-Software-Development-Fundamentals%29%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Cortex-M-Software-Development-Fundamentals%29%2F&text=ARM+%EA%B0%95%EC%9D%98%28Cortex-M+Software+Development+Fundamentals%29+-+DK%27s+Software+Engineering+Knowledge+Storage" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/STL_MAP/">STL_Map</a><li><a href="/posts/STL_Priority_Queue/">STL_Priority_Queue</a><li><a href="/posts/STL_Vector/">STL_Vector</a><li><a href="/posts/STL_String/">STL_String</a><li><a href="/posts/STL_Queue/">STL_Queue</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/bfs/">BFS</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/embedded-engineering/">Embedded Engineering</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/container/">Container</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EC%97%90%EC%96%B4%EC%BB%A8-%EC%9E%90%EB%8F%99-%EC%A0%9C%EC%96%B4/"><div class="card-body"> <em class="small" data-ts="1747494000" data-df="YYYY-MM-DD" > 2025-05-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>아두이노 에어컨 자동 제어</h3><div class="text-muted small"><p> [아두이노] 에어컨 자동 제어 아두이노를 활용하여 에어컨의 리모컨 신호를 복사하고, 원하는 시간에 자동으로 송신하여 에어컨을 제어하는 프로젝트를 진행할 수 있다. 이를 위해 필요한 부품, 회로 연결 방법, 아두이노 코드 예제, 그리고 시간 기반 제어 방법을 자세히 설명한다. 1. 필요한 부품 아두이노 보드 (Arduino Uno, ATmeg...</p></div></div></a></div><div class="card"> <a href="/posts/Embedded_OS-%EA%B0%9C%EB%B0%9C/"><div class="card-body"> <em class="small" data-ts="1663513200" data-df="YYYY-MM-DD" > 2022-09-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Embedded OS 개발</h3><div class="text-muted small"><p> Embedded OS 개발 프로젝트 1장. 임베디드 운영체제 임베디드 운영체제와 펌웨어 임베디드 운영체제는 임베디드 시스템에서 동작하는 펌웨어의 일종으로서 하드웨어 성능이 일정 수준으로 올라온 현재 임베디드 장치에도 임베디드 운영체제를 많이 사용하고 있다. 펌웨어란 임베디드 운영체제 유무에 상관없이 임베디드 시스템 용 전체 소프트웨어를 지칭한다...</p></div></div></a></div><div class="card"> <a href="/posts/FreeRTOS-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"><div class="card-body"> <em class="small" data-ts="1671462000" data-df="YYYY-MM-DD" > 2022-12-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>FreeRTOS 내용정리</h3><div class="text-muted small"><p> FreeRTOS 내용정리 Task 태스크는 가상의 CPU를 각자 가지고 있는 것처럼 동작한다.(Time Division) 태스크 간에는 커널 서비스인 Inter Process Communication 방법을 사용하여 통신한다. Round Robin 스케쥴링 모든 태스크들이 CPU 자원을 공평하게 나누어 사용하는 개념 각 태스크...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ARM-%EA%B0%95%EC%9D%98(Armv8-M-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD)/" class="btn btn-outline-primary" prompt="이전 글"><p>ARM 강의</p></a> <a href="/posts/OSEK-%EC%9E%90%EB%A3%8C%EC%A0%95%EB%A6%AC/" class="btn btn-outline-primary" prompt="다음 글"><p>OSEK</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">DK</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/bfs/">BFS</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/embedded-engineering/">Embedded Engineering</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/container/">Container</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
