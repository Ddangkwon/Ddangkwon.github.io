<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="ARM 강의" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="ARM 아키텍처의 발전" /><meta property="og:description" content="ARM 아키텍처의 발전" /><link rel="canonical" href="/posts/ARM-%EA%B0%95%EC%9D%98(Armv8-M-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD)/" /><meta property="og:url" content="/posts/ARM-%EA%B0%95%EC%9D%98(Armv8-M-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD)/" /><meta property="og:site_name" content="DK’s Software Engineering Knowledge Storage" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-06-03T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ARM 강의" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="k9n3TqutGkNvqf7uv9HP04BF1yRBxsowePxu32o6gBk" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-28T12:49:37+09:00","datePublished":"2024-06-03T00:00:00+09:00","description":"ARM 아키텍처의 발전","headline":"ARM 강의","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/ARM-%EA%B0%95%EC%9D%98(Armv8-M-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD)/"},"url":"/posts/ARM-%EA%B0%95%EC%9D%98(Armv8-M-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD)/"}</script><title>ARM 강의 | DK's Software Engineering Knowledge Storage</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="DK's Software Engineering Knowledge Storage"><meta name="application-name" content="DK's Software Engineering Knowledge Storage"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/green_galaxy.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">DK's Software Engineering Knowledge Storage</a></div><div class="site-subtitle font-italic">Software Engineering Knowledge Repo.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>ARM 강의</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>ARM 강의</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1717340400" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2024-06-03 </em> </span> <span> 업데이트 <em class="" data-ts="1722138577" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2024-07-28 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">DK</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="14203 단어"> <em>78 분</em>읽는 시간</span></div></div></div><div class="post-content"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9717042333563257" crossorigin="anonymous"></script><h1 id="arm-아키텍처의-발전">ARM 아키텍처의 발전</h1><h2 id="개요"><span class="mr-2">개요</span><a href="#개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>ARM 아키텍처는 수년에 걸쳐 개발 및 발전해 왔으며, 모든 ARM 프로세서의 기반입니다. 이 요약에서는 아키텍처 버전 V4T부터 V8 및 V9까지의 주요 내용을 다룹니다.</p><h2 id="주요-내용"><span class="mr-2">주요 내용</span><a href="#주요-내용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="초기-버전-v1-v2-v3"><span class="mr-2">초기 버전 (V1, V2, V3)</span><a href="#초기-버전-v1-v2-v3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>초기 버전</strong>: 아키텍처 버전 1, 2, 3이 있었으나, Thumb 명령어 세트가 도입되면서 ARM이 대중화되었습니다.</ul><h3 id="아키텍처-버전-4t"><span class="mr-2">아키텍처 버전 4T</span><a href="#아키텍처-버전-4t" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Thumb 명령어 세트 도입</strong>: 16비트 명령어 세트가 도입되어 ARM7TDMI와 같은 인기 프로세서가 개발되었습니다. 그 전에는 32비트 명령어만 사용할 수 있었습니다.</ul><h3 id="아키텍처-버전-5"><span class="mr-2">아키텍처 버전 5</span><a href="#아키텍처-버전-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>향상된 수학 명령어</strong>: Count Leading Zeros (CLZ)와 같은 향상된 수학 명령어가 추가되었습니다.<li><strong>DSP 명령어</strong>: DSP 연산을 효율적으로 수행할 수 있는 명령어가 추가되었습니다.</ul><h3 id="아키텍처-버전-6"><span class="mr-2">아키텍처 버전 6</span><a href="#아키텍처-버전-6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Thumb-2</strong>: 16비트와 32비트 명령어를 혼합하여 사용할 수 있는 Thumb-2 명령어가 도입되었습니다.<li><strong>TrustZone</strong>: 보안 확장 기능인 TrustZone이 도입되었습니다.<li><strong>멀티코어 지원</strong>: 추가 커널 및 멀티코어 지원이 포함되었습니다.</ul><h3 id="아키텍처-버전-7"><span class="mr-2">아키텍처 버전 7</span><a href="#아키텍처-버전-7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>가상화</strong>: 일부 A-profile 시스템에서 가상화 기능이 도입되었습니다.<li><strong>NEON SIMD 명령어 세트</strong>: 매우 강력한 NEON SIMD 명령어 세트가 도입되었습니다.</ul><h3 id="아키텍처-버전-8"><span class="mr-2">아키텍처 버전 8</span><a href="#아키텍처-버전-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>64비트 레지스터</strong>: 64비트 레지스터와 새로운 예외 모델 및 메모리 모델이 도입되었습니다.<li><strong>호환성 모드</strong>: 이전 아키텍처 코드와의 호환성을 유지하며, 새로운 프로세서에서도 실행이 가능했습니다.</ul><h3 id="아키텍처-버전-9"><span class="mr-2">아키텍처 버전 9</span><a href="#아키텍처-버전-9" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>통합 및 정리</strong>: V8의 다양한 포인트 버전을 통합 및 정리한 버전입니다.<li><strong>최신 버전</strong>: V8-M 프로파일과 비교할 때 TrustZone을 지원하는 것이 주요 특징입니다.</ul><h2 id="cortex-m-프로세서"><span class="mr-2">Cortex-M 프로세서</span><a href="#cortex-m-프로세서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>예외 처리 메커니즘</strong>: Cortex-M 프로세서는 매우 우수한 예외 처리 메커니즘을 갖추고 있습니다.<li><strong>파이프라인 길이</strong>: 프로세서 파이프라인의 길이는 아키텍처에서 지정하지 않으며, 예로 Cortex-M3와 Cortex-M7을 들 수 있습니다.</ul><p>이 요약을 통해 ARM 아키텍처의 발전 과정을 이해하고, 각 버전에서 도입된 주요 기능을 알 수 있습니다.</p><h3 id="cortex-m-프로세서-개요"><span class="mr-2">Cortex-M 프로세서 개요</span><a href="#cortex-m-프로세서-개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Cortex-M 제품군</strong>: Arm의 다양한 프로세서 중 한 부분으로, Linux 및 Windows와 같은 운영 체제를 지원하는 애플리케이션 프로파일, 고성능 임베디드 제어 애플리케이션을 목표로 하는 실시간 프로파일, 그리고 저전력, 비용 민감한 장치를 위한 마이크로컨트롤러 프로파일로 나뉩니다.<li><strong>고성능 기능</strong>: 일부 Cortex-M 프로세서는 물리적 변조 방지 기능과 사이드 채널 완화 기능을 추가하여 보안에 민감한 애플리케이션에 적합합니다.</ul><h3 id="주요-cortex-m-프로세서"><span class="mr-2">주요 Cortex-M 프로세서</span><a href="#주요-cortex-m-프로세서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Cortex-M0과 Cortex-M0+</strong>: 가장 작은 최저 전력 대역에 속하며, Armv6-M 명령어 세트를 구현합니다. 단일 사이클 저지연 I/O 포트를 제공합니다.<li><strong>Cortex-M23</strong>: Cortex-M0+에서 개발된 것으로, Armv8-M 명령어 세트를 기반으로 합니다. TrustZone 보안 기능이 추가되었습니다.<li><strong>Cortex-M3 및 Cortex-M4</strong>: Armv7-M 명령어 세트를 기반으로 하며, 다양한 32비트 연산 코드를 지원합니다. Cortex-M4는 DSP 명령어 세트와 단정밀도 부동 소수점 연산을 추가로 지원합니다.<li><strong>Cortex-M33 및 Cortex-M35P</strong>: Armv8-M 명령어 세트를 기반으로 하며, 변조 방지 기능을 포함합니다.<li><strong>Cortex-M7</strong>: Cortex-M 제품군 중 가장 고성능으로, 6단계 파이프라인과 이중 이슈 처리 기능을 갖추고 있습니다. 단정밀도 및 배정밀도 부동 소수점 연산을 지원합니다.</ul><h3 id="보안-기능"><span class="mr-2">보안 기능</span><a href="#보안-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>TrustZone</strong>: Cortex-M35P와 같은 일부 프로세서는 Armv8-M TrustZone 보안 기능을 제공합니다.<li><strong>변조 방지</strong>: 보안에 민감한 애플리케이션을 위한 물리적 변조 방지 기능을 포함합니다.</ul><h3 id="디버깅-및-개발-지원"><span class="mr-2">디버깅 및 개발 지원</span><a href="#디버깅-및-개발-지원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>디버그 인터페이스</strong>: 각 Cortex-M 프로세서에는 독립형 프로세서 시스템으로 디버깅할 수 있도록 디버그 액세스 포트(DAP)가 제공됩니다.<li><strong>CoreSight 지원</strong>: 칩 레벨에서 스트리밍 트레이스 출력 또는 전용 트레이스 핀을 제공하여, 프로세서 활동을 외부 디버그 도구에 지속적으로 보고할 수 있습니다.</ul><h3 id="최신-버전"><span class="mr-2">최신 버전</span><a href="#최신-버전" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Armv8-M</strong>: 최신 M 프로파일 아키텍처 버전으로, 보안 확장과 M 프로파일 벡터 확장(MVE)을 포함합니다.</ul><p>이 요약은 Cortex-M 프로세서의 다양한 기능과 각 모델의 특징을 이해하는 데 도움이 됩니다.</p><h1 id="armv8-m-프로세서-및-마이크로컨트롤러-프로파일-개요">Armv8-M 프로세서 및 마이크로컨트롤러 프로파일 개요</h1><h2 id="개요-1"><span class="mr-2">개요</span><a href="#개요-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M 프로세서는 마이크로컨트롤러 시장을 지원하도록 설계되었습니다. 실제로 Armv8-M의 M은 마이크로컨트롤러의 약자입니다. 이 문서에서는 Armv8-M 프로세서의 주요 특징과 다른 두 가지 주요 아키텍처 프로필인 A 프로파일과 R 프로파일을 간단히 살펴봅니다.</p><h2 id="주요-내용-1"><span class="mr-2">주요 내용</span><a href="#주요-내용-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="arm-프로파일"><span class="mr-2">Arm 프로파일</span><a href="#arm-프로파일" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>A 프로파일</strong>: A는 Applications를 의미합니다. 메모리 용량이 크고 주파수가 높은 복잡한 시스템에 적합합니다. 이러한 시스템에는 Linux나 Android 등과 같은 운영 체제가 포함될 수 있습니다.<li><strong>R 프로파일</strong>: R은 실시간(Real-time)을 의미합니다. 실시간 시스템 전용으로, 자동차 시스템 등에서 사용됩니다.<li><strong>M 프로파일</strong>: M은 마이크로컨트롤러를 의미합니다. IoT 시스템에서 베어메탈 시스템에 이르기까지 다양한 임베디드 시스템에 사용됩니다. 실시간 요구 사항이 있는 시스템에도 적합합니다.</ul><h3 id="m-프로파일의-특징"><span class="mr-2">M-프로파일의 특징</span><a href="#m-프로파일의-특징" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>단순화된 아키텍처</strong>: 대부분의 명령어가 단일 사이클로 실행되며, RISC 아키텍처를 기반으로 합니다. RISC는 축소된 명령어 세트 컴퓨터(Reduced Instruction Set Computer)의 약자입니다.<li><strong>전력 효율성</strong>: 전력 소비가 적어 배터리 수명이 중요한 마이크로컨트롤러 시스템에 적합합니다.<li><strong>프로그래밍 용이성</strong>: C 또는 C++로 프로그래밍할 수 있으며, 특정 루틴에 대해 어셈블리 언어를 사용할 수도 있습니다.<li><strong>단순한 메모리 보호 모델</strong>: 가상 주소를 물리적 주소로 변환할 수 있는 메모리 관리 장치(MMU)가 포함된 애플리케이션 프로세서와 달리, 더 간단한 메모리 보호 모델을 사용합니다.</ul><h3 id="실행-모드"><span class="mr-2">실행 모드</span><a href="#실행-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>스레드 모드</strong>: 재설정 후 사용되며, 운영 체제에서 생성되는 프로세스와 스레드에 사용됩니다.<li><strong>핸들러 모드</strong>: 예외를 처리하는 데 사용됩니다.</ul><h3 id="예외-처리"><span class="mr-2">예외 처리</span><a href="#예외-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>벡터 테이블</strong>: 명령어가 아닌 주소로 구성됩니다. 이는 더 유연한 접근 방식을 제공합니다.<li><strong>컨텍스트 저장</strong>: 예외 발생 시 자동으로 컨텍스트를 저장하여 안전하게 반환할 수 있습니다.</ul><h3 id="데이터-유형"><span class="mr-2">데이터 유형</span><a href="#데이터-유형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>로드 및 저장 아키텍처</strong>: 32비트 로드 및 저장 아키텍처로, 메모리 액세스는 로드 및 저장 명령을 통해 이루어집니다.<li><strong>지원되는 데이터 유형</strong>: 바이트(8비트), 하프 워드(16비트), 워드(32비트), 더블 워드(64비트)를 지원합니다.</ul><p>이 문서는 Armv8-M 프로세서의 다양한 기능과 각 프로파일의 특징을 이해하는 데 도움이 됩니다.</p><h1 id="armv8-m-코어-레지스터-소개">ARMv8-M 코어 레지스터 소개</h1><h2 id="r0-r7-레지스터"><span class="mr-2">R0-R7 레지스터</span><a href="#r0-r7-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>대부분의 명령에서 접근 가능<li>데이터 처리 및 메모리 액세스 명령에 사용</ul><h2 id="r8-r12-레지스터-하이-레지스터"><span class="mr-2">R8-R12 레지스터 (하이 레지스터)</span><a href="#r8-r12-레지스터-하이-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>32비트 명령어에 주로 사용<li>일부 16비트 명령어에도 사용 가능</ul><h2 id="스택-포인터와-링크-레지스터-프로그램-카운터"><span class="mr-2">스택 포인터와 링크 레지스터, 프로그램 카운터</span><a href="#스택-포인터와-링크-레지스터-프로그램-카운터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>R13 (스택 포인터): 스택에 접근하는 데 사용<ul><li>메인 스택 포인터와 프로세스 스택 포인터의 두 가지 버전 존재</ul><li>R14 (링크 레지스터): 함수 호출에서 리턴 주소를 저장<ul><li>서브루틴 호출 시 사용</ul><li>프로그램 카운터: 명령어를 단계별로 실행</ul><h2 id="xpsr-프로그램-상태-레지스터"><span class="mr-2">XPSR (프로그램 상태 레지스터)</span><a href="#xpsr-프로그램-상태-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>응용 프로그램 상태 레지스터, 실행 프로그램 상태 레지스터, 인터럽트 프로그램 상태 레지스터로 구성<li>제어 레지스터에는 다양한 특수 비트 존재</ul><h2 id="armv81-추가-기능"><span class="mr-2">Armv8.1 추가 기능</span><a href="#armv81-추가-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>포인터 인증 브랜치 (PACBTI)와 같은 확장 기능 추가<li>여러 활성화 및 비활성화 비트가 컨트롤 레지스터에 포함됨</ul><h2 id="스택-포인터-사용-예제"><span class="mr-2">스택 포인터 사용 예제</span><a href="#스택-포인터-사용-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>풀 디센딩 스택 모델: 스택은 메모리에서 아래로 확장되고 스택 포인터는 마지막 위치를 가리킴<li>푸시 및 팝 연산을 통해 스택 포인터가 메모리의 위치를 가리킴</ul><h2 id="링크-레지스터-사용-예제"><span class="mr-2">링크 레지스터 사용 예제</span><a href="#링크-레지스터-사용-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>함수 호출 시 링크 레지스터를 사용하여 리턴 주소를 저장<li>BL 명령어를 사용하여 함수로 분기<li>BX 명령어를 사용하여 링크 레지스터의 값으로 분기</ul><h2 id="프로그램-카운터"><span class="mr-2">프로그램 카운터</span><a href="#프로그램-카운터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>명령어를 단계별로 실행하며 분기 명령어에서 암시적으로 사용됨<li>C 언어에서 함수 호출 시 적절한 점프 명령어를 생성</ul><h2 id="프로그램-상태-레지스터-xpsr"><span class="mr-2">프로그램 상태 레지스터 (XPSR)</span><a href="#프로그램-상태-레지스터-xpsr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>ALU 플래그: N (음수), Z (0), C (캐리), V (오버플로우)<li>인터럽트 프로그램 상태 레지스터: 현재 활성화된 인터럽트 또는 예외 번호 표시<li>실행 프로그램 상태 레지스터: T 비트 및 IT 필드 포함</ul><h2 id="제어-레지스터"><span class="mr-2">제어 레지스터</span><a href="#제어-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>최대 8비트까지 확장 가능<li>NPriv 필드와 SPSEL 필드: 스레드 모드에서 실행 권한 및 스택 포인터 선택<li>부동 소수점 컨텍스트 활성 필드 (FPCA)<li>부동 소수점 확장 및 보안 확장과 관련된 비트</ul><h2 id="스택-제한-레지스터"><span class="mr-2">스택 제한 레지스터</span><a href="#스택-제한-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>메인 스택 및 프로세스 스택에 대한 제한 설정 가능<li>스택 제한 값을 초과할 경우 UsageFault 발생<li>보안 확장을 사용할 경우 추가 레지스터 존재</ul><h2 id="예외-처리-관련-레지스터"><span class="mr-2">예외 처리 관련 레지스터</span><a href="#예외-처리-관련-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>특수 용도의 레지스터: 인터럽트와 오류를 마스킹하는 방법 제공<li>BASEPRI 레지스터: 현재 스레드를 중단할 수 있는 인터럽트 결정</ul><p>이 문서는 ARMv8-M 코어 레지스터에 대한 개요를 제공하며, 각 레지스터의 기능과 사용 방법에 대해 설명합니다. ARM 아키텍처의 다양한 명령어와 예외 처리 메커니즘을 이해하는 데 도움이 됩니다.</p><h1 id="armv8-m-명령어-세트-소개">Armv8-M 명령어 세트 소개</h1><h2 id="개요-2"><span class="mr-2">개요</span><a href="#개요-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M 아키텍처는 다양한 명령어 세트를 제공합니다. 이 문서에서는 주요 명령어 세트와 그 특성에 대해 설명합니다. 자세한 내용은 나중에 어셈블리 언어를 다룰 때 더 깊이 다루겠습니다.</p><h2 id="명령어-세트-개요"><span class="mr-2">명령어 세트 개요</span><a href="#명령어-세트-개요" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>T32 명령어 세트</strong>: Thumb 명령어 세트로, Armv7-M 명령어 세트에서 파생되었습니다.<li><strong>16비트 및 32비트 명령어</strong>: 두 가지 명령어를 혼합하여 사용 가능. 16비트 명령어는 코드 밀도를 높이고 메모리 사용량을 줄이기 위해 도입되었습니다.</ul><h2 id="명령어-예시"><span class="mr-2">명령어 예시</span><a href="#명령어-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>ADD 명령어</strong>: 16비트 ADD와 32비트 ADD 명령어가 있으며, 컴파일러나 어셈블리 프로그램이 적절한 버전을 선택할 수 있습니다.<li><strong>LSLS 명령어</strong>: 논리적 전환 명령어로, 비트를 왼쪽으로 이동시키는 곱셈 연산도 포함됩니다.</ul><h2 id="새로운-명령어"><span class="mr-2">새로운 명령어</span><a href="#새로운-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>로드-획득 및 스토어-릴리즈 명령어</strong>: 동기화 및 세마포어 관리에 사용됩니다.<li><strong>보안 확장 명령어</strong>: 보안 격리를 돕기 위한 SG 명령어와 NS명령어 등이 있습니다.<li><strong>TT 명령어</strong>: 특정 주소의 메모리 속성을 테스트하는 명령어입니다.</ul><h2 id="다이어그램-요약"><span class="mr-2">다이어그램 요약</span><a href="#다이어그램-요약" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>기본 아키텍처 명령어</strong>: 모든 기본 명령어를 포함.<li><strong>DSP 확장 명령어</strong>: 7개의 추가 명령어 포함.<li><strong>부동 소수점 확장 명령어</strong>: 부동 소수점 연산을 위한 명령어 포함.</ul><h2 id="메모리-액세스-명령어"><span class="mr-2">메모리 액세스 명령어</span><a href="#메모리-액세스-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>STR 명령어</strong>: 레지스터의 값을 메모리 주소에 저장.<li><strong>LDR 명령어</strong>: 메모리 주소에서 레지스터로 데이터 로드.<li><strong>로드-획득 및 스토어-릴리즈 명령어</strong>: 암묵적 장벽 연산 포함.</ul><h2 id="프로그램-흐름-명령어"><span class="mr-2">프로그램 흐름 명령어</span><a href="#프로그램-흐름-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>브랜치 명령어</strong>: 레이블로 직접 이동하거나 서브루틴 호출에 사용.<li><strong>BX 명령어</strong>: 레지스터 값으로 브랜치.<li><strong>BLX 명령어</strong>: 서브루틴 호출에 사용.</ul><h2 id="결론"><span class="mr-2">결론</span><a href="#결론" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M 명령어 세트는 다양한 명령어를 통해 효율적이고 유연한 프로그래밍을 가능하게 합니다. 어셈블리 언어와 함께 사용하면 더 깊이 있는 프로그래밍이 가능합니다.</p><h1 id="프로그래밍-표준-및-cmsis-개요">프로그래밍 표준 및 CMSIS 개요</h1><h2 id="arm-아키텍처-프로시저-호출-표준-aapcs"><span class="mr-2">Arm 아키텍처 프로시저 호출 표준 (AAPCS)</span><a href="#arm-아키텍처-프로시저-호출-표준-aapcs" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="개요-3"><span class="mr-2">개요</span><a href="#개요-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>AAPCS는 Arm 아키텍처에서 함수 호출 시 레지스터와 메모리의 사용 규칙을 정의하는 표준입니다. 이는 컴파일러와 어셈블러 프로그래머가 서로 호환되는 객체와 이미지를 만들기 위해 준수해야 하는 중요한 문서입니다.</p><h3 id="주요-내용-2"><span class="mr-2">주요 내용</span><a href="#주요-내용-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>레지스터 사용</strong>: 함수 인수는 <code class="language-plaintext highlighter-rouge">r0</code>~<code class="language-plaintext highlighter-rouge">r3</code> 레지스터를 사용하며, 추가 인수는 스택에 저장됩니다.<li><strong>보존 레지스터</strong>: <code class="language-plaintext highlighter-rouge">r4</code>~<code class="language-plaintext highlighter-rouge">r11</code> 레지스터는 함수 내에서 보존해야 하며, 사용 전에 스택에 푸시되어야 합니다.<li><strong>8바이트 스택 정렬 규칙</strong>: 스택은 항상 8바이트로 정렬되어야 합니다.<li><strong>위치 독립적 데이터</strong>: <code class="language-plaintext highlighter-rouge">r9</code>는 위치 독립적 데이터의 기본 포인터로 사용될 수 있습니다.<li><strong>디버깅</strong>: <code class="language-plaintext highlighter-rouge">r11</code>은 디버깅용 프레임 포인터로 예약될 수 있습니다.</ul><h3 id="예제"><span class="mr-2">예제</span><a href="#예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>호출자 함수가 <code class="language-plaintext highlighter-rouge">foo</code> 함수를 호출할 때, 인수는 <code class="language-plaintext highlighter-rouge">r0</code>에서 <code class="language-plaintext highlighter-rouge">r3</code> 레지스터로 전달됩니다. 호출자 함수는 <code class="language-plaintext highlighter-rouge">r0</code>에서 <code class="language-plaintext highlighter-rouge">r3</code> 레지스터를 보존할 필요는 없으나, <code class="language-plaintext highlighter-rouge">r4</code>에서 <code class="language-plaintext highlighter-rouge">r11</code> 레지스터는 보존해야 합니다. <code class="language-plaintext highlighter-rouge">foo</code> 함수가 반환될 때, 결과는 <code class="language-plaintext highlighter-rouge">r0</code>에 저장됩니다.</p><h2 id="공통-마이크로컨트롤러-소프트웨어-인터페이스-cmsis"><span class="mr-2">공통 마이크로컨트롤러 소프트웨어 인터페이스 (CMSIS)</span><a href="#공통-마이크로컨트롤러-소프트웨어-인터페이스-cmsis" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="개요-4"><span class="mr-2">개요</span><a href="#개요-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CMSIS는 Cortex-M 마이크로컨트롤러의 표준 소프트웨어 인터페이스입니다. CMSIS는 다양한 구성 요소로 구성되어 있으며, 각 구성 요소는 특정 기능을 제공합니다.</p><h3 id="주요-구성-요소"><span class="mr-2">주요 구성 요소</span><a href="#주요-구성-요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>CMSIS-DSP</strong>: DSP 기능을 위한 무료 라이브러리.<li><strong>CMSIS-NN</strong>: 신경망 기능을 위한 라이브러리.<li><strong>CMSIS-DAP</strong>: 소형 마이크로컨트롤러를 디버깅하기 위한 펌웨어.<li><strong>CMSIS-RTOS</strong>: 운영 체제와 주변 장치 액세스를 위한 코드.<li><strong>CMSIS-Driver</strong>: 주변 장치 액세스를 위한 드라이버.<li><strong>CMSIS-Core</strong>: 프로세서의 주변 장치에 표준 방식으로 액세스하는 데 유용한 명령 내장 및 기능 제공.</ul><h3 id="cmsis-core-기능"><span class="mr-2">CMSIS-Core 기능</span><a href="#cmsis-core-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>명령어 내장 함수</strong>: C 프로그램에서 Arm 아키텍처의 특수 명령어를 사용하기 쉽게 함.<li><strong>시작 코드</strong>: 리셋 핸들러 코드, 스택 포인터 초기화 코드, 벡터 테이블 및 표준 인터럽트 핸들러 포함.<li><strong>SIMD 명령어</strong>: 단일 명령어로 여러 작업을 수행할 수 있는 명령어.<li><strong>NVIC 및 SyStick 타이머 구성</strong>: 중첩 벡터 인터럽트 컨트롤러와 시스템 타이머 구성.<li><strong>인터럽트 마스킹</strong>: 특정 인터럽트를 비활성화하는 기능 제공.</ul><h3 id="사용-예시"><span class="mr-2">사용 예시</span><a href="#사용-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CMSIS-Core를 사용하면 Cortex-M 프로세서 또는 M-profile 구현을 표준화된 방법으로 프로그래밍할 수 있습니다. 이는 Arm Compiler, GNU 도구, IAR 컴파일러 등 다양한 툴체인에서 작동하는 내장 함수를 제공합니다.</p><h3 id="유용한-리소스"><span class="mr-2">유용한 리소스</span><a href="#유용한-리소스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>developer.arm.com</strong>: CMSIS와 관련된 다양한 참조 자료와 블로그 제공.<li><strong>GitHub</strong>: CMSIS 소스 코드와 설명서 제공.<li><strong>Keil MDK</strong>: CMSIS 지원 및 패키지가 사전 설치된 제품.</ul><h3 id="결론-1"><span class="mr-2">결론</span><a href="#결론-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>CMSIS는 프로세서의 주변 장치에 표준화된 방식으로 액세스할 수 있도록 도와주며, 오픈 소스 프로젝트로서 개발자들이 기여할 수 있습니다. 이를 통해 Arm 마이크로컨트롤러 시스템의 개발을 용이하게 합니다.</p><h2 id="참고-자료"><span class="mr-2">참고 자료</span><a href="#참고-자료" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><a href="https://developer.arm.com">developer.arm.com</a><li><a href="https://github.com/ARM-software/CMSIS_5">GitHub - CMSIS</a><li><a href="https://developer.arm.com/documentation">Arm 아키텍처 참조 설명서</a></ul><h1 id="armv8-m-mainline-어셈블리-언어-프로그래밍">Armv8-M Mainline 어셈블리 언어 프로그래밍</h1><h2 id="개요-5"><span class="mr-2">개요</span><a href="#개요-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈에서는 Armv8-M Mainline 장치에서 어셈블리 언어 프로그래밍이 유용한 이유와 사용 가능한 어셈블리 언어 명령어 유형을 살펴봅니다. 데이터 처리 명령, 로드/스토어 명령, 흐름 제어 명령, 기타 유용한 명령어 및 Armv8.1-M 사용자 지정 데이터 경로 확장(CDE)에 포함된 명령어를 다룹니다.</p><h3 id="어셈블리-언어-프로그래밍의-필요성"><span class="mr-2">어셈블리 언어 프로그래밍의 필요성</span><a href="#어셈블리-언어-프로그래밍의-필요성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>시스템 레지스터 접근</strong>: C 언어로는 시스템 레지스터에 직접 접근할 수 없으므로 어셈블리 명령어를 사용해야 합니다.<li><strong>특정 명령 시퀀스 테스트</strong>: 매우 구체적인 명령 시퀀스의 동작을 테스트하거나, 컴파일러가 자동으로 수행할 수 없는 경우 직접 코드를 최적화할 때 유용합니다.<li><strong>디버깅</strong>: 컴파일러의 출력을 디버깅할 때 어셈블리 명령어를 이해하면 유용합니다.</ul><h3 id="t32-명령어-세트"><span class="mr-2">T32 명령어 세트</span><a href="#t32-명령어-세트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>이전 명칭</strong>: Thumb 명령어 세트<li><strong>명령어 길이</strong>: 16비트와 32비트 명령어가 혼합되어 있습니다.<li><strong>목적</strong>: 코드 크기를 최소화하고, 다양한 명령어 너비를 혼합하여 메모리 효율성을 높이는 데 도움.</ul><h3 id="어셈블리-명령어-구문"><span class="mr-2">어셈블리 명령어 구문</span><a href="#어셈블리-명령어-구문" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>명령어 형식</strong>:<ul><li><code class="language-plaintext highlighter-rouge">opcode</code>는 명령어 이름<li>한정어, 조건 코드, 레지스터 피연산자 등을 포함할 수 있음<li>대상 레지스터 <code class="language-plaintext highlighter-rouge">Rd</code>, 두 번째 레지스터 피연산자 <code class="language-plaintext highlighter-rouge">Rn</code>, 선택적 피연산자 <code class="language-plaintext highlighter-rouge">Rm</code></ul><li><strong>UAL 구문</strong>: 통합 어셈블러 언어 구문으로, 모든 Arm 아키텍처와 프로세서에 적용.</ul><h2 id="주요-어셈블리-명령어"><span class="mr-2">주요 어셈블리 명령어</span><a href="#주요-어셈블리-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="데이터-처리-명령어"><span class="mr-2">데이터 처리 명령어</span><a href="#데이터-처리-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>MOV</strong>: 데이터를 한 레지스터에서 다른 레지스터로 이동.<li><strong>ADD</strong>: 두 레지스터의 값을 더하여 결과를 레지스터에 저장.<li><strong>SUB</strong>: 한 레지스터의 값에서 다른 레지스터의 값을 빼서 결과를 레지스터에 저장.</ul><h3 id="로드스토어-명령어"><span class="mr-2">로드/스토어 명령어</span><a href="#로드스토어-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>LDR</strong>: 메모리에서 데이터를 레지스터로 로드.<li><strong>STR</strong>: 레지스터의 데이터를 메모리에 저장.</ul><h3 id="흐름-제어-명령어"><span class="mr-2">흐름 제어 명령어</span><a href="#흐름-제어-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>B</strong>: 조건 없이 분기.<li><strong>BL</strong>: 서브루틴 호출 및 링크 레지스터에 반환 주소 저장.<li><strong>BX</strong>: 레지스터의 값으로 분기.</ul><h3 id="기타-명령어"><span class="mr-2">기타 명령어</span><a href="#기타-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>NOP</strong>: 아무 작업도 하지 않음.<li><strong>WFI</strong>: 인터럽트 대기.</ul><h3 id="사용자-지정-명령어"><span class="mr-2">사용자 지정 명령어</span><a href="#사용자-지정-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>CDE 명령어</strong>: Armv8.1-M 사용자 지정 데이터 경로 확장에 포함된 명령어.</ul><h2 id="조건-코드-및-플래그"><span class="mr-2">조건 코드 및 플래그</span><a href="#조건-코드-및-플래그" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>APSR</strong>: 애플리케이션 프로그램 상태 레지스터, 조건 플래그 포함.<ul><li><strong>N</strong>: 네거티브 플래그<li><strong>Z</strong>: 제로 플래그<li><strong>C</strong>: 캐리 플래그<li><strong>V</strong>: 오버플로 플래그</ul></ul><h2 id="어셈블리-언어-프로그래밍의-예"><span class="mr-2">어셈블리 언어 프로그래밍의 예</span><a href="#어셈블리-언어-프로그래밍의-예" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>루프 예제</strong>: 조건 플래그를 사용하여 루프의 종료를 제어.<ul><li>카운터를 감소시키고, Z 플래그가 설정되면 루프를 종료.</ul></ul><h2 id="참고-문서"><span class="mr-2">참고 문서</span><a href="#참고-문서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>Armv8-M 아키텍처 참조 매뉴얼</strong>: 어셈블리 명령어와 그 사용법에 대한 자세한 정보 제공.<li><strong>Arm Compiler 툴체인 문서</strong>: Arm 컴파일러에서 지원하는 어셈블러와 그 사용법 설명.</ul><h1 id="armv8-m-assembly-language-programming-overview">Armv8-M Assembly Language Programming Overview</h1><hr /><h2 id="데이터-처리-명령-data-processing-instructions"><span class="mr-2">데이터 처리 명령 (Data Processing Instructions)</span><a href="#데이터-처리-명령-data-processing-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 섹션에서는 Armv8-M Mainline 아키텍처의 일부로 사용할 수 있는 다양한 유형의 데이터 처리 명령을 살펴보겠습니다.</p><ul><li><strong>산술 연산 (Arithmetic Operations)</strong>: ADD, SUB, ADCS, RSB 등의 명령이 있으며, 이들은 레지스터 간의 산술 연산을 수행합니다.<li><strong>논리 연산 (Logical Operations)</strong>: AND, ORR, BIC 등이 있으며, 비트 단위 논리 연산을 수행합니다.<li><strong>조건 플래그 (Conditional Flags)</strong>: 대부분의 데이터 처리 명령은 S 접미사를 사용하여 조건 플래그를 업데이트할 수 있습니다.</ul><h3 id="데이터-처리-명령-예제-examples"><span class="mr-2">데이터 처리 명령 예제 (Examples)</span><a href="#데이터-처리-명령-예제-examples" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><h4 id="add-명령-예제"><span class="mr-2">ADD 명령 예제:</span><a href="#add-명령-예제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">ADD{S} {Rd}, Rn, Rm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">ADDS r0, r1, r2</code> - r1과 r2의 합을 r0에 저장하고 플래그를 업데이트합니다.</ul><h2 id="비교-명령-compare-instructions"><span class="mr-2">비교 명령 (Compare Instructions)</span><a href="#비교-명령-compare-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>CMP 명령</strong>: 두 레지스터 값을 비교하여 조건 플래그를 설정합니다.<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">CMP Rn, Rm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">CMP r1, r2</code> - r1과 r2를 비교하고 플래그를 설정합니다.</ul><h2 id="논리-연산-logical-operations"><span class="mr-2">논리 연산 (Logical Operations)</span><a href="#논리-연산-logical-operations" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>논리 연산 명령 예제:</p><ul><li><strong>AND</strong>: 비트 단위 AND 연산<li><strong>ORR</strong>: 비트 단위 OR 연산<li><strong>BIC</strong>: 비트 지우기 연산<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">AND{S} {Rd}, Rn, Rm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">ANDS r0, r1, r2</code> - r1과 r2의 AND 결과를 r0에 저장하고 플래그를 업데이트합니다.</ul><h2 id="시프트-및-회전-명령-shift-and-rotate-instructions"><span class="mr-2">시프트 및 회전 명령 (Shift and Rotate Instructions)</span><a href="#시프트-및-회전-명령-shift-and-rotate-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M Mainline 아키텍처의 시프트 명령:</p><ul><li><strong>ASR</strong>: Arithmetic Shift Right<li><strong>LSL</strong>: Logical Shift Left<li><strong>LSR</strong>: Logical Shift Right<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">ASR {Rd}, Rn, #imm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">ASR r0, r1, #2</code> - r1을 오른쪽으로 2비트 산술 이동하여 r0에 저장합니다.</ul><h2 id="곱셈-및-나눗셈-명령-multiplication-and-division-instructions"><span class="mr-2">곱셈 및 나눗셈 명령 (Multiplication and Division Instructions)</span><a href="#곱셈-및-나눗셈-명령-multiplication-and-division-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="곱셈-명령"><span class="mr-2">곱셈 명령:</span><a href="#곱셈-명령" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>MUL</strong>: 32비트 곱셈<li><strong>SMULL</strong>: 64비트 부호 있는 곱셈<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">MUL {Rd}, Rn, Rm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">MUL r0, r1, r2</code> - r1과 r2를 곱하여 r0에 저장합니다.</ul><h2 id="비트-조작-명령-bit-manipulation-instructions"><span class="mr-2">비트 조작 명령 (Bit Manipulation Instructions)</span><a href="#비트-조작-명령-bit-manipulation-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>비트 조작 명령:</p><ul><li><strong>UBFX</strong>: 부호 없는 비트 필드 추출<li><strong>BFI</strong>: 비트 필드 삽입<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">UBFX {Rd}, Rn, #lsb, #width</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">UBFX r0, r1, #8, #8</code> - r1의 8번 비트부터 8비트를 추출하여 r0에 저장합니다.</ul><h2 id="c와-어셈블리-간의-변환-transformations-between-c-and-assembly"><span class="mr-2">C와 어셈블리 간의 변환 (Transformations between C and Assembly)</span><a href="#c와-어셈블리-간의-변환-transformations-between-c-and-assembly" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>C 코드에서 어셈블리 코드로 변환 예제:</p><ul><li><strong>C 코드</strong>: <code class="language-plaintext highlighter-rouge">dest1 = op1 + op2; dest2 = op3 - op4;</code><li><strong>어셈블리 코드</strong>:</ul><h2 id="상수-로드-명령-constant-load-instructions"><span class="mr-2">상수 로드 명령 (Constant Load Instructions)</span><a href="#상수-로드-명령-constant-load-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>상수 값을 레지스터에 로드하는 방법:</p><ul><li><strong>MOV</strong>: 상수를 레지스터에 로드<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">MOV {Rd}, #imm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">MOV r0, #0x2543</code> - 0x2543 값을 r0에 로드합니다.</ul><h2 id="나눗셈-명령-division-instructions"><span class="mr-2">나눗셈 명령 (Division Instructions)</span><a href="#나눗셈-명령-division-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="나눗셈-명령"><span class="mr-2">나눗셈 명령:</span><a href="#나눗셈-명령" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>SDIV</strong>: 부호 있는 나눗셈<li><strong>UDIV</strong>: 부호 없는 나눗셈<li><strong>구문</strong>: <code class="language-plaintext highlighter-rouge">SDIV {Rd}, Rn, Rm</code><li><strong>예</strong>: <code class="language-plaintext highlighter-rouge">SDIV r0, r1, r2</code> - r1을 r2로 나누어 r0에 저장합니다.</ul><h2 id="메모리-액세스-명령-memory-access-instructions"><span class="mr-2">메모리 액세스 명령 (Memory Access Instructions)</span><a href="#메모리-액세스-명령-memory-access-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="메모리에서-데이터-로드-및-저장"><span class="mr-2">메모리에서 데이터 로드 및 저장</span><a href="#메모리에서-데이터-로드-및-저장" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>이 섹션에서는 메모리에서 데이터를 로드하고 저장하는 데 사용할 수 있는 명령 유형을 살펴봅니다. 특히, Armv8-M 메인라인 아키텍처의 일부인 명령어 세트에서 메모리 액세스 크기와 데이터를 로드하거나 저장하는 주소가 계산되는 방식에 대해 다룹니다.</p><h4 id="명령어-유형"><span class="mr-2">명령어 유형</span><a href="#명령어-유형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li><strong>LDR (Load Register)</strong>: 단어(word) 데이터를 메모리에서 로드합니다.<li><strong>STR (Store Register)</strong>: 단어 데이터를 메모리에 저장합니다.<li><strong>LDRB (Load Register Byte)</strong>: 바이트 데이터를 메모리에서 로드합니다.<li><strong>STRB (Store Register Byte)</strong>: 바이트 데이터를 메모리에 저장합니다.<li><strong>LDRH (Load Register Halfword)</strong>: 하프워드 데이터를 메모리에서 로드합니다.<li><strong>STRH (Store Register Halfword)</strong>: 하프워드 데이터를 메모리에 저장합니다.<li><strong>LDRSB (Load Register Signed Byte)</strong>: 부호 있는 바이트 데이터를 메모리에서 로드합니다.<li><strong>LDRSH (Load Register Signed Halfword)</strong>: 부호 있는 하프워드 데이터를 메모리에서 로드합니다.</ul><p>메모리 로드 명령어는 메모리에서 데이터를 로드하면 대상 레지스터의 최하위 비트를 차지하고 나머지 공간은 0으로 채워집니다. 부호 확장을 수행하는 경우 가장 중요한 비트를 다른 모든 비트에 복사합니다.</p><h3 id="오프셋-주소-지정-모드-offset-addressing-modes"><span class="mr-2">오프셋 주소 지정 모드 (Offset Addressing Modes)</span><a href="#오프셋-주소-지정-모드-offset-addressing-modes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>다양한 오프셋 주소 지정 모드를 지원하여 메모리 액세스 시 유연성을 제공합니다.</p><ul><li><strong>기본 레지스터 오프셋 (Register Offset)</strong>: 기본 레지스터에 상수를 더하거나 뺀 값을 사용합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDR r0, [r1, #8]</code> - r1 값에 8을 더한 주소에서 r0으로 로드합니다.</ul><li><strong>레지스터 시프트 오프셋 (Register Shifted Offset)</strong>: 레지스터 값을 시프트하여 오프셋으로 사용합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDR r0, [r1, r2, LSL #2]</code> - r2 값을 왼쪽으로 2비트 시프트하고 r1에 더한 주소에서 r0으로 로드합니다.</ul></ul><h3 id="주소-지정-모드"><span class="mr-2">주소 지정 모드</span><a href="#주소-지정-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>네 가지 주소 지정 모드를 지원합니다.</p><ul><li><strong>단순 주소 지정 모드 (Simple Addressing Mode)</strong>: 기본 레지스터에서 단순히 로드하거나 저장합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDR r0, [r1]</code> - r1 주소에서 r0으로 로드합니다.</ul><li><strong>오프셋 주소 지정 모드 (Offset Addressing Mode)</strong>: 기본 레지스터에 오프셋을 더하여 주소를 계산합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDR r0, [r1, #12]</code> - r1 값에 12를 더한 주소에서 r0으로 로드합니다.</ul><li><strong>사전 인덱스 주소 지정 모드 (Pre-indexed Addressing Mode)</strong>: 오프셋을 더한 후 로드하거나 저장합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDR r0, [r1, #12]!</code> - r1 값에 12를 더한 주소에서 r0으로 로드하고, r1을 갱신합니다.</ul><li><strong>사후 인덱스 주소 지정 모드 (Post-indexed Addressing Mode)</strong>: 로드나 저장 후 오프셋을 더합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDR r0, [r1], #12</code> - r1 주소에서 r0으로 로드한 후 r1 값에 12를 더합니다.</ul></ul><h3 id="다중-레지스터-로드-및-저장-multiple-register-load-and-store"><span class="mr-2">다중 레지스터 로드 및 저장 (Multiple Register Load and Store)</span><a href="#다중-레지스터-로드-및-저장-multiple-register-load-and-store" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>LDM (Load Multiple)</strong>: 여러 레지스터를 한 번에 로드합니다.<li><strong>STM (Store Multiple)</strong>: 여러 레지스터를 한 번에 저장합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDM r10!, {r0, r1, r4}</code> - r10 주소에서 r0, r1, r4에 로드한 후 r10을 갱신합니다.</ul></ul><h3 id="스택-액세스-stack-access"><span class="mr-2">스택 액세스 (Stack Access)</span><a href="#스택-액세스-stack-access" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>PUSH</strong>: 스택에 레지스터를 저장합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">STMFD sp!, {r4-r7, lr}</code> - r4에서 r7 및 링크 레지스터를 스택에 푸시합니다.</ul><li><strong>POP</strong>: 스택에서 레지스터를 로드합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">LDMFD sp!, {r4-r7, pc}</code> - r4에서 r7 및 프로그램 카운터를 스택에서 팝합니다.</ul></ul><h3 id="메모리-복사-작업"><span class="mr-2">메모리 복사 작업</span><a href="#메모리-복사-작업" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>메모리 복사 작업을 수행하는 어셈블리 명령 시퀀스:</p><ul><li><strong>소스에서 로드</strong>: <code class="language-plaintext highlighter-rouge">LDRB r0, [r1], #1</code> - r1 주소에서 바이트를 로드하고, r1 값을 1 증가시킵니다.<li><strong>목적지에 저장</strong>: <code class="language-plaintext highlighter-rouge">STRB r0, [r2], #1</code> - r0 값을 r2 주소에 저장하고, r2 값을 1 증가시킵니다.<li><strong>반복 루프</strong>: 문자열 복사 작업을 반복합니다.<ul><li>예:<pre><code class="language-assembly">loop:
  LDRB r0, [r1], #1
  STRB r0, [r2], #1
  CMP r0, #0
  BNE loop
</code></pre></ul></ul><h1 id="armv8-m-assembly-language-programming---control-flow-instructions">Armv8-M Assembly Language Programming - Control Flow Instructions</h1><h2 id="흐름-제어-명령어-control-flow-instructions"><span class="mr-2">흐름 제어 명령어 (Control Flow Instructions)</span><a href="#흐름-제어-명령어-control-flow-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="개요-6"><span class="mr-2">개요</span><a href="#개요-6" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>어셈블리 언어 프로그램이 실행될 때, 프로세서는 기본적으로 사용 가능한 다음 주소에서 다음 명령을 계속 실행합니다. 흐름 제어 명령어를 사용하면 이러한 동작을 변경하여 특정 명령을 건너뛰거나 코드의 다른 지점으로 이동할 수 있습니다. 이 섹션에서는 ARMv8-M 아키텍처의 다양한 흐름 제어 명령어를 살펴봅니다.</p><h3 id="분기-명령어-branch-instructions"><span class="mr-2">분기 명령어 (Branch Instructions)</span><a href="#분기-명령어-branch-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>분기 명령어는 프로그램 카운터(PC)를 변경하여 코드의 다른 부분으로 이동할 수 있게 합니다. 분기 명령어는 일반적으로 레이블과 함께 사용됩니다.</p><ul><li><strong>B</strong>: 기본 분기 명령어로, 지정된 레이블로 분기합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">B label</code></ul><li><strong>BL</strong>: 링크 명령이 있는 분기 명령어로, 서브루틴이나 함수를 호출할 때 사용됩니다. 현재 주소를 링크 레지스터(LR)에 저장한 후 지정된 레이블로 분기합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">BL func</code></ul></ul><h3 id="조건부-분기-conditional-branch"><span class="mr-2">조건부 분기 (Conditional Branch)</span><a href="#조건부-분기-conditional-branch" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>조건부 분기 명령어는 특정 조건이 참일 때만 분기합니다. 조건은 상태 플래그(N, Z, C, V)에 따라 결정됩니다.</p><ul><li><strong>BEQ</strong>: Z 플래그가 설정되어 있을 때 분기 (equal).<ul><li>예: <code class="language-plaintext highlighter-rouge">BEQ label</code></ul><li><strong>BNE</strong>: Z 플래그가 설정되지 않았을 때 분기 (not equal).<ul><li>예: <code class="language-plaintext highlighter-rouge">BNE label</code></ul><li><strong>BGT</strong>: N 플래그와 V 플래그가 같을 때 분기 (greater than).<ul><li>예: <code class="language-plaintext highlighter-rouge">BGT label</code></ul><li><strong>BLT</strong>: N 플래그와 V 플래그가 다를 때 분기 (less than).<ul><li>예: <code class="language-plaintext highlighter-rouge">BLT label</code></ul></ul><h3 id="비교-및-분기-명령어-compare-and-branch-instructions"><span class="mr-2">비교 및 분기 명령어 (Compare and Branch Instructions)</span><a href="#비교-및-분기-명령어-compare-and-branch-instructions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ARMv8-M 메인라인 아키텍처는 비교와 분기를 하나의 명령어로 결합한 명령어를 제공합니다.</p><ul><li><strong>CBZ (Compare and Branch on Zero)</strong>: 지정된 레지스터의 값이 0일 때 분기.<ul><li>예: <code class="language-plaintext highlighter-rouge">CBZ r0, label</code></ul><li><strong>CBNZ (Compare and Branch on Non-Zero)</strong>: 지정된 레지스터의 값이 0이 아닐 때 분기.<ul><li>예: <code class="language-plaintext highlighter-rouge">CBNZ r0, label</code></ul></ul><h3 id="조건부-실행-블록-conditional-execution-blocks"><span class="mr-2">조건부 실행 블록 (Conditional Execution Blocks)</span><a href="#조건부-실행-블록-conditional-execution-blocks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>if-then 블록을 사용하여 여러 명령어를 조건부로 실행할 수 있습니다. IT (If-Then) 명령어를 사용하여 최대 4개의 후속 명령어를 조건부로 실행할 수 있습니다.</p><ul><li><strong>IT</strong>: if-then 블록의 시작을 정의합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">IT EQ</code></ul><li><strong>ITE</strong>: if-then-else 블록의 시작을 정의합니다.<ul><li>예: <code class="language-plaintext highlighter-rouge">ITE EQ</code></ul></ul><h4 id="예제-1"><span class="mr-2">예제</span><a href="#예제-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>다음은 if-then 블록을 사용하는 예제입니다.</p><pre><code class="language-assembly">CMP r0, #0      // r0을 0과 비교
IT EQ           // if-then 블록 시작
MOVEQ r1, #2    // r0이 0이면 r1에 2를 이동
MOVNE r1, #4    // r0이 0이 아니면 r1에 4를 이동
</code></pre><h1 id="arm-어셈블리-지침-요약">ARM 어셈블리 지침 요약</h1><h2 id="어셈블리-구문의-이해"><span class="mr-2">어셈블리 구문의 이해</span><a href="#어셈블리-구문의-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>어셈블리 지침 및 구문은 ARM 컴파일러와 GNU 어셈블러에서 다르게 사용됩니다. 이 섹션에서는 두 가지 구문의 차이점을 이해하고, 어떤 컴파일러가 사용되었는지 구분할 수 있는 방법을 학습합니다. 또한, Armv8-M 메인라인 특수 목적 레지스터의 값을 변경하는 간단한 읽기-수정-쓰기 시퀀스를 작성하는 방법을 배웁니다.</p><h2 id="어셈블러-비교"><span class="mr-2">어셈블러 비교</span><a href="#어셈블러-비교" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>레거시 armasm 어셈블러와 ARM 컴파일러 6의 armclang 통합 어셈블러를 비교합니다. 이 두 어셈블러는 통합 어셈블리 언어(UAL) 구문 규칙을 준수하지만, 디렉티브와 표현식을 작성하는 방식에서 차이가 있습니다.</p><ul><li><strong>armasm 어셈블러</strong>는 이전 ARM 컴파일러 5의 일부였으며 ARMV8-M 아키텍처의 모든 기능을 지원하지는 않습니다.<li><strong>armclang 어셈블러</strong>는 ARM 컴파일러 6의 일부이며 ARMV8-M 아키텍처의 모든 기능을 지원합니다.</ul><h2 id="명령어-및-디렉티브"><span class="mr-2">명령어 및 디렉티브</span><a href="#명령어-및-디렉티브" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>두 어셈블러는 동일한 명령 시퀀스를 사용하지만, 지침에서는 차이가 발생합니다.</p><ul><li><strong>섹션 정의</strong>: armasm에서는 <code class="language-plaintext highlighter-rouge">area</code> 지시문을 사용하고, armclang에서는 <code class="language-plaintext highlighter-rouge">section</code> 지시문을 사용합니다.<li><strong>상수 정의</strong>: armasm에서는 <code class="language-plaintext highlighter-rouge">EQU</code> 지시문을 사용하고, armclang에서는 <code class="language-plaintext highlighter-rouge">.equ</code> 지시문을 사용합니다.<li><strong>32비트 값 정의</strong>: armasm에서는 <code class="language-plaintext highlighter-rouge">DCD</code> 지시문을 사용하고, armclang에서는 <code class="language-plaintext highlighter-rouge">.word</code> 지시문을 사용합니다.<li><strong>파일 종료</strong>: armasm에서는 <code class="language-plaintext highlighter-rouge">END</code> 지시문을 사용하고, armclang에서는 <code class="language-plaintext highlighter-rouge">.end</code> 지시문을 사용합니다.</ul><h2 id="디지털-신호-처리dsp-명령어"><span class="mr-2">디지털 신호 처리(DSP) 명령어</span><a href="#디지털-신호-처리dsp-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>DSP 애플리케이션에서 포화 연산을 수행하는 방법을 설명합니다. 포화 연산은 값을 특정한 2의 거듭제곱으로 제한하는 연산입니다. ARMv8-M 아키텍처는 하드웨어에서 이 작업을 수행하기 위한 USAT 및 SSAT 명령을 제공합니다.</p><h2 id="바이트-리버설-명령"><span class="mr-2">바이트 리버설 명령</span><a href="#바이트-리버설-명령" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>다른 주변 장치를 다루기 위해 바이트 리버설 지침을 사용할 수 있습니다. <code class="language-plaintext highlighter-rouge">rev</code> 명령을 사용하여 레지스터의 바이트 순서를 뒤집을 수 있습니다.</p><h2 id="카운트-리딩-제로-명령어"><span class="mr-2">카운트 리딩 제로 명령어</span><a href="#카운트-리딩-제로-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>CLZ 또는 카운트 리딩 제로 명령어는 최상위 비트에서 시작하여 설정되지 않은 0의 수를 세고 해당 값을 레지스터에 반환합니다.</p><h2 id="특수-용도의-레지스터-프로그래밍"><span class="mr-2">특수 용도의 레지스터 프로그래밍</span><a href="#특수-용도의-레지스터-프로그래밍" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>특수 용도의 레지스터를 사용하여 Cortex-M 장치를 프로그래밍하는 방법을 설명합니다.</p><ul><li><strong>MRS 명령어</strong>: 특수 목적 레지스터에서 범용 레지스터로 이동하는 명령어입니다.<li><strong>MSR 명령어</strong>: 범용 레지스터에서 특수 목적 레지스터로 이동하는 명령어입니다.</ul><h2 id="전원-관리-명령어"><span class="mr-2">전원 관리 명령어</span><a href="#전원-관리-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>프로세서를 저전력 상태로 전환하거나 멀티코어 시스템의 다른 프로세서에 이벤트를 알리는 데 사용할 수 있는 몇 가지 전원 관리 명령이 있습니다.</p><ul><li><strong>WFI 명령어</strong>: 프로세서를 저전력 상태로 전환합니다.<li><strong>WFE 명령어</strong>: 송신 이벤트에 대한 응답으로 깨어납니다.</ul><h2 id="기타-유용한-명령어"><span class="mr-2">기타 유용한 명령어</span><a href="#기타-유용한-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>NOP 명령어</strong>: 코드에서 자리 표시자로 자주 사용됩니다. 컴파일러에서 명령을 특정 경계에 정렬하는 데 사용할 수 있습니다.</ul><h2 id="armv8-m-아키텍처의-추가-지침"><span class="mr-2">ARMv8-M 아키텍처의 추가 지침</span><a href="#armv8-m-아키텍처의-추가-지침" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>보안 상태 지침</strong>: ARMv8-M 보안 확장 교육 모듈에서 다루는 지침입니다.<li><strong>장벽 명령</strong>: 작업 발생 순서를 제어하고 잘못된 실행을 방지하는 데 사용됩니다.<li><strong>관리자 호출 명령(SVC)</strong>: 운영 체제에 작업을 수행하도록 요청하는 데 사용됩니다.</ul><h1 id="arm-사용자-지정-명령어-요약">ARM 사용자 지정 명령어 요약</h1><h2 id="개요-7"><span class="mr-2">개요</span><a href="#개요-7" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈의 마지막 부분에서는 Arm Custom Instructions 기능에 대해 알아봅니다. 이는 Armv8-M 및 Armv8.1-M 아키텍처를 위한 사용자 지정 데이터 경로 확장의 일부로, 프로세서 설계자가 Arm 프로세서에 자체 기능을 추가할 수 있도록 합니다.</p><h2 id="사용자-지정-명령어의-구문"><span class="mr-2">사용자 지정 명령어의 구문</span><a href="#사용자-지정-명령어의-구문" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용자 지정 명령어는 여러 명령어 클래스로 나뉘며, 각 클래스는 지정할 수 있는 입력 및 출력 피연산자의 유형에 따라 정의됩니다.</p><ul><li><strong>클래스 1</strong>: 출력 대상 레지스터와 입력 즉시값 피연산자.<li><strong>클래스 2</strong>: 출력 대상 레지스터, 입력 즉시값 피연산자, 추가 소스 레지스터 피연산자.<li><strong>클래스 3</strong>: 여러 소스 레지스터 피연산자.</ul><h2 id="조건-코드-전달"><span class="mr-2">조건 코드 전달</span><a href="#조건-코드-전달" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용자 정의 명령어로 조건 코드를 전달하려면 APSR_NZCV라는 이름을 사용해야 합니다. 이는 애플리케이션 프로세스 상태 레지스터를 의미하며, Negative, Zero, Carry, Overflow 플래그를 포함합니다.</p><h2 id="simd-및-부동-소수점-레지스터"><span class="mr-2">SIMD 및 부동 소수점 레지스터</span><a href="#simd-및-부동-소수점-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용 중인 프로세서에 따라 사용자 지정 명령어에 SIMD 및 부동 소수점 레지스터를 전달할 수도 있습니다. 예를 들어, Cortex-M33은 SIMD 레지스터 전달을 지원하지 않습니다.</p><h2 id="사용자-지정-명령어의-인코딩"><span class="mr-2">사용자 지정 명령어의 인코딩</span><a href="#사용자-지정-명령어의-인코딩" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>사용자 지정 명령어는 보조 프로세서 명령어와 동일한 인코딩 공간을 사용합니다. 특정 명령어를 Arm 사용자 지정 명령어로 전달하려면 코어 프로세서에 연결해야 합니다.</p><h2 id="사용자-지정-명령어-클래스의-변형"><span class="mr-2">사용자 지정 명령어 클래스의 변형</span><a href="#사용자-지정-명령어-클래스의-변형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>각 명령어 클래스에는 몇 가지 변형이 있습니다.</p><ul><li><strong>일반 변형</strong>: 결과를 계산하고 출력 레지스터를 사용.<li><strong>누산기 변형</strong>: 등록된 값을 소비하여 연산.<li><strong>이중 변형</strong>: 결과를 두 개의 레지스터에 저장.</ul><h2 id="명령어-클래스-1"><span class="mr-2">명령어 클래스 1</span><a href="#명령어-클래스-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>명령어 클래스 1은 다음과 같은 형태로 나타납니다:</p><ul><li>CX로 시작하여 사용자 지정 명령어임을 나타냅니다.<li>보조 프로세서 이름(P0 등).<li>대상 레지스터(범용 레지스터 또는 특수 이름).<li>즉시값(최대 13비트).</ul><h3 id="비누산기-변형"><span class="mr-2">비누산기 변형</span><a href="#비누산기-변형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>레지스터만 출력으로 사용하며, 실제 값은 코프로세서에 전달되지 않습니다.</p><h3 id="누산기-변형"><span class="mr-2">누산기 변형</span><a href="#누산기-변형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>레지스터 또는 플래그와 즉시값을 코어 프로세서로 전달하여 레지스터를 업데이트합니다.</p><h2 id="명령어-클래스-2"><span class="mr-2">명령어 클래스 2</span><a href="#명령어-클래스-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>명령어 클래스 2는 다음과 같은 형태로 나타납니다:</p><ul><li>CX로 시작하여 사용자 지정 명령어임을 나타냅니다.<li>보조 프로세서 이름(P1 등).<li>두 개의 대상 레지스터.<li>소스 레지스터 및 즉시값(최대 9비트).</ul><h3 id="비누산기-변형-1"><span class="mr-2">비누산기 변형</span><a href="#비누산기-변형-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>두 개의 대상 레지스터를 입력으로 사용하지 않고 즉시값과 opcode를 코어 프로세서로 전송하여 업데이트.</p><h3 id="누산기-변형-1"><span class="mr-2">누산기 변형</span><a href="#누산기-변형-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>두 개의 대상 레지스터 값을 받아 코어 프로세서로 확장하여 모든 값을 사용할 수 있게 합니다.</p><h2 id="참고-사항"><span class="mr-2">참고 사항</span><a href="#참고-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>누산기 변형이라는 용어는 보조 프로세서가 대상 레지스터 값을 사용하는 방식을 의미하며, 단순히 더하기 또는 빼기 연산을 수행하는 것은 아닙니다. 원하는 연산을 수행할 수 있습니다.</ul><h1 id="armv8-m-메모리-모델-요약">Armv8-M 메모리 모델 요약</h1><h2 id="개요-8"><span class="mr-2">개요</span><a href="#개요-8" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>안녕하세요, 여러분. 저는 Arm에서 일하는 애플리케이션 엔지니어 Yang Song입니다. 오늘은 Armv8-M 메인라인 아키텍처의 중요한 주제인 메모리 모델에 대해 알아보겠습니다.</p><h2 id="학습-목표"><span class="mr-2">학습 목표</span><a href="#학습-목표" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈을 마치면 다음을 할 수 있습니다:</p><ul><li>Armv8-M 메인라인 주소 공간의 여러 파티션을 나열<li>Arm 아키텍처 메모리 유형 구분<li>주소 공간의 특정 파티션에 사용되는 이유 구분<li>다양한 메모리 속성과 해당 속성이 로드 및 저장에 미치는 영향 식별<li>Endianness가 Armv8-M 프로세서에 미치는 영향 특성화<li>다양한 Barrier 명령 인식 및 사용 이유 설명</ul><h2 id="메모리-주소-공간"><span class="mr-2">메모리 주소 공간</span><a href="#메모리-주소-공간" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Armv8-M은 최대 4GB의 물리적 주소 공간을 포함하는 메모리 매핑 아키텍처입니다. 주소 공간은 물리적 메모리와 프로세서 제어 및 상태 레지스터 모두를 위한 공유 주소 공간입니다. 메모리는 8개의 512MB 세그먼트 또는 파티션으로 분할됩니다:</p><ul><li>코드 섹션<li>SRAM<li>주변기기<li>2개의 RAM 영역<li>2개의 장치 영역<li>시스템 영역</ul><p>시스템 영역에는 프로세서 제어 및 상태 레지스터가 포함됩니다.</p><h2 id="메모리-유형과-속성"><span class="mr-2">메모리 유형과 속성</span><a href="#메모리-유형과-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>메모리 영역에는 일반 메모리 또는 장치 메모리가 포함될 수 있습니다. 메모리 유형은 프로세서가 해당 메모리에 액세스하는 방식을 결정합니다. 각 메모리 유형에는 추가 속성(액세스 권한, 실행 권한, 공유 가능성, 캐시 가능성)이 있습니다.</p><h3 id="일반-메모리"><span class="mr-2">일반 메모리</span><a href="#일반-메모리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>정상 메모리</strong>: 코드 및 대부분의 데이터 영역에 사용. 최상의 성능을 제공하며, CPU가 액세스를 재정렬하거나 병합할 수 있음.<li><strong>추측적 액세스</strong>: 일반 메모리는 순서가 약한 메모리 모델을 구현하여 다른 일반 액세스 및 장치 액세스와 관련하여 액세스를 순서대로 완료할 필요가 없음.</ul><h3 id="장치-메모리"><span class="mr-2">장치 메모리</span><a href="#장치-메모리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>장치 유형 메모리</strong>: 액세스에 부작용이 발생할 수 있는 영역에 사용. 예를 들어, 주변 장치의 제어 레지스터에 기록하면 인터럽트가 발생할 수 있음.<li><strong>장치 메모리 변형</strong>: NGNRNE (가장 제한적), NGNRE, GRE (가장 제한이 적음).</ul><h2 id="endianness"><span class="mr-2">Endianness</span><a href="#endianness" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>리틀 엔디안</strong>: 기본 설정. 단어의 최하위 바이트가 가장 낮은 주소를 가리킴.<li><strong>빅 엔디안</strong>: 구성 가능. 단어의 최상위 바이트가 가장 낮은 주소를 가리킴.<li><strong>BE-8 모델</strong>: Arm Cortex-M 프로파일 코어에서 지원.</ul><h2 id="barrier-명령어"><span class="mr-2">Barrier 명령어</span><a href="#barrier-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li><strong>DMB (Data Memory Barrier)</strong>: DMB 이전의 모든 명시적 메모리 액세스가 DMB 이후의 명시적 메모리 액세스 전에 완료되도록 보장.<li><strong>DSB (Data Synchronization Barrier)</strong>: DSB가 완료되기 전에 모든 명시적 메모리 트랜잭션이 완료되도록 보장. DSB는 매우 제한적이며 명령어 실행을 차단.<li><strong>ISB (Instruction Synchronization Barrier)</strong>: 시스템 제어 레지스터의 변경 사항을 동기화하여 새로운 체계를 설정.</ul><h1 id="메모리-보호-memory-protection">메모리 보호 (Memory Protection)</h1><h2 id="학습-목표-1"><span class="mr-2">학습 목표</span><a href="#학습-목표-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈을 완료하면 다음을 할 수 있습니다:</p><ul><li>메모리 보호 장치(MPU)의 필요성 설명<li>Armv8-M MPU가 이전 Armv7-M 및 Arm6-M MPU와 어떻게 다른지 이해<li>다양한 메모리 맵핑된 MPU 레지스터 설명<li>MPU 레지스터를 프로그래밍하여 메모리 영역 구성</ul><h2 id="메모리-보호의-동기"><span class="mr-2">메모리 보호의 동기</span><a href="#메모리-보호의-동기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>메모리 보호는 주소 공간 접근을 제어합니다.</p><ul><li>코어가 다양한 보안 및 특권 상태에서 작동할 수 있기 때문에 필요하며, 민감한 데이터를 특정 상태로 제한하는 것이 중요합니다.</ul><h2 id="메모리-보호와-보안-속성"><span class="mr-2">메모리 보호와 보안 속성</span><a href="#메모리-보호와-보안-속성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>메모리 보호는 다음으로 구성됩니다:</p><ul><li>선택적 메모리 보호 장치(MPU)<ul><li>보호 메모리 시스템 아키텍처(PMSAv8)를 기반으로 함</ul><li>선택적 보안 속성 장치(SAU)<ul><li>보안 확장이 구현된 경우 사용 가능</ul></ul><p>MPU는 다음을 완전히 지원합니다:</p><ul><li>보호 영역, 접근 권한 및 시스템에 메모리 속성 내보내기<li>MPU 불일치 및 권한 위반은 MemManage 핸들러를 호출</ul><h2 id="기본-시스템-주소-맵"><span class="mr-2">기본 시스템 주소 맵</span><a href="#기본-시스템-주소-맵" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>기본적으로 주소 공간은 8개의 0.5GB 영역을 정의합니다.</p><ul><li>MPU가 구현되지 않은 경우 기본 시스템 주소 맵이 적용됩니다.<li>MPU가 구현되었지만 비활성화된 경우<li>시스템이 PPB 주소 공간에 접근하는 경우 등</ul><h2 id="메모리-보호-장치mpu"><span class="mr-2">메모리 보호 장치(MPU)</span><a href="#메모리-보호-장치mpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>MPU는 기본 메모리 관리를 제공합니다.</p><ul><li>주소 영역에 속성을 적용할 수 있도록 함<li>모든 접근은 MPU 영역에 대해 검사됩니다.</ul><p>각 영역은 다음으로 구성됩니다:</p><ul><li>기본 주소<li>한계 주소<li>속성(예: 유형, 크기, 접근 권한)</ul><h2 id="mpu-레지스터"><span class="mr-2">MPU 레지스터</span><a href="#mpu-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th>주소<th>이름<th>유형<th>설명<tbody><tr><td>0xE000ED90<td>MPU_TYPE<td>RO<td>MPU 유형 레지스터<tr><td>0xE000ED94<td>MPU_CTRL<td>RW<td>MPU 제어 레지스터<tr><td>0xE000ED98<td>MPU_RNR<td>RW<td>MPU 영역 번호 레지스터<tr><td>0xE000ED9C<td>MPU_RBAR<td>RW<td>MPU 영역 기본 주소 레지스터<tr><td>0xE000EDA0<td>MPU_RLAR<td>RW<td>MPU 영역 한계 주소 레지스터<tr><td>0xE000EDC0<td>MPU_MAIR0<td>RW<td>MPU 메모리 속성 간접 레지스터 0<tr><td>0xE000EDC4<td>MPU_MAIR1<td>RW<td>MPU 메모리 속성 간접 레지스터 1</table></div><h2 id="mpu-제어-레지스터-mpu_ctrl"><span class="mr-2">MPU 제어 레지스터 (MPU_CTRL)</span><a href="#mpu-제어-레지스터-mpu_ctrl" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="table-wrapper"><table><thead><tr><th>비트 위치<th>이름<th>설명<tbody><tr><td>[2]<td>PRIVDEFENA<td>MPU가 활성화된 경우 기본 메모리 맵을 백그라운드 영역으로 사용하도록 허용<tr><td>[1]<td>HFNMIENA<td>하드폴트 및 NMI 핸들러가 MPU를 활성화된 상태로 메모리에 접근할 수 있도록 제어<tr><td>[0]<td>ENABLE<td>MPU 활성화/비활성화 (1: 활성화, 0: 비활성화)</table></div><h2 id="mpu-영역-기본-주소-레지스터-mpu_rbar"><span class="mr-2">MPU 영역 기본 주소 레지스터 (MPU_RBAR)</span><a href="#mpu-영역-기본-주소-레지스터-mpu_rbar" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>XN: 실행 불가 여부 (0: 실행 가능, 1: 실행 불가)<li>SH: 공유 가능성 (00: 공유 불가, 01: 예약됨, 10: 외부 공유 가능, 11: 내부 공유 가능)<li>AP: 접근 권한 (00: 특권 코드만 읽기/쓰기, 01: 모든 특권 레벨에서 읽기/쓰기, 10: 특권 코드만 읽기, 11: 모든 특권 레벨에서 읽기)</ul><h2 id="mpu-영역-한계-주소-레지스터-mpu_rlar"><span class="mr-2">MPU 영역 한계 주소 레지스터 (MPU_RLAR)</span><a href="#mpu-영역-한계-주소-레지스터-mpu_rlar" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>LIMIT: 선택된 MPU 메모리 영역의 상한 한계 주소<li>AttrIndx: MPU_MAIR0/1 필드에서 속성 세트를 연결<li>EN: 영역 활성화 여부 (0: 비활성화, 1: 활성화)</ul><h2 id="mpu-메모리-속성-간접-레지스터-mpu_mair01"><span class="mr-2">MPU 메모리 속성 간접 레지스터 (MPU_MAIR0/1)</span><a href="#mpu-메모리-속성-간접-레지스터-mpu_mair01" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Attr<n>: 속성 (예: 0000: 디바이스 메모리, 00RW: 외부 쓰기-스루 일시적, 0100: 외부 비캐시)</n></ul><h2 id="mpu-구성"><span class="mr-2">MPU 구성</span><a href="#mpu-구성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>MPU_TYPE 읽기: 사용 가능한 영역 수 확인<li>MPU_RBAR에 기본 주소, 공유 가능성 및 접근 권한 쓰기<li>MPU_RLAR에 한계 주소, 추가 메모리 속성 및 영역 활성화 비트 쓰기<li>MPU_MAIRn에 Attr<n> 값에 해당하는 메모리 속성 인코딩 쓰기</n><li>MPU_CTRL 레지스터에 쓰기하여 Hardfault/NMI 동작 및 특권 접근 구성 후 MPU 활성화<li>MPU_RNR에 영역 번호 쓰기</ol><h2 id="memmanage-faults-armv8-m-mainline-전용"><span class="mr-2">MemManage faults (Armv8-M Mainline 전용)</span><a href="#memmanage-faults-armv8-m-mainline-전용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>데이터 접근 위반 (DACCVIOL)<li>명령어 접근 위반 (IACCVIOL)<li>예외 엔트리 스택 메모리 작업 실패 (MSTKERR)<li>예외 반환 스택 메모리 작업 실패 (MUNSTKERR)<li>게으른 상태 보존 오류 플래그 (MLSPERR)</ul><h1 id="armv8-m-아키텍처의-예외-처리">Armv8-M 아키텍처의 예외 처리</h1><h2 id="학습-목표-2"><span class="mr-2">학습 목표</span><a href="#학습-목표-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>이 모듈을 완료하면 다음을 수행할 수 있습니다:</p><ul><li>M-프로파일 예외 모델 설명<ul><li>내장된 중첩 벡터 인터럽트 컨트롤러(NVIC) 및 임베디드 시스템에 최적화된 방식<li>예외 유형<li>벡터 테이블<li>리셋 동작<li>기본 예외 처리 메커니즘</ul><li>리셋 동작 설명<li>예외 진입 및 예외 반환 시 발생하는 일 설명<li>예외 대기 시간과 예외 처리 속도를 높이기 위한 아키텍처 최적화 논의</ul><h2 id="목차"><span class="mr-2">목차</span><a href="#목차" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>소개<li>예외 모델<ul><li>예외 진입 및 종료 동작<li>우선순위와 제어<li>인터럽트 민감도</ul><li>벡터 테이블 및 인터럽트 핸들러 작성<li>내부 예외 및 RTOS 지원<li>오류 예외<li>참고 자료</ol><h2 id="개요-9"><span class="mr-2">개요</span><a href="#개요-9" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Arm 마이크로컨트롤러 프로파일 아키텍처 버전의 예외 아키텍처는 다른 Arm 아키텍처와 매우 다릅니다. 마이크로컨트롤러 응용 프로그램을 위해 설계되었습니다.</p><ul><li>많은 인터럽트 소스를 지원<li>중첩 인터럽트의 효율적인 처리<li>유연한 인터럽트 아키텍처 (높은 구성 가능성)<li>RTOS 지원 내장</ul><h3 id="주요-기능"><span class="mr-2">주요 기능</span><a href="#주요-기능" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>중첩 벡터 인터럽트 컨트롤러(NVIC)<li>마이크로 코드 아키텍처가 “더티 작업” 처리<ul><li>인터럽트 진입/종료 및 인터럽트 중첩에 대한 소프트웨어 오버헤드 없음</ul><li>모든 예외 처리를 위한 단일 모드 및 단일 스택<ul><li>핸들러 모드 / 메인 스택</ul><li>프로그래밍이 용이<ul><li>어셈블리어로 핸들러 코드를 작성할 필요 없음</ul></ul><h2 id="마이크로-코드-인터럽트-메커니즘"><span class="mr-2">마이크로 코드 인터럽트 메커니즘</span><a href="#마이크로-코드-인터럽트-메커니즘" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>저지연을 위한 인터럽트 아키텍처 설계<li>NVIC에 내장된 인터럽트 우선순위 메커니즘<li>인터럽트 진입/종료는 하드웨어 제어로 “마이크로 코드화”<ul><li>프로세서 컨텍스트를 자동으로 저장 및 복원<li>가장 높은 우선순위 대기 인터럽트의 늦은 결정 허용<li>프로세서 상태의 전체 복원/저장 없이 다른 대기 인터럽트 서비스 허용 (테일 체이닝)<li>인터럽트 서비스 루틴(ISR)은 전적으로 C 언어로 작성 가능</ul><li>일부 다중 사이클 명령어는 개선된 인터럽트 대기 시간을 위해 인터럽트 가능</ul><h2 id="예외-유형"><span class="mr-2">예외 유형</span><a href="#예외-유형" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>예외는 다양한 이벤트로 인해 발생할 수 있습니다:</p><ul><li>내부<li>외부</ul><h3 id="프로세서-모드-사용-예"><span class="mr-2">프로세서 모드 사용 예</span><a href="#프로세서-모드-사용-예" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>스레드 모드에서 예외가 발생하면 프로세서 모드가 변경됩니다. 핸들러 모드에서 예외가 발생하면 모드가 변경되지 않습니다.</p><h2 id="외부-인터럽트"><span class="mr-2">외부 인터럽트</span><a href="#외부-인터럽트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>NVIC에 의해 처리되는 외부 인터럽트<li>프로세서 코어와 긴밀하게 결합<li>하나의 비마스킹 인터럽트(NMI) 지원<li>외부 인터럽트의 수는 구현에 따라 다름 (최대 496개 인터럽트 지원)</ul><h2 id="선점"><span class="mr-2">선점</span><a href="#선점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>선점은 예외를 처리하기 위해 태스크가 일시 중단될 때 발생합니다. 동일한 우선순위의 여러 예외가 대기 중인 경우 고정된 순서로 처리됩니다. 활성화된 예외는 높은 우선순위 예외만 선점할 수 있습니다.</p><h2 id="예외-처리-모델"><span class="mr-2">예외 처리 모델</span><a href="#예외-처리-모델" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>프로세서는 “기본 실행 우선순위 수준”으로 실행을 시작합니다. 리셋 시 모든 인터럽트가 비활성화됩니다. 기본 실행 우선순위는 가장 낮은 프로그래밍 가능한 우선순위보다 낮으므로 활성화된 모든 인터럽트가 코어를 선점합니다.</p><h2 id="벡터-테이블"><span class="mr-2">벡터 테이블</span><a href="#벡터-테이블" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>벡터 테이블의 첫 번째 항목은 초기 메인 스택 포인터를 포함합니다. 나머지 항목은 예외 핸들러의 주소입니다. 벡터 테이블은 최대 496개의 외부 인터럽트를 가질 수 있습니다.</p><h2 id="예외-진입-동작"><span class="mr-2">예외 진입 동작</span><a href="#예외-진입-동작" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>예외를 받을 때 프로세서는 대부분의 명령어에서 현재 명령어 스트림을 완료합니다. 프로세서 상태는 현재 스택에 자동으로 저장됩니다. ISR 주소는 벡터 테이블에서 읽어옵니다. 링크 레지스터는 인터럽트 반환을 위해 수정됩니다. 예외 핸들러 루틴은 핸들러 모드에서 메인 스택을 사용하여 실행됩니다.</p><h2 id="예외-반환"><span class="mr-2">예외 반환</span><a href="#예외-반환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>예외에서 반환할 때 프로세서는 특정 “매직” 값(0xFFFF_FFXX)으로 PC가 로드될 때 다음 명령어를 실행합니다. 대기 중인 인터럽트가 없는 경우 포어그라운드 상태가 복원됩니다. 다른 인터럽트가 대기 중인 경우 가장 높은 우선순위가 서비스될 수 있습니다.</p><h2 id="내부-예외-및-rtos-지원"><span class="mr-2">내부 예외 및 RTOS 지원</span><a href="#내부-예외-및-rtos-지원" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="systick-타이머"><span class="mr-2">SysTick 타이머</span><a href="#systick-타이머" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>RTOS 또는 사용자 정의 프로그램 실행을 위한 시스템 하트비트 제공<li>주기적 인터럽트는 시스템 태스크 스케줄링을 구동</ul><h3 id="supervisor-call-svc"><span class="mr-2">Supervisor Call (SVC)</span><a href="#supervisor-call-svc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>비특권 소프트웨어가 시스템 호출을 할 수 있도록 허용<li>RTOS 서비스 요청 처리</ul><h3 id="pended-system-call-pendsv"><span class="mr-2">Pended System Call (PendSV)</span><a href="#pended-system-call-pendsv" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>RTOS 개발을 용이하게 함</ul><h2 id="오류-예외"><span class="mr-2">오류 예외</span><a href="#오류-예외" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="일반-오류의-세-가지-클래스"><span class="mr-2">일반 오류의 세 가지 클래스</span><a href="#일반-오류의-세-가지-클래스" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>BusFault: 메모리 액세스 오류 (프리페치 또는 데이터 액세스)<li>MemManage: MPU 권한 불일치<li>UsageFault: 정의되지 않은 명령어, CP 액세스, 불법 상태 전환 등</ul><h3 id="오류-처리"><span class="mr-2">오류 처리</span><a href="#오류-처리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>단순 시스템은 HardFault 핸들러만 사용합니다. 별도의 오류 핸들러를 활성화하는 것은 필요한 경우에만 해야 합니다. 각 오류에는 연관된 상태 레지스터가 있습니다.</p><h3 id="lockup-상태"><span class="mr-2">Lockup 상태</span><a href="#lockup-상태" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>회복 불가능한 예외의 경우 Lockup 상태에 진입합니다. NMI 예외 또는 디버그 이벤트, 리셋 시 Lockup 상태에서 벗어날 수 있습니다.</p><h3 id="동기-및-비동기-예외"><span class="mr-2">동기 및 비동기 예외</span><a href="#동기-및-비동기-예외" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>동기 예외는 명령어 스트림과 고정된 관계가 있습니다. 비동기 예외는 명령어 스트림과 고정된 관계가 없습니다.</p><h2 id="참고-자료-1"><span class="mr-2">참고 자료</span><a href="#참고-자료-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ul><li>Armv8-M 아키텍처 레퍼런스 매뉴얼<li>애플리케이션 노트: AN209 - Cortex-M3/M4/M7 오류 예외 사용<li>도서: The Definitive Guide to the Cortex-M3 and Cortex-M4 Processors (ISBN: 978-0124080829) - Yiu</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/embedded-engineering/'>Embedded Engineering</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/embedded-engineering/" class="post-tag no-text-decoration" >Embedded Engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=ARM+%EA%B0%95%EC%9D%98+-+DK%27s+Software+Engineering+Knowledge+Storage&url=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Armv8-M-%25EC%2595%2584%25ED%2582%25A4%25ED%2585%258D%25EC%25B2%2598-%25EA%25B8%25B0%25EB%25B3%25B8-%25EC%2582%25AC%25ED%2595%25AD%29%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=ARM+%EA%B0%95%EC%9D%98+-+DK%27s+Software+Engineering+Knowledge+Storage&u=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Armv8-M-%25EC%2595%2584%25ED%2582%25A4%25ED%2585%258D%25EC%25B2%2598-%25EA%25B8%25B0%25EB%25B3%25B8-%25EC%2582%25AC%25ED%2595%25AD%29%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Armv8-M-%25EC%2595%2584%25ED%2582%25A4%25ED%2585%258D%25EC%25B2%2598-%25EA%25B8%25B0%25EB%25B3%25B8-%25EC%2582%25AC%25ED%2595%25AD%29%2F&text=ARM+%EA%B0%95%EC%9D%98+-+DK%27s+Software+Engineering+Knowledge+Storage" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/STL_MAP/">STL_Map</a><li><a href="/posts/STL_Priority_Queue/">STL_Priority_Queue</a><li><a href="/posts/STL_Vector/">STL_Vector</a><li><a href="/posts/STL_String/">STL_String</a><li><a href="/posts/STL_Queue/">STL_Queue</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/bfs/">BFS</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/embedded-engineering/">Embedded Engineering</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/container/">Container</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EC%97%90%EC%96%B4%EC%BB%A8-%EC%9E%90%EB%8F%99-%EC%A0%9C%EC%96%B4/"><div class="card-body"> <em class="small" data-ts="1747494000" data-df="YYYY-MM-DD" > 2025-05-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>아두이노 에어컨 자동 제어</h3><div class="text-muted small"><p> [아두이노] 에어컨 자동 제어 아두이노를 활용하여 에어컨의 리모컨 신호를 복사하고, 원하는 시간에 자동으로 송신하여 에어컨을 제어하는 프로젝트를 진행할 수 있다. 이를 위해 필요한 부품, 회로 연결 방법, 아두이노 코드 예제, 그리고 시간 기반 제어 방법을 자세히 설명한다. 1. 필요한 부품 아두이노 보드 (Arduino Uno, ATmeg...</p></div></div></a></div><div class="card"> <a href="/posts/Embedded_OS-%EA%B0%9C%EB%B0%9C/"><div class="card-body"> <em class="small" data-ts="1663513200" data-df="YYYY-MM-DD" > 2022-09-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Embedded OS 개발</h3><div class="text-muted small"><p> Embedded OS 개발 프로젝트 1장. 임베디드 운영체제 임베디드 운영체제와 펌웨어 임베디드 운영체제는 임베디드 시스템에서 동작하는 펌웨어의 일종으로서 하드웨어 성능이 일정 수준으로 올라온 현재 임베디드 장치에도 임베디드 운영체제를 많이 사용하고 있다. 펌웨어란 임베디드 운영체제 유무에 상관없이 임베디드 시스템 용 전체 소프트웨어를 지칭한다...</p></div></div></a></div><div class="card"> <a href="/posts/FreeRTOS-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"><div class="card-body"> <em class="small" data-ts="1671462000" data-df="YYYY-MM-DD" > 2022-12-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>FreeRTOS 내용정리</h3><div class="text-muted small"><p> FreeRTOS 내용정리 Task 태스크는 가상의 CPU를 각자 가지고 있는 것처럼 동작한다.(Time Division) 태스크 간에는 커널 서비스인 Inter Process Communication 방법을 사용하여 통신한다. Round Robin 스케쥴링 모든 태스크들이 CPU 자원을 공평하게 나누어 사용하는 개념 각 태스크...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/EB-AUTOSAR/" class="btn btn-outline-primary" prompt="이전 글"><p>EB AUTOSAR</p></a> <a href="/posts/ARM-%EA%B0%95%EC%9D%98(Cortex-M-Software-Development-Fundamentals)/" class="btn btn-outline-primary" prompt="다음 글"><p>ARM 강의(Cortex-M Software Development Fundamentals)</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">DK</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/bfs/">BFS</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/embedded-engineering/">Embedded Engineering</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/container/">Container</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
