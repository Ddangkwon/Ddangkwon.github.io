<!DOCTYPE html><html lang="ko-KR" data-mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="ARM 강의 (Arm 아키텍처의 구조와 원리)" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="ARM 아키텍처 소개" /><meta property="og:description" content="ARM 아키텍처 소개" /><link rel="canonical" href="/posts/ARM-%EA%B0%95%EC%9D%98(Arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9B%90%EB%A6%AC)/" /><meta property="og:url" content="/posts/ARM-%EA%B0%95%EC%9D%98(Arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9B%90%EB%A6%AC)/" /><meta property="og:site_name" content="DK’s Software Engineering Knowledge Storage" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-08-18T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="ARM 강의 (Arm 아키텍처의 구조와 원리)" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="k9n3TqutGkNvqf7uv9HP04BF1yRBxsowePxu32o6gBk" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-18T00:00:00+09:00","datePublished":"2024-08-18T00:00:00+09:00","description":"ARM 아키텍처 소개","headline":"ARM 강의 (Arm 아키텍처의 구조와 원리)","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/ARM-%EA%B0%95%EC%9D%98(Arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9B%90%EB%A6%AC)/"},"url":"/posts/ARM-%EA%B0%95%EC%9D%98(Arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9B%90%EB%A6%AC)/"}</script><title>ARM 강의 (Arm 아키텍처의 구조와 원리) | DK's Software Engineering Knowledge Storage</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="DK's Software Engineering Knowledge Storage"><meta name="application-name" content="DK's Software Engineering Knowledge Storage"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/green_galaxy.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">DK's Software Engineering Knowledge Storage</a></div><div class="site-subtitle font-italic">Software Engineering Knowledge Repo.</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>홈</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>카테고리</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>태그</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>아카이브</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>정보</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['',''].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> 홈 </a> </span> <span>ARM 강의 (Arm 아키텍처의 구조와 원리)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 포스트</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>ARM 강의 (Arm 아키텍처의 구조와 원리)</h1><div class="post-meta text-muted"> <span> 게시 <em class="" data-ts="1723906800" data-df="YYYY-MM-DD" data-toggle="tooltip" data-placement="bottom"> 2024-08-18 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://twitter.com/username">DK</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7592 단어"> <em>42 분</em>읽는 시간</span></div></div></div><div class="post-content"> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9717042333563257" crossorigin="anonymous"></script><h1 id="arm-아키텍처-소개">ARM 아키텍처 소개</h1><h2 id="1-arm-프로세서와-시스템-반도체"><span class="mr-2">1. ARM 프로세서와 시스템 반도체</span><a href="#1-arm-프로세서와-시스템-반도체" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="시스템-반도체-개발-과정"><span class="mr-2">시스템 반도체 개발 과정</span><a href="#시스템-반도체-개발-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>시스템 반도체의 핵심은 ARM 프로세서입니다. ARM은 다양한 기술적 요소를 집약한 핵심 IP(Intellectual Property)를 제공하며, 이러한 IP를 바탕으로 파운드리에서 SoC(System-on-Chip)와 같은 시스템 반도체가 양산됩니다.</p><h3 id="arm의-비즈니스-모델"><span class="mr-2">ARM의 비즈니스 모델</span><a href="#arm의-비즈니스-모델" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ARM은 라이선스 비즈니스를 통해 수익을 창출합니다. 주요 IP를 라이선스하는 방식으로, 시스템 반도체 개발 기업들에게 제공됩니다.</p><h2 id="2-arm의-역사"><span class="mr-2">2. ARM의 역사</span><a href="#2-arm의-역사" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="arm의-설립과-초기"><span class="mr-2">ARM의 설립과 초기</span><a href="#arm의-설립과-초기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>1978년</strong>: 영국 캠브리지에서 크리스 커리와 헤르만 하우저가 Acorn Computers라는 회사를 설립했습니다.<li><strong>1985년</strong>: RISC 기반의 첫 번째 ARM 프로세서인 ARM1이 개발되었습니다.</ul><h3 id="arm의-발전"><span class="mr-2">ARM의 발전</span><a href="#arm의-발전" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>1990년</strong>: 애플과 VLSI Technology와의 조인트 벤처로 ARM Ltd.가 설립되었습니다.<li><strong>2005년</strong>: Cortex 시리즈가 발표되었고, 고성능 애플리케이션 프로세서(Cortex-A), 실시간 프로세서(Cortex-R), 마이크로 컨트롤러(Cortex-M)로 제품군이 세분화되었습니다.</ul><h3 id="최근-역사"><span class="mr-2">최근 역사</span><a href="#최근-역사" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>2011년</strong>: ARMv8 아키텍처가 발표되었으며, 64비트 동작 모드를 지원하여 스마트폰 및 서버 시장에 진출했습니다.<li><strong>2021년</strong>: ARMv9 아키텍처가 발표되었고, AI 및 클라우드 컴퓨팅 시장을 목표로 하고 있습니다.</ul><h2 id="3-arm의-라이선스-모델"><span class="mr-2">3. ARM의 라이선스 모델</span><a href="#3-arm의-라이선스-모델" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="ipintellectual-property"><span class="mr-2">IP(Intellectual Property)</span><a href="#ipintellectual-property" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>IP는 재사용 가능하도록 모듈화된 핵심 기능 설계입니다. ARM은 이러한 IP를 라이선스하여 다양한 반도체 기업들에게 제공하고 있습니다.</p><h3 id="개발-과정"><span class="mr-2">개발 과정</span><a href="#개발-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>시스템 반도체 개발은 다음과 같은 과정을 거칩니다:</p><ul><li>스펙 확정<li>RTL 설계(Verilog)<li>합성 및 검증<li>FPGA 검증<li>공정 개발 및 Wafer 작업<li>패키징 및 브링업<li>특성 평가 및 시스템 통합</ul><h2 id="4-arm-프로세서의-패밀리"><span class="mr-2">4. ARM 프로세서의 패밀리</span><a href="#4-arm-프로세서의-패밀리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="cortex-시리즈"><span class="mr-2">Cortex 시리즈</span><a href="#cortex-시리즈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>Cortex-A</strong>: 높은 성능이 요구되는 스마트폰, 넷북, 디지털 TV 등에서 사용되는 애플리케이션 프로세서.<li><strong>Cortex-R</strong>: 실시간 응답이 필요한 통신 모뎀 및 산업용 컨트롤러 등에 사용되는 리얼타임 프로세서.<li><strong>Cortex-M</strong>: 저전력 소모와 저비용이 중요한 마이크로 컨트롤러에서 사용.</ul><h2 id="5-arm-아키텍처-진화-과정"><span class="mr-2">5. ARM 아키텍처 진화 과정</span><a href="#5-arm-아키텍처-진화-과정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="주요-아키텍처"><span class="mr-2">주요 아키텍처</span><a href="#주요-아키텍처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>ARMv6</strong>: ARM11 제품군으로 SIMD 및 TrustZone 기술을 도입.<li><strong>ARMv7</strong>: Cortex 시리즈로 확장되며 멀티코어 지원과 가상화 기술을 추가.<li><strong>ARMv8</strong>: 64비트 지원, 저전력 설계, 서버 시장 진출을 목표로 한 아키텍처.<li><strong>ARMv9</strong>: AI와 클라우드 컴퓨팅을 지원하는 최신 아키텍처로, 보안 기능이 강화되었습니다.</ul><h2 id="6-arm-프로세서와-관련된-용어"><span class="mr-2">6. ARM 프로세서와 관련된 용어</span><a href="#6-arm-프로세서와-관련된-용어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="arm-아키텍처"><span class="mr-2">ARM 아키텍처</span><a href="#arm-아키텍처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARM 아키텍처는 ARM 프로세서를 설계하는 기본적인 디자인입니다. 소프트웨어 개발자가 알아야 할 레지스터, 메모리 구조, 어셈블리 명령어 등이 포함됩니다.</ul><h3 id="peprocessing-element"><span class="mr-2">PE(Processing Element)</span><a href="#peprocessing-element" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>PE는 ARM 아키텍처를 구현한 프로세서의 요소로, 예를 들어 Cortex-A8은 싱글 코어 프로세서로 구성되며, Cortex-A53은 멀티코어 프로세서로 각각의 코어가 PE로 명시됩니다.</ul><h2 id="7-arm-아키텍처와-cortex-프로세서의-종류"><span class="mr-2">7. ARM 아키텍처와 Cortex 프로세서의 종류</span><a href="#7-arm-아키텍처와-cortex-프로세서의-종류" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="arm-아키텍처별-cortex-프로세서"><span class="mr-2">ARM 아키텍처별 Cortex 프로세서</span><a href="#arm-아키텍처별-cortex-프로세서" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>ARMv7-A</strong>: Cortex-A5, Cortex-A7, Cortex-A9<li><strong>ARMv8-A</strong>: Cortex-A53, Cortex-A57, Cortex-A72</ul><h1 id="arm-아키텍처-학습-방법">ARM 아키텍처 학습 방법</h1><h2 id="1-arm-프로세서를-배워야-하는-이유"><span class="mr-2">1. ARM 프로세서를 배워야 하는 이유</span><a href="#1-arm-프로세서를-배워야-하는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-보드-브링업board-bring-up과-arm-아키텍처"><span class="mr-2">1.1 보드 브링업(Board Bring-up)과 ARM 아키텍처</span><a href="#11-보드-브링업board-bring-up과-arm-아키텍처" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ARM 아키텍처를 배우는 것은 보드 브링업 과정에서 매우 중요합니다. 브링업 단계에서는 부트로더의 ‘스타트업’ 코드를 작성하며, 이는 시스템 자원(메모리, 캐시 등)과 주변 장치(키보드, USB 등)를 초기화하는 작업을 포함합니다. 이 과정을 성공적으로 수행하려면 ARM 어셈블리 명령어와 ARM 아키텍처의 동작 원리를 잘 이해해야 합니다.</p><h3 id="12-디바이스-드라이버-개발"><span class="mr-2">1.2 디바이스 드라이버 개발</span><a href="#12-디바이스-드라이버-개발" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ARM 프로세서의 동작 원리를 이해하면, 디바이스 드라이버 개발 시 성능을 최적화할 수 있습니다. 예를 들어, ARM의 Generic Interrupt Controller(GIC)가 인터럽트를 처리하는 방식을 알면, 인터럽트 우선순위 설정이나 IRQ/FIQ 설정을 효과적으로 수행할 수 있습니다.</p><h3 id="13-rtos나-리눅스-커널의-이해"><span class="mr-2">1.3 RTOS나 리눅스 커널의 이해</span><a href="#13-rtos나-리눅스-커널의-이해" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>리눅스 커널이나 RTOS의 핵심 루틴은 ARM 어셈블리 명령어로 구현된 경우가 많습니다. 인터럽트 핸들러, 컨텍스트 스위칭, 선점 스케줄링, 시스템 콜 핸들러 등의 기능을 깊이 이해하기 위해서는 ARM 프로세서의 동작 원리를 잘 파악해야 합니다.</p><h3 id="14-디버깅-능력-향상"><span class="mr-2">1.4 디버깅 능력 향상</span><a href="#14-디버깅-능력-향상" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ARM 아키텍처를 깊이 이해하면, 디버깅 과정에서 문제 해결 능력을 크게 향상시킬 수 있습니다. 예를 들어, 메모리 어보트가 발생할 때 ARM 아키텍처의 익셉션 처리와 관련 레지스터의 용법을 이해하면, 문제의 원인을 효율적으로 파악할 수 있습니다.</p><h2 id="2-arm-아키텍처를-학습하는-방법의-문제점"><span class="mr-2">2. ARM 아키텍처를 학습하는 방법의 문제점</span><a href="#2-arm-아키텍처를-학습하는-방법의-문제점" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="21-이론과-실습의-불일치"><span class="mr-2">2.1 이론과 실습의 불일치</span><a href="#21-이론과-실습의-불일치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>ARM 아키텍처의 기능을 이해하는 것뿐만 아니라, 이러한 기능이 리눅스 커널이나 RTOS에서 어떻게 활용되는지 파악하는 과정이 중요합니다. ARM 아키텍처의 익셉션 벡터 테이블이 운영체제에서 어떤 방식으로 구현되는지를 이해하지 않으면 시스템의 동작 원리를 완전히 파악하기 어렵습니다.</p><h3 id="22-실전-프로젝트에서의-활용-부족"><span class="mr-2">2.2 실전 프로젝트에서의 활용 부족</span><a href="#22-실전-프로젝트에서의-활용-부족" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>실습을 통해 ARM 프로세서의 주요 개념을 학습하는 것은 중요하지만, 이 학습된 내용을 실전 프로젝트에서 어떻게 활용할 수 있는지 이해하지 않으면 학습한 내용을 내재화하기 어렵습니다. 시간이 지나면 학습한 내용을 잊기 쉬우며, 이를 방지하기 위해서는 실전에서의 활용 경험이 필요합니다.</p><h2 id="3-arm-아키텍처-학습-방법"><span class="mr-2">3. ARM 아키텍처 학습 방법</span><a href="#3-arm-아키텍처-학습-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-디버깅을-통한-학습"><span class="mr-2">3.1 디버깅을 통한 학습</span><a href="#31-디버깅을-통한-학습" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>디버깅 과정에서 ARM 어셈블리 명령어를 익히는 것이 효과적입니다. GDB와 같은 디버깅 도구를 사용해 실습을 진행하면, 배운 내용을 더 오래 기억할 수 있습니다.</p><h3 id="32-운영체제와-함께-학습"><span class="mr-2">3.2 운영체제와 함께 학습</span><a href="#32-운영체제와-함께-학습" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>운영체제의 기본 원리를 ARM 아키텍처와 함께 학습하는 것이 중요합니다. ARM 아키텍처에서 정의된 주요 기능이 리눅스 커널에서 어떻게 구현되는지를 파악하는 것이 필수적입니다.</p><h3 id="33-실전-프로젝트에서의-확인"><span class="mr-2">3.3 실전 프로젝트에서의 확인</span><a href="#33-실전-프로젝트에서의-확인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>실전 프로젝트에서 배운 내용이 어떻게 구현되는지 확인하는 것이 중요합니다. 이를 통해 학습한 내용을 실전에서 적용할 수 있게 되며, 학습의 효과를 극대화할 수 있습니다.</p><h1 id="arm-아키텍처-레지스터">ARM 아키텍처: 레지스터</h1><h2 id="1-레지스터란-무엇인가"><span class="mr-2">1. 레지스터란 무엇인가?</span><a href="#1-레지스터란-무엇인가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-기본-개념"><span class="mr-2">1.1 기본 개념</span><a href="#11-기본-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레지스터는 CPU가 직접 접근하고 사용하는 변수입니다. 다른 메모리와 비교해 개수가 적지만, 속도가 빠릅니다.<li>ARM 프로그래밍에서 레지스터는 중요한 역할을 하며, ARMv7과 ARMv8에서의 레지스터 사용 방식이 다릅니다.<ul><li><strong>ARMv7</strong>: R13은 스택 포인터, R14는 링크 레지스터로 사용됩니다.<li><strong>ARMv8</strong>: SP는 스택 포인터, X30은 링크 레지스터로 사용됩니다.</ul></ul><h3 id="12-레지스터의-중요성"><span class="mr-2">1.2 레지스터의 중요성</span><a href="#12-레지스터의-중요성" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레지스터는 어셈블리 명령어와 함께 사용되며, ARM 코어의 작업을 최적화하는 데 중요한 역할을 합니다.<li>대부분의 프로그래밍에서 레지스터가 어떻게 사용되는지 이해하는 것이 중요합니다.</ul><h2 id="2-armv7-아키텍처에서의-레지스터"><span class="mr-2">2. ARMv7 아키텍처에서의 레지스터</span><a href="#2-armv7-아키텍처에서의-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="21-범용-레지스터"><span class="mr-2">2.1 범용 레지스터</span><a href="#21-범용-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>R0 ~ R15</strong>: ARMv7 아키텍처에서 주로 사용되는 범용 레지스터입니다. 이들 레지스터는 어셈블리 명령어의 입력과 출력으로 사용되며, 프로세스의 실행 흐름을 나타냅니다.<li><strong>CPSR, SPSRs</strong>: 프로세스 상태를 나타내는 레지스터로, 인터럽트 및 예외 처리에 관련된 플래그와 모드 정보를 담고 있습니다.</ul><h3 id="22-뱅크드-레지스터"><span class="mr-2">2.2 뱅크드 레지스터</span><a href="#22-뱅크드-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARMv7에서는 각 작업 모드(SVC, UND, IRQ, FIQ 등)별로 다른 뱅크드 레지스터가 있습니다. 이는 각 모드에서 다른 스택 포인터(R13)와 링크 레지스터(R14)를 사용하게 합니다.<li>동작 모드가 변경될 때마다 관련된 레지스터가 전환되어, 각 작업 모드가 독립적으로 관리될 수 있도록 합니다.</ul><h2 id="3-armv8-아키텍처에서의-레지스터"><span class="mr-2">3. ARMv8 아키텍처에서의 레지스터</span><a href="#3-armv8-아키텍처에서의-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-범용-레지스터"><span class="mr-2">3.1 범용 레지스터</span><a href="#31-범용-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>X0 ~ X30</strong>: ARMv8 아키텍처에서 사용되는 64비트 범용 레지스터입니다. 이들 레지스터는 어셈블리 명령어의 입력과 출력으로 사용됩니다.<li><strong>W0 ~ W30</strong>: X0 ~ X30의 하위 32비트로, 32비트 연산에 사용됩니다.</ul><h3 id="32-스페셜-레지스터"><span class="mr-2">3.2 스페셜 레지스터</span><a href="#32-스페셜-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>PSTATE</strong>: 이전의 CPSR와 유사한 역할을 하는 레지스터로, 프로세서의 상태를 관리합니다. 이 레지스터는 인터럽트 마스크, 조건 플래그, 익셉션 레벨 등을 포함합니다.<li><strong>SPSR_ELx</strong>: 예외 처리 시 PSTATE 값을 백업하는 레지스터입니다. 익셉션 레벨별로 존재하며, 익셉션을 처리한 후 복귀할 때 사용됩니다.</ul><h3 id="33-시스템-레지스터"><span class="mr-2">3.3 시스템 레지스터</span><a href="#33-시스템-레지스터" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>TTBR_EL1, TTBR_EL2, TTBR_EL3</strong>: 메모리 관리와 가상화 등을 제어하는 데 사용되는 시스템 레지스터입니다. 이들 레지스터는 각 익셉션 레벨에서 접근할 수 있는 권한이 다릅니다.<li><strong>SCTLR_ELx</strong>: 시스템 제어 레지스터로, MMU, 캐시, 얼라인먼트 검사 등 주요 아키텍처 기능을 제어합니다.</ul><h2 id="4-레지스터의-사용-예시"><span class="mr-2">4. 레지스터의 사용 예시</span><a href="#4-레지스터의-사용-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="41-리눅스-커널에서의-레지스터-사용"><span class="mr-2">4.1 리눅스 커널에서의 레지스터 사용</span><a href="#41-리눅스-커널에서의-레지스터-사용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>리눅스 커널에서 범용 레지스터는 다양한 작업을 수행하는 데 사용됩니다. 예를 들어, 컨텍스트 스위칭 과정에서는 X19 ~ X28 범용 레지스터가 스택에 저장되고 복원됩니다.</ul><h3 id="42-디버깅에서의-레지스터-활용"><span class="mr-2">4.2 디버깅에서의 레지스터 활용</span><a href="#42-디버깅에서의-레지스터-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레지스터는 디버깅 과정에서도 중요한 역할을 합니다. 예를 들어, 커널 패닉 로그를 분석할 때, 범용 레지스터와 스페셜 레지스터의 상태를 확인하여 문제의 원인을 추적할 수 있습니다.</ul><h2 id="5-레지스터-학습-방법"><span class="mr-2">5. 레지스터 학습 방법</span><a href="#5-레지스터-학습-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="51-실습을-통한-학습"><span class="mr-2">5.1 실습을 통한 학습</span><a href="#51-실습을-통한-학습" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>레지스터는 기계적으로 학습하는 것보다 RTOS나 커널과 함께 실습을 통해 배우는 것이 효과적입니다. 디버깅 툴을 사용하여 어셈블리 명령어와 레지스터의 관계를 이해하는 것이 중요합니다.</ul><h3 id="52-운영체제와-함께-배우기"><span class="mr-2">5.2 운영체제와 함께 배우기</span><a href="#52-운영체제와-함께-배우기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARM 아키텍처의 레지스터를 학습할 때, 운영체제의 기본 원리와 함께 학습하는 것이 도움이 됩니다. 이는 학습한 내용을 실전 프로젝트에서 효과적으로 활용할 수 있게 도와줍니다.</ul><h1 id="어셈블리-명령어">어셈블리 명령어</h1><h2 id="1-어셈블리-명령어가-어렵다고-느끼는-이유"><span class="mr-2">1. 어셈블리 명령어가 어렵다고 느끼는 이유</span><a href="#1-어셈블리-명령어가-어렵다고-느끼는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-입문자에게-어셈블리-명령어란"><span class="mr-2">1.1 입문자에게 어셈블리 명령어란</span><a href="#11-입문자에게-어셈블리-명령어란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARM 아키텍처를 처음 학습할 때 어셈블리 명령어는 큰 장벽으로 느껴질 수 있습니다.<li>어셈블리 명령어는 매우 간단하고 명료하지만, 해당 프로시저의 목적을 파악하기 어려운 경우가 많습니다.<li>어셈블리 명령어를 학습할 때는 명령어 자체뿐만 아니라, 루틴을 통해 동작을 이해하는 것이 중요합니다.</ul><h3 id="12-예시-코드로-설명"><span class="mr-2">1.2 예시 코드로 설명</span><a href="#12-예시-코드로-설명" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>예를 들어, C 언어로 작성된 함수와 이를 어셈블리 코드로 표현한 경우를 비교하면 어셈블리 코드가 구체적으로 어떤 동작을 수행하는지 이해하기 어려울 수 있습니다.</ul><h2 id="2-어셈블리-명령어로-할-수-있는-것들"><span class="mr-2">2. 어셈블리 명령어로 할 수 있는 것들</span><a href="#2-어셈블리-명령어로-할-수-있는-것들" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="21-부트-시퀀스-관점에서의-소프트웨어-스택"><span class="mr-2">2.1 부트 시퀀스 관점에서의 소프트웨어 스택</span><a href="#21-부트-시퀀스-관점에서의-소프트웨어-스택" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>어셈블리 명령어는 부트로더 개발에서 매우 중요한 역할을 합니다. 하드웨어 초기화, 메모리 초기화, 커널 이미지 로딩 등을 처리합니다.<li>ARM 아키텍처의 기능을 활용한 드라이버 구현이나 리눅스 커널에서 SMC(시큐어 모니터 콜) 호출 관련 드라이버도 어셈블리 명령어로 구현할 수 있습니다.</ul><h3 id="22-디버깅에서의-활용"><span class="mr-2">2.2 디버깅에서의 활용</span><a href="#22-디버깅에서의-활용" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>디버깅 시, 커널의 NULL 포인터 역참조 등과 같은 문제를 추적하기 위해 어셈블리 명령어의 동작을 분석하는 것이 필요합니다.</ul><h2 id="3-어셈블리-명령어의-기본-포맷"><span class="mr-2">3. 어셈블리 명령어의 기본 포맷</span><a href="#3-어셈블리-명령어의-기본-포맷" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-명령어-형식"><span class="mr-2">3.1 명령어 형식</span><a href="#31-명령어-형식" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>어셈블리 명령어는 주로 OP Code와 레지스터로 구성됩니다.<li>예를 들어, <code class="language-plaintext highlighter-rouge">MOV</code> 명령어는 레지스터에 값을 이동시키는 역할을 하며, <code class="language-plaintext highlighter-rouge">ADD</code> 명령어는 덧셈을 수행합니다.</ul><h3 id="32-예시"><span class="mr-2">3.2 예시</span><a href="#32-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>간단한 예로, <code class="language-plaintext highlighter-rouge">MOV R0, #7</code>은 R0 레지스터에 7을 저장합니다.<li><code class="language-plaintext highlighter-rouge">ADD R0, R1, R2</code>는 R1과 R2의 값을 더하여 R0에 저장합니다.</ul><h2 id="4-산술-연산-명령어"><span class="mr-2">4. 산술 연산 명령어</span><a href="#4-산술-연산-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="41-add-명령어"><span class="mr-2">4.1 ADD 명령어</span><a href="#41-add-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ADD 명령어는 두 개의 값을 더하여 결과를 특정 레지스터에 저장합니다.<li>예제: <code class="language-plaintext highlighter-rouge">ADD R0, R1, #7</code>은 R1에 7을 더한 결과를 R0에 저장합니다.</ul><h3 id="42-sub-sbc-rsb-rsc-명령어"><span class="mr-2">4.2 SUB, SBC, RSB, RSC 명령어</span><a href="#42-sub-sbc-rsb-rsc-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>SUB 명령어는 두 값을 빼는 연산을 수행하며, SBC는 캐리를 고려한 뺄셈 연산을 수행합니다.<li>RSB는 뺄셈의 피연산자 순서를 반대로 수행하며, RSC는 캐리를 적용하여 피연산자의 순서를 반대로 수행합니다.</ul><h2 id="5-비트-시프트-명령어"><span class="mr-2">5. 비트 시프트 명령어</span><a href="#5-비트-시프트-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="51-lsl-lsr-asr-ror-명령어"><span class="mr-2">5.1 LSL, LSR, ASR, ROR 명령어</span><a href="#51-lsl-lsr-asr-ror-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>LSL은 왼쪽으로 비트를 시프트하고, LSR은 오른쪽으로 비트를 시프트합니다.<li>ASR은 오른쪽으로 비트를 시프트하면서 부호 비트를 유지하고, ROR은 오른쪽으로 시프트한 결과를 순환시킵니다.</ul><h2 id="6-논리-연산-명령어"><span class="mr-2">6. 논리 연산 명령어</span><a href="#6-논리-연산-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="61-and-orr-orn-eor-bic-명령어"><span class="mr-2">6.1 AND, ORR, ORN, EOR, BIC 명령어</span><a href="#61-and-orr-orn-eor-bic-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>AND 명령어는 두 값의 비트 AND 연산을 수행합니다.<li>ORR 명령어는 OR 연산을, ORN은 OR NOT 연산을 수행합니다.<li>EOR는 XOR 연산을, BIC는 특정 비트를 클리어하는 연산을 수행합니다.</ul><h2 id="7-메모리-액세스-명령어-loadstore"><span class="mr-2">7. 메모리 액세스 명령어: Load/Store</span><a href="#7-메모리-액세스-명령어-loadstore" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="71-ldr-명령어"><span class="mr-2">7.1 LDR 명령어</span><a href="#71-ldr-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>LDR 명령어는 메모리에서 데이터를 로드하여 레지스터에 저장하는 역할을 합니다.<li>예제: <code class="language-plaintext highlighter-rouge">LDR R0, [R1]</code>은 R1이 가리키는 주소에서 값을 로드하여 R0에 저장합니다.</ul><h3 id="72-str-명령어"><span class="mr-2">7.2 STR 명령어</span><a href="#72-str-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>STR 명령어는 레지스터의 값을 메모리에 저장하는 역할을 합니다.<li>예제: <code class="language-plaintext highlighter-rouge">STR R3, [R1]</code>은 R3의 값을 R1이 가리키는 메모리 주소에 저장합니다.</ul><h2 id="8-브랜치-명령어"><span class="mr-2">8. 브랜치 명령어</span><a href="#8-브랜치-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="81-b-bl-blx-blr-명령어"><span class="mr-2">8.1 B, BL, BLX, BLR 명령어</span><a href="#81-b-bl-blx-blr-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>B 명령어는 지정된 주소로 무조건 분기합니다.<li>BL은 서브루틴을 호출하고 복귀 주소를 링크 레지스터에 저장합니다.<li>BLX, BLR 명령어는 함수 포인터로 호출하여 분기하는 데 사용됩니다.</ul><h2 id="9-조건부-브랜치-명령어"><span class="mr-2">9. 조건부 브랜치 명령어</span><a href="#9-조건부-브랜치-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="91-cbz-cbnz-tbz-tbnz-명령어"><span class="mr-2">9.1 CBZ, CBNZ, TBZ, TBNZ 명령어</span><a href="#91-cbz-cbnz-tbz-tbnz-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>CBZ는 레지스터 값이 0이면 분기하고, CBNZ는 0이 아니면 분기합니다.<li>TBZ는 특정 비트가 0이면 분기하고, TBNZ는 특정 비트가 1이면 분기합니다.</ul><h2 id="10-svc-hvc-smc-명령어"><span class="mr-2">10. SVC, HVC, SMC 명령어</span><a href="#10-svc-hvc-smc-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="101-svc-명령어"><span class="mr-2">10.1 SVC 명령어</span><a href="#101-svc-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>SVC는 유저 애플리케이션에서 커널로 진입하기 위해 사용됩니다.</ul><h3 id="102-hvc-명령어"><span class="mr-2">10.2 HVC 명령어</span><a href="#102-hvc-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>HVC는 하이퍼바이저 호출에 사용되며, 주로 가상화 환경에서 사용됩니다.</ul><h3 id="103-smc-명령어"><span class="mr-2">10.3 SMC 명령어</span><a href="#103-smc-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>SMC는 시큐어 월드와 논 시큐어 월드 간의 전환을 수행합니다.</ul><h2 id="11-xpsrcpsr-spsrs-레지스터-설정"><span class="mr-2">11. xPSR(CPSR, SPSRs) 레지스터 설정</span><a href="#11-xpsrcpsr-spsrs-레지스터-설정" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="111-xpsr이란"><span class="mr-2">11.1 xPSR이란</span><a href="#111-xpsr이란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>xPSR은 프로세서의 상태를 나타내는 레지스터로, CPSR과 SPSR_<mode>가 포함됩니다.</mode></ul><h3 id="112-xpsr-레지스터-읽기쓰기-명령어"><span class="mr-2">11.2 xPSR 레지스터 읽기/쓰기 명령어</span><a href="#112-xpsr-레지스터-읽기쓰기-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>MRS 명령어를 통해 xPSR의 값을 읽을 수 있으며, MSR 명령어로 값을 쓸 수 있습니다.</ul><h1 id="arm-아키텍처-동작-모드">ARM 아키텍처: 동작 모드</h1><h2 id="1-동작-모드를-알아야-하는-이유"><span class="mr-2">1. 동작 모드를 알아야 하는 이유</span><a href="#1-동작-모드를-알아야-하는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-익셉션-처리와-동작-모드"><span class="mr-2">1.1 익셉션 처리와 동작 모드</span><a href="#11-익셉션-처리와-동작-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARM 아키텍처에서 익셉션이 발생하면, 프로세서는 특정 동작 모드로 전환됩니다. 이 과정에서 동작 모드에 대한 이해가 필수적입니다.<li>동작 모드는 프로세서가 특정 작업을 수행할 때 필요한 특권 레벨과 연관됩니다. 예를 들어, 메모리 관리나 인터럽트 처리는 특정 동작 모드에서만 가능합니다.</ul><h3 id="12-범용-레지스터와-동작-모드의-관계"><span class="mr-2">1.2 범용 레지스터와 동작 모드의 관계</span><a href="#12-범용-레지스터와-동작-모드의-관계" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>각 동작 모드에는 고유의 범용 레지스터 집합이 있으며, 이러한 레지스터는 동작 모드에 따라 다르게 동작합니다. 예를 들어, 슈퍼바이저 모드에서는 범용 레지스터 R13과 R14가 SVC 모드에 특화된 값으로 설정됩니다.</ul><h3 id="13-어셈블리-명령어와-동작-모드"><span class="mr-2">1.3 어셈블리 명령어와 동작 모드</span><a href="#13-어셈블리-명령어와-동작-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARM 어셈블리 명령어를 통해 동작 모드를 전환할 수 있습니다. 이러한 전환은 특히 시스템 소프트웨어나 커널을 개발할 때 중요합니다.</ul><h2 id="2-armv7-아키텍처의-동작-모드"><span class="mr-2">2. ARMv7 아키텍처의 동작 모드</span><a href="#2-armv7-아키텍처의-동작-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="21-동작-모드와-특권-레벨"><span class="mr-2">2.1 동작 모드와 특권 레벨</span><a href="#21-동작-모드와-특권-레벨" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>유저 모드(USR)</strong>: 유저 애플리케이션이 실행되는 모드로, 가장 낮은 특권 레벨(PL0)을 가집니다.<li><strong>슈퍼바이저 모드(SVC)</strong>: 운영체제의 커널이 구동되는 모드로, SVC 명령어를 통해 진입하며, 특권 레벨은 PL1입니다.<li><strong>IRQ 모드</strong>: 일반 인터럽트가 발생했을 때 진입하는 모드로, PL1 특권 레벨을 가집니다.<li><strong>FIQ 모드</strong>: 고속 인터럽트가 발생했을 때 진입하는 모드로, PL1 특권 레벨을 가집니다.<li><strong>Abort 모드(ABT)</strong>: 메모리 어보트 익셉션이 발생했을 때 진입하는 모드로, PL1 특권 레벨을 가집니다.<li><strong>Undefined 모드(UND)</strong>: 정의되지 않은 명령어가 실행될 때 진입하는 모드로, PL1 특권 레벨을 가집니다.<li><strong>System 모드(SYS)</strong>: 유저 모드의 레지스터 뷰를 공유하며 PL1에서 실행됩니다.</ul><h3 id="22-동작-모드-전환-방법"><span class="mr-2">2.2 동작 모드 전환 방법</span><a href="#22-동작-모드-전환-방법" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>동작 모드는 MSR CPSR_C 명령어를 통해 소프트웨어적으로 전환할 수 있습니다. 이 명령어는 CPSR 레지스터의 M[4:0] 비트를 수정하여 새로운 동작 모드로 전환합니다.</ul><h3 id="23-동작-모드-변경-시-주의-사항"><span class="mr-2">2.3 동작 모드 변경 시 주의 사항</span><a href="#23-동작-모드-변경-시-주의-사항" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>유저 모드(PL0)에서는 PL1 모드로의 직접적인 전환이 불가능하며, 반드시 SVC 명령어 등을 통해 익셉션을 유발해야 합니다.<li>특정 동작 모드로 전환한 후에는 해당 모드에서만 사용할 수 있는 레지스터와 특권 명령어를 활용하여 시스템을 제어할 수 있습니다.</ul><h2 id="3-armv7-동작-모드와-privilege-level특권-레벨"><span class="mr-2">3. ARMv7 동작 모드와 Privilege Level(특권 레벨)</span><a href="#3-armv7-동작-모드와-privilege-level특권-레벨" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-특권-레벨의-정의"><span class="mr-2">3.1 특권 레벨의 정의</span><a href="#31-특권-레벨의-정의" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARM 아키텍처에서 특권 레벨은 소프트웨어가 시스템 리소스에 접근할 수 있는 권한을 정의합니다. PL0부터 PL3까지의 특권 레벨이 존재하며, PL0는 유저 애플리케이션이, PL1은 운영체제 커널이 주로 사용하는 레벨입니다.</ul><h3 id="32-pl0-privilege-level-0"><span class="mr-2">3.2 PL0 (Privilege Level 0)</span><a href="#32-pl0-privilege-level-0" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>PL0는 비특권 레벨로, 유저 모드에서 애플리케이션이 실행됩니다. 이 레벨에서는 시스템 설정이나 메모리 관리에 대한 접근 권한이 제한됩니다.</ul><h3 id="33-pl1-privilege-level-1"><span class="mr-2">3.3 PL1 (Privilege Level 1)</span><a href="#33-pl1-privilege-level-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>PL1은 대부분의 시스템 소프트웨어가 실행되는 특권 레벨로, 운영체제 커널이나 인터럽트 핸들러가 이 레벨에서 동작합니다.</ul><h2 id="4-cpsr-레지스터와-동작-모드"><span class="mr-2">4. CPSR 레지스터와 동작 모드</span><a href="#4-cpsr-레지스터와-동작-모드" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="41-cpsr-레지스터란"><span class="mr-2">4.1 CPSR 레지스터란?</span><a href="#41-cpsr-레지스터란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>CPSR(Current Program Status Register)은 ARM 프로세서의 현재 상태를 나타내는 레지스터입니다. 이 레지스터는 프로세서의 동작 모드, 인터럽트 상태, 조건 플래그 등을 관리합니다.</ul><h3 id="42-cpsr-레지스터의-m40-비트"><span class="mr-2">4.2 CPSR 레지스터의 M[4:0] 비트</span><a href="#42-cpsr-레지스터의-m40-비트" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>M[4:0] 비트는 현재 동작 모드를 인코딩하여 나타냅니다. 예를 들어, 유저 모드는 0b10000 (0x10)으로, 슈퍼바이저 모드는 0b10011 (0x13)으로 설정됩니다.</ul><h3 id="43-cpsr-접근-권한"><span class="mr-2">4.3 CPSR 접근 권한</span><a href="#43-cpsr-접근-권한" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>PL0에서는 CPSR 레지스터에 직접 접근할 수 없으며, PL1 이상의 특권 레벨에서만 직접 접근이 가능합니다.</ul><h2 id="5-동작-모드-전환을-위한-어셈블리-명령어"><span class="mr-2">5. 동작 모드 전환을 위한 어셈블리 명령어</span><a href="#5-동작-모드-전환을-위한-어셈블리-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="51-msr-cpsr_c-명령어"><span class="mr-2">5.1 MSR CPSR_C 명령어</span><a href="#51-msr-cpsr_c-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>MSR CPSR_C 명령어는 CPSR 레지스터의 특정 필드를 수정하여 동작 모드를 변경하는 데 사용됩니다. 이 명령어를 사용하여 프로세서를 슈퍼바이저 모드, IRQ 모드 등으로 전환할 수 있습니다.</ul><h3 id="52-subs-및-movs-명령어"><span class="mr-2">5.2 SUBS 및 MOVS 명령어</span><a href="#52-subs-및-movs-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>SUBS PC LR 혹은 MOVS PC LR 명령어는 레지스터 값을 기반으로 동작 모드를 전환합니다. 이 명령어는 주로 익셉션 처리 루틴에서 사용됩니다.</ul><h2 id="6-리눅스-커널에서의-동작-모드-전환"><span class="mr-2">6. 리눅스 커널에서의 동작 모드 전환</span><a href="#6-리눅스-커널에서의-동작-모드-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="61-리눅스-커널의-실행-흐름"><span class="mr-2">6.1 리눅스 커널의 실행 흐름</span><a href="#61-리눅스-커널의-실행-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>리눅스 커널에서 유저 모드에서 발생한 인터럽트를 처리할 때, IRQ 모드로 진입한 후 슈퍼바이저 모드로 전환합니다. 이 과정에서 ARM 어셈블리 명령어를 사용하여 모드를 전환하고, 필요한 처리를 수행합니다.</ul><h3 id="62-리눅스-커널의-어셈블리-코드-예시"><span class="mr-2">6.2 리눅스 커널의 어셈블리 코드 예시</span><a href="#62-리눅스-커널의-어셈블리-코드-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>리눅스 커널의 setup.c 파일에서 MSR CPSR_C 명령어를 사용하여 다양한 동작 모드에서 스택 포인터를 설정하는 과정을 확인할 수 있습니다.</ul><h3 id="63-irq-모드에서-슈퍼바이저-모드로의-전환"><span class="mr-2">6.3 IRQ 모드에서 슈퍼바이저 모드로의 전환</span><a href="#63-irq-모드에서-슈퍼바이저-모드로의-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>IRQ 모드에서 인터럽트 처리 후 슈퍼바이저 모드로 진입하는 과정을 통해, 리눅스 커널이 시스템의 안정성을 어떻게 유지하는지 확인할 수 있습니다.</ul><h1 id="arm-아키텍처-익셉션-레벨-exception-levels">ARM 아키텍처: 익셉션 레벨 (Exception Levels)</h1><h2 id="1-익셉션-레벨의-핵심-개념"><span class="mr-2">1. 익셉션 레벨의 핵심 개념</span><a href="#1-익셉션-레벨의-핵심-개념" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="11-익셉션-레벨이란"><span class="mr-2">1.1 익셉션 레벨이란?</span><a href="#11-익셉션-레벨이란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>익셉션 레벨(Exception Level, EL)은 ARM 프로세서에서 소프트웨어가 실행되는 권한 수준(Privilege Level)을 정의합니다.<li>ARMv8 아키텍처는 EL0에서 EL3까지의 4가지 익셉션 레벨을 제공합니다.<ul><li><strong>EL0</strong>: 일반 애플리케이션이 실행되는 비특권(Unprivileged) 모드.<li><strong>EL1</strong>: 운영체제 커널(OS Kernel)과 같은 특권(Privileged) 모드.<li><strong>EL2</strong>: 하이퍼바이저(Hypervisor) 모드로, 가상화를 지원하는 특권 레벨.<li><strong>EL3</strong>: 시큐어 모니터(Secure Monitor) 모드로, 시스템의 가장 높은 특권을 가지며, 시큐어 상태와 논 시큐어 상태 간 전환을 담당.</ul></ul><h3 id="12-익셉션-레벨을-알아야-하는-이유"><span class="mr-2">1.2 익셉션 레벨을 알아야 하는 이유</span><a href="#12-익셉션-레벨을-알아야-하는-이유" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ARMv8 아키텍처를 제대로 이해하기 위해서는 익셉션 레벨에 대한 이해가 필수적입니다.<li>익셉션 레벨은 시스템의 보안 및 가상화 기술을 구현하는 데 중요한 역할을 합니다.<li>특히, 트러스트존(TrustZone)과 하이퍼바이저 등의 기능은 각각 EL3와 EL2에서 실행됩니다.</ul><h2 id="2-익셉션-레벨과-privilege-level"><span class="mr-2">2. 익셉션 레벨과 Privilege Level</span><a href="#2-익셉션-레벨과-privilege-level" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="21-privilege-level이란"><span class="mr-2">2.1 Privilege Level이란?</span><a href="#21-privilege-level이란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>Privilege Level(PL)은 메모리, 명령어, 레지스터 등에 접근할 수 있는 권한을 의미합니다.<li>각 익셉션 레벨은 특정 Privilege Level을 가지며, 이 권한에 따라 시스템 자원에 대한 접근이 결정됩니다.</ul><h3 id="22-익셉션-레벨과-관련된-소프트웨어-스택"><span class="mr-2">2.2 익셉션 레벨과 관련된 소프트웨어 스택</span><a href="#22-익셉션-레벨과-관련된-소프트웨어-스택" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>EL0</strong>: 애플리케이션이 실행됩니다.<li><strong>EL1</strong>: 리눅스 커널 또는 RTOS 커널이 실행됩니다.<li><strong>EL2</strong>: 하이퍼바이저가 실행되며, 가상화된 환경에서 여러 운영체제를 관리합니다.<li><strong>EL3</strong>: 시큐어 모니터가 실행되며, 보안 상태 전환을 관리합니다.</ul><h2 id="3-익셉션-레벨-전환"><span class="mr-2">3. 익셉션 레벨 전환</span><a href="#3-익셉션-레벨-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="31-높은-익셉션-레벨로-전환"><span class="mr-2">3.1 높은 익셉션 레벨로 전환</span><a href="#31-높은-익셉션-레벨로-전환" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>익셉션(예: 인터럽트, 시스템 호출)이 발생하면, 프로세서는 높은 익셉션 레벨로 전환하여 이를 처리합니다.<li>이 과정에서 시스템의 안정성과 보안을 유지하기 위해 각 레벨에서 적절한 처리가 이루어집니다.</ul><h3 id="32-낮은-익셉션-레벨로-복귀"><span class="mr-2">3.2 낮은 익셉션 레벨로 복귀</span><a href="#32-낮은-익셉션-레벨로-복귀" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>익셉션 처리 후, 프로세서는 원래 실행 중이던 코드로 복귀하기 위해 낮은 익셉션 레벨로 돌아갑니다.<li>복귀 과정은 SPSR_ELx 및 ELR_ELx 레지스터를 설정하고, ERET 명령어를 실행함으로써 이루어집니다.</ul><h2 id="4-익셉션-레벨과-pstate"><span class="mr-2">4. 익셉션 레벨과 PSTATE</span><a href="#4-익셉션-레벨과-pstate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="41-pstate란"><span class="mr-2">4.1 PSTATE란?</span><a href="#41-pstate란" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>PSTATE는 프로세서의 상태를 나타내는 레지스터로, 현재 익셉션 레벨(CurrentEL)을 포함한 여러 상태 정보를 관리합니다.<li><strong>CurrentEL 시스템 레지스터</strong>: 현재 익셉션 레벨을 확인할 수 있는 레지스터입니다.</ul><h3 id="42-pstate와-익셉션-레벨-읽기"><span class="mr-2">4.2 PSTATE와 익셉션 레벨 읽기</span><a href="#42-pstate와-익셉션-레벨-읽기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>MRS 명령어를 사용하여 CurrentEL 레지스터에서 현재 익셉션 레벨을 읽어올 수 있습니다.<li>이러한 정보는 디버깅 및 시스템 상태를 확인하는 데 유용합니다.</ul><h2 id="5-익셉션-레벨-관련-어셈블리-명령어"><span class="mr-2">5. 익셉션 레벨 관련 어셈블리 명령어</span><a href="#5-익셉션-레벨-관련-어셈블리-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="51-svc-hvc-smc-명령어"><span class="mr-2">5.1 SVC, HVC, SMC 명령어</span><a href="#51-svc-hvc-smc-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>SVC</strong>: EL0에서 EL1로 익셉션 레벨을 변경합니다.<li><strong>HVC</strong>: EL1에서 EL2로 익셉션 레벨을 변경합니다.<li><strong>SMC</strong>: EL1에서 EL3로 익셉션 레벨을 변경합니다.</ul><h3 id="52-eret-명령어"><span class="mr-2">5.2 ERET 명령어</span><a href="#52-eret-명령어" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>ERET 명령어는 익셉션을 처리한 후, 원래의 익셉션 레벨로 복귀합니다.<li>이 명령어는 익셉션 처리 루틴에서 사용되며, PSTATE와 ELR_ELx 레지스터를 이용해 원래의 코드 실행 위치로 복귀합니다.</ul><h2 id="6-익셉션-레벨에-따른-실행-흐름"><span class="mr-2">6. 익셉션 레벨에 따른 실행 흐름</span><a href="#6-익셉션-레벨에-따른-실행-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="61-애플리케이션에서-하이퍼바이저까지"><span class="mr-2">6.1 애플리케이션에서 하이퍼바이저까지</span><a href="#61-애플리케이션에서-하이퍼바이저까지" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li><strong>EL0</strong>: 유저 애플리케이션이 실행되는 비특권 모드.<li><strong>EL1</strong>: 시스템 자원에 접근할 수 있는 커널 모드.<li><strong>EL2</strong>: 가상화 환경을 관리하는 하이퍼바이저 모드.<li><strong>EL3</strong>: 시스템의 가장 높은 특권을 가지며, 보안과 관련된 작업을 수행하는 시큐어 모니터 모드.</ul><h3 id="62-익셉션-처리의-전체-흐름"><span class="mr-2">6.2 익셉션 처리의 전체 흐름</span><a href="#62-익셉션-처리의-전체-흐름" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>시스템에서 발생하는 모든 익셉션은 익셉션 벡터 테이블에 의해 관리되며, 각 익셉션 레벨에 대응하는 핸들러가 처리합니다.</ul><hr /><p>이 문서는 ARM 아키텍처의 익셉션 레벨에 대해 깊이 있는 설명을 제공하며, 시스템 소프트웨어 개발자가 익셉션 레벨을 이해하고 효과적으로 활용할 수 있도록 돕습니다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/embedded-engineering/'>Embedded Engineering</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/embedded-engineering/" class="post-tag no-text-decoration" >Embedded Engineering</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=ARM+%EA%B0%95%EC%9D%98+%28Arm+%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98+%EA%B5%AC%EC%A1%B0%EC%99%80+%EC%9B%90%EB%A6%AC%29+-+DK%27s+Software+Engineering+Knowledge+Storage&url=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Arm-%25EC%2595%2584%25ED%2582%25A4%25ED%2585%258D%25EC%25B2%2598%25EC%259D%2598-%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580-%25EC%259B%2590%25EB%25A6%25AC%29%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=ARM+%EA%B0%95%EC%9D%98+%28Arm+%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98+%EA%B5%AC%EC%A1%B0%EC%99%80+%EC%9B%90%EB%A6%AC%29+-+DK%27s+Software+Engineering+Knowledge+Storage&u=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Arm-%25EC%2595%2584%25ED%2582%25A4%25ED%2585%258D%25EC%25B2%2598%25EC%259D%2598-%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580-%25EC%259B%2590%25EB%25A6%25AC%29%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=%2Fposts%2FARM-%25EA%25B0%2595%25EC%259D%2598%28Arm-%25EC%2595%2584%25ED%2582%25A4%25ED%2585%258D%25EC%25B2%2598%25EC%259D%2598-%25EA%25B5%25AC%25EC%25A1%25B0%25EC%2599%2580-%25EC%259B%2590%25EB%25A6%25AC%29%2F&text=ARM+%EA%B0%95%EC%9D%98+%28Arm+%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98+%EA%B5%AC%EC%A1%B0%EC%99%80+%EC%9B%90%EB%A6%AC%29+-+DK%27s+Software+Engineering+Knowledge+Storage" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/STL_MAP/">STL_Map</a><li><a href="/posts/STL_Priority_Queue/">STL_Priority_Queue</a><li><a href="/posts/STL_Vector/">STL_Vector</a><li><a href="/posts/STL_String/">STL_String</a><li><a href="/posts/STL_Queue/">STL_Queue</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/bfs/">BFS</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/embedded-engineering/">Embedded Engineering</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/container/">Container</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EC%97%90%EC%96%B4%EC%BB%A8-%EC%9E%90%EB%8F%99-%EC%A0%9C%EC%96%B4/"><div class="card-body"> <em class="small" data-ts="1747494000" data-df="YYYY-MM-DD" > 2025-05-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>아두이노 에어컨 자동 제어</h3><div class="text-muted small"><p> [아두이노] 에어컨 자동 제어 아두이노를 활용하여 에어컨의 리모컨 신호를 복사하고, 원하는 시간에 자동으로 송신하여 에어컨을 제어하는 프로젝트를 진행할 수 있다. 이를 위해 필요한 부품, 회로 연결 방법, 아두이노 코드 예제, 그리고 시간 기반 제어 방법을 자세히 설명한다. 1. 필요한 부품 아두이노 보드 (Arduino Uno, ATmeg...</p></div></div></a></div><div class="card"> <a href="/posts/Embedded_OS-%EA%B0%9C%EB%B0%9C/"><div class="card-body"> <em class="small" data-ts="1663513200" data-df="YYYY-MM-DD" > 2022-09-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Embedded OS 개발</h3><div class="text-muted small"><p> Embedded OS 개발 프로젝트 1장. 임베디드 운영체제 임베디드 운영체제와 펌웨어 임베디드 운영체제는 임베디드 시스템에서 동작하는 펌웨어의 일종으로서 하드웨어 성능이 일정 수준으로 올라온 현재 임베디드 장치에도 임베디드 운영체제를 많이 사용하고 있다. 펌웨어란 임베디드 운영체제 유무에 상관없이 임베디드 시스템 용 전체 소프트웨어를 지칭한다...</p></div></div></a></div><div class="card"> <a href="/posts/FreeRTOS-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/"><div class="card-body"> <em class="small" data-ts="1671462000" data-df="YYYY-MM-DD" > 2022-12-20 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>FreeRTOS 내용정리</h3><div class="text-muted small"><p> FreeRTOS 내용정리 Task 태스크는 가상의 CPU를 각자 가지고 있는 것처럼 동작한다.(Time Division) 태스크 간에는 커널 서비스인 Inter Process Communication 방법을 사용하여 통신한다. Round Robin 스케쥴링 모든 태스크들이 CPU 자원을 공평하게 나누어 사용하는 개념 각 태스크...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/ARM-%EA%B0%95%EC%9D%98(%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B0%98%EB%8F%84%EC%B2%B4%EC%99%80-%EC%A0%84%EA%B8%B0-%EC%9E%90%EB%8F%99%EC%B0%A8-%EC%A4%91%EC%8B%AC)/" class="btn btn-outline-primary" prompt="이전 글"><p>ARM 강의(시스템 반도체와 전기 자동차 중심)</p></a> <a href="/posts/C++-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/" class="btn btn-outline-primary" prompt="다음 글"><p>C++ 알고리즘 정리</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/username">DK</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">일부 권리 보유</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/codingtest/">CodingTest</a> <a class="post-tag" href="/tags/bfs/">BFS</a> <a class="post-tag" href="/tags/simulation/">simulation</a> <a class="post-tag" href="/tags/dp/">DP</a> <a class="post-tag" href="/tags/dfs/">DFS</a> <a class="post-tag" href="/tags/embedded-engineering/">Embedded Engineering</a> <a class="post-tag" href="/tags/algorithm/">Algorithm</a> <a class="post-tag" href="/tags/stl/">STL</a> <a class="post-tag" href="/tags/container/">Container</a> <a class="post-tag" href="/tags/python/">python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">새 버전의 콘텐츠를 사용할 수 있습니다.</p><button type="button" class="btn btn-primary" aria-label="Update"> 업데이트 </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
