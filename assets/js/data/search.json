[ { "title": "꿀꿀이 축제", "url": "/posts/%EA%BF%80%EA%BF%80%EC%9D%B4-%EC%B6%95%EC%A0%9C/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2026-01-10 00:00:00 +0900", "snippet": "꿀꿀이 축제문제N개의 마을에 꿀꿀이들이 한 마리씩 살고 있다.이 N마리의 꿀꿀이들이 X (1 ≤ X ≤ N)번 마을에 모여 축제를 열기로 했다. 마을 사이에는 총 M개의 단방향 도로들이 있고 i번 길을 걸어서 통과하는데 Ti(1 ≤ Ti ≤ 100)의 시간이 소비된다.각 꿀꿀이들은 파티에 참석하기 위해 X번 마을까지 걸어가서 축제를 즐긴 후 다시 자신의 마을로 돌아온다.걷는 것이 힘든 꿀꿀이들은 가능한 짧은 시간에 오고 가기를 원한다.도로들은 단방향이기 때문에 꿀꿀이들이 오고 가는 길이 다를 수 있다.N마리의 꿀꿀이들 중 오고 가는데 가장 많은 시간이 걸리는 꿀꿀이의 소요시간을 구하시오.입력첫째 줄에 N(1 &lt;= N &lt;= 1,000), M(1 &lt;= M &lt;= 10,000), X가 공백으로 구분되어 입력된다.두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다.출력첫 번째 줄에 N명의 꿀꿀이들 중 오고 가는데 가장 오래 걸리는 꿀꿀이의 소요시간을 출력한다풀이 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #include &lt;climits&gt; #define ARR_MAX_LEN 1001 using namespace std; typedef struct{ int pos; int cost; }data_t; struct compare{ bool operator()(const data_t &amp;a, const data_t &amp;b) const{ return a.cost &gt; b.cost; } }; int N, M, X; vector&lt;data_t&gt; graph[ARR_MAX_LEN]; vector&lt;data_t&gt; rgraph[ARR_MAX_LEN]; int dist[ARR_MAX_LEN] = { 0 }; int rdist[ARR_MAX_LEN] = { 0 }; void input(void) { cin &gt;&gt; N &gt;&gt; M &gt;&gt; X; for(int i = 0; i &lt; M; i++){ int start, end, time; cin &gt;&gt; start &gt;&gt; end &gt;&gt; time; graph[start].push_back({end, time}); rgraph[end].push_back({start, time}); } } void dijkstra(int *pdist, vector&lt;data_t&gt; *pgraph) { priority_queue&lt;data_t, vector&lt;data_t&gt;, compare&gt; pq; for(int i = 0; i &lt;= N; i++) pdist[i] = INT_MAX; pdist[X] = 0; pq.push({X, 0}); while(!pq.empty()){ data_t cur_data = pq.top(); int cur_pos = cur_data.pos; int cur_cost = cur_data.cost; pq.pop(); // 갱신된 최소 거리가 아닐 경우 skip if(cur_cost != pdist[cur_pos]) continue; for(auto&amp; next_data : pgraph[cur_pos]){ int next_pos = next_data.pos; int next_cost = pdist[cur_pos] + next_data.cost; if(next_cost &lt; pdist[next_pos]){ pdist[next_pos] = next_cost; pq.push({next_pos, next_cost}); } } } } int main(void) { int answer = INT_MIN; ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); // 왕복거리를 각각 graph 에 업데이트 해둔 값을 바탕으로 계산 dijkstra(dist, graph); dijkstra(rdist, rgraph); // 왕복이 가능하고, 왕복 거리 중 가장 큰 값을 정답 값으로 저장하고 출력 for(int i = 1; i &lt;= N; i++){ if (i == X) continue; if((dist[i] != INT_MAX &amp;&amp; rdist[i] != INT_MAX) &amp;&amp; ((dist[i] + rdist[i]) &gt; answer)) answer = (dist[i] + rdist[i]); } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0; }" }, { "title": "등산로 찾기", "url": "/posts/%EB%93%B1%EC%82%B0%EB%A1%9C-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2026-01-09 00:00:00 +0900", "snippet": "등산로 찾기문제N × N 행렬로 지형도가 표시된 산이 있다.행렬의 각 원소 값은 해당 위치의 높이(양의 정수)를 의미한다.등산가들은 산의 바깥 지역(높이 0)에서 출발하여 정상에 도달하기 위한 가장 경제적인 루트를 찾으려고 한다.경제적인 경로란 정상까지 올라가는데 필요한 힘의 총합이 최소가 되는 경로를 의미한다.산의 바깥 지역은 행렬 밖의 모든 위치이며, 높이는 모두 0이라고 가정한다.출발 위치는 바깥 지역 어디든 가능하다.이동 규칙등산가는 현재 위치에서 상, 하, 좌, 우 4방향 인접한 위치로만 이동할 수 있다.현재 위치의 높이를 h1, 이동할 위치의 높이를 h2라고 할 때,이동에 필요한 힘은 다음과 같이 계산된다.1. 평지 이동 (같은 높이) 조건: h1 = h2 필요한 힘: 02. 내리막 이동 조건: h1 &gt; h2 필요한 힘: h1 - h2예시높이 5에서 높이 3으로 이동하면 필요한 힘은 2이다.3. 오르막 이동 조건: h1 &lt; h2 필요한 힘: (h2 - h1)²예시높이 2에서 높이 4로 이동하면 필요한 힘은 4이다.입력 첫 줄: 산의 크기 N 둘째 줄: 정상의 위치 i, j 다음 N줄: 산의 지형을 나타내는 N × N 행렬제한 조건 N ≤ 100 각 지형의 최대 높이 ≤ 50 바깥 지역의 높이는 0으로 가정한다출력정상까지 도달하는 가장 경제적인 경로를 따라 이동할 때 사용되는최소 힘의 합을 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define ARR_MAX_LEN 105using namespace std;typedef struct{ int y; int x; int cost;}data_t;struct compare{ bool operator()(const data_t&amp; a, const data_t&amp; b) const { return a.cost &gt; b.cost; // min-heap }};int N;int mount[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int dist[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };int topy, topx;void input(void){ cin &gt;&gt; N; cin &gt;&gt; topy &gt;&gt; topx; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ cin &gt;&gt; mount[i][j]; } }}int dijkstra(int sy, int sx){ priority_queue&lt;data_t, vector&lt;data_t&gt;, compare&gt; pq; for(int i = 0; i &lt;= N + 1; i++){ for(int j = 0; j &lt;= N + 1; j++){ dist[i][j] = INT_MAX; } } dist[sy][sx] = 0; pq.push({sy, sx, 0}); while(!pq.empty()){ data_t cur = pq.top(); pq.pop(); int cy = cur.y; int cx = cur.x; int ccost = cur.cost; if(ccost &gt; dist[cy][cx]) continue; // 경계 바깥 좌표로 벗어나면 종료 if(cy &lt; 1 || cy &gt; N || cx &lt; 1 || cx &gt; N) return ccost; for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; // diff/cost 정의 (다익스트라 임으로 음수 가중치가 나오지 않도록 함) int diff = mount[cy][cx] - mount[ny][nx]; int ncost = (diff &gt; 0) ? (diff * diff) : diff * -1; if(dist[ny][nx] &gt; dist[cy][cx] + ncost){ dist[ny][nx] = dist[cy][cx] + ncost; pq.push({ny, nx, dist[ny][nx]}); } } } return -1;}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); cout &lt;&lt; dijkstra(topy, topx) &lt;&lt; \"\\n\"; return 0;}" }, { "title": "지하철", "url": "/posts/%EC%A7%80%ED%95%98%EC%B2%A0/", "categories": "CodingTest", "tags": "CodingTest, Floyd Warshall", "date": "2026-01-03 00:00:00 +0900", "snippet": "지하철문제 설명지방에서 서울로 관광을 온 도훈이는 지하철 노선을 보고 깜짝 놀랐다.노선이 매우 복잡하게 얽혀 있어, 잘못 이동하면 10분이면 갈 수 있는 거리를 1시간이나 돌아서 가는 상황이 발생할 수 있었다.어쩔 수 없이 도훈이는 현재 숙소가 있는 역(1번 역)에서 관광할 목적지 역까지가장 짧은 시간에 도착할 수 있는 경로와 소요 시간을 표로 정리하려고 한다.다음 조건이 주어진다.각 지하철역에는 관광지가 있다.지하철을 갈아타는 데 걸리는 시간은 없다고 가정한다.역과 역 사이의 이동 시간은 모두 주어진다.입력첫 줄에 두 개의 정수 N과 M이 주어진다.N은 지하철역의 개수이다. (3 ≤ N ≤ 100)M은 도착하고자 하는 목적역의 번호이다. (1 ≤ M ≤ N)다음 N개의 줄에는 각각 N개의 정수가 주어진다.i번째 줄의 j번째 수 Sij는i번 역에서 j번 역까지 이동하는 데 걸리는 시간이다.i = j 인 경우 항상 0이다.이동 시간 Sij는 0 이상 100 이하의 정수이다.1번 역이 도훈이의 숙소가 있는 출발역이다.출력목적역 M까지 이동하는 데 걸리는 최소 시간을 출력한다.풀이#include &lt;iostream&gt;#include &lt;climits&gt;#define ARR_MAX_LEN 101using namespace std;int N, M;// timemap[i][j] : i번 역에서 j번 역까지 걸리는 최소 시간int timemap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// path[i][j] : i → j 최단경로에서의 중간 경유 정점// 경유지가 없으면 0int path[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };void input(void){ cin &gt;&gt; N &gt;&gt; M; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ cin &gt;&gt; timemap[i][j]; } }}void floydwarshall(void){ for(int k = 1; k &lt;= N; k++){ for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ if(timemap[i][j] &gt; timemap[i][k] + timemap[k][j]){ timemap[i][j] = timemap[i][k] + timemap[k][j]; path[i][j] = k; } } } }}void trace(int start, int end){ // 중간 경유지가 없으면 start를 출력 if(path[start][end] == 0){ cout &lt;&lt; start &lt;&lt; \" \"; return ; } // start → mid → end 로 경로를 분리 int mid = path[start][end]; // start → mid 경로 출력 trace(start, mid); // mid → end 경로 출력 trace(mid, end);}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); floydwarshall(); // 목적역까지 가는 최단 거리 cout &lt;&lt; timemap[1][M] &lt;&lt; \"\\n\"; // 목적지까지의 경로 출력 trace(1, M); cout &lt;&lt; M &lt;&lt; \"\\n\"; return 0;};" }, { "title": "Algorithm_Floyd Warshall", "url": "/posts/Algorithm_Floyd-Warshall/", "categories": "CodingTest", "tags": "CodingTest, Floyd Warshall", "date": "2026-01-03 00:00:00 +0900", "snippet": "Algorithm_Floyd Warshall1. 개요플루이드 와샬(Floyd–Warshall) 알고리즘은그래프에서 모든 정점 쌍(All-Pairs) 사이의 최단 거리를 구하는 알고리즘이다. 모든 정점 → 모든 정점 음수 가중치 허용 음수 사이클 탐지 가능 동적 계획법(DP, Dynamic Programming) 기반2. 언제 사용하는가다음 조건일 때 적합하다. 정점 개수 N이 작을 때 (보통 N ≤ 400) 모든 쌍 최단 거리가 필요할 때 그래프가 조밀(Dense)할 때 음수 간선이 존재할 수 있을 때다익스트라(Dijkstra)는 단일 출발점(Single Source)에 적합하고,플루이드 와샬은 전역 최단 경로 문제에 적합하다.3. 핵심 아이디어정점 k를 중간 경유지로 사용할 수 있는지 여부를 기준으로최단 거리를 점진적으로 갱신한다.i → j 최단 경로는 기존 i → j i → k → j중 더 짧은 것을 선택한다.4. 점화식dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])k를 1부터 N까지 확장하며 적용한다.5. 알고리즘 구조3중 반복문 구조 k : 경유 정점 i : 출발 정점 j : 도착 정점반드시 k → i → j 순서를 유지해야 한다.6. 시간 / 공간 복잡도 시간 복잡도: O(N³) 공간 복잡도: O(N²)7. 기본 구현 (C++)#include &lt;iostream&gt;#include &lt;climits&gt;using namespace std;#define INF 1000000000#define MAXN 401int dist[MAXN][MAXN];int N, M;int main() { cin &gt;&gt; N &gt;&gt; M; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ if(i == j) dist[i][j] = 0; else dist[i][j] = INF; } } for(int i = 0; i &lt; M; i++){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; dist[a][b] = min(dist[a][b], c); } for(int k = 1; k &lt;= N; k++){ for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ if(dist[i][k] + dist[k][j] &lt; dist[i][j]){ dist[i][j] = dist[i][k] + dist[k][j]; } } } } return 0;}8. 음수 사이클 탐지 dist[i][i] &lt; 0 인 정점이 존재하면 음수 사이클이 존재한다.9. 요약 모든 쌍 최단 경로 알고리즘 O(N³) 복잡도 음수 간선, 음수 사이클 처리 가능 정점 수가 작을 때 매우 강력" }, { "title": "숨바꼭질 3", "url": "/posts/%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88-3/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2026-01-02 00:00:00 +0900", "snippet": "숨바꼭질 3https://www.acmicpc.net/problem/13549문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.풀이#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define ARR_MAX_LEN 100001#define MAX_NUM 100000using namespace std;typedef struct{ int pos; int time;}info_t;struct less_compare{ bool operator()(const info_t &amp;a, const info_t &amp;b) const{ return a.time &gt; b.time; // min-heap }};int N, K;int time_arr[ARR_MAX_LEN];void input(void){ cin &gt;&gt; N &gt;&gt; K; for(int i = 0; i &lt;= MAX_NUM; i++) time_arr[i] = INT_MAX;}void bfs(int start){ priority_queue&lt;info_t, vector&lt;info_t&gt;, less_compare&gt; pq; pq.push({start, 0}); time_arr[start] = 0; while(!pq.empty()){ info_t cur = pq.top(); pq.pop(); int cur_pos = cur.pos; int cur_time = cur.time; if(cur_time &gt; time_arr[cur_pos]) continue; // 목표 위치 찾으면 탐색 종료 if(cur_pos == K) return; // cur_pos - 1 (cost 1) if(cur_pos &gt; 0){ int npos = cur_pos - 1; int ntime = cur_time + 1; if(time_arr[npos] &gt; ntime){ time_arr[npos] = ntime; pq.push({npos, ntime}); } } // cur_pos + 1 (cost 1) if(cur_pos + 1 &lt;= MAX_NUM){ int npos = cur_pos + 1; int ntime = cur_time + 1; if(time_arr[npos] &gt; ntime){ time_arr[npos] = ntime; pq.push({npos, ntime}); } } // cur_pos * 2 (cost 0) if(cur_pos * 2 &lt;= MAX_NUM){ int npos = cur_pos * 2; int ntime = cur_time; if(time_arr[npos] &gt; ntime){ time_arr[npos] = ntime; pq.push({npos, ntime}); } } }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); bfs(N); cout &lt;&lt; time_arr[K] &lt;&lt; \"\\n\"; return 0;}" }, { "title": "간선 이어가기 2", "url": "/posts/%EA%B0%84%EC%84%A0-%EC%9D%B4%EC%96%B4%EA%B0%80%EA%B8%B0-2/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2026-01-02 00:00:00 +0900", "snippet": "간선 이어가기 2https://www.acmicpc.net/problem/14284문제정점 n개, 0개의 간선으로 이루어진 무방향 그래프가 주어진다. 그리고 m개의 가중치 간선의 정보가 있는 간선리스트가 주어진다. 간선리스트에 있는 간선 하나씩 그래프에 추가해 나갈 것이다. 이때, 특정 정점 s와 t가 연결이 되는 시점에서 간선 추가를 멈출 것이다. 연결이란 두 정점이 간선을 통해 방문 가능한 것을 말한다.s와 t가 연결이 되는 시점의 간선의 가중치의 합이 최소가 되게 추가하는 간선의 순서를 조정할 때, 그 최솟값을 구하시오.입력첫째 줄에 정점의 개수 n, 간선리스트의 간선 수 m이 주어진다.(2≤n≤5000,1≤m≤100,000)다음 m줄에는 a,b,c가 주어지는데, 이는 a와 b는 c의 가중치를 가짐을 말한다. (1≤a,b≤n,1≤c≤100,a≠b)다음 줄에는 두 정점 s,t가 주어진다. (1≤s,t≤n,s≠t)모든 간선을 연결하면 그래프는 연결 그래프가 됨이 보장된다.출력s와 t가 연결되는 시점의 간선의 가중치 합의 최솟값을 출력하시오,풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define MAX_LINE_NUM 100001using namespace std;typedef struct{ int dest; int weight;}info_t;struct compare_less{ bool operator()(const info_t&amp; a, const info_t&amp; b) const{ return a.weight &gt; b.weight; }};int n, m, s, t;vector&lt;info_t&gt; graph[MAX_LINE_NUM];int dist[MAX_LINE_NUM] = { 0 };void input(void){ cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++){ int a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; graph[a].push_back({b, c}); graph[b].push_back({a, c}); } cin &gt;&gt; s &gt;&gt; t;}void dijkstra(int start){ priority_queue&lt;info_t, vector&lt;info_t&gt;, compare_less&gt; pq; // 정점 모든 거리 초기화 for(int i = 1; i &lt;= n; i++) dist[i] = INT_MAX; dist[start] = 0; pq.push({start, 0}); while(!pq.empty()){ info_t cur_info = pq.top(); int cur_dest = cur_info.dest; int cur_weight = cur_info.weight; pq.pop(); // 목표 위치 간선이 연결되면 가중치 최소값 출력 if(cur_dest == t){ cout &lt;&lt; dist[t] &lt;&lt; \"\\n\"; return ; } if(cur_weight &gt; dist[cur_dest]) continue; for(auto&amp; next_info : graph[cur_dest]){ int next_dest = next_info.dest; int next_weight = dist[cur_dest] + next_info.weight; if(next_weight &lt; dist[next_dest]){ dist[next_dest] = next_weight; pq.push({next_dest, next_weight}); } } }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); dijkstra(s); return 0;}" }, { "title": "최소 비용 구하기", "url": "/posts/%ED%83%9D%EB%B0%B0-%EB%B0%B0%EC%86%A1/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2025-12-28 00:00:00 +0900", "snippet": "최소 비용 구하기https://www.acmicpc.net/problem/5972문제농부 현서는 농부 찬홍이에게 택배를 배달해줘야 합니다. 그리고 지금, 갈 준비를 하고 있습니다. 평화롭게 가려면 가는 길에 만나는 모든 소들에게 맛있는 여물을 줘야 합니다. 물론 현서는 구두쇠라서 최소한의 소들을 만나면서 지나가고 싶습니다.농부 현서에게는 지도가 있습니다. N (1 &lt;= N &lt;= 50,000) 개의 헛간과, 소들의 길인 M (1 &lt;= M &lt;= 50,000) 개의 양방향 길이 그려져 있고, 각각의 길은 C_i (0 &lt;= C_i &lt;= 1,000) 마리의 소가 있습니다. 소들의 길은 두 개의 떨어진 헛간인 A_i 와 B_i (1 &lt;= A_i &lt;= N; 1 &lt;= B_i &lt;= N; A_i != B_i)를 잇습니다. 두 개의 헛간은 하나 이상의 길로 연결되어 있을 수도 있습니다. 농부 현서는 헛간 1에 있고 농부 찬홍이는 헛간 N에 있습니다.다음 지도를 참고하세요. [2]--- / | \\ /1 | \\ 6 / | \\ [1] 0| --[3] \\ | / \\2 4\\ | /4 [6] \\ | / /1 [4]-----[5] 3농부 현서가 선택할 수 있는 최선의 통로는 1 -&gt; 2 -&gt; 4 -&gt; 5 -&gt; 6 입니다. 왜냐하면 여물의 총합이 1 + 0 + 3 + 1 = 5 이기 때문입니다.농부 현서의 지도가 주어지고, 지나가는 길에 소를 만나면 줘야할 여물의 비용이 주어질 때 최소 여물은 얼마일까요? 농부 현서는 가는 길의 길이는 고려하지 않습니다.입력첫째 줄에 N과 M이 공백을 사이에 두고 주어집니다.둘째 줄부터 M+1번째 줄까지 세 개의 정수 A_i, B_i, C_i가 주어집니다.출력첫째 줄에 농부 현서가 가져가야 될 최소 여물을 출력합니다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define ARR_MAX_LEN 50001using namespace std;typedef struct{ int dest; int cow_num;}edge_t;struct compare{ bool operator()(const edge_t &amp;a, const edge_t&amp; b) const{ return a.cow_num &gt; b.cow_num; }};int N, M;int dist[ARR_MAX_LEN] = { 0 };vector&lt;edge_t&gt; graph[ARR_MAX_LEN];void input(void){ cin &gt;&gt; N &gt;&gt; M; for(int i = 0; i &lt; M; i++){ int A, B, C; cin &gt;&gt; A &gt;&gt; B &gt;&gt; C; graph[A].push_back({B, C}); graph[B].push_back({A, C}); }}void dijkstra(int start){ priority_queue&lt;edge_t, vector&lt;edge_t&gt;, compare&gt; pq; dist[start] = 0; pq.push({start, 0}); while(!pq.empty()){ edge_t cur_node = pq.top(); pq.pop(); if(dist[cur_node.dest] &lt; cur_node.cow_num) continue; for(auto &amp; next_node : graph[cur_node.dest]){ int next_dest = next_node.dest; int next_cow_num = dist[cur_node.dest] + next_node.cow_num; if(next_cow_num &lt; dist[next_dest]){ dist[next_dest] = next_cow_num; pq.push({next_dest, next_cow_num}); } } }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for(int i = 0; i &lt;= N; i++) dist[i] = INT_MAX; dijkstra(1); cout &lt;&lt; dist[N] &lt;&lt; \"\\n\"; return 0;}" }, { "title": "최소 비용 구하기", "url": "/posts/%EC%B5%9C%EC%86%8C-%EB%B9%84%EC%9A%A9-%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2025-12-27 00:00:00 +0900", "snippet": "최소 비용 구하기https://www.acmicpc.net/problem/1916문제N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.입력첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.출력첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define CITY_NUM_MAX 1001using namespace std;typedef struct{ int dest; int cost;}edge_t;struct compare{ bool operator()(const edge_t&amp; a, const edge_t&amp; b) const{ return a.cost &gt; b.cost; }};int N, M;int query_start, query_dest;int dist[CITY_NUM_MAX];vector&lt;edge_t&gt; graph[CITY_NUM_MAX];void input(void){ cin &gt;&gt; N &gt;&gt; M; for(int i= 0; i &lt; M; i++){ int start, dest, cost; cin &gt;&gt; start &gt;&gt; dest &gt;&gt; cost; graph[start].push_back({dest, cost}); } cin &gt;&gt; query_start &gt;&gt; query_dest;}void dijkstra(int start){ priority_queue&lt;edge_t, vector&lt;edge_t&gt;, compare&gt; pq; pq.push({start, 0}); dist[start] = 0; while(!pq.empty()){ edge_t curr_edge = pq.top(); pq.pop(); if(curr_edge.cost &gt; dist[curr_edge.dest]) continue; for(auto &amp;next_edge : graph[curr_edge.dest]){ int next_dest = next_edge.dest; int next_cost = dist[curr_edge.dest] + next_edge.cost; if(next_cost &lt; dist[next_edge.dest]){ pq.push({next_dest, next_cost}); dist[next_dest] = next_cost; } } }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for(int i = 0; i &lt;= N; i++) dist[i] = INT_MAX; dijkstra(query_start); cout &lt;&lt; dist[query_dest] &lt;&lt; \"\\n\"; return 0;}x" }, { "title": "최단 경로", "url": "/posts/%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2025-12-25 00:00:00 +0900", "snippet": "최단 경로https://www.acmicpc.net/problem/1753문제방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.입력첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.출력첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define MAX_LEN 20001using namespace std;typedef struct{ int dest; int weight;}edge_t;struct compare{ bool operator()(const edge_t&amp; a, const edge_t&amp; b) const { return a.weight &gt; b.weight; }};int V, E, K;vector&lt;edge_t&gt; graph[MAX_LEN];int dist[MAX_LEN] = { 0 };void input(){ cin &gt;&gt; V &gt;&gt; E; cin &gt;&gt; K; for(int i = 0; i &lt; E; i++){ int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; graph[u].push_back({v, w}); }}void dijkstra(int start){ priority_queue&lt;edge_t, vector&lt;edge_t&gt;, compare&gt; pq; pq.push({start, 0}); dist[start] = 0; while(!pq.empty()){ edge_t cur_node = pq.top(); pq.pop(); int cur_dest = cur_node.dest; int cur_weight = cur_node.weight; if(cur_weight &gt; dist[cur_dest]) continue; for(auto &amp;next_node : graph[cur_dest]){ int next_dest = next_node.dest; int next_weight = dist[cur_dest] + next_node.weight; if(next_weight &lt; dist[next_dest]){ pq.push({next_dest, next_weight}); dist[next_dest] = next_weight; } } }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for(int i = 1; i &lt; MAX_LEN; i++){ dist[i] = INT_MAX; } dijkstra(K); for(int i = 1 ; i &lt;= V; i++){ if(dist[i] == INT_MAX) cout &lt;&lt; \"INF\\n\"; else cout &lt;&lt; dist[i] &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "특정 거리의 도시 찾기", "url": "/posts/%ED%8A%B9%EC%A0%95-%EA%B1%B0%EB%A6%AC%EC%9D%98-%EB%8F%84%EC%8B%9C-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-12-20 00:00:00 +0900", "snippet": "특정 거리의 도시 찾기https://www.acmicpc.net/problem/18352문제어떤 나라에는 1번부터 N번까지의 도시와 M개의 단방향 도로가 존재한다. 모든 도로의 거리는 1이다.이 때 특정한 도시 X로부터 출발하여 도달할 수 있는 모든 도시 중에서, 최단 거리가 정확히 K인 모든 도시들의 번호를 출력하는 프로그램을 작성하시오. 또한 출발 도시 X에서 출발 도시 X로 가는 최단 거리는 항상 0이라고 가정한다.예를 들어 N=4, K=2, X=1일 때 다음과 같이 그래프가 구성되어 있다고 가정하자.이 때 1번 도시에서 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 2인 도시는 4번 도시 뿐이다. 2번과 3번 도시의 경우, 최단 거리가 1이기 때문에 출력하지 않는다.입력첫째 줄에 도시의 개수 N, 도로의 개수 M, 거리 정보 K, 출발 도시의 번호 X가 주어진다. (2 ≤ N ≤ 300,000, 1 ≤ M ≤ 1,000,000, 1 ≤ K ≤ 300,000, 1 ≤ X ≤ N) 둘째 줄부터 M개의 줄에 걸쳐서 두 개의 자연수 A, B가 공백을 기준으로 구분되어 주어진다. 이는 A번 도시에서 B번 도시로 이동하는 단방향 도로가 존재한다는 의미다. (1 ≤ A, B ≤ N) 단, A와 B는 서로 다른 자연수이다.출력X로부터 출발하여 도달할 수 있는 도시 중에서, 최단 거리가 K인 모든 도시의 번호를 한 줄에 하나씩 오름차순으로 출력한다.이 때 도달할 수 있는 도시 중에서, 최단 거리가 K인 도시가 하나도 존재하지 않으면 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAX_LEN 300001using namespace std;vector&lt;int&gt; graph[MAX_LEN];int visited_cnt[MAX_LEN];int N, M, K, X;void bfs(int start){ queue&lt;int&gt; q; q.push(start); visited_cnt[start] = 0; while(!q.empty()){ int cur_node = q.front(); q.pop(); for(auto &amp;next_node : graph[cur_node]){ if(visited_cnt[next_node] == -1){ visited_cnt[next_node] = visited_cnt[cur_node] + 1; q.push(next_node); } } }}int main(void){ bool visit_flag = false; ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; X; for(int i = 0; i &lt; M; i++){ int a, b; cin &gt;&gt; a &gt;&gt; b; graph[a].push_back(b); } memset(visited_cnt, -1, sizeof(visited_cnt)); bfs(X); for(int i = 1; i &lt;= N; i++){ if(visited_cnt[i] == K){ cout &lt;&lt; i &lt;&lt; \"\\n\"; visit_flag = true; } } if(!visit_flag) cout &lt;&lt; \"-1\\n\"; return 0;}" }, { "title": "패턴 찾기1", "url": "/posts/%ED%8C%A8%ED%84%B4-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Hash", "date": "2025-12-19 00:00:00 +0900", "snippet": "패턴 찾기1문제한 변의 길이가 N으로 된 2차원 테이블 A[][]의 각 셀에 0 또는 1이 채워져 있다.이 테이블의 임의의 위치에서 가로 세로의 길이가 모두 M인 부분을복사하여 저장한 테이블을 B[][]라고 하자.N, A[][], M과 B[][]가 주어질 때, B[][]가 A[][]의 어느 위치의 일부분이었는지찾는 프로그램을 작성해보자.사용자는 다음 두 함수를 구현한다. void init(int n, int ap[][1000], int m): 초기 2차원 테이블 크기 n과 내역 A[][], 그리고 B[][]의 크기 m이 주어진다. int query(int bp[][20]): 알아보고자 하는 2차원 테이블 B[][]이 주어진다.A[][]에서 B[][]를 찾고 찾은 구간의 가장 상단, 가장 왼쪽 셀의 행번호(row) 열번호(col)를row * n + col로 계산하여 반환한다.[제약조건] Test case : 50개 각 case당 쿼리 : 10 ~ 1000개 N(20 &lt;= N &lt;= 1000) M(5 &lt;= M &lt;= 20) 풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;// user.cpp#define PII pair&lt;int, int&gt;#define MOD 1 &lt;&lt; 16using namespace std;int N, M;vector&lt;PII&gt; hash_table[MOD];int get_code(int r, int c){ int code = 0; for(int i = 0; i &lt; 4; i++){ for(int j = 0; j &lt; 4; j++){ // 16개의 값을 총 16비트 값에 채워넣음 code = code * 2 + A[r + i][c + j]; } } return code;}void init(int n, int ap[][1000], int m){ N = n, M = m; int code = 0; for(int i = 0; i &lt; MOD; i++) hash_table[i].clear(); memcpy(A, ap, sizeof(A)); for(int i = 0; i &lt;= N - M; i++){ for(int j = 0; j &lt;= N - M; j++){ code = get_code(i, j); hash_table[code].push_back({i, j}); } }}int check_validity(int r, int c){ for(int i = 0; i &lt; M; i++){ for(int j = 0; j &lt; M; j++){ if(A[r + i][c + j] != B[i][j]) return 0; } } return 1;}int query(int bp[][20]){ int row = 0, col = 0; memcpy(B, bp, sizeof(B)); int table_idx = 0; for(int i = 0; i &lt; 4; i++){ for(int j = 0; j &lt; 4; j++){ table_idx = table_idx * 2 + B[i][j]; } } for(auto &amp;data : hash_table[table_idx]){ int srow = data.first, scol = data.second; if(check_validity(srow, scol)){ row = srow, col = scol; } } return row * N + col;}// main.cpp#ifndef _CRT_SECURE_NO_WARNINGS#define _CRT_SECURE_NO_WARNINGS#endif // _CRT_SECURE_NO_WARNINGS #include &lt;stdio.h&gt;static int AN, A[1000][1000], BM, B[20][20];static unsigned int seed;static unsigned int myRand(){ seed = 22695477 * seed + 1; return seed&gt;&gt;16;} extern void init(int, int[][1000], int);extern int query(int[][20]); static void makeArr(){ int i, j; for(i=0;i&lt;AN;++i)for(j=0;j&lt;AN;++j){ A[i][j] = myRand() &amp; 1; }} static int makeBrr(int limit){ int r = myRand() % (limit + 1); int c = myRand() % (limit + 1); int i, j, zero = 1; for(i=0;i&lt;BM;++i)for(j=0;j&lt;BM;++j){ B[i][j] = A[r+i][c+j]; if(B[i][j]) zero = 0; } return zero;} static int run(){ int limit = AN - BM; int i, j, ret; while(makeBrr(limit)); ret = query(B); int userR = ret / AN, userC = ret % AN; if(userR &lt; 0 || userR &gt; limit || userC &lt; 0 || userC &gt; limit) return 0; for(i=0;i&lt;BM;++i)for(j=0;j&lt;BM;++j){ if(B[i][j] != A[userR+i][userC+j]) return 0; } return 100;} int main(){ //freopen(\"input.txt\", \"r\", stdin); int TC, i, j, Q; scanf(\"%d\", &amp;TC); for(i=1;i&lt;=TC;++i){ scanf(\"%d %d %u %d\", &amp;AN, &amp;BM, &amp;seed, &amp;Q); int total = 0; makeArr(); init(AN, A, BM); for(j=1;j&lt;=Q;++j){ int sc = run(); total += sc; } printf(\"#case %d : %d\\n\", i, total / Q); } return 0;}" }, { "title": "경로 찾기", "url": "/posts/%EA%B2%BD%EB%A1%9C-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2025-12-14 00:00:00 +0900", "snippet": "경로 찾기문제길이가 같은 두 개의 이진수 코드 A와 B가 있다고 하자.이 두 코드 사이의 해밍 거리는 A와 B의 각 비트를 왼쪽부터 오른쪽으로 차례대로 비교할 때 서로 다른 값을 가진 비트의 수이다.예를 들어, A=010010, B=011011 이라고 하면, 세 번째 비트와 여섯 번째 비트만 서로 다르므로 이 두 코드 사이의 해밍 거리는 2이다.우리는 총 N개의 이진 코드를 가지고 있고, 각 코드의 길이는 K로 같다.예를 들어, 다음과 같이 길이가 3인 5개의 이진 코드들이 있다.A=000, B=111, C=010, D=110, E=001두 코드 A와 B사이의 해밍 거리를 H(A,B)로 표현한다. 그러면, H(A,B)=3, H(A,C)=1, H(A,D)=2, H(A,E)=1 이다.우리는 이진 코드들에 대해 해밍 경로를 찾고자 한다. 해밍 경로는 모든 인접한 두 코드사이의 해밍 거리가 1인 경로이다.위의 예에서 (A,C,D)는 코드 A와 C의 해밍 거리가 1이고, 코드 C와 D의 해밍 거리가 1이므로 해밍 경로이다.(A,E,B)는 코드 A와 E의 해밍 거리는 1이지만, 코드 E와 B의 해밍 거리가 2이므로 해밍 경로가 아니다.이 문제는 주어진 두 코드 사이에 가장 짧은 해밍 경로를 구하는 프로그램을 작성하는 것이다.입력첫째 줄에는 두 개의 정수 N과 K가 빈칸을 사이에 두고 주어진다(3≤N≤1,000, 2≤K≤30).둘째 줄부터 N개의 줄에는 각 줄마다 길이가 K인 이진 코드가 하나씩 주어진다.하나의 코드는 빈칸이 없이 주어진다. 코드들은 주어진 순서대로 1부터 N까지의 번호로 구분된다.코드가 같은 경우는 없다.그 다음 줄에는 해밍 경로를 찾고자 하는 서로 다른 두 개의 코드 A와 B가 각각의 코드번호로 주어진다.출력입력으로 주어진 두 코드 사이에 해밍 경로가 존재하면그 경로 중 가장 짧은 경로를 코드 A부터 코드 B까지 경로상의 코드 번호로 출력한다.코드 번호를 출력할 경우에는 코드 번호 사이에 하나의 빈칸을 사이에 두고 출력한다.만약 답이 여러 개 있으면 그 중에 하나만 출력하고, 경로가 존재하지 않으면 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#define ARR_ROW_MAX_LEN 1100#define ARR_COL_MAX_LEN 33#define PII pair&lt;int, int&gt;#define rint register intusing namespace std;int N, K, A, B;int arrmap[ARR_ROW_MAX_LEN][ARR_COL_MAX_LEN] = { 0 };int dist[ARR_ROW_MAX_LEN] = { 0 };int parent[ARR_ROW_MAX_LEN] = { 0 };vector&lt;PII &gt; graph[ARR_ROW_MAX_LEN];struct compare{ bool operator()(const PII &amp;a, const PII &amp;b) const { return a.second &gt; b.second; }};void input(){ cin &gt;&gt; N &gt;&gt; K; for(int i = 0; i &lt; N; i++){ string str; cin &gt;&gt; str; for(int j = 0; j &lt; K; j++){ arrmap[i][j] = str[j]; } } cin &gt;&gt; A &gt;&gt; B;}int calc_hamming_distance(int a, int b){ rint ret_dist = 0; for(int i = 0; i &lt; K; i++){ if(arrmap[a][i] ^ arrmap[b][i]) ret_dist++; } return ret_dist;}void make_graph(){ for(rint i = 1; i &lt;= N - 1; i++){ for(rint j = i + 1; j &lt;= N; j++){ rint dist = calc_hamming_distance(i - 1, j - 1); // 해밍거리 1인 point 들 사이(해밍 경로)만 연결을 수행 if(dist == 1){ graph[i].push_back({j, dist}); graph[j].push_back({i, dist}); } } }}bool dijkstra(){ priority_queue&lt;PII, vector&lt;PII &gt;, compare&gt; pq; // 거리 최대값으로 초기화 for(rint i = 0; i &lt;= N; i++) dist[i] = INT_MAX; // 시작점 pq 에 push 및 dist 배열 업데이트 pq.push({A, 0}); dist[A] = 0; while(!pq.empty()){ PII cur = pq.top(); rint cur_point = cur.first; rint cur_dist = cur.second; pq.pop(); if(cur_point == B) return true; if(cur_dist &gt; dist[cur_point]) continue; for(auto next : graph[cur_point]){ rint next_point = next.first; rint next_dist = cur_dist + next.second; if(next_dist &lt; dist[next_point]){ dist[next_point] = next_dist; parent[next_point] = cur_point; pq.push({next_point, next_dist}); } } } return false;}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); make_graph(); bool isfound = dijkstra(); if(!isfound){ cout &lt;&lt; \"-1\\n\"; return 0; } vector&lt;int&gt; result_path; result_path.push_back(B); // B-A 사이 경로 parent 배열을 통해 탐색 for(rint i = parent[B]; i != A; i = parent[i]){ result_path.push_back(i); } result_path.push_back(A); // 부모노드를 탐색해가면서 거꾸로 vector 에 값을 채웠기 때문에 print 할 때는 역순으로 출력 for(rint i = result_path.size() - 1; i &gt;= 0; i--){ cout &lt;&lt; result_path[i] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; return 0;}" }, { "title": "위성 사진", "url": "/posts/%EC%9C%84%EC%84%B1%EC%82%AC%EC%A7%84/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-12-13 00:00:00 +0900", "snippet": "위성 사진문제농부 창호는 자신의 농장을 위성을 이용해 찍은 사진을 얻게 되었다.이 사진은 W*H 크기의 픽셀로 이루어진 사진이다.창호는 이렇게 찍힌 사진들 중에서 가장 많이 연속되어 연결된 목장의 크기가 알고 싶어 한다.목장이란 사진에 비어있지 않은 곳을 가정하며, 하나의 픽셀은 하나의 목장이 될 수 있다.연결된 목장이란 다른 목장과 가로 혹은 세로방향으로 맞닿아 있는 것을 뜻한다.또한 연속되어 연결 되었다는 것은 연결되었다고 가정한 목장들의 집합 안 에서 모든 두 지점에 대해,상하좌우로 목장만을 이동경로로 둘 경우 모든 두 지점에 대한 경로가 존재할 경우 이 집합 안의 목장들은 연속되어 연결 되었다고 이야기 한다.각 위성사진은 2개의 문자로 이루어져 있는데 ‘*’ 표시는 목장, ‘.’ 은 비어있는 곳을 의미한다.아래는 이러한 위성사진의 예이다.​..*.....**.**..*****.*...*......****.***..****.***위의 그림에서 4, 16, 6개의 픽셀로 이루어진 연속된 목장이 존재한다.그리고 이 경우는 16이 창호가 찾고자 하는 답이 된다.입력첫 번째 줄에는 W와 H가 공백을 사이에 두고 입력 된다 (1≤W≤80, 1≤H≤1,000). 그 다음 줄부터 H의 줄에 W개의 문자 ‘*’, ‘.’로 이루어진 위성 사진의 한 줄이 입력된다.출력입력된 위성사진에서 나타나는 가장 많은 연속된 목장의 개수를 출력한다.풀이#include &lt;iostream&gt;#include &lt;string&gt;#define ARR_MAX_LEN 1001using namespace std;int W, H, cnt = 0, answer = 0;char arrmap[ARR_MAX_LEN][ARR_MAX_LEN];bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[4] = { -1, 1, 0 , 0 };int dx[4] = { 0, 0, -1, 1 };void dfs(int y, int x){ isvisited[y][x] = true; cnt++; for(int dir = 0; dir &lt; 4; dir++){ int ny = y + dy[dir]; int nx = x + dx[dir]; if(ny &lt; 0 || ny &gt;= H || nx &lt; 0 || nx &gt;= W) continue; if(!isvisited[ny][nx] &amp;&amp; arrmap[ny][nx] == '*') dfs(ny, nx); }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; W &gt;&gt; H; for(int i = 0; i &lt; H; i++){ string str; cin &gt;&gt; str; for(int j = 0; j &lt; str.length(); j++){ arrmap[i][j] = str[j]; } } for(int i = 0; i &lt; H; i++){ for(int j = 0; j &lt; W; j++){ if(arrmap[i][j] == '*' &amp;&amp; !isvisited[i][j]){ cnt = 0; dfs(i, j); answer = max(answer, cnt); } } } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "ID 찾기", "url": "/posts/ID-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Hash", "date": "2025-12-07 00:00:00 +0900", "snippet": "ID 찾기문제정올이는 정보올림피아드를 준비하는 동아리의 운영자이다.동아리 회원들의 학습에 도움이 되고자 학습사이트를 준비하고 있다.회원가입과 로그인등 회원 관리를 위하여 회원들이 ID를 입력한 경우이를 확인하는 프로그램을 만드는 중이다.ID는 ​알파벳 소문자(a ~ z)와 숫자(0 ~ 9)를 포함하며 길이는 5 ~ 12자이다.정올이는 다음과 같은 함수를 만들 생각이다.하지만 여러 가지로 너무 바빠 여러분에게 구현을 부탁하고 있다.정올이를 도와 프로그램을 완성해보자.명령 1 : int validate(char* ID): ID가 이미 가입되어 있다면 1을, 그렇지 않다면 0을 반환한다.명령 2 : ​ int activate(char* ID): ID가 로그인 중이라면 1을, 그렇지 않다면 0을 반환한다.​​명령 3​ : ​int signup(char*ID): 새로운 ID이라면 등록하고 현재 등록 중인 회원 수를 반환한다.등록만 되고 자동으로 로그인되지 않는다는 것에 유의하자.​이미 등록된 ID​라면 현재 등록 중인 회원 수만 반환한다.​​​명령 4​ : ​int close(char*ID): ID가 등록된 회원이라면 탈퇴 처리한다.등록된 회원이 로그인 되어 있다면 탈퇴와 동시에 로그아웃도 처리되어야 한다.등록된 회원이 아니라면 아무 일도 하지 않는다.현재 등록 중인 회원 수를 반환한다.​​명령 5 : ​ int login(char*ID): ID가 등록된 회원이고 로그아웃된 상태라면 로그인 처리한다.그렇지 않다면 아무 일도 하지 않는다.​현재 로그인 중인 회원 수를 반환한다.​​​명령 6 ​: ​int logout(char*ID): ID가 로그인 된 회원이라면 로그아웃 처리한다.그렇지 않다면 아무 일도 하지 않는다.현재 로그인 중인 회원 수를 반환한다.입력첫 행에 명령 수 N이 입력된다. (100 ≤ N ≤ 500,000)다음 행부터 N행에 걸쳐 cmd ID 형식의 데이터가 입력된다.(1 ≤ cmd ≤ 6) ( ID : 알파벳 소문자(a ~ z)와 숫자(0 ~ 9)를 포함하며 길이는 5 ~ 12)출력각 명령에 대한 결과를 행으로 구분하여 출력한다.풀이#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; member;int N, login_cnt = 0;int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ int cmd, answer = 0; string word; cin &gt;&gt; cmd &gt;&gt; word; auto it = member.find(word); // validate if(cmd == 1){ answer = (int)(it != member.end()); } // activate else if(cmd == 2){ answer = (int)(it != member.end() &amp;&amp; it-&gt;second == 1); } // signup else if(cmd == 3){ member.insert({word, 0}); answer = (int)member.size(); } // close else if(cmd == 4){ if(it != member.end()){ login_cnt -= it-&gt;second; member.erase(it); } answer = (int)member.size(); } // login else if(cmd == 5){ if(it != member.end() &amp;&amp; it-&gt;second == 0){ it-&gt;second = 1; login_cnt++; } answer = login_cnt; } // logout else if(cmd == 6){ if(it != member.end() &amp;&amp; it-&gt;second == 1){ it-&gt;second = 0; login_cnt--; } answer = login_cnt; } cout &lt;&lt; answer &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "생명체 분류", "url": "/posts/%EC%83%9D%EB%AA%85%EC%B2%B4-%EB%B6%84%EB%A5%98/", "categories": "CodingTest", "tags": "CodingTest, Trie", "date": "2025-12-06 00:00:00 +0900", "snippet": "생명체 분류문제지구상에 존재하는 모든 생명체는 여러가지 방법에 따라 분류가 된다.가장 큰 그룹으로 분류하면 26종으로 분류가 가능하다고 한다.그리고 각 그룹의 멤버들은 다시 26종으로 분류가 가능하다.이렇게 최대 9단계까지 세부 분류가 될 수 있다.이러한 단계를 나타낸다면 총 26^9의 서로 다른 종류의 생명체로 분류가 가능하고 그 단계를 알파벳 대문자로 표현할 수 있다.”AB”라면 가장 높은 단계의 분류가 ‘A’이고 두번째 단계가 ‘B’인 모든 생명체를 의미한다.생명체를 연구하는 정올 박사는 어떤 무인도에서 서식하는 생명체의 연구를 하면서 생명체가 발견될 때마다 분류표에 넣고 있다.그러다가 수시로 현재까지 발견된 특정 종의 개수를 알고 싶어 한다.예를 들어 생명체 “ABC”와 “ABDF”가 있을때 “AB”종의 개수를 구하려고 하면 모두 “AB”그룹에 포함되므로 2가 된다.알고리즘을 모르는 정올 박사를 위해 프로그램을 작성해 주자.입력첫째 줄에 테스트케이스의 개수를 나타내는 정수 T가 주어진다. (1 ≤ T ≤ 50)각 테스트케이스마다 첫째 줄에 정올박사가 요구하는 연산의 횟수를 나타내는 정수 N이 주어진다. ( 1 ≤ N ≤ 1000 )이후 N개의 줄에 걸쳐서 정올박사가 요구하는 연산의 정보가 순서대로 주어진다.각 연산 정보는 한 개의 문자로 구성된 명령의 종류 C와 생명체의 분류를 나타내는 문자열 S가 공백을 사이에 두고 주어진다.C가 ‘I’이면 정올 박사가 새로운 생명체를 발견하여 분류표에 저장하는 것이다.C가 ‘O’이면 현재까지 저장된 생명체중 S그룹의 수를 묻는 것이다. S의 길이는 1 이상 9이하이다.출력각 테스트케이스마다 한줄에 C가 ‘O’인 연산들에 대해 공백 하나를 사이에 두고 순서대로 답을 출력한다.풀이#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int T, N;char C;string S;typedef struct{ int path_cnt; // 이 노드를 root 로 하는 word 개수 (해당 prefix 개수) int child[26]; // 문자를 Integer Index 로 변환, A -&gt; 0 Z -&gt; 25}trie_node_t;vector&lt;trie_node_t&gt; buf;int buf_cnt = 0; // 새로 할당되는 node 의 수 (root node 제외)void init(){ buf_cnt = 0; buf.clear(); buf.push_back({ 0 }); // root = index 0 // Root 노드를 초기화하는 다른 방법 /* trie_node_t root; root.pathCnt = 0; for (int i = 0; i &lt; 26; i++) { root.child[i] = 0; } buf.push_back(root); */}void push(string str){ int cur_buf_idx = 0; for (int i = 0; i &lt; str.length(); i++) { int idx = str[i] - 'A'; if (buf[cur_buf_idx].child[idx] == 0) { // 새로운 노드 할당 buf.push_back({ 0 }); buf[cur_buf_idx].child[idx] = ++buf_cnt; // 새 노드 인덱스 = 1,2,3... } cur_buf_idx = buf[cur_buf_idx].child[idx]; // buf[cur_buf_idx] 를 root node 로 하는 word 개수 증가 buf[cur_buf_idx].path_cnt++; }}int get_cnt(string str){ int cur_buf_idx = 0; for(int i = 0; i &lt; str.length(); i++){ int idx = str[i] - 'A'; // 검색하는 문자열이 없는 경우 return 0 if(buf[cur_buf_idx].child[idx] == 0) return 0; cur_buf_idx = buf[cur_buf_idx].child[idx]; } // buf[cur_buf_idx] 를 root node 로 하는 word 개수를 반환 return buf[cur_buf_idx].path_cnt;}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; T; for(int i = 0; i &lt; T; i++){ cin &gt;&gt; N; init(); for(int cmd_idx = 0; cmd_idx &lt; N; cmd_idx++){ cin &gt;&gt; C &gt;&gt; S; if(C == 'I'){ push(S); } else if(C == 'O'){ int answer_cnt = get_cnt(S); cout &lt;&lt; answer_cnt &lt;&lt; \" \"; } } cout &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "Algorithm_Trie", "url": "/posts/Algorithm_Trie/", "categories": "CodingTest", "tags": "CodingTest, Trie", "date": "2025-12-06 00:00:00 +0900", "snippet": "Algorithm_Trie1. Trie 개요Trie(트라이)는 문자열 집합을 다루기 위한 트리 기반 자료구조이다.특히 다음과 같은 상황에서 유용하다. 많은 문자열을 저장하고 정확히 존재 여부를 빠르게 검사해야 할 때 어떤 문자열이 특정 접두사(prefix) 를 가지는지 자주 물어볼 때 자동완성(auto-complete), 사전(dictionary), 검색어 추천과 같이 접두사 기반 검색이 핵심일 때Trie의 핵심 아이디어는 문자열을 통째로 노드에 저장하지 않고,문자 하나하나를 간선(edge) 로 두고 루트에서부터 한 글자씩 내려가며 표현하는 것이다.2. Trie 기본 구조Trie는 보통 다음과 같은 정보를 가진다. 루트 노드 하나 각 노드는 자식 포인터(또는 포인터 배열, map, unordered_map) 해당 노드에서 문자열이 끝나는지를 표시하는 is_end 플래그 (선택) 그 아래 서브트리에 포함된 문자열 개수 등 부가 정보 예를 들어 문자열 집합이 다음과 같다고 하자. apple app bat루트에서 시작해 a → p → p → l → e 와 같은 경로로 apple 을,a → p → p 지점에서 app 의 끝을 표시하고,b → a → t 경로로 bat 를 표현한다.3. Trie의 핵심 연산3.1 문자열 삽입(insert) 현재 노드를 루트로 둔다. 문자열의 각 문자 c에 대해 현재 노드에 문자 c로 가는 자식이 없으면 새 노드를 만든다. 자식 노드로 내려간다. 문자열의 마지막 문자를 처리한 뒤, 해당 노드를 is_end = true 로 표시한다.3.2 문자열 검색(exact search) 현재 노드를 루트로 둔다. 문자열의 각 문자 c에 대해 현재 노드에 문자 c로 가는 자식이 없으면 문자열이 존재하지 않는다. 있으면 자식 노드로 이동한다. 마지막 문자까지 모두 이동한 후 그 노드의 is_end 가 true이면 문자열이 존재한다고 본다. false이면 해당 경로는 있지만 정확히 그 문자열은 없다(다른 문자열의 접두사). 3.3 접두사 검사(prefix check, starts_with) 현재 노드를 루트로 둔다. 접두사 문자열의 각 문자 c에 대해 현재 노드에 문자 c로 가는 자식이 없으면 실패이다. 있으면 자식 노드로 이동한다. 모든 문자를 처리했다면 접두사를 가지는 문자열이 하나 이상 존재한다고 본다. 추가로 노드에 서브트리 문자열 개수 를 저장해두면, 해당 접두사를 가진 문자열이 몇 개 있는지도 바로 알 수 있다. 4. 시간 복잡도와 공간 복잡도 문자열 길이를 L이라 두면 삽입: O(L) 검색: O(L) 접두사 검사: O(L) 일반적인 해시 기반 자료구조는 평균 O(1)처럼 보이지만, 문자열 길이에 비례하는 해시 계산이 필요하므로 사실상 O(L)이다.Trie의 강점은 충돌이 없고, 접두사 처리에 특화되어 있다는 점이다.공간 복잡도는 다음에 의존한다. 저장할 문자열의 개수 N 각 문자열의 길이 L 사용 문자 집합의 크기(알파벳 수)최악의 경우 O(N × L)의 노드가 필요할 수 있다.문자 집합이 알파벳 소문자 26개로 제한되면 각 노드마다 자식 포인터 26개를 고정 배열로 둘 수 있다.문자 집합이 크거나 유니코드 등을 다루면 map 또는 unordered_map을 쓰는 편이 공간 면에서 유리하다.5. 구현 방식 비교5.1 고정 크기 배열 사용 (예: 알파벳 소문자만)각 노드에서 children[26] 형태로 포인터 배열을 두는 방식이다.장점 매우 빠르다. 인덱스로 바로 접근하므로 O(1) 구현이 단순하다.단점 문자 집합이 작을 때만 쓸 수 있다. 사용하지 않는 자식 포인터도 메모리를 차지한다.5.2 map 또는 unordered_map 사용각 노드에서 문자 → 자식 노드 포인터를 map 혹은 unordered_map으로 관리한다.장점 문자 집합이 커도 낭비가 없다. 유니코드, 대소문자 혼용, 특수문자 등도 자연스럽게 처리 가능하다.단점 배열 방식보다 느리다. 자료구조 오버헤드로 인해 메모리도 더 쓴다.6. C++ 구현 예제 1: 알파벳 소문자(a~z)만 사용하는 Trie#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;struct TrieNode { TrieNode* child[26]; bool is_end; TrieNode() { for (int i = 0; i &lt; 26; i++) { child[i] = nullptr; } is_end = false; }};struct Trie { TrieNode* root; Trie() { root = new TrieNode(); } void insert(const string&amp; s) { TrieNode* node = root; for (char c : s) { int idx = c - 'a'; if (idx &lt; 0 || idx &gt;= 26) { continue; } if (node-&gt;child[idx] == nullptr) { node-&gt;child[idx] = new TrieNode(); } node = node-&gt;child[idx]; } node-&gt;is_end = true; } bool search(const string&amp; s) { TrieNode* node = root; for (char c : s) { int idx = c - 'a'; if (idx &lt; 0 || idx &gt;= 26) { return false; } if (node-&gt;child[idx] == nullptr) { return false; } node = node-&gt;child[idx]; } return node-&gt;is_end; } bool starts_with(const string&amp; prefix) { TrieNode* node = root; for (char c : prefix) { int idx = c - 'a'; if (idx &lt; 0 || idx &gt;= 26) { return false; } if (node-&gt;child[idx] == nullptr) { return false; } node = node-&gt;child[idx]; } return true; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Trie trie; trie.insert(\"apple\"); trie.insert(\"app\"); cout &lt;&lt; trie.search(\"apple\") &lt;&lt; \" \"; cout &lt;&lt; trie.search(\"app\") &lt;&lt; \" \"; cout &lt;&lt; trie.search(\"ap\") &lt;&lt; \" \"; cout &lt;&lt; trie.starts_with(\"ap\") &lt;&lt; \" \"; cout &lt;&lt; trie.starts_with(\"b\") &lt;&lt; \" \"; return 0;}7. C++ 구현 예제 2: 임의의 문자 집합을 지원하는 Trie (unordered_map 사용)#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;struct TrieNode { unordered_map&lt;char, TrieNode*&gt; child; bool is_end; TrieNode() { is_end = false; }};struct Trie { TrieNode* root; Trie() { root = new TrieNode(); } void insert(const string&amp; s) { TrieNode* node = root; for (char c : s) { if (node-&gt;child.find(c) == node-&gt;child.end()) { node-&gt;child[c] = new TrieNode(); } node = node-&gt;child[c]; } node-&gt;is_end = true; } bool search(const string&amp; s) { TrieNode* node = root; for (char c : s) { auto it = node-&gt;child.find(c); if (it == node-&gt;child.end()) { return false; } node = it-&gt;second; } return node-&gt;is_end; } bool starts_with(const string&amp; prefix) { TrieNode* node = root; for (char c : prefix) { auto it = node-&gt;child.find(c); if (it == node-&gt;child.end()) { return false; } node = it-&gt;second; } return true; }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); Trie trie; trie.insert(\"Hello\"); trie.insert(\"Hell\"); trie.insert(\"Heap\"); cout &lt;&lt; trie.search(\"Hello\") &lt;&lt; \" \"; cout &lt;&lt; trie.search(\"Hell\") &lt;&lt; \" \"; cout &lt;&lt; trie.search(\"He\") &lt;&lt; \" \"; cout &lt;&lt; trie.starts_with(\"He\") &lt;&lt; \" \"; cout &lt;&lt; trie.starts_with(\"Hi\") &lt;&lt; \" \"; return 0;}8. Trie의 대표적인 응용 자동완성 기능 사용자가 몇 글자만 입력해도 해당 접두사로 시작하는 단어들을 빠르게 찾을 수 있다. 각 노드에 서브트리 단어수를 저장하면, 인기 검색어 순위 같은 것도 쉽게 계산할 수 있다. 사전(Dictionary) 구현 단어 존재 여부를 빠르게 검사할 수 있다. 단어 추가, 삭제, 접두사 기반 탐색 등에 유리하다. 문자열 집합 문제 예: N개의 문자열이 주어지고, M개의 쿼리 문자열 각각이 집합에 속하는지 확인하는 문제 해시 대신 Trie를 쓰면 접두사 기반 추가 기능을 자연스럽게 붙일 수 있다. 공통 접두사 관련 문제 여러 문자열의 최장 공통 접두사를 구하는 문제 등에서 Trie를 사용할 수 있다. IP 주소, 도메인 이름 관리 등 문자열 또는 특정 포맷의 토큰 시퀀스를 관리할 때 활용할 수 있다. 9. 구현 시 자주 하는 실수 정리 인덱스 범위 체크 누락 알파벳 소문자만 다루는 경우, 반드시 문자에서 ‘a’를 빼서 0~25 범위인지 확인해야 한다. 동적 할당한 노드 해제 누락 온라인 저지는 대개 프로그램 종료 시 메모리를 회수하지만, 실제 서비스 코드라면 소멸자에서 노드를 모두 해제해야 한다. 문자 집합을 과소 또는 과대 가정 실제 입력 문자열이 소문자만 온다는 보장이 없는 경우, 배열 기반 구현은 오류를 낸다. 반대로, 문자 집합이 극도로 제한적이라면 굳이 map을 쓸 필요가 없다. 접두사와 완전 일치 검색을 혼동 search 연산에서는 마지막 노드의 is_end를 반드시 체크해야 한다. starts_with 연산은 is_end를 확인하지 않고, 경로가 존재하는지만 보면 된다. 10. 마무리Trie는 문자열에 특화된 강력한 자료구조이다.특히 접두사 기반 연산이 잦은 문제에서는 해시나 정렬 기반 탐색보다 자연스럽고 직관적인 해결책을 제공한다.대신, 문자열 수와 길이가 매우 크면 메모리 사용량이 부담될 수 있으므로,입력 스펙에 따라 Trie, 해시, 정렬+이분 탐색 등을 적절히 선택하는 것이 중요하다." }, { "title": "구간의 최대합1", "url": "/posts/%EA%B5%AC%EA%B0%84%EC%9D%98-%EC%B5%9C%EB%8C%80%ED%95%A91/", "categories": "CodingTest", "tags": "CodingTest, Sqrt Decomposition", "date": "2025-11-28 00:00:00 +0900", "snippet": "구간의 최대합1문제N개의 정수로 이뤄진 수열을 입력 받는다.(1 ≤ N ≤ 50000)다음 Q개의 질의에 대한 답을 구하여 출력한다.(1 ≤ Q ≤ 200000)각 질의는 수열의 임의의 연속된 구간의 최대값을 구하여 답하는 것이다.입력입력의 첫번째 줄에는 수열을 이루는 원소의 갯수 N(1≤N≤50,000)과구간의 갯수 Q(1≤Q≤200,000)가 공백을 사이에 두고 입력된다.그 다음 N개의 줄에는 순서대로 서있는 원소의 숫자가 한줄에 하나씩 입력되는데,이는 1이상 1,000,000이하이다.그 다음 Q개의 구간의 시작 인덱스와 끝 인덱스 A, B가 공백을 사이에 두고 입력되며,A는 구간이 시작되는 원소의 번호, B는 구간이 끝나는 원소의 번호이며A와 B는 1이상 N이하의 수이며 A는 B보다 작거나 같다.출력입력된 Q개의 구간에 대한 가장 큰 원소를 출력하는 프로그램을 작성한다.풀이#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 50001using namespace std;long long arr[ARR_MAX_LEN] = { 0 };long long blockmax[ARR_MAX_LEN] = { 0 };int N, Q, block_len;void build_table(long long* arr) { long long max_num = 0; int cnt = 0; block_len = sqrt(N); if (block_len == 0) block_len = 1; for (int i = 0; i &lt; N; i++) { if (cnt == block_len) { cnt = 0; max_num = 0; } max_num = max(max_num, arr[i]); blockmax[i / block_len] = max_num; cnt++; }}long long max_query(int start, int end, long long* arr) { long long res = 0; int start_block = start / block_len; int end_block = end / block_len; // 같은 블록 안에 다 들어있을 때 if (start_block == end_block) { for (int i = start; i &lt;= end; i++) { res = max(res, arr[i]); } return res; } // 시작 블록의 나머지 부분 int end_of_start = (start_block + 1) * block_len; for (int i = start; i &lt;= end_of_start; i++) { res = max(res, arr[i]); } // 중간에 완전히 포함된 블록들 for (int i = start_block + 1; i &lt; end_block; i++) { res = max(res, blockmax[i]); } // 마지막 블록의 일부 int start_of_end = end_block * block_len; for (int i = start_of_end; i &lt;= end; i++) { res = max(res, arr[i]); } return res;}int main(void) { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; Q; for (int i = 1; i &lt;= N; i++) { cin &gt;&gt; arr[i]; } build_table(arr); for (int i = 0; i &lt; Q; i++) { int a, b; cin &gt;&gt; a &gt;&gt; b; long long answer = max_query(a, b, arr); cout &lt;&lt; answer &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "Algorithm_Square Root Decomposition", "url": "/posts/Algorithm_Square-Root-Decomposition/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-11-22 00:00:00 +0900", "snippet": "Algorithm_Square Root Decomposition1. Square Root Decomposition 개요Square Root Decomposition 은 배열에 대한 구간 질의(range query) 와 점 업데이트(point update) 를 빠르게 처리하기 위한 자료구조 기법이다.크기 N 인 배열을 대략 √N 크기의 블록(block) 으로 나누고, 각 블록에 대해 요약 정보(예: 합, 최소, 최대 등) 를 미리 저장한다.대표적인 사용 예 구간 합 Range Sum Query 구간 최소 Range Minimum Query 구간 최대 Range Maximum Query 구간 XOR, 빈도 등 변형 가능시간 복잡도 전처리 O(N) 구간 질의 O(√N) 점 업데이트 O(√N)2. 기본 아이디어배열 크기 N 블록 크기 B = floor(√N) 블록 개수 ≒ N / B 각 블록에 대한 합, 최소, 최대 등 요약 정보를 저장 질의 시 양 끝 블록은 직접 계산 중간 블록들은 저장된 요약 값만 사용 3. Range Sum Query 구조배열 arr[i]보조 배열 blockSum[b]i 의 블록 번호 b = i / B구간 [L, R] 처리 L 에서 시작 블록 경계까지 직접 더하기 중간 블록들은 blockSum[b] 만 더하기 마지막 블록의 일부를 직접 더하기업데이트 diff = val - arr[i] blockSum[i / B] += diff4. C++ 구현#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int n;int blockSize;int numBlocks;vector&lt;long long&gt; arr;vector&lt;long long&gt; blockSum;// 전처리void build(const vector&lt;long long&gt;&amp; input) { n = input.size(); arr = input; blockSize = (int)sqrt(n); if (blockSize == 0) blockSize = 1; numBlocks = (n + blockSize - 1) / blockSize; blockSum.assign(numBlocks, 0); for (int i = 0; i &lt; n; i++) { blockSum[i / blockSize] += arr[i]; }}// 점 업데이트: arr[idx] = valvoid updateSet(int idx, long long val) { int b = idx / blockSize; long long diff = val - arr[idx]; arr[idx] = val; blockSum[b] += diff;}// 구간 합 쿼리: [L, R]long long querySum(int L, int R) { long long res = 0; int startBlock = L / blockSize; int endBlock = R / blockSize; // 같은 블록이면 직접 계산 if (startBlock == endBlock) { for (int i = L; i &lt;= R; i++) res += arr[i]; return res; } // L 이 포함된 블록의 경계까지 직접 더하기 int endOfStart = (startBlock + 1) * blockSize - 1; for (int i = L; i &lt;= endOfStart; i++) { res += arr[i]; } // 사이에 있는 블록들 전체 더하기 for (int b = startBlock + 1; b &lt;= endBlock - 1; b++) { res += blockSum[b]; } // R 이 포함된 블록의 일부 직접 더하기 int startOfEnd = endBlock * blockSize; for (int i = startOfEnd; i &lt;= R; i++) { res += arr[i]; } return res;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int q; cin &gt;&gt; n; vector&lt;long long&gt; input(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; input[i]; build(input); cin &gt;&gt; q; while (q--) { int type; cin &gt;&gt; type; if (type == 1) { int idx; long long val; cin &gt;&gt; idx &gt;&gt; val; updateSet(idx, val); } else if (type == 2) { int L, R; cin &gt;&gt; L &gt;&gt; R; cout &lt;&lt; querySum(L, R) &lt;&lt; \"\\n\"; } } return 0;}5. 시간 복잡도 전처리 O(N) 점 업데이트 O(1) 수준 구간 질의 O(√N)6. 변형들 구간 최소: blockMin[b] 사용 구간 최대: blockMax[b] 사용 구간 XOR, AND, OR 도 가능7. 장단점장점 구현이 단순 대회에서 사용하기 좋음 다양한 변형 가능단점 세그먼트 트리보다 느릴 수 있음 구간 업데이트는 복잡해짐8. 결론Square Root Decomposition 은구간 질의 + 점 업데이트 문제에 대해단순성과 성능 사이의 균형을 제공하는 유용한 방법이다." }, { "title": "미로 탐색", "url": "/posts/%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-11-16 00:00:00 +0900", "snippet": "미로 탐색문제동현이는 방이 N개인 미로의 지도를 갖고 있다.각 방에는 1번부터 N번까지 번호가 매겨져 있고, N개의 방 사이에는 M개의 문이 있으며,각 문은 서로 다른 두 방을 연결한다.동현이는 1번 방에서 출발해서 N개의 방을 모두 탐색해 볼 것이다.동현이는 모험심이 강하기 때문에 항상 새로운 방을 찾기를 원한다.동현이는 자신이 위치한 방과 연결된 방 중 한 번도 들르지 않은 방이 있다면 그 중 가장 번호가 작은 방으로 가고,그렇지 않으면(연결된 방이 모두 전에 들렀던 방이면) 그냥 왔던 곳으로 되돌아가게 된다.동현이가 N개의 방을 모두 방문하고 1번 방으로 오면 동현이는 탐색을 끝낸다.N개의 방을, 동현이가 먼저 방문한 순으로 정렬하는 프로그램을 작성하여라.입력첫 번째 줄에는 방의 수 N과 문의 수 M이 주어진다. (2 ≤ N ≤ 100,000, 1 ≤ M ≤ 500,000)두 번째 줄부터 M개의 줄에는 각 문이 연결하는 두 방의 번호가 입력된다.모든 방들은 문을 통해 연결되어 있고, 임의의 두 방 사이에는 최대 1개의 문이 있다.전체 데이터의 38%는 2 ≤ N ≤ 3,000 이다.출력첫 번째 줄에 동현이가 방문한 순서대로 N개의 방의 번호를 정렬하여 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 500001using namespace std;int N, M;vector&lt;vector&lt;int&gt; &gt; graph(ARR_MAX_LEN);vector&lt;bool&gt; isvisited(ARR_MAX_LEN);void dfs(int start){ isvisited[start] = true; cout &lt;&lt; start &lt;&lt; \" \"; for(int data : graph[start]){ if(!isvisited[data]){ dfs(data); } }}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; for(int i = 0; i &lt; M; i++){ int a, b; cin &gt;&gt; a &gt;&gt; b; graph[a].push_back(b); graph[b].push_back(a); } for(int i = 1; i &lt;= N; i++) sort(graph[i].begin(), graph[i].end()); dfs(1); cout &lt;&lt; \"\\n\"; return 0;}" }, { "title": "종교", "url": "/posts/%EC%A2%85%EA%B5%90/", "categories": "CodingTest", "tags": "CodingTest, Union Find", "date": "2025-11-15 00:00:00 +0900", "snippet": "종교문제오늘날 아주 많은 다른 종교들이 있고 이들 모두를 추적하는 것은 어려운 일이다.당신이 다니는 학교에서 학생들이 믿고 있는 종교가 총 몇 가지 있는가를 알고자 한다.학교에는 n (0 &lt; n ≤ 50,000)명의 학생이 있다. 모든 학생에게 자기가 가진 종교가 무엇인지를 물어보는 것은 힘든 일이고게다가 많은 학생들은 그들의 종교를 나타내는 것을 좋아하지 않는다.이 문제를 해결하기 위한 한 가지 방법은 같은 종교를 가지는 사람들 끼리 짝을 짓도록 하는 것이다.쌍의 수는 m ( 0 ≤ m ≤ 100,000 ) 이다.이 데이터로 당신은 모든 학생들이 어떤 종교를 가지고 있는가는 알지 못하지만학생들이 최대한 가질 수 있는 종교의 가지 수를 알 수 있다.모든 학생들이 최대 한 가지 종교를 가지고 있다고 하자.입력정수 n , m 이 주어진다. 다음 m 라인은 두 정수 i , j 가 주어진다.i, j 는 i번 학생과 j번 학생이 같은 종교를 가진 학생의 쌍이다(1≤i, j≤n).출력종교의 가지 수를 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#define ARR_MAX_LEN 100001using namespace std;// 각 노드가 속한 집합 정보 (Union-Find parent)vector&lt;int&gt; parent(ARR_MAX_LEN, 0); // 각 노드의 부모 노드vector&lt;int&gt; rankv(ARR_MAX_LEN, 0); // 랭크(트리 높이 개념)// n = 노드 개수, m = 간선(Union 연산) 개수// answer = 최종적으로 남는 집합의 개수int n, m, answer = 0;// find: 경로 압축을 사용한 대표 노드 찾기// 경로 압축: 부모를 루트로 직접 연결int find_parent(int x){ if(parent[x] == x) // x가 루트 노드면 그대로 반환 return x; return parent[x] = find_parent(parent[x]); }// union: 두 집합을 병합int union_parent(int x, int y){ x = find_parent(x); // x의 루트 찾기 y = find_parent(y); // y의 루트 찾기 // 이미 같은 집합 → 병합 X (집합 수 변화 없음) if(x == y) return 0; // 트리 랭크 기준으로 작은 트리를 큰 트리에 붙임 if(rankv[x] &lt; rankv[y]) parent[x] = y; else{ parent[y] = x; if(rankv[x] == rankv[y]) rankv[x]++; // 높이가 같다면 합친 쪽 트리 랭크 증가 } return 1;}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; answer = n; // 초기에는 집합이 n개 (각 노드가 자기 자신) // 초기 parent 설정 for(int i = 1; i &lt;= n; i++){ parent[i] = i; // 자기 자신이 루트 } // m개의 union 연산 처리 for(int cnt = 0; cnt &lt; m; ++cnt){ int i, j; cin &gt;&gt; i &gt;&gt; j; answer -= union_parent(i, j); } // 최종적으로 남은 서로소 집합의 개수 출력 cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "DFS 와 BFS", "url": "/posts/DFS-%EC%99%80-BFS/", "categories": "CodingTest", "tags": "CodingTest, DFS, BFS", "date": "2025-11-15 00:00:00 +0900", "snippet": "DFS 와 BFS문제1~N까지의 정점을 가지는 양방향 그래프와 탐색을 시작하는 정점이 주어진다.이 때 시작점에서 DFS와 BFS로 각각 탐색하며 방문하게 되는 정점을 순서대로 출력해야 한다.단, 한 정점은 직접 연결된 정점을 방문할 때 정점 번호가 작은 것을 먼저 방문하며,더 이상 방문할 정점이 없는 경우 종료한다.입력첫째 줄에 정점의 개수 N(1&lt;=N&lt;=100), 간선의 개수 M(1&lt;=M&lt;=1,000)이 주어진다.둘째 줄에 탐색을 시작한 정점의 번호 s(1&lt;=s&lt;=N)가 주어진다.셋째 줄부터 M개의 줄에 걸쳐 간선이 연결하는 두 정점의 번호 a,b(1&lt;=a,b&lt;=N)가 주어진다.두 정점 사이에 여러개의 간선이 있을 수 있다.출력첫째 줄에 DFS를 수행할 때의 순서를 출력하고둘째 줄에 BFS를 수행할 때의 순서를 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 1001using namespace std;vector&lt;vector&lt;int&gt; &gt; graph(ARR_MAX_LEN);vector&lt;bool&gt; isvisited(ARR_MAX_LEN, false);int N, M;void dfs(vector&lt;vector&lt;int&gt;&gt; &amp; graph, int start){ isvisited[start] = true; cout &lt;&lt; start &lt;&lt; \" \"; for(int nnum : graph[start]){ if(!isvisited[nnum]){ dfs(graph, nnum); } }}void bfs(vector&lt;vector&lt;int&gt;&gt; &amp; graph, int start){ queue&lt;int&gt; q; q.push(start); isvisited[start] = true; while(!q.empty()){ int cnum = q.front(); q.pop(); cout &lt;&lt; cnum &lt;&lt; \" \"; for(int nnum : graph[cnum]){ if(!isvisited[nnum]){ q.push(nnum); isvisited[nnum] = true; } } } cout &lt;&lt; \"\\n\";}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int s; cin &gt;&gt; N &gt;&gt; M; cin &gt;&gt; s; for(int num = 0; num &lt; M; ++num){ int i, j; cin &gt;&gt; i &gt;&gt; j; graph[i].push_back(j); graph[j].push_back(i); } // 방문 순서 일정하게 하려면 정렬 for (int i = 1; i &lt;= N; ++i) sort(graph[i].begin(), graph[i].end()); dfs(graph, s); cout &lt;&lt; \"\\n\"; for(int i = 1; i &lt;= M; i++) isvisited[i] = false; bfs(graph, s); return 0;}" }, { "title": "Algorithm_Union Find", "url": "/posts/Algorithm_Union-Find/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-11-15 00:00:00 +0900", "snippet": "Algorithm_Union Find개요Union-Find(서로소 집합, Disjoint Set) 은 여러 원소가 속한 집합을 효율적으로 관리하기 위한 자료구조이다.특히 집합의 합치기(Union) 와 대표 원소 찾기(Find) 연산을 매우 빠르게 수행할 수 있다.대표적인 활용 분야는 다음과 같다. 그래프의 사이클 판별 MST(최소 스패닝 트리) 알고리즘 (Kruskal) 네트워크 연결 여부 확인 집합 간 관계 관리핵심 개념Union-Find 구조는 트리 기반 집합 표현을 사용한다. parent[x]: x의 부모 노드 (루트면 자기 자신) find(x): x가 속한 집합의 대표(root)를 찾음 union(a, b): a와 b가 속한 두 집합을 하나로 합침기본 구조#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; parent;int find_parent(int x) { if (parent[x] == x) return x; // 루트 노드 return parent[x] = find_parent(parent[x]); // 경로 압축(Path Compression)}void union_parent(int a, int b) { a = find_parent(a); b = find_parent(b); if (a &lt; b) parent[b] = a; else parent[a] = b;}int main() { ios::sync_with_stdio(false); cin.tie(NULL); int n, m; cin &gt;&gt; n &gt;&gt; m; // 노드, 연산 수 parent.resize(n + 1); for (int i = 1; i &lt;= n; ++i) parent[i] = i; for (int i = 0; i &lt; m; ++i) { int op, a, b; cin &gt;&gt; op &gt;&gt; a &gt;&gt; b; if (op == 0) union_parent(a, b); // 합치기 else { if (find_parent(a) == find_parent(b)) cout &lt;&lt; \"YES\\n\"; else cout &lt;&lt; \"NO\\n\"; } }}최적화 기법1️⃣ 경로 압축 (Path Compression)find 연산 시 재귀적으로 올라가며, 부모를 루트로 직접 연결한다.이를 통해 시간 복잡도를 거의 O(1)에 가깝게 만든다.int find_parent(int x) { if (parent[x] != x) parent[x] = find_parent(parent[x]); return parent[x];}2️⃣ 랭크(또는 크기) 기반 합치기 (Union by Rank/Size)작은 트리를 큰 트리에 붙이면 트리 깊이가 줄어든다.vector&lt;int&gt; parent, rankv;void union_parent(int a, int b) { a = find_parent(a); b = find_parent(b); if (a == b) return; if (rankv[a] &lt; rankv[b]) swap(a, b); parent[b] = a; if (rankv[a] == rankv[b]) rankv[a]++;}응용 1: 사이클 판별무방향 그래프에서 사이클 발생 여부를 확인할 때 사용한다.#include &lt;bits/stdc++.h&gt;using namespace std;vector&lt;int&gt; parent;int find_parent(int x) { if (x == parent[x]) return x; return parent[x] = find_parent(parent[x]);}bool union_parent(int a, int b) { a = find_parent(a); b = find_parent(b); if (a == b) return true; // 사이클 존재 parent[b] = a; return false;}int main() { int V, E; cin &gt;&gt; V &gt;&gt; E; parent.resize(V + 1); for (int i = 1; i &lt;= V; ++i) parent[i] = i; bool cycle = false; for (int i = 0; i &lt; E; ++i) { int a, b; cin &gt;&gt; a &gt;&gt; b; if (union_parent(a, b)) cycle = true; } cout &lt;&lt; (cycle ? \"Cycle Detected\" : \"No Cycle\") &lt;&lt; \"\\n\";}응용 2: Kruskal MST (최소 스패닝 트리)Union-Find 는 Kruskal 알고리즘에서 사이클 판별에 핵심적으로 사용된다.#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int u, v, w; bool operator&lt;(const Edge &amp;other) const { return w &lt; other.w; }};vector&lt;int&gt; parent;int find_parent(int x) { if (x == parent[x]) return x; return parent[x] = find_parent(parent[x]);}bool union_parent(int a, int b) { a = find_parent(a); b = find_parent(b); if (a == b) return false; parent[b] = a; return true;}int main() { int V, E; cin &gt;&gt; V &gt;&gt; E; vector&lt;Edge&gt; edges(E); for (int i = 0; i &lt; E; ++i) cin &gt;&gt; edges[i].u &gt;&gt; edges[i].v &gt;&gt; edges[i].w; sort(edges.begin(), edges.end()); parent.resize(V + 1); for (int i = 1; i &lt;= V; ++i) parent[i] = i; int total = 0; for (auto &amp;e : edges) if (union_parent(e.u, e.v)) total += e.w; cout &lt;&lt; \"MST cost: \" &lt;&lt; total &lt;&lt; \"\\n\";}시간 복잡도 연산 일반 최적화 적용 후 find / union O(log N) O(α(N)) ≈ O(1) 전체 연산 N번 O(N log N) O(N) α(N): 아커만(Ackermann) 함수의 역함수. 매우 느리게 증가하므로 거의 상수.핵심 요약 개념 설명 Find 원소의 루트 노드 탐색 Union 두 집합 병합 Path Compression 부모를 루트로 직접 연결 Union by Rank 트리 깊이 최소화 시간복잡도 거의 O(1) 수준 마무리Union-Find는 단순하면서도 강력한 구조로,그래프 이론, 집합 관리, 네트워크 연결성 등 다양한 분야에서 사용된다.특히 MST, 그룹화, 사이클 검출 등 모든 연결성 기반 문제의 핵심 도구이다." }, { "title": "이진 탐색 연습 문제", "url": "/posts/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%EC%97%B0%EC%8A%B5-%EB%AC%B8%EC%A0%9C/", "categories": "CodingTest", "tags": "CodingTest, Binary Search", "date": "2025-11-14 00:00:00 +0900", "snippet": "이진 탐색 연습 문제문제N개의 정렬된 데이터가 주어지고 Q개의 질의가 주어진다.정렬된 데이터에서 목표값이 있는 위치(인덱스)를 찾는 프로그램을 작성하시오.풀이#include &lt;iostream&gt;#define ARR_MAX_LEN 500001using namespace std;int N, Q;int arr[ARR_MAX_LEN] = { 0 };int binary_search(int num){ int low = 0, high = N - 1, mid = (low + high) / 2; while(low &lt;= high){ if(arr[mid] == num) return mid; else if(arr[mid] &lt; num) low = mid + 1; else high = mid - 1; mid = (low + high) / 2; } return -1;}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; arr[i]; } cin &gt;&gt; Q; for(int i = 0; i &lt; Q; i++){ int answer = 0, search_num; cin &gt;&gt; search_num; answer = binary_search(search_num); cout &lt;&lt; answer &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; return 0;}" }, { "title": "Algorithm_Binary Search", "url": "/posts/Algorithm_Binary-Search/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-11-14 00:00:00 +0900", "snippet": "Algorithm_Binary Search개요Binary Search(이진 탐색) 은 정렬된 배열 또는 단조성을 가진 함수에서 특정 값을 빠르게 찾는 알고리즘이다.단순 선형 탐색이 O(N) 인 반면, 이진 탐색은 O(log N) 으로 동작한다.기본 원리 탐색 구간의 시작(low)과 끝(high)을 지정한다. 중간 인덱스(mid = (low + high) / 2)를 계산한다. mid 위치의 값과 목표값을 비교한다. 목표값이 작으면 high = mid - 1 목표값이 크면 low = mid + 1 같으면 탐색 종료. 값이 없으면 low &gt; high 시점에 종료된다.예시 코드 (정확한 값 탐색)#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n, target; cin &gt;&gt; n &gt;&gt; target; vector&lt;int&gt; arr(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; arr[i]; sort(arr.begin(), arr.end()); int low = 0, high = n - 1; bool found = false; while (low &lt;= high) { int mid = (low + high) / 2; if (arr[mid] == target) { found = true; break; } else if (arr[mid] &lt; target) low = mid + 1; else high = mid - 1; } cout &lt;&lt; (found ? \"YES\" : \"NO\") &lt;&lt; \"\\n\";}STL 이진 탐색 함수C++ STL 은 이진 탐색을 위한 다양한 함수들을 제공한다.모두 &lt;algorithm&gt; 헤더에 정의되어 있다. 함수 반환 설명 binary_search(begin, end, val) bool 존재 여부 확인 lower_bound(begin, end, val) iterator val 이상이 처음 나오는 위치 upper_bound(begin, end, val) iterator val 초과가 처음 나오는 위치 equal_range(begin, end, val) pair [lower_bound, upper_bound) 구간 반환 예시: lower_bound / upper_bound#include &lt;bits/stdc++.h&gt;using namespace std;int main() { vector&lt;int&gt; v = {1, 2, 2, 2, 3, 5, 7}; int x = 2; auto lb = lower_bound(v.begin(), v.end(), x); // 첫 2의 위치 auto ub = upper_bound(v.begin(), v.end(), x); // 마지막 2 다음 위치 cout &lt;&lt; \"lower_bound index: \" &lt;&lt; (lb - v.begin()) &lt;&lt; \"\\n\"; cout &lt;&lt; \"upper_bound index: \" &lt;&lt; (ub - v.begin()) &lt;&lt; \"\\n\"; cout &lt;&lt; \"count of 2 = \" &lt;&lt; (ub - lb) &lt;&lt; \"\\n\";}출력:lower_bound index: 1upper_bound index: 4count of 2 = 3예시: 조건을 만족하는 최솟값 / 최댓값 찾기이진 탐색은 단순 값 탐색뿐 아니라 단조성(boolean monotonic) 을 가지는 조건에 대해 경계값을 찾는 데 자주 쓰인다.예시: x^2 &gt;= N 을 만족하는 최소 x 찾기#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() { ll N; cin &gt;&gt; N; ll low = 0, high = N, ans = -1; while (low &lt;= high) { ll mid = (low + high) / 2; if (mid * mid &gt;= N) { ans = mid; high = mid - 1; } else { low = mid + 1; } } cout &lt;&lt; ans &lt;&lt; \"\\n\"; // sqrt(N)의 올림값}응용 패턴 패턴 설명 정렬 배열에서 값 찾기 기본 이진 탐색 정답이 단조적인 문제 parametric search(파라메트릭 서치) 배열 내 특정 조건 만족 구간 찾기 lower_bound / upper_bound 함수의 경계 탐색 연속값 함수에서 최소/최대 경계값 계산 시간·거리·속도 등 이분 탐색 Ex: 최소 시간, 최소 거리 등 문제 Parametric Search (파라메트릭 서치)이진 탐색을 이용한 최적화 문제 풀이 기법으로,“조건을 만족하는 최솟값(혹은 최댓값)” 을 구하는 형태로 자주 사용된다.예제: 나무 자르기 문제 (BOJ 2805)#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() { int N; ll M; cin &gt;&gt; N &gt;&gt; M; vector&lt;ll&gt; tree(N); for (auto &amp;t : tree) cin &gt;&gt; t; ll low = 0, high = *max_element(tree.begin(), tree.end()); ll ans = 0; while (low &lt;= high) { ll mid = (low + high) / 2; ll sum = 0; for (ll h : tree) if (h &gt; mid) sum += (h - mid); if (sum &gt;= M) { // 더 많이 잘랐으면 절단 높이를 높인다. ans = mid; low = mid + 1; } else { high = mid - 1; } } cout &lt;&lt; ans &lt;&lt; \"\\n\";}시간복잡도 연산 복잡도 이진 탐색 O(log N) lower_bound / upper_bound O(log N) parametric search O(log N × f(N)) 핵심 요약 포인트 설명 1. 정렬 필요 이진 탐색은 정렬된 데이터에만 적용 가능 2. 중간값 계산 시 오버플로우 주의 mid = low + (high - low) / 2 3. lower/upper_bound 적극 활용 경계 탐색 문제에 유용 4. Parametric Search 조건 만족 최소/최대값 탐색 시 강력 5. O(log N) 매우 효율적인 탐색 알고리즘 마무리Binary Search 는 단순 탐색부터 최적화 문제까지 폭넓게 사용된다.특히 단조성을 가진 조건을 잘 정의하면, 거의 모든 “최소/최대” 문제를 해결할 수 있다." }, { "title": "Const 구간의 합 구하기_1D", "url": "/posts/Const-%EA%B5%AC%EA%B0%84%EC%9D%98-%ED%95%A9-%EA%B5%AC%ED%95%98%EA%B8%B0_1D/", "categories": "CodingTest", "tags": "CodingTest, Prefix Sum", "date": "2025-11-09 00:00:00 +0900", "snippet": "Const 구간의 합 구하기_1D문제1차원 배열에 N개의 수들이 입력되어 있다.이 배열의 임의의 구간에 있는 수들의 합을 물어보는 M의 쿼리에 답하는 프로그램을 작성하시오.쿼리에 답하는 중간에 배열의 어떤 원소도 값이 변경되지 않는다.풀이구간 합을 계산 하는 문제, 숫자 범위가 커서 Prefix Sum 으로 구간 별 합을 미리 모두 계산해놓고 그 값을 통해 구간 합 쿼리에 대한 답을 해야 시간 초과가 발생하지 않음#include &lt;iostream&gt;#define ARR_MAX_LEN 1000001using namespace std;long long arr[ARR_MAX_LEN] = { 0 };long long prefix_sum[ARR_MAX_LEN] = { 0 };int N, M;int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); long long answer = 0; cin &gt;&gt; N; for(int i = 1; i &lt;= N; i++){ cin &gt;&gt; arr[i]; // Prefix Sum 구하기 prefix_sum[i] += prefix_sum[i - 1] + arr[i]; } cin &gt;&gt; M; for(int i = 0; i &lt; M; i++){ int s, e; cin &gt;&gt; s &gt;&gt; e; answer = prefix_sum[e] - prefix_sum[s - 1]; cout &lt;&lt; answer &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "Algorithm_Prefix Sum", "url": "/posts/Algorithm_Prefix-Sum/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-11-09 00:00:00 +0900", "snippet": "Algorithm_Prefix Sum개요Prefix Sum(누적 합) 은 배열의 부분합을 빠르게 계산하기 위한 대표적인 전처리 기법이다.한 번의 전처리로 모든 구간 합을 O(1)에 계산할 수 있어, 완전탐색 O(N²) 문제를 O(N)으로 줄인다.기본 개념배열 A[1..N] 에 대해 다음과 같이 누적합 배열 P[1..N] 을 정의한다.\\[P[i] = A[1] + A[2] + ... + A[i]\\]즉, P[i] = P[i-1] + A[i], 단 P[0] = 0 으로 정의한다.이때 구간 [L, R]의 합은 다음처럼 O(1)에 계산된다.\\[sum(L, R) = P[R] - P[L-1]\\]예제 코드 (기본 1차원)#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int N, Q; cin &gt;&gt; N &gt;&gt; Q; vector&lt;int&gt; A(N+1), P(N+1, 0); for (int i = 1; i &lt;= N; ++i) { cin &gt;&gt; A[i]; P[i] = P[i-1] + A[i]; } while (Q--) { int L, R; cin &gt;&gt; L &gt;&gt; R; cout &lt;&lt; P[R] - P[L-1] &lt;&lt; \"\\n\"; } return 0;}2차원 Prefix Sum2차원 배열에서도 동일 개념을 확장할 수 있다.\\[S[y][x] = A[y][x] + S[y-1][x] + S[y][x-1] - S[y-1][x-1]\\]구간합([y1,x1]~[y2,x2])은 다음처럼 구한다.\\[sum = S[y2][x2] - S[y1-1][x2] - S[y2][x1-1] + S[y1-1][x1-1]\\]#include &lt;bits/stdc++.h&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int N, M; cin &gt;&gt; N &gt;&gt; M; vector&lt;vector&lt;int&gt;&gt; A(N+1, vector&lt;int&gt;(N+1)); vector&lt;vector&lt;int&gt;&gt; S(N+1, vector&lt;int&gt;(N+1, 0)); for (int i = 1; i &lt;= N; ++i) { for (int j = 1; j &lt;= N; ++j) { cin &gt;&gt; A[i][j]; S[i][j] = A[i][j] + S[i-1][j] + S[i][j-1] - S[i-1][j-1]; } } while (M--) { int y1, x1, y2, x2; cin &gt;&gt; y1 &gt;&gt; x1 &gt;&gt; y2 &gt;&gt; x2; int ans = S[y2][x2] - S[y1-1][x2] - S[y2][x1-1] + S[y1-1][x1-1]; cout &lt;&lt; ans &lt;&lt; \"\\n\"; }}Prefix Sum 변형 응용1️⃣ 차이 배열(Difference Array)구간 업데이트를 빠르게 수행할 때 사용한다.예: [L, R] 구간에 +v 를 더할 때diff[L] += v;diff[R+1] -= v;그리고 마지막에 누적합 한 번 수행:for (int i = 1; i &lt;= N; ++i) arr[i] = arr[i-1] + diff[i];2️⃣ 부분합이 K인 구간 개수 세기누적합 배열을 이용해 빠르게 조건을 만족하는 구간 수를 찾을 수 있다.#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int N, K; cin &gt;&gt; N &gt;&gt; K; vector&lt;long long&gt; a(N+1), prefix(N+1, 0); for (int i = 1; i &lt;= N; ++i) { cin &gt;&gt; a[i]; prefix[i] = prefix[i-1] + a[i]; } unordered_map&lt;long long,int&gt; cnt; long long ans = 0; cnt[0] = 1; // prefix[0] for (int i = 1; i &lt;= N; ++i) { ans += cnt[prefix[i] - K]; cnt[prefix[i]]++; } cout &lt;&lt; ans &lt;&lt; \"\\n\";}시간복잡도 연산 복잡도 누적합 계산 O(N) 구간합 계산 O(1) 2차원 누적합 전처리 O(N²) 2차원 구간합 계산 O(1) 핵심 요약 포인트 설명 1. 전처리로 O(1) 쿼리 처리 P[i] = P[i-1] + A[i] 2. 구간합 계산 공식 sum(L,R)=P[R]-P[L-1] 3. 2차원 확장 가능 영역합 계산 가능 4. 구간 업데이트는 차이 배열 diff로 처리 후 누적 5. 누적합+해시 조합 부분합이 K인 구간 개수 등 다양한 문제 해결 가능 마무리Prefix Sum은 모든 누적 연산 기반 문제의 기본 도구이다.누적합 배열은 단순하지만 강력하며, 슬라이딩 윈도우·DP 등과 결합하면 효율적인 풀이를 구성할 수 있다." }, { "title": "용액", "url": "/posts/%EC%9A%A9%EC%95%A1/", "categories": "CodingTest", "tags": "CodingTest, Two Pointer", "date": "2025-11-08 00:00:00 +0900", "snippet": "특정한 최단 경로문제KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다.각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.산성 용액의 특성값은 1부터 1,000,000,000 까지의 양의 정수로 나타내고,알칼리성 용액의 특성값은 -1부터 -1,000,000,000 까지의 음의 정수로 나타낸다.같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다.이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다.참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때,이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.입력첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다.둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며,이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다.N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.출력첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다.출력해야하는 두 용액은 특성값의 오름차순으로 출력한다.특성값이 0 에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int N;vector&lt;int&gt; char_num_lst;int main(void){ int answer_a = 0, answer_b = 0, answer = 0; cin &gt;&gt; N; for(int i = 0; i &lt; N; ++i){ int temp_num; cin &gt;&gt; temp_num; char_num_lst.push_back(temp_num); } int sp = 0, ep = N - 1; answer_a = char_num_lst[sp]; answer_b = char_num_lst[ep]; // 정답 값은 절대값 크기, 합산 값은 움직일 포인터를 결정하기 위해 부호 값을 가지고 있어야 함 int sum = char_num_lst[sp] + char_num_lst[ep]; answer = abs(sum); // sp != ep 도 가능, 포인터는 한 번에 하나만 움직이기 때문 while(sp &lt; ep){ sum = char_num_lst[sp] + char_num_lst[ep]; if(abs(sum) &lt;= answer){ answer = abs(sum); answer_a = char_num_lst[sp]; answer_b = char_num_lst[ep]; } // 투 포인터 이동 방향 결정, 두 값의 합이 0보다 작으면 시작 포인터 오른쪽 한칸 이동, 0보다 크면 끝 포인터 왼쪽으로 한칸 이동 if(sum == 0) break; else if(sum &lt; 0) sp++; else ep--; } cout &lt;&lt; answer_a &lt;&lt; \" \" &lt;&lt; answer_b &lt;&lt; \"\\n\"; return 0;}" }, { "title": "Algorithm_Two Pointer", "url": "/posts/Algorithm_Two-Pointer/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-11-08 00:00:00 +0900", "snippet": "Algorithm_Two Pointer개요Two Pointers(투 포인터) 는 하나의 배열 또는 두 개의 배열 위에서 두 개의 인덱스 포인터를 이동시키며 답을 구하는 기법이다. Sliding Window(슬라이딩 윈도우) 는 Two Pointers의 특수 케이스로, 구간의 왼쪽·오른쪽 경계를 포인터로 관리해 연속 구간 성질을 유지한 채 확장·축소한다. (정렬된 배열에서 해당 알고리즘을 사용해야 함)이 기법은 누적합 대비 메모리 사용이 적고, 완전탐색의 O(N²) 을 O(N) 또는 O(N log N) 으로 줄이는 데 효과적이다.알고리즘 활용 포인트 정렬된 배열에서 합이나 차이의 조건을 만족하는 쌍, 트리플을 찾을 때 적합하다. 연속 구간에 대한 합, 개수, 조건 만족 여부를 관리할 때 슬라이딩 윈도우가 적합하다. 윈도우 내부의 성질이 단조(monotonic) 하게 변해 왼쪽 포인터를 이동할 충분조건이 있을 때 효과적이다. 음수가 섞인 합 문제는 윈도우 불변식이 깨지는 경우가 많아 주의가 필요하다. 이 경우 자료구조 보강이나 다른 기법이 필요하다.시간복잡도 패턴 전형 복잡도 두 포인터 합/차이 탐색 O(N) 가변 길이 슬라이딩 윈도우(해시맵 동반) O(N) 평균 고정 길이 슬라이딩 윈도우 O(N) 두 포인터는 각 포인터가 배열을 최대 한 번씩만 끝까지 이동하기 때문에 O(N) 이 된다.기본 패턴1. 같은 배열에서 양끝 수렴(two-sum on sorted)#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() { ios::sync_with_stdio(false); cin.tie(NULL); int n; ll target; cin &gt;&gt; n &gt;&gt; target; vector&lt;ll&gt; a(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; // 정렬된 배열에서 사용되는 알고리즘이기 때문에 먼저 정렬 수행 sort(a.begin(), a.end()); int l = 0, r = n - 1; bool ok = false; while (l &lt; r) { ll s = a[l] + a[r]; if (s == target) { ok = true; break; } if (s &lt; target) ++l; else --r; } cout &lt;&lt; (ok ? \"YES\\n\" : \"NO\\n\"); return 0;}2. 서로 다른 두 배열 머지·교집합 탐색#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; A(n), B(m); for (int &amp;x: A) cin &gt;&gt; x; for (int &amp;y: B) cin &gt;&gt; y; sort(A.begin(), A.end()); sort(B.begin(), B.end()); int i = 0, j = 0; vector&lt;int&gt; inter; while (i &lt; n &amp;&amp; j &lt; m) { if (A[i] == B[j]) { inter.push_back(A[i]); ++i; ++j; } else if (A[i] &lt; B[j]) ++i; else ++j; } for (int z: inter) cout &lt;&lt; z &lt;&lt; ' '; cout &lt;&lt; '\\n';}3. 고정 길이 슬라이딩 윈도우(fixed window)#include &lt;bits/stdc++.h&gt;using namespace std;using ll = long long;int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;ll&gt; a(n); for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i]; ll sum = 0, best = LLONG_MIN; for (int i = 0; i &lt; n; ++i) { sum += a[i]; if (i &gt;= k) sum -= a[i - k]; if (i &gt;= k - 1) best = max(best, sum); } cout &lt;&lt; best &lt;&lt; '\\n';}4. 가변 길이 슬라이딩 윈도우(양수 배열의 부분합)#include &lt;bits/stdc++.h&gt;using namespace std;int main() { int n; long long S; cin &gt;&gt; n &gt;&gt; S; vector&lt;long long&gt; a(n); for (auto &amp;x: a) cin &gt;&gt; x; long long sum = 0; int ans = INT_MAX, l = 0; for (int r = 0; r &lt; n; ++r) { sum += a[r]; while (l &lt;= r &amp;&amp; sum - a[l] &gt;= S) { sum -= a[l]; ++l; } if (sum &gt;= S) ans = min(ans, r - l + 1); } cout &lt;&lt; (ans == INT_MAX ? 0 : ans) &lt;&lt; '\\n';}마무리Two Pointers 및 Sliding Window 는 연속 구간의 성질과 단조성을 이용해 완전탐색을 선형으로 줄이는 핵심 기법이다. 정렬 전제와 윈도우 불변식을 정확히 세우고, 포인터 전진 규칙을 명확히 구현하면 대부분의 고전 문제를 효율적으로 해결할 수 있다." }, { "title": "Algorithm_Dijkstra", "url": "/posts/Algorithm_Dijkstra/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-10-31 00:00:00 +0900", "snippet": "Algorithm_Dijkstra다익스트라 알고리즘 (Dijkstra Algorithm)다익스트라 알고리즘(Dijkstra Algorithm) 은 하나의 시작점(Source) 으로부터 다른 모든 정점까지의 최단 거리(Shortest Path) 를 구하는 알고리즘이다.단, 간선의 가중치(Weight) 가 음수이면 사용할 수 없다.1. 핵심 개념 시작 노드의 거리를 0으로 두고, 나머지 노드의 거리를 무한(INF)으로 초기화한다. 가장 짧은 거리의 노드를 선택한다. 그 노드와 연결된 간선을 확인하여 더 짧은 경로를 발견하면 갱신(Relaxation) 한다. 모든 노드를 처리할 때까지 반복한다.2. 자료구조 구성 역할 자료형 설명 그래프 vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; 인접 리스트 (to, weight) 거리 배열 vector&lt;int&gt; 시작점으로부터의 최단 거리 저장 우선순위 큐 priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt;&gt; 최소 거리 노드를 빠르게 탐색 3. 시간 복잡도 그래프 표현 복잡도 인접 행렬 O(V²) 인접 리스트 + Min-Heap O((V + E) log V) 4. C++ 기본 구현 코드#include &lt;iostream&gt;using namespace std;struct Edge { int to; // 정점 int cost; // 간선 가중치 (큐에서 사용할 때는 누적 가중치가 된다)};// 우선순위 큐 비교자 (Min-Heap)struct cmp { bool operator()(const Edge&amp; a, const Edge&amp; b) const { return a.cost &gt; b.cost; // cost가 작은 Edge가 더 높은 우선순위 }};int main() { ios::sync_with_stdio(false); cin.tie(NULL); int n, m; cin &gt;&gt; n &gt;&gt; m; // 정점, 간선 개수 vector&lt;vector&lt;Edge&gt;&gt; graph(n); for (int i = 0; i &lt; m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; graph[u].push_back({v, w}); graph[v].push_back({u, w}); // 무방향 그래프 예시 } const int INF = 1e9; vector&lt;int&gt; dist(n, INF); priority_queue&lt;Edge, vector&lt;Edge&gt;, cmp&gt; pq; // Edge 구조체 기반 큐 int start = 0; dist[start] = 0; pq.push({start, 0}); while (!pq.empty()) { Edge cur = pq.top(); pq.pop(); // 현재 가중치가 작은 경우만 dist 에 업데이트 할 수 있도록 함 if (cur.cost &gt; dist[cur.to]) continue; for (auto &amp;next : graph[cur.to]) { int newCost = cur.cost + next.cost; if (newCost &lt; dist[next.to]) { dist[next.to] = newCost; pq.push({next.to, newCost}); } } } cout &lt;&lt; \"최단 거리 결과:\\n\"; for (int i = 0; i &lt; n; ++i) cout &lt;&lt; i &lt;&lt; \" : \" &lt;&lt; dist[i] &lt;&lt; \"\\n\"; return 0;}5. 구현 포인트 정리 요소 설명 priority_queue 가장 짧은 거리 노드를 효율적으로 선택 비교자 cmp Min-Heap 형태로 동작하도록 변경 Relaxation 더 짧은 경로를 발견하면 거리 갱신 visited 불필요 dist 값으로 방문 여부 판별 가능 무방향 그래프 간선을 양쪽으로 추가 6. 시각적 이해Start(0) ├──▶ (1, 2) ├──▶ (2, 5) └──▶ (3, 9)pq: [ (0,0) ]→ (0,0) pop → (1,2), (2,5), (3,9) push→ (1,2) pop → Relax 주변 노드→ 계속 반복하며 dist[] 갱신7. 확장 응용 다중 시작점 Dijkstra: 여러 source를 모두 pq에 넣고 시작 경로 복원(Path Tracking): prev[] 배열로 경로 추적 SPFA / Bellman-Ford: 음수 가중치가 있을 때 대체 알고리즘8. 결론다익스트라 알고리즘은 Greedy + Priority Queue 조합으로,최단 경로를 효율적으로 찾는 대표적인 알고리즘이다.C++에서는 priority_queue를 Min-Heap으로 바꾸기 위해 Functor 또는 greater&lt;&gt; 비교자를 사용하는 것이 핵심이다." }, { "title": "특정한 최단 경로", "url": "/posts/%ED%8A%B9%EC%A0%95%ED%95%9C-%EC%B5%9C%EB%8B%A8-%EA%B2%BD%EB%A1%9C/", "categories": "CodingTest", "tags": "CodingTest, Dijkstra", "date": "2025-10-26 00:00:00 +0900", "snippet": "특정한 최단 경로https://www.acmicpc.net/problem/1504문제방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.입력첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.출력첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_LEN 810typedef struct{ int node; int weight;}edge_t;int N, E, V1, V2, answer = -1;vector&lt;vector&lt;edge_t&gt; &gt; graph(MAX_LEN);vector&lt;int&gt; dist(MAX_LEN, INT_MAX);struct compare{ bool operator()(const edge_t &amp;a, const edge_t &amp;b) const { return a.weight &gt; b.weight; }};void input(){ cin &gt;&gt; N &gt;&gt; E; int a, b, c; for(int i = 0; i &lt; E; i++){ cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; graph[a].push_back({b, c}); graph[b].push_back({a, c}); } cin &gt;&gt; V1 &gt;&gt; V2;}void dijkstra(int start){ priority_queue&lt;edge_t, vector&lt;edge_t&gt;, compare&gt; pq; // 호출할 때마다 dist 전체를 초기화하지 않고, 호출 전/후에 호출자가 초기화하는 패턴 유지 dist[start] = 0; pq.push({start, 0}); while(!pq.empty()){ edge_t cur_edge = pq.top(); pq.pop(); if(cur_edge.weight &gt; dist[cur_edge.node]) continue; for(auto &amp;next_edge : graph[cur_edge.node]){ int update_weight = cur_edge.weight + next_edge.weight; if(update_weight &lt; dist[next_edge.node]){ dist[next_edge.node] = update_weight; pq.push({next_edge.node, update_weight}); } } }}void init_lst(vector&lt;int&gt; &amp;arr){ for(int i = 1; i &lt;= N; ++i){ arr[i] = INT_MAX; }}// 1 -&gt; V1 -&gt; V2 -&gt; N// 1 -&gt; V2 -&gt; V1 -&gt; Nvoid simulate(){ bool flag1 = true, flag2 = true; // dist 초기화 (1..N) init_lst(dist); // 1 -&gt; V1, 1 -&gt; V2 dijkstra(1); int route1 = dist[V1]; int route2 = dist[V2]; // 도달 가능 여부 정확히 판정 if(dist[V1] == INT_MAX) flag1 = false; if(dist[V2] == INT_MAX) flag2 = false; // 두 경로 모두 도달 불가일 경우 answer 값 업데이트 후 return if(!flag1 &amp;&amp; !flag2){ answer = -1; return ; } // dist 초기화 init_lst(dist); // V1 -&gt; V2 (무방향이므로 V1→V2와 V2→V1 비용 동일) dijkstra(V1); if(flag1 &amp;&amp; dist[V2] != INT_MAX) route1 += dist[V2]; else flag1 = false; if(flag2 &amp;&amp; dist[V2] != INT_MAX) route2 += dist[V2]; // 1→V2 경로에서 V2→V1 비용 추가(대칭) else flag2 = false; // dist 초기화 init_lst(dist); // V2 -&gt; N (route1 마무리) dijkstra(V2); if(flag1 &amp;&amp; dist[N] != INT_MAX) route1 += dist[N]; else flag1 = false; // dist 초기화 init_lst(dist); // V1 -&gt; N (route2 마무리) dijkstra(V1); if(flag2 &amp;&amp; dist[N] != INT_MAX) route2 += dist[N]; else flag2 = false; if(!flag1 &amp;&amp; !flag2) answer = -1; else if(!flag1) answer = route2; else if(!flag2) answer = route1; else answer = min(route1, route2);}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); simulate(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "C++_Functor", "url": "/posts/C++_Functor/", "categories": "CodingTest", "tags": "CodingTest, C++", "date": "2025-10-26 00:00:00 +0900", "snippet": "C++_Functor1. Functor란?Functor(펑터) 는 함수처럼 동작하는 객체(Function Object) 를 의미한다.즉, 클래스나 구조체 내부에 operator() 연산자를 정의하여, 객체를 함수처럼 호출할 수 있도록 만든 것이다.C++에서는 함수 포인터보다 상태를 보존할 수 있는 함수 객체가 더 유연하게 사용된다.Functor는 STL(Standard Template Library) 의 핵심 구성 요소로, 알고리즘(예: sort, find, transform)과 컨테이너(priority_queue, map 등)에서 비교자, 조건자, 변환자로 자주 사용된다.2. Functor의 기본 형태#include &lt;iostream&gt;using namespace std;struct Adder { int base; int operator()(int x) const { return base + x; }};int main() { Adder add{10}; cout &lt;&lt; add(5) &lt;&lt; \"\\n\"; // add.operator()(5) 와 동일, 결과는 15}이때 Adder 객체는 함수처럼 호출 가능하다.즉, add(5) 는 add.operator()(5) 를 호출하는 문법적 축약이다.Functor의 장점 상태(base)를 내부에 유지 가능 컴파일 시 인라인 최적화 가능 함수 포인터보다 타입 안정성이 높음3. struct cmp 비교자 Functor 예시priority_queue, sort, set, map 등에서 정렬 기준을 바꾸려면 Functor를 직접 정의한다.struct Edge { int to; int cost;};struct cmp { bool operator()(const Edge&amp; a, const Edge&amp; b) const { return a.cost &gt; b.cost; }};이 Functor는 비교자(Comparator) 로 동작한다.a.cost &gt; b.cost 를 반환하므로, 비용(cost) 이 작은 Edge 가 더 높은 우선순위를 가진다.즉, min-heap 형태의 priority_queue를 만들 때 사용한다.4. 문법 요소별 해석 문법 요소 설명 struct cmp 비교용 Functor 정의 operator() 함수 호출 연산자 오버로딩 (객체를 함수처럼 호출) const Edge&amp; a, const Edge&amp; b 복사 없이 참조로 전달하며, 원본을 변경하지 않음 함수 뒤 const Functor 객체가 상수 컨텍스트에서 호출되어도 동작 가능하도록 보장 즉, operator() 함수는 다음과 같이 동작한다.cmp cmpObj;Edge e1{1, 5}, e2{2, 3};bool result = cmpObj(e1, e2); // cmpObj.operator()(e1, e2)이때 result 는 true (5 &gt; 3)이므로, e1이 e2보다 우선순위가 낮다는 의미다.5. priority_queue에서의 사용 예시#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int to; int cost;};struct cmp { bool operator()(const Edge&amp; a, const Edge&amp; b) const { return a.cost &gt; b.cost; }};int main() { priority_queue&lt;Edge, vector&lt;Edge&gt;, cmp&gt; pq; pq.push({1, 5}); pq.push({2, 3}); pq.push({3, 7}); while (!pq.empty()) { auto e = pq.top(); pq.pop(); cout &lt;&lt; e.to &lt;&lt; \":\" &lt;&lt; e.cost &lt;&lt; \"\\n\"; }}출력2:31:53:7이처럼 Functor를 통해 priority_queue를 최소 힙(min-heap) 으로 구성할 수 있다.6. Functor vs LambdaFunctor와 Lambda는 같은 기능을 수행할 수 있다.람다는 C++11 이후 Functor를 간결하게 표현하는 문법이다.#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int to; int cost; };int main() { auto cmp = [](const Edge&amp; a, const Edge&amp; b) { return a.cost &gt; b.cost; }; priority_queue&lt;Edge, vector&lt;Edge&gt;, decltype(cmp)&gt; pq(cmp); pq.push({1, 5}); pq.push({2, 3}); pq.push({3, 7}); while (!pq.empty()) { auto e = pq.top(); pq.pop(); cout &lt;&lt; e.to &lt;&lt; \":\" &lt;&lt; e.cost &lt;&lt; \"\\n\"; }}람다는 문법이 간단하고, 지역 범위에서 쉽게 정의할 수 있지만,Functor는 명시적 타입 정의가 가능하고 복잡한 비교 로직이나 상태를 유지할 때 유리하다.7. Functor가 STL에서 쓰이는 이유STL 알고리즘과 컨테이너는 함수를 인자로 받는 일반화된 구조를 갖는다.이때 Functor를 사용하면 템플릿 기반 타입 안정성과 인라인 최적화가 가능하다.예시: sort()에서 Functor를 이용한 사용자 정의 정렬struct cmpInt { bool operator()(int a, int b) const { return a &gt; b; }};vector&lt;int&gt; v = {5, 1, 4, 2};sort(v.begin(), v.end(), cmpInt()); // Functor 객체 전달결과: 1 2 4 58. 요약 항목 설명 Functor 함수처럼 동작하는 객체 operator() 함수 호출 연산자 오버로딩 cmp 구조체 비교자 Functor, 우선순위 큐에서 사용 const 참조 불필요한 복사 방지 및 안전성 확보 함수 뒤 const 상수 객체 호출 보장 priority_queue에서 cmp 사용 min-heap 구성 가능 람다(lambda) Functor의 간결한 형태 (C++11 이후) " }, { "title": "Algorithm_Hash", "url": "/posts/Algorithm_Hash/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-10-26 00:00:00 +0900", "snippet": "Algorithm_HashHash(해시) 는 어떤 데이터를 고정된 크기의 숫자 값으로 변환하는 방법이다.예를 들어 문자열 “apple” → 1234 처럼 바꾸는 함수가 Hash Function(해시 함수) 이다.이 숫자를 배열의 인덱스처럼 사용하면 데이터를 빠르게 찾을 수 있다.이 개념을 이용한 자료구조가 Hash Table(해시 테이블) 이다.Hash Table 기본 구조Hash Table은 Key → Value 형태로 데이터를 저장한다. Hash Function으로 Key를 숫자로 변환 Bucket 배열의 인덱스로 사용 같은 인덱스에 여러 데이터가 들어올 경우 충돌(Collision) 이 발생충돌은 보통 체이닝(Chaining) 방식으로 해결한다.(같은 인덱스에 여러 값을 리스트로 저장)간단한 예시로 보는 Hash Function#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 간단한 문자열 해시 함수int simpleHash(const string&amp; key, int tableSize) { int hashValue = 0; for (char c : key) hashValue += c; // 문자 아스키값의 합 return hashValue % tableSize; // 테이블 크기로 나눈 나머지}int main() { cout &lt;&lt; \"apple → \" &lt;&lt; simpleHash(\"apple\", 10) &lt;&lt; \"\\n\"; cout &lt;&lt; \"banana → \" &lt;&lt; simpleHash(\"banana\", 10) &lt;&lt; \"\\n\"; cout &lt;&lt; \"peach → \" &lt;&lt; simpleHash(\"peach\", 10) &lt;&lt; \"\\n\";}출력 예시apple → 0banana → 9peach → 3문자열을 숫자로 바꿔서 테이블 인덱스로 쓰는 구조이다.간단한 Hash Table 구현#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;// 문자열 해시 함수int hashFunc(const string&amp; key, int tableSize) { int hashValue = 0; for (char c : key) hashValue = (hashValue + c) % tableSize; return hashValue;}class HashTable { vector&lt;list&lt;pair&lt;string, string&gt;&gt;&gt; table; // 체이닝 구조 int size;public: HashTable(int s) : size(s) { table.resize(s); } void insert(const string&amp; key, const string&amp; value) { int idx = hashFunc(key, size); for (auto&amp; kv : table[idx]) { if (kv.first == key) { kv.second = value; // 업데이트 return; } } table[idx].push_back({key, value}); } string find(const string&amp; key) { int idx = hashFunc(key, size); for (auto&amp; kv : table[idx]) { if (kv.first == key) return kv.second; } return \"(not found)\"; } void print() { for (int i = 0; i &lt; size; i++) { cout &lt;&lt; i &lt;&lt; \": \"; for (auto&amp; kv : table[i]) cout &lt;&lt; \"[\" &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; \"] \"; cout &lt;&lt; \"\\n\"; } }};int main() { HashTable ht(5); ht.insert(\"apple\", \"red\"); ht.insert(\"banana\", \"yellow\"); ht.insert(\"grape\", \"purple\"); ht.insert(\"melon\", \"green\"); ht.print(); cout &lt;&lt; \"find(banana): \" &lt;&lt; ht.find(\"banana\") &lt;&lt; \"\\n\"; cout &lt;&lt; \"find(peach): \" &lt;&lt; ht.find(\"peach\") &lt;&lt; \"\\n\";}출력 예시0: [banana:yellow] 1: [melon:green] 2: 3: [grape:purple] 4: [apple:red] find(banana): yellowfind(peach): (not found)핵심 요약 개념 설명 Hash Function 데이터를 숫자로 바꾸는 함수 Collision 서로 다른 키가 같은 인덱스로 해시될 때 Chaining 같은 인덱스에 리스트로 여러 값을 저장 Load Factor 저장된 개수 / 테이블 크기 Rehash 테이블이 가득 차면 크기를 늘려 다시 해시 정리 Hash Table은 평균 O(1) 속도로 탐색이 가능하다. 좋은 해시 함수일수록 충돌이 적고 빠르다. 해시 테이블 크기는 소수로 잡야야 충돌이 일어날 가능성이 적어진다. C++에서는 직접 구현할 필요 없이 unordered_map 을 많이 사용한다.#include &lt;unordered_map&gt;unordered_map&lt;string, string&gt; color;color[\"apple\"] = \"red\";cout &lt;&lt; color[\"apple\"];Hash의 원리를 이해하고 직접 구현해보면,unordered_map의 내부 구조를 쉽게 이해할 수 있다.C++ unordered_map 활용C++에서는 직접 Hash Table을 구현하기보다 unordered_map을 많이 사용한다.평균적으로 탐색, 삽입, 삭제가 O(1) 이지만, 해시 충돌이 극단적으로 많으면 최악 O(N) 이 될 수 있다.기본 예시#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, string&gt; color; color[\"apple\"] = \"red\"; color[\"banana\"] = \"yellow\"; cout &lt;&lt; color[\"apple\"] &lt;&lt; \"\\n\"; return 0;}자주 나오는 실수 1: operator[]가 원소를 만든다operator[]는 키가 없으면 기본값으로 새 원소를 생성한다.존재 여부만 확인하고 싶으면 find를 쓰는 편이 안전하다.#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; // 여기서 \"ghost\" 키가 없는데도 생성되고 값 0이 들어간다 cout &lt;&lt; m[\"ghost\"] &lt;&lt; \"\\n\"; // 존재 여부 확인은 find가 더 안전하다 if (m.find(\"ghost2\") == m.end()) { cout &lt;&lt; \"ghost2 not found\\n\"; } return 0;}빈도 카운팅 패턴 (코테 최다 출현)#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;int main() { vector&lt;int&gt; a = {1, 3, 3, 7, 1, 3}; unordered_map&lt;int, int&gt; cnt; for (int x : a) cnt[x]++; cout &lt;&lt; \"count(1) = \" &lt;&lt; cnt[1] &lt;&lt; \"\\n\"; cout &lt;&lt; \"count(3) = \" &lt;&lt; cnt[3] &lt;&lt; \"\\n\"; cout &lt;&lt; \"count(7) = \" &lt;&lt; cnt[7] &lt;&lt; \"\\n\"; return 0;}성능 팁: reserve와 max_load_factor데이터가 많아지면 rehash가 반복되면서 시간 비용이 커질 수 있다.대략 원소 개수를 예측할 수 있으면 reserve로 미리 버킷을 준비하는 편이 유리하다.#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main() { unordered_map&lt;int, int&gt; m; // 대략 200000개쯤 들어갈 예정이라면 미리 예약한다 m.reserve(200000); // 충돌을 더 줄이고 싶다면 로드 팩터도 낮출 수 있다 m.max_load_factor(0.7f); for (int i = 0; i &lt; 200000; i++) m[i] = i; cout &lt;&lt; m[199999] &lt;&lt; \"\\n\"; return 0;}커스텀 키: pair를 키로 쓰는 방법unordered_map은 기본적으로 pair에 대한 해시가 없다.pair&lt;int,int&gt; 같은 키를 쓰려면 해시 함수를 직접 제공해야 한다.#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;struct PairHash { size_t operator()(const pair&lt;int, int&gt;&amp; p) const { // 흔히 쓰는 결합 방식 중 하나이다 // (충돌을 완전히 막는 것은 아니고 분산을 좋게 만들기 위함이다) size_t h1 = (size_t)p.first; size_t h2 = (size_t)p.second; return h1 * 1315423911u + h2; }};int main() { unordered_map&lt;pair&lt;int, int&gt;, int, PairHash&gt; mp; mp[{1, 2}] = 10; mp[{3, 4}] = 20; cout &lt;&lt; mp[{1, 2}] &lt;&lt; \"\\n\"; return 0;}unordered_map STL API 정리unordered_map에서 가장 많이 쓰는 API(Application Programming Interface)를 코테 관점으로 정리했다.아래 표의 복잡도는 평균 기준이며, 충돌이 극단적이면 최악 O(N)이 될 수 있다.1) 생성, 상태 확인 API 의미 평균 복잡도 unordered_map&lt;K,V&gt; m; 기본 생성이다. - m.empty() 비어있는지 확인한다. O(1) m.size() 원소 개수를 반환한다. O(1) m.clear() 전부 삭제한다. O(N) 생성 예시#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; // 기본 생성 unordered_map&lt;string, int&gt; m2 = m; // 복사 unordered_map&lt;string, int&gt; m3(move(m2)); // 이동 cout &lt;&lt; m3.empty() &lt;&lt; \"\\n\"; cout &lt;&lt; m3.size() &lt;&lt; \"\\n\"; return 0;}2) 조회 API API 의미 특징 m.find(key) key를 찾는다. 없으면 end를 반환한다. m.count(key) key 존재 여부를 0 또는 1로 반환한다. unordered_map은 키 중복이 없어서 0 또는 1이다. m.contains(key) key 존재 여부를 bool로 반환한다. C++20부터 지원이다. m.at(key) key에 대응하는 값을 반환한다. 없으면 예외가 발생한다. m[key] key에 대응하는 값을 참조로 반환한다. 없으면 기본값 원소가 생성된다. find, count 예시#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; m[\"a\"] = 10; auto it = m.find(\"a\"); if (it != m.end()) cout &lt;&lt; it-&gt;second &lt;&lt; \"\\n\"; cout &lt;&lt; m.count(\"a\") &lt;&lt; \"\\n\"; // 1 cout &lt;&lt; m.count(\"b\") &lt;&lt; \"\\n\"; // 0 return 0;}at vs operator[] 차이 예시#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; m[\"a\"] = 10; // at는 없으면 예외가 난다 try { cout &lt;&lt; m.at(\"b\") &lt;&lt; \"\\n\"; } catch (...) { cout &lt;&lt; \"at: not found\\n\"; } // operator[]는 없으면 원소를 만든다 cout &lt;&lt; m[\"b\"] &lt;&lt; \"\\n\"; // 0 출력, 동시에 b가 생성된다 cout &lt;&lt; m.size() &lt;&lt; \"\\n\"; // 2 return 0;}3) 삽입 API API 의미 특징 m.insert({k,v}) (k,v) 삽입을 시도한다. 이미 있으면 삽입되지 않는다. m.emplace(k,v) (k,v) 삽입을 시도한다. 불필요한 복사를 줄이는 편이다. m.try_emplace(k, args…) 키가 없을 때만 value를 생성해 삽입한다. value 생성 비용이 큰 경우 유리하다. m.insert_or_assign(k, v) 있으면 덮어쓰고 없으면 삽입한다. 업데이트 패턴에 편하다. insert의 반환값 활용insert는 pair&lt;iterator, bool&gt;을 반환한다. bool은 실제 삽입 성공 여부이다.#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; auto r1 = m.insert({\"a\", 10}); cout &lt;&lt; r1.second &lt;&lt; \"\\n\"; // 1 auto r2 = m.insert({\"a\", 20}); cout &lt;&lt; r2.second &lt;&lt; \"\\n\"; // 0, 이미 존재해서 실패 cout &lt;&lt; m[\"a\"] &lt;&lt; \"\\n\"; // 10 return 0;}insert_or_assign 예시#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; m.insert_or_assign(\"a\", 10); m.insert_or_assign(\"a\", 30); cout &lt;&lt; m[\"a\"] &lt;&lt; \"\\n\"; // 30 return 0;}4) 삭제 API API 의미 특징 m.erase(key) key를 삭제한다. 삭제된 개수(0 또는 1)를 반환한다. m.erase(it) iterator 위치 원소를 삭제한다. 반복 중 삭제에 유리하다. 반복 중 삭제 패턴#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; m[\"a\"] = 1; m[\"b\"] = 2; m[\"c\"] = 3; for (auto it = m.begin(); it != m.end(); ) { if (it-&gt;second % 2 == 1) it = m.erase(it); // 홀수 제거 else ++it; } cout &lt;&lt; m.size() &lt;&lt; \"\\n\"; return 0;}5) 순회 API API 의미 m.begin(), m.end() iterator로 전체 순회한다. m.cbegin(), m.cend() const iterator로 순회한다. range based for 전체 순회한다. unordered_map은 정렬된 순서를 보장하지 않는다. 출력 순서가 실행마다 달라질 수 있다.#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;string&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; m; m[\"apple\"] = 3; m[\"banana\"] = 5; for (auto&amp; kv : m) { cout &lt;&lt; kv.first &lt;&lt; \" \" &lt;&lt; kv.second &lt;&lt; \"\\n\"; } return 0;}6) 버킷, 로드 팩터 관련 APIhash 성능은 충돌과 관련이 있고, 충돌은 로드 팩터와 버킷 수에 영향을 받는다. API 의미 m.bucket_count() 버킷 개수를 반환한다. m.bucket(key) key가 들어갈 버킷 번호를 반환한다. m.load_factor() 현재 로드 팩터를 반환한다. m.max_load_factor(x) 최대 로드 팩터를 설정한다. m.rehash(b) 최소 b개의 버킷을 확보하도록 재해시한다. m.reserve(n) n개 원소를 넣어도 재해시가 덜 나게 버킷을 준비한다. " }, { "title": "STL_Set", "url": "/posts/STL_Set/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-10-18 00:00:00 +0900", "snippet": "Set (STL) 개요std::set 컨테이너는 중복 없이(unique), 정렬된 상태(sorted) 로 요소를 보관하는 연관 컨테이너(associative container)다.즉, 값 자체가 키(key)가 되며, 삽입·검색·삭제 등이 모두 로그(logarithmic) 시간 복잡도를 갖는다.주로 설정값 집합(configuration set), 유니크한 식별자 집합(ID set) 등을 다룰 때 유용하다. 특성상 속도가 조금 느릴 수 있고, 이를 감안하여 사용해야 한다.1. 헤더 및 기본 문법#include &lt;set&gt;std::set&lt;T&gt; s;여기서 T 는 요소 타입이다.기본 비교 객체(comparator)로 std::less&lt;T&gt; 가 사용되어 오름차순 정렬을 갖는다.내림차순 등 커스텀 정렬이 필요하면 다음처럼 지정할 수 있다.std::set&lt;int, std::greater&lt;int&gt;&gt; descSet = {5, 1, 3, 2};2. 주요 특징 유일한 요소 유지: 동일한 값이 둘 이상 존재할 수 없다. 삽입 시 이미 존재하면 동작이 무시된다. 자동 정렬 유지: 삽입할 때마다 내부적으로 정렬이 유지된다. 이 때문에 인덱스 연산([])은 지원되지 않는다. 값 수정 불가(불변 요소): 컨테이너에 저장된 값은 직접 수정할 수 없고, 수정하려면 삭제 후 재삽입해야 한다. 로그 시간 복잡도: 삽입, 삭제, 탐색 모두 평균적으로 O(log n)이다. 내부 구현은 보통 레드‑블랙 트리(Red‑Black Tree) 형태다.3. 사용 예시#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() { set&lt;int&gt; s = {4, 2, 5, 2, 1}; // 중복 2가 한 번만 저장 for (auto x : s) { cout &lt;&lt; x &lt;&lt; \" \"; // 출력: 1 2 4 5 } cout &lt;&lt; endl; // 삽입 auto [it, inserted] = s.insert(3); if (inserted) { cout &lt;&lt; \"3 inserted\\n\"; } // 탐색 if (s.find(4) != s.end()) { cout &lt;&lt; \"4 exists\\n\"; } // 삭제 s.erase(1); return 0;} insert 와 erase 를 활용하는 예시#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int Q;set&lt;int&gt; s;int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int val; char ch; cin &gt;&gt; Q; for(int i = 0; i &lt; Q; i++){ cin &gt;&gt; ch &gt;&gt; val; if(ch == 'i'){ s.insert(val); } else if(ch == 'r'){ s.erase(val); } } for(const auto &amp; data : s){ cout &lt;&lt; data &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; return 0;} Set 함수 인덱스 참조하고 싶을 때 (vector 로 copy 하는 방법도 있음)#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int Q;set&lt;long long&gt; s;int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; Q; for (int i = 0; i &lt; Q; i++) { char ch; long long val; cin &gt;&gt; ch &gt;&gt; val; if (ch == 'i') s.insert(val); else if (ch == 'r') s.erase(val); } long long x; // 1-based cin &gt;&gt; x; if (s.empty() || x &lt; 1 || x &gt; s.size()) { cout &lt;&lt; \"OVER\\n\"; return 0; } long long idx = 1; // 1-based for (auto it = s.begin(); it != s.end(); ++it, ++idx) { if (idx == x) { cout &lt;&lt; *it &lt;&lt; '\\n'; break; } } // 다른 풀이 // **set → vector 복사** vector&lt;long long&gt; v(s.begin(), s.end()); cout &lt;&lt; v[x - 1] &lt;&lt; '\\n'; // 1-based index → 0-based로 변환 return 0;} find() 활용법#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;cmath&gt;#include &lt;climits&gt;using namespace std;int Q;set&lt;int&gt; s;int main(void) { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int val; char ch; cin &gt;&gt; Q; for (int i = 0; i &lt; Q; i++) { cin &gt;&gt; ch &gt;&gt; val; if (ch == 'i') { s.insert(val); } else if (ch == 'r') { s.erase(val); } else if (ch == 'f') { // 존재 확인: 반드시 find() 사용 auto it = s.find(val); if (it == s.end()) { cout &lt;&lt; \"NOPE\\n\"; continue; } // 집합에 유일한 원소이면 UNIQUE if (s.size() == 1) { cout &lt;&lt; \"UNIQUE\\n\"; continue; } long long search_num = val; long long diff_min = LLONG_MAX; int answer = 0; // s.size() &gt;= 2 이므로 최소 하나는 후보가 생김 for (const auto &amp;num : s) { if (num == val) continue; // 자기 자신 제외 long long temp_diff = llabs(search_num - (long long)num); if (temp_diff &lt; diff_min) { diff_min = temp_diff; answer = num; } else if (temp_diff == diff_min &amp;&amp; num &lt; answer) { // 차이가 같으면 더 작은 수 answer = num; } } cout &lt;&lt; answer &lt;&lt; \"\\n\"; } } return 0;} lower_bound, upper_bound 활용법#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int Q;set&lt;int&gt; s;int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int val; char ch; cin &gt;&gt; Q; for(int i = 0; i &lt; Q; i++){ cin &gt;&gt; ch &gt;&gt; val; if(ch == 'i'){ s.insert(val); } else if(ch == 'r'){ s.erase(val); } //lower_bound(x) 는 첫 번째 값 ≥ x 의 iterator 를 준다. // val 이상 원소 중 가장 작은 값 else if(ch == 'b'){ if(s.lower_bound(val) != s.end()){ auto iter = s.lower_bound(val); cout &lt;&lt; *iter &lt;&lt; \"\\n\"; } } //upper_bound(x) 는 첫 번째 값 &gt; x 의 iterator 를 준다. //upper_bound(x) → x 초과 첫 값 else if(ch == 's'){ if(s.upper_bound(val) != s.begin()){ auto iter = s.upper_bound(val); // val 이하 원소 중 가장 큰 값 iter--; cout &lt;&lt; *iter &lt;&lt; \"\\n\"; } } } cout &lt;&lt; \"\\n\"; return 0;}4. 주요 멤버 함수 및 연산자 함수/연산자 설명 insert(value) 값 삽입 (존재하면 삽입 안됨) erase(value) 값 삭제 find(key) 키 탐색, iterator 반환 count(key) 키와 동일한 요소 개수 (Set은 0 또는 1) lower_bound(key) / upper_bound(key) 키 이상(이상)/키 초과 첫 위치 iterator 반환 size() / empty() 크기 조회 / 비었는지 확인 begin() / end() 순회용 iterator 비교 연산자 ==, != 지원 두 Set의 동일 여부 비교 가능 5. 커스텀 비교 및 정렬 순서 변경// 내림차순 정렬std::set&lt;int, std::greater&lt;int&gt;&gt; sDesc = {1, 5, 3, 2};for (auto x : sDesc) { cout &lt;&lt; x &lt;&lt; \" \"; // 출력: 5 3 2 1}또한 커스텀 비교 함수 객체를 만들면 복잡한 기준으로 정렬 가능하다.예를 들어 구조체를 키로 사용할 때 비교 기준을 직접 정의하면, 정렬된 유일 요소 집합을 구성할 수 있다.6. 성능 및 내부 구현 고려사항 삽입·삭제가 빈번하고 요소 수가 많으면 O(log n) 구조인 Set이 성능 병목이 될 수 있다. 이 경우 std::unordered_set (평균 O(1)) 고려 가능하다. 정렬된 상태가 필요 없다면 unordered_set 또는 vector + sort + unique 전략이 더 효율적이다. Sorted 상태 유지가 필요하고, 범위 탐색(range query), 순서 기반 작업이 많다면 Set이 유리하다. 예: 주파수 대역 세트, 활성 RF 채널 세트 등. 탐색 외에 인덱스 기반 접근이나 랜덤 접근이 필요하다면 std::vector + 이진 탐색이나 std::deque 등을 고려해야 한다.7. 주의사항 및 한계 인덱스 연산(s[0])이 없고, 순회는 iterator 기반으로만 가능하다. 저장된 요소의 값을 직접 변경할 수 없다. 값 변경이 필요하면 삭제 후 삽입해야 한다. 반복자(iterator) 유효성(invalidation)에 주의해야 한다. Set의 삽입/삭제는 기존 반복자를 무효화하지 않는 경우가 많지만, erase로 제거된 iterator는 무효하다. 대량 삽입/삭제가 반복되는 실시간 시스템에서는 GC‑like 비용이나 메모리 단편화(fragmentation)를 고려해야 한다.8. 요약 std::set은 유일한 요소 + 정렬된 상태를 유지하는 연관 컨테이너다. 설정값, ID 집합, 구성요소 목록 등 정렬과 고유성이 중요한 곳에 적합하다. 반면, 정렬이 필요 없거나 랜덤 접근이 많은 경우에는 다른 자료구조가 더 적합하다. 통신/RF SW 맥락에서는 주파수 대역, 활성 채널 리스트, 식별자 집합 등으로 많이 활용될 수 있으며, 삽입/삭제/탐색 요구사항에 맞춰 선택해야 한다." }, { "title": "STL_Pair", "url": "/posts/STL_Pair/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-10-18 00:00:00 +0900", "snippet": "Pair (STL) 개요개요pair 는 두 개의 값을 하나의 단위로 묶는 STL 컨테이너 어댑터(Container Adapter) 이다. 서로 다른 타입을 조합할 수 있고, 가벼운 레코드 레벨 구조로 쓰인다. 정렬, 우선순위 큐(priority_queue), map, unordered_map 에서 보조 키로 자주 쓰인다.헤더와 기본 선언#include &lt;iostream&gt;#include &lt;utility&gt; // pairusing namespace std;int main() { pair&lt;int, string&gt; p1; // 기본 생성. first=0, second=\"\" pair&lt;int, string&gt; p2(7, \"seven\"); // 생성자 pair&lt;int, string&gt; p3 = make_pair(3, \"three\"); // make_pair pair&lt;int, string&gt; p4{10, \"ten\"}; // 중괄호 초기화(C++11+) cout &lt;&lt; p2.first &lt;&lt; \" / \" &lt;&lt; p2.second &lt;&lt; \"\\n\"; // 7 / seven}포인트 make_pair 는 템플릿 인자 추론을 위해 유용하다. C++11 이후 중괄호 초기화가 가장 간단하다.값 접근과 수정#include &lt;iostream&gt;#include &lt;utility&gt;using namespace std;int main() { pair&lt;int, double&gt; p{1, 3.14}; p.first = 2; p.second = 6.28; cout &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; \"\\n\"; // 2, 6.28}구조적 바인딩(Structured Binding)과 tie#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;tuple&gt; // tieusing namespace std;pair&lt;int, string&gt; get_user() { return {42, \"alice\"}; }int main() { // 구조적 바인딩(C++17) auto [id, name] = get_user(); cout &lt;&lt; id &lt;&lt; \" \" &lt;&lt; name &lt;&lt; \"\\n\"; // tie (C++11) int i; string s; tie(i, s) = get_user(); cout &lt;&lt; i &lt;&lt; \" \" &lt;&lt; s &lt;&lt; \"\\n\";}구조적 바인딩은 가독성이 좋다. 구 표준 호환이 필요하면 tie 를 쓴다.비교 연산과 정렬 규칙pair 는 사전식 비교(lexicographical order)를 지원한다.규칙 먼저 first 를 비교한다. first 가 같으면 second 를 비교한다.#include &lt;bits/stdc++.h&gt;using namespace std;int main() { //vector&lt;pair&lt;int,int&gt;&gt; v = {{2,3}, {1,5}, {1,2}, {2,1}}; sort(v.begin(), v.end()); // 사전식 오름차순 // 결과: (1,2), (1,5), (2,1), (2,3) for (auto &amp;x : v) cout &lt;&lt; \"(\" &lt;&lt; x.first &lt;&lt; \",\" &lt;&lt; x.second &lt;&lt; \") \"; cout &lt;&lt; \"\\n\";} 내림차순은 비교자 사용#include &lt;bits/stdc++.h&gt;using namespace std;struct cmp_desc { bool operator()(const pair&lt;int,int&gt;&amp; a, const pair&lt;int,int&gt;&amp; b) const { if (a.first != b.first) return a.first &gt; b.first; return a.second &gt; b.second; }};int main() { vector&lt;pair&lt;int,int&gt;&gt; v = {{2,3}, {1,5}, {1,2}, {2,1}}; sort(v.begin(), v.end(), cmp_desc()); for (auto &amp;x : v) cout &lt;&lt; \"(\" &lt;&lt; x.first &lt;&lt; \",\" &lt;&lt; x.second &lt;&lt; \") \"; cout &lt;&lt; \"\\n\";}priority_queue 에서의 pair기본 priority_queue 는 최대 힙(max-heap) 이다. pair 는 first 기준으로, 같으면 second 기준으로 비교한다.최소 힙(min-heap) 으로 쓰려면 greater 사용#include &lt;bits/stdc++.h&gt;using namespace std;int main() { priority_queue&lt;pair&lt;int,int&gt;, vector&lt;pair&lt;int,int&gt;&gt;, greater&lt;pair&lt;int,int&gt;&gt;&gt; pq; // Min-Heap pq.push({5, 1}); pq.push({3, 9}); pq.push({3, 7}); while (!pq.empty()) { auto t = pq.top(); pq.pop(); cout &lt;&lt; t.first &lt;&lt; \",\" &lt;&lt; t.second &lt;&lt; \"\\n\"; } // 출력: 3,7 -&gt; 3,9 -&gt; 5,1}Dijkstra 에서 흔히 (거리, 정점) 형태로 사용한다.map 과 pairmap&lt;Key, T&gt; 에서 value_type 은 pair&lt;const Key, T&gt; 이다.#include &lt;bits/stdc++.h&gt;using namespace std;int main() { map&lt;string, int&gt; freq; freq[\"apple\"]++; freq[\"banana\"] += 2; for (const auto &amp;kv : freq) { // kv: pair&lt;const string, int&gt; cout &lt;&lt; kv.first &lt;&lt; \" -&gt; \" &lt;&lt; kv.second &lt;&lt; \"\\n\"; }}vector&lt;pair&lt;…» 로 데이터를 모은 뒤 map 으로 옮기는 패턴#include &lt;bits/stdc++.h&gt;using namespace std;using P = pair&lt;string,int&gt;;int main() { vector&lt;P&gt; v = {{\"a\",2}, {\"b\",5}, {\"a\",3}}; map&lt;string,int&gt; mp; for (auto &amp;e : v) mp[e.first] += e.second; for (auto &amp;kv : mp) cout &lt;&lt; kv.first &lt;&lt; \":\" &lt;&lt; kv.second &lt;&lt; \"\\n\";}unordered_map 에서 pair 를 키로 쓰기표준에는 pair 의 해시가 기본 제공되지 않는다. 사용자 정의 해시(Hash Function) 가 필요하다.#include &lt;bits/stdc++.h&gt;using namespace std;struct pair_hash { size_t operator()(const pair&lt;int,int&gt;&amp; p) const noexcept { // 간단한 조합 (Xor + shift). 충돌 분산을 위해 해시 합성 권장. return hash&lt;int&gt;()(p.first) ^ (hash&lt;int&gt;()(p.second) &lt;&lt; 1); }};int main() { unordered_map&lt;pair&lt;int,int&gt;, int, pair_hash&gt; um; um[{1,2}] = 10; um[{2,3}] = 20; cout &lt;&lt; um[{1,2}] &lt;&lt; \"\\n\"; // 10}주의 noexcept 로 표시하면 컨테이너 예외 보장을 돕는다. 더 견고한 해시를 원하면 boost::hash 또는 커스텀 해시 합성 함수를 사용한다.make_pair vs 중괄호 초기화auto p1 = make_pair(1, 2); // 타입 추론pair&lt;int,int&gt; p2{1, 2}; // 명시적 타입 + 중괄호C++14 이후에는 중괄호 초기화가 가독성이 좋아 선호된다. 템플릿 인자 추론이 필요한 컨텍스트에서는 make_pair 가 유용하다.move 와 piecewise_construct#include &lt;bits/stdc++.h&gt;using namespace std;int main() { string k = \"key\"; string v = \"value\"; pair&lt;string,string&gt; p1 = make_pair(move(k), move(v)); // 이동 시도 // map 에 복잡한 생성자 인자를 전달할 때 map&lt;int, pair&lt;string, string&gt;&gt; mp; mp.emplace(1, piecewise_construct, forward_as_tuple(), forward_as_tuple(\"A\", \"B\")); // value의 pair를 직접 생성}piecewise_construct 는 pair 내부 멤버를 각각의 생성자 인자 집합으로 직접 생성하게 하여 불필요한 복사를 줄인다.흔한 실수 pair 를 정렬할 때 사전식 비교 규칙을 잊는 실수 priority_queue 에서 Min-Heap 을 만들지 않고 기본 비교자를 써서 Max-Heap 으로 잘못 동작 unordered_map 키로 pair 를 쓰면서 해시를 정의하지 않음 pair&lt;int,int&gt; 와 같이 의미가 불명확할 경우 구조체 로 바꾸어 가독성을 높이는 게 낫다실전 스니펫 모음1. 좌표 정렬: x 오름차순, y 오름차순#include &lt;bits/stdc++.h&gt;using namespace std;using P = pair&lt;int,int&gt;;int main() { vector&lt;P&gt; pts = {{2,3},{1,5},{1,2},{2,1}}; sort(pts.begin(), pts.end()); // (x,y) 오름차순 for (auto &amp;p : pts) cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; \"\\n\";}2. 등장 횟수 상위 K개 (빈도, 값) 기준 Min-Heap#include &lt;bits/stdc++.h&gt;using namespace std;int main() { vector&lt;int&gt; a = {1,1,1,2,2,3}; unordered_map&lt;int,int&gt; cnt; for (int x : a) cnt[x]++; using P = pair&lt;int,int&gt;; // (빈도, 값) priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt;&gt; pq; // Min-Heap int K = 2; for (auto &amp;kv : cnt) { pq.push({kv.second, kv.first}); if ((int)pq.size() &gt; K) pq.pop(); } vector&lt;int&gt; ans; while (!pq.empty()) { ans.push_back(pq.top().second); pq.pop(); } reverse(ans.begin(), ans.end()); for (int x : ans) cout &lt;&lt; x &lt;&lt; \" \";}3. 그래프 간선 저장#include &lt;bits/stdc++.h&gt;using namespace std;using Edge = pair&lt;int,int&gt;; // (to, weight)int main() { int N = 5; vector&lt;vector&lt;Edge&gt;&gt; g(N); auto add = [&amp;](int u, int v, int w){ g[u].push_back({v, w}); g[v].push_back({u, w}); }; add(0,1,2); add(0,2,5); add(1,2,1);}마무리pair 는 두 값을 가볍게 묶어 전달, 정렬, 우선순위 큐, 연관 컨테이너의 값 표현 등 폭넓게 쓰인다. 의미가 불분명해질 때는 구조체 로 전환해 명시성을 확보한다. pair 의 비교 규칙, priority_queue 와의 조합, unordered_map 키 해시 정의 패턴을 익혀두면 실전 활용도가 높다." }, { "title": "STL_Deque", "url": "/posts/STL_Deque/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-10-18 00:00:00 +0900", "snippet": "Pair (STL) 개요개요deque(Double-ended queue) 는 양쪽 끝에서 삽입과 삭제가 모두 상수 시간 평균으로 가능한 시퀀스 컨테이너이다. 내부적으로는 세그먼트 블록 배열 + 인덱스 테이블 구조를 사용하여 앞과 뒤에서의 연산이 모두 빠르다. vector 와 달리 앞쪽 연산이 효율적이다.헤더와 기본 선언#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;int main() { deque&lt;int&gt; dq; // 기본 생성 deque&lt;int&gt; dq2(5, 7); // 길이 5, 값 7로 초기화 deque&lt;int&gt; dq3 = {1,2,3}; // 리스트 초기화}주요 특징 요약 앞뒤 양쪽 끝에서 push/pop 이 평균 O(1) 이다. 임의 접근(Random access) 지원. operator[], at 사용 가능. (O(1)) 중간 삽입/삭제는 요소 이동 비용으로 인해 O(n) 이다. 메모리 배치가 분절되어 있어 vector 보다 연속성이 떨어진다. iterator 무효화 규칙이 vector 와 다르다. 앞/뒤 삽입 시 더 자주 무효화될 수 있다.멤버 함수 총정리생성자와 대입 deque() deque(size_type n) deque(size_type n, const T&amp; value) deque(InputIt first, InputIt last) deque(const deque&amp; other), deque(deque&amp;&amp; other) operator=, assign(count, value), assign(first, last), assign(init_list)용량 size(), empty(), max_size() resize(n), resize(n, value) shrink_to_fit() 메모리 회수 요청 (강제 보장 아님)요소 접근 at(pos) 범위 검사 후 예외 던짐 front(), back()수정 push_back(value), emplace_back(args…) push_front(value), emplace_front(args…) pop_back(), pop_front() insert(pos, value), insert(pos, count, value), insert(pos, first, last), insert(pos, init_list) emplace(pos, args…) erase(pos), erase(first, last) clear(), swap(deque&amp; other)반복자 begin(), end(), cbegin(), cend() rbegin(), rend(), crbegin(), crend()사용 패턴과 예제1. 양쪽 큐 동작#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;int main() { deque&lt;int&gt; dq; dq.push_back(2); // [2] dq.push_front(1); // [1,2] dq.push_back(3); // [1,2,3] cout &lt;&lt; dq.front() &lt;&lt; \" \" &lt;&lt; dq.back() &lt;&lt; \"\\n\"; // 1 3 dq.pop_front(); // [2,3] dq.pop_back(); // [2] cout &lt;&lt; dq[0] &lt;&lt; \"\\n\"; // 2 (경계 체크 없음) return 0;}2. 슬라이딩 윈도우 최대값 O(n) (Monotonic deque)#include &lt;bits/stdc++.h&gt;using namespace std;// 윈도우 크기 k 에 대해 각 위치의 최대값을 계산한다.vector&lt;int&gt; sliding_max(const vector&lt;int&gt;&amp; a, int k) { deque&lt;int&gt; dq; // 인덱스를 저장, a[dq] 가 단조 감소 vector&lt;int&gt; ans; for (int i = 0; i &lt; (int)a.size(); ++i) { // 윈도우 범위 밖 인덱스 제거 if (!dq.empty() &amp;&amp; dq.front() &lt;= i - k) dq.pop_front(); // 새 원소보다 작은 값들은 뒤에서 제거(단조성 유지) while (!dq.empty() &amp;&amp; a[dq.back()] &lt;= a[i]) dq.pop_back(); dq.push_back(i); if (i &gt;= k - 1) ans.push_back(a[dq.front()]); } return ans;}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); vector&lt;int&gt; a = {1, 3, -1, -3, 5, 3, 6, 7}; auto res = sliding_max(a, 3); for (auto x : res) cout &lt;&lt; x &lt;&lt; \" \"; // 3 3 5 5 6 7 cout &lt;&lt; \"\\n\";}3. 0-1 BFS (가중치 0 또는 1인 최단거리)#include &lt;bits/stdc++.h&gt;using namespace std;const int INF = 1e9;int main() { int n, m; // 정점, 간선 cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; g(n); // (to, w) w in {0,1} for (int i = 0; i &lt; m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; // 0 또는 1 g[u].push_back({v, w}); g[v].push_back({u, w}); } deque&lt;int&gt; dq; vector&lt;int&gt; dist(n, INF); int s = 0; dist[s] = 0; dq.push_front(s); while (!dq.empty()) { int u = dq.front(); dq.pop_front(); for (auto [v, w] : g[u]) { if (dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if (w == 0) dq.push_front(v); else dq.push_back(v); } } } for (int i = 0; i &lt; n; ++i) cout &lt;&lt; dist[i] &lt;&lt; \" \"; cout &lt;&lt; \"\\n\"; return 0;}4. 회전(rotate) 시뮬레이션 예시#include &lt;bits/stdc++.h&gt;using namespace std;int main() { deque&lt;int&gt; dq = {1,2,3,4,5}; // 오른쪽으로 k 스텝 회전 int k = 2; while (k--) { dq.push_front(dq.back()); dq.pop_back(); } for (auto x : dq) cout &lt;&lt; x &lt;&lt; \" \"; // 4 5 1 2 3 cout &lt;&lt; \"\\n\"; // 왼쪽으로 1 스텝 회전 dq.push_back(dq.front()); dq.pop_front(); for (auto x : dq) cout &lt;&lt; x &lt;&lt; \" \"; // 5 1 2 3 4 cout &lt;&lt; \"\\n\";}vector 와의 비교 앞쪽 연산deque 의 push_front/pop_front 는 평균 O(1) 이다. vector 는 앞쪽 삽입이 O(n) 이다. 메모리 연속성vector 는 메모리가 연속이어서 캐시 지역성이 좋다. deque 는 블록 기반으로 연속성이 떨어진다. 중간 삽입/삭제둘 다 O(n) 이다. 빈번하면 list 또는 다른 자료구조 고려. iterator 무효화deque 는 양끝 삽입/삭제로도 반복자가 무효화될 수 있다. 반복자 안정성이 필요하면 주의한다.성능 및 주의사항 at 은 경계 검사를 수행하므로 안전하지만 약간 느리다. operator[] 는 빠르지만 범위 체크를 하지 않는다. 자주 참조하는 데이터는 vector 가 더 빠를 수 있다. deque 는 양쪽 끝 연산 위주의 시나리오에 적합하다. 반복자 무효화 규칙에 유의한다. 특히 루프에서 erase/pop 을 섞을 때는 주의한다. shrink_to_fit 는 강제 보장이 아니다. 메모리 회수는 구현 의존적이다.표준 시간복잡도 표 연산 복잡도 push_front / push_back 평균 O(1) pop_front / pop_back 평균 O(1) operator[] / at O(1) front / back O(1) insert / erase (중간) O(n) size / empty O(1) 마무리deque 는 앞과 뒤에서의 삽입·삭제 성능이 요구되는 상황에서 최적의 선택이다. 슬라이딩 윈도우, 0-1 BFS, 시뮬레이션(회전, 덱 게임) 등에서 자주 사용한다. vector 가 기본값이라면, 앞쪽 연산이 많은 경우 deque 로 바꿔서 성능을 확보한다." }, { "title": "C++_Iterator_Range_Base_For_Loop", "url": "/posts/C++_Iterator_Range_Base_For_Loop/", "categories": "CodingTest", "tags": "CodingTest, C++", "date": "2025-10-18 00:00:00 +0900", "snippet": "C++_Iterator_Range_Base_For_Loop++11에서 도입된 Range-based for loop 은 컨테이너(STL Container)나 배열(Array)의 모든 요소를 간결하게 순회할 수 있는 구문이다.이 문법은 반복자의 begin(), end() 함수를 내부적으로 호출하여, 기존 for문을 자동으로 단축한 형태로 동작한다.1. 사전개념 (C++ Iterator)C++의 Iterator(반복자) 는 컨테이너(Container) 내부의 원소를 순회(Traverse)하기 위한 객체이다.즉, 배열의 인덱스처럼 작동하지만, 모든 STL 컨테이너(vector, list, map 등)에서 통일된 방식으로 동작한다.Iterator는 컨테이너 내부 요소를 가리키는 포인터(Pointer)와 유사한 객체이다.하지만 컨테이너의 내부 구조를 몰라도 접근할 수 있도록 일종의 추상화 계층(Abstract Layer) 역할을 한다.즉, 배열의 인덱스 접근과 같은 기능을 일반화한 것 컨테이너마다 내부 구조(list, tree, hash)가 달라도 동일한 인터페이스로 접근 가능iterator는 컨테이너 내부를 직접 가리키는 포인터나 구조체 형태의 객체다.예: vector의 iterator 구조(개념적)┌──────────────┐│ vector&lt;int&gt; ││ [10][20][30] │└──────────────┘ ↑ └── iterator(it)기본 문법#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { vector&lt;int&gt; v = {10, 20, 30, 40, 50}; vector&lt;int&gt;::iterator it; for (it = v.begin(); it != v.end(); ++it) { cout &lt;&lt; *it &lt;&lt; \" \"; }}출력 결과10 20 30 40 50설명| 코드 | 의미 ||——|——|| v.begin() | 컨테이너의 첫 번째 원소를 가리키는 iterator 반환 || v.end() | 마지막 원소 다음 위치 를 가리키는 iterator 반환 || *it | iterator가 가리키는 원소의 실제 값 참조 || ++it | 다음 원소로 이동 (전위 증가 연산자) |Iterator의 장점 항목 설명 컨테이너 독립성 배열, vector, list, set 등 어떤 컨테이너든 동일한 접근 방식 포인터 유사성 *, ++, –, -&gt; 연산자 사용 가능 일관된 인터페이스 알고리즘(sort, find, copy 등)에서 범용적으로 사용 가능 추상화 유지 내부 자료구조(연결리스트, 트리 등)를 몰라도 접근 가능 Iterator의 주요 연산자 연산자 의미 예시 *it iterator가 가리키는 원소의 값 cout « *it; it-&gt; 구조체나 클래스의 멤버 접근 it-&gt;member ++it 다음 원소로 이동 (전위 증가) ++it –it 이전 원소로 이동 (양방향 컨테이너만) –it it1 == it2 동일 위치 비교 if (it == v.end()) it + n, it - n n만큼 이동 (Random Access 지원 컨테이너만) v.begin() + 3 2. 예시#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { vector&lt;int&gt; v = {1, 2, 3, 4, 5}; // (1) 값 복사 방식 for (auto x : v) { cout &lt;&lt; x &lt;&lt; \" \"; } cout &lt;&lt; endl; // (2) 참조 방식 for (auto &amp;x : v) { x *= 2; // 원본 데이터 수정 } // (3) const 참조 방식 for (const auto &amp;x : v) { cout &lt;&lt; x &lt;&lt; \" \"; }}출력 결과1 2 3 4 52 4 6 8 103. 참조 &amp; const의 차이 형태 의미 원본 수정 가능 여부 auto x 복사 불가능 auto &amp;x 참조 가능 const auto &amp;x 읽기 전용 참조 불가능 auto &amp; 또는 const auto &amp; 를 사용하면 불필요한 복사를 방지하고 성능을 향상시킬 수 있다.4. 최종 요약 항목 range-based for 일반 for 가독성 매우 높음 낮음 코드 길이 짧음 김 성능 (참조) 동일 동일 복사 비용 auto x 시 발생 없음 인덱스 접근 불가능 가능 iterator 제어 불가능 가능 STL 호환성 높음 높음 5. 권장 사용 패턴 목적 추천 구문 단순 출력 for (auto x : v) 원본 수정 for (auto &amp;x : v) 읽기 전용 for (const auto &amp;x : v) 인덱스 필요 일반 for문 사용 " }, { "title": "십자 모양의 지속적 폭발", "url": "/posts/%EC%8B%AD%EC%9E%90-%EB%AA%A8%EC%96%91%EC%9D%98-%EC%A7%80%EC%86%8D%EC%A0%81-%ED%8F%AD%EB%B0%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-11 00:00:00 +0900", "snippet": "십자 모양의 지속적 폭발https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-cross-shape-continuous-bomb/description풀이#include &lt;iostream&gt;using namespace std;#define ARR_MAX_LEN 210int N, M;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };void explode_marble(int col){ int start_row = 0; for(int i = 1; i &lt;= N; i++){ if(arrmap[i][col] != 0){ start_row = i; break; } } if (start_row == 0) return; int blow_coverage = arrmap[start_row][col]; for(int i = 0; i &lt; blow_coverage; i++){ for(int dir = 0; dir &lt; 4; dir++){ int ny = start_row + (i * dy[dir]); int nx = col + (i * dx[dir]); if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N) continue; arrmap[ny][nx] = 0; } }}void drop_marble(){ for(int c = 1; c &lt;= N; c++){ int end_idx = -1; for(int r = N; r &gt; 1; r--){ if(arrmap[r][c] == 0){ end_idx = r; break; } } if(end_idx == -1) continue; for(int r = end_idx; r &gt;= 1; r--){ if(arrmap[r][c] != 0){ arrmap[end_idx][c] = arrmap[r][c]; arrmap[r][c] = 0; end_idx--; } } }}void print_answer(){ for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ cout &lt;&lt; arrmap[i][j] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; }}void simulate(int col){ // 1. 현재 열의 가장 상단의 값을 기준으로 폭발이 발생 explode_marble(col); // 2. 폭발 이후 중력에 의한 Drop 시뮬레이션 수행 drop_marble();}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ cin &gt;&gt; arrmap[i][j]; } } for(int i = 0; i &lt; M; i++){ int sel_col; cin &gt;&gt; sel_col; simulate(sel_col); } print_answer(); return 0;}" }, { "title": "AI 로봇 청소기", "url": "/posts/AI-%EB%A1%9C%EB%B4%87-%EC%B2%AD%EC%86%8C%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-11 00:00:00 +0900", "snippet": "AI 로봇 청소기https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/ai-robot/solutions풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;#define ARR_MAX_LEN 55#define WALL (-1)typedef struct{ int y; int x;}loc_t;int N, K, L, answer = 0; // 격자 크기, 로봇 청소기 개수, 테스트 횟수int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// 0: 우, 1: 하, 2: 좌, 3: 상 (CodeTree 풀이와 동일 축 사용)int dy[4] = { 0, 1, 0, -1 };int dx[4] = { 1, 0, -1, 0 };vector&lt;loc_t&gt; cleaner_loc;bool check_pos[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; // 다른 청소기 위치 마스크inline int min20(int v){ return v &lt; 20 ? v : 20; }void input(){ cin &gt;&gt; N &gt;&gt; K &gt;&gt; L; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ cin &gt;&gt; arrmap[i][j]; // -1(벽/물건), 나머지=먼지 } } int r, c; for(int i = 0; i &lt; K; i++){ cin &gt;&gt; r &gt;&gt; c; cleaner_loc.push_back({ r, c }); }}// 가장 가까운 오염 칸 BFS (다른 청소기(check_pos) 금지, 같은 거리면 행→열 작은 순)loc_t bfs(int y, int x){ if(arrmap[y][x] &gt; 0) return { y, x }; queue&lt;loc_t&gt; q; bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; q.push({ y, x }); isvisited[y][x] = true; loc_t ret = { -1, -1 }; int found_dist = -1; int dist = 0; while(!q.empty()){ int qs = q.size(); // 같은 거리 레벨에서 행/열 오름차순 보장을 위해 수집 후 정렬 대신 // 4방향 탐색 순서를 우,하,좌,상으로 고정하고, // 후보가 여러 개면 레벨 내에서 최소 y,x를 수동 비교한다. loc_t best = { INT_MAX, INT_MAX }; bool found = false; while(qs--){ int cy = q.front().y; int cx = q.front().x; q.pop(); if(arrmap[cy][cx] &gt; 0 &amp;&amp; check_pos[cy][cx] == false){ // 같은 거리 내 tie-break if(cy &lt; best.y || (cy == best.y &amp;&amp; cx &lt; best.x)){ best = { cy, cx }; } found = true; } for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N) continue; if(arrmap[ny][nx] == WALL) // 물건/벽 continue; if(check_pos[ny][nx]) // 다른 청소기 위치 금지 continue; if(isvisited[ny][nx]) continue; isvisited[ny][nx] = true; q.push({ ny, nx }); } } if(found){ ret = best; found_dist = dist; break; } dist++; } if(found_dist == -1) return { y, x }; // 이동 불가 시 제자리 return ret;}// 이동 단계: check_pos 초기화→표시 후, 각 청소기 순서대로 이동void move_cleaner(){ // 0. 현재 청소기 좌표 체크 for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= N; j++) check_pos[i][j] = false; for(auto &amp;p : cleaner_loc) check_pos[p.y][p.x] = true; // 1. 이동 for(int i = 0; i &lt; (int)cleaner_loc.size(); i++){ loc_t cur = cleaner_loc[i]; loc_t dst = bfs(cur.y, cur.x); // 마스크 갱신 check_pos[cur.y][cur.x] = false; check_pos[dst.y][dst.x] = true; cleaner_loc[i] = dst; }}// 방향 선택: “현재칸 + 4방향(min(칸,20)) 합”에서 **역방향 제외**가 최대가 되는 방향int choose_dir_for_clean(int cy, int cx){ // 우(0), 하(1), 좌(2), 상(3) 기준, 역방향 매핑 int changeDir[4] = { 2, 3, 0, 1 }; // total = 현재칸 + 4방향(min(,20), 벽 제외) int total = (arrmap[cy][cx] &gt; 0 ? min20(arrmap[cy][cx]) : 0); for(int d = 0; d &lt; 4; d++){ int ny = cy + dy[d], nx = cx + dx[d]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N) continue; if(arrmap[ny][nx] == WALL) continue; if(arrmap[ny][nx] &gt; 0) total += min20(arrmap[ny][nx]); } int best_dir = 0, best_val = -1; for(int d = 0; d &lt; 4; d++){ int reverse = changeDir[d]; int val = total; int ry = cy + dy[reverse], rx = cx + dx[reverse]; if(ry &gt;= 1 &amp;&amp; ry &lt;= N &amp;&amp; rx &gt;= 1 &amp;&amp; rx &lt;= N &amp;&amp; arrmap[ry][rx] != WALL){ if(arrmap[ry][rx] &gt; 0) val -= min20(arrmap[ry][rx]); } if(val &gt; best_val){ best_val = val; best_dir = d; } } return best_dir;}// 청소: 선택된 방향의 **역방향만 제외**하고, 현재칸 포함 20씩 감산(하한 0)void run_clean_process(){ int changeDir[4] = { 2, 3, 0, 1 }; for(auto &amp;p : cleaner_loc){ int cy = p.y, cx = p.x; int dir = choose_dir_for_clean(cy, cx); int reverse = changeDir[dir]; // 4방향 중 역방향만 제외 for(int d = 0; d &lt; 4; d++){ if(d == reverse) continue; int ny = cy + dy[d], nx = cx + dx[d]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N) continue; if(arrmap[ny][nx] == WALL) continue; if(arrmap[ny][nx] &gt; 0){ arrmap[ny][nx] -= 20; if(arrmap[ny][nx] &lt; 0) arrmap[ny][nx] = 0; } } // 현재 위치 if(arrmap[cy][cx] &gt; 0){ arrmap[cy][cx] -= 20; if(arrmap[cy][cx] &lt; 0) arrmap[cy][cx] = 0; } }}void accum_dust(){ for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ if(arrmap[i][j] == WALL) continue; if(arrmap[i][j] &gt; 0) arrmap[i][j] += 5; } }}// 0인 칸만 확산: 이웃 4칸의 먼지 합을 10으로 나눈 값을 더함(동시 갱신, WALL 제외)void spread_dust(){ static int next_map[ARR_MAX_LEN][ARR_MAX_LEN]; for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= N; j++) next_map[i][j] = arrmap[i][j]; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= N; j++){ if(arrmap[i][j] != 0) continue; if(arrmap[i][j] == WALL) continue; int sum = 0; for(int d = 0; d &lt; 4; d++){ int ny = i + dy[d], nx = j + dx[d]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N) continue; if(arrmap[ny][nx] == WALL) continue; if(arrmap[ny][nx] &gt; 0) sum += arrmap[ny][nx]; } next_map[i][j] += (sum / 10); } } for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= N; j++) arrmap[i][j] = next_map[i][j];}int total_dust(){ int s = 0; for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= N; j++) if(arrmap[i][j] &gt; 0) s += arrmap[i][j]; return s;}void simulate_one_step_and_print(){ move_cleaner(); run_clean_process(); accum_dust(); spread_dust(); cout &lt;&lt; total_dust() &lt;&lt; \"\\n\"; // 매 턴 출력}int main(void){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for(int t = 0; t &lt; L; t++){ simulate_one_step_and_print(); } return 0;}" }, { "title": "합쳐지는 구슬들", "url": "/posts/%ED%95%A9%EC%B3%90%EC%A7%80%EB%8A%94-%EA%B5%AC%EC%8A%AC%EB%93%A4/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-10 00:00:00 +0900", "snippet": "합쳐지는 구슬들https://www.codetree.ai/ko/trails/complete/curated-cards/test-merge-marbles/description풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int n, m, t, max_weight = INT_MIN;int arrmap[51][51] = { 0 };// 좌상우하int dy[4] = { 0, -1, 0, 1 };int dx[4] = { -1, 0, 1, 0 };typedef struct{ int idx; int y; int x; int dir; int weight;}info_t;vector&lt;info_t&gt; marble_lst;void move_marble(){ for(int i = 0; i &lt; marble_lst.size(); i++){ int cy = marble_lst[i].y; int cx = marble_lst[i].x; int dir = marble_lst[i].dir; int ny = cy, nx = cx; int ty = cy + dy[dir]; int tx = cx + dx[dir]; if(ty &lt; 1 || ty &gt; n || tx &lt; 1 || tx &gt; n){ dir = (dir + 2) % 4; // 방향 바꾸는데 1초의 시간이 소모됨 } else{ ny += dy[dir]; nx += dx[dir]; } marble_lst[i].y = ny; marble_lst[i].x = nx; marble_lst[i].dir = dir; arrmap[ny][nx]++; arrmap[cy][cx]--; }}void merge_marble(int y, int x){ vector&lt;info_t&gt; temp_marble_lst; vector&lt;int&gt; merge_idx_lst; int merge_dir = 0, merge_weight = 0, merge_cnt = 0, max_num = 0; for(int i = 0; i &lt; marble_lst.size(); i++){ if(y == marble_lst[i].y &amp;&amp; x == marble_lst[i].x){ if(max_num &lt; marble_lst[i].idx){ max_num = marble_lst[i].idx; merge_dir = marble_lst[i].dir; } merge_cnt++; merge_weight += marble_lst[i].weight; merge_idx_lst.push_back(i); } } // 합쳐진 구슬들 삭제하고 다시 원 리스트에 복사 for(int i = 0; i &lt; marble_lst.size(); i++){ bool check_flag = true; for(int j = 0; j &lt; merge_idx_lst.size(); j++){ if(i == merge_idx_lst[j]) check_flag = false; } if(check_flag) temp_marble_lst.push_back(marble_lst[i]); } marble_lst.clear(); for(int i = 0; i &lt; temp_marble_lst.size(); i++){ marble_lst.push_back(temp_marble_lst[i]); } // 새롭게 합쳐진 구슬 정보 추가 marble_lst.push_back({max_num, y, x, merge_dir, merge_weight}); // 구슬 개수 업데이트 m -= (merge_cnt - 1); // 해당 칸에 구슬 개수 업데이트 arrmap[y][x] = 1;}void simulate(){ move_marble(); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(arrmap[i][j] &gt; 1){ merge_marble(i, j); } } }}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; for (int i = 0; i &lt; m; i++) { int r, c, w, dir; char d; cin &gt;&gt; r &gt;&gt; c &gt;&gt; d &gt;&gt; w; if(d == 'L') dir = 0; else if(d == 'U') dir = 1; else if(d == 'R') dir = 2; else dir = 3; marble_lst.push_back({(i + 1), r, c, dir, w}); arrmap[r][c]++; } for(int i = 0; i &lt; t; i++){ simulate(); } for(int i = 0; i &lt; marble_lst.size(); i++){ max_weight = max(max_weight, marble_lst[i].weight); } cout &lt;&lt; m &lt;&lt; \" \" &lt;&lt; max_weight &lt;&lt; \"\\n\"; return 0;}" }, { "title": "최적의 십자 모양 폭발", "url": "/posts/%EC%B5%9C%EC%A0%81%EC%9D%98-%EC%8B%AD%EC%9E%90-%EB%AA%A8%EC%96%91-%ED%8F%AD%EB%B0%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-10 00:00:00 +0900", "snippet": "최적의 십자 모양 폭발https://www.codetree.ai/ko/trails/complete/curated-cards/test-best-cross-shape-bomb/description풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;climits&gt;using namespace std;int n, answer = INT_MIN;int grid[50][50];int temp_grid[50][50];int dy[4] = {-1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };void find_block_pair(){ int temp_cnt = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if(temp_grid[i][j] != 0){ for(int dir = 0; dir &lt; 4; dir++){ int ny = i + dy[dir]; int nx = j + dx[dir]; if(ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= n) continue; if(temp_grid[i][j] == temp_grid[ny][nx]) temp_cnt++; } } } } answer = max(answer, temp_cnt / 2);}void drop_block(){ for(int c = 0; c &lt; n; c++){ int end_idx = -1; // 최상단 0번 인덱스 탐색은 의미가 없음 for(int r = n - 1; r &gt; 0; r--){ if(temp_grid[r][c] == 0){ end_idx = r; break; } } // 0을 채울 곳이 없을 때, 즉 Drop 되어 상태가 변경될 일이 없을 때 if(end_idx == -1) continue; // Drop 되어 0 자리에 들어갈 값 찾아서 값 입력 for(int r = end_idx - 1; r &gt;= 0; r--){ if(temp_grid[r][c] != 0){ temp_grid[end_idx][c] = temp_grid[r][c]; temp_grid[r][c] = 0; end_idx--; } } }}void explode_block(int y, int x){ int explos_coverage = temp_grid[y][x] - 1; temp_grid[y][x] = 0; for(int i = 0; i &lt; explos_coverage; i++){ for(int dir = 0; dir &lt; 4; dir++){ int ny = y + ((i + 1) * dy[dir]); int nx = x + ((i + 1) * dx[dir]); if(ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= n) continue; temp_grid[ny][nx] = 0; } }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; } } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { // 2D MAP 을 포인트마다 업데이트 하여 사용하기 위해 임시 배열에 복사 memcpy(temp_grid, grid, sizeof(grid)); // 1. 해당 포인트 블록 폭파 결과 업데이트 explode_block(i, j); // 2. 중력에 따라 Block Drop 되는 것 구현 drop_block(); // 3. Block Pair 탐색 find_block_pair(); } } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "구슬의 이동", "url": "/posts/%EA%B5%AC%EC%8A%AC%EC%9D%98-%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-09 00:00:00 +0900", "snippet": "구슬의 이동https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-marble-movement/description풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 51using namespace std;int n, m, t, k;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// 0, 1, 2, 3 상, 하, 좌, 우int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{ int idx; int y; int x; int dir; int vel;}info_t;vector&lt;info_t&gt; marble_lst;// 1. 구슬의 이동// 2. 같은 좌표에 구슬이 K 개 이하인지 확인하고, k개 초과이면 우선 순위에 따라 구슬을 삭제 // 3. bool compare(const info_t &amp; v1, const info_t &amp; v2){ if (v1.vel != v2.vel) return v1.vel &gt; v2.vel; return v1.idx &gt; v2.idx; // ← 큰 idx 우선}void move_marble(){ for(int i = 0; i &lt; marble_lst.size(); i++){ int cy = marble_lst[i].y; int cx = marble_lst[i].x; int cvel = marble_lst[i].vel; int dir = marble_lst[i].dir; int ny = cy, nx = cx; for(int j = 0; j &lt; cvel; j++){ int ty = ny + dy[dir]; int tx = nx + dx[dir]; if(ty &lt; 1 || ty &gt; n || tx &lt; 1 || tx &gt; n){ if(dir == 0) dir = 1; else if(dir == 1) dir = 0; else if(dir == 2) dir = 3; else dir = 2; ty = ny + dy[dir]; tx = nx + dx[dir]; } ny = ty; nx = tx; } // 구슬 위치 좌표 업데이트 marble_lst[i].y = ny; marble_lst[i].x = nx; marble_lst[i].dir = dir; arrmap[cy][cx]--; arrmap[ny][nx]++; }}void simulate(){ vector&lt;info_t&gt; temp_marble_lst; vector&lt;int&gt; erase_lst; move_marble(); sort(marble_lst.begin(), marble_lst.end(), compare); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ int remove_cnt = 0; if(arrmap[i][j] &gt; k){ int temp_cnt = 0; for(int idx = 0; idx &lt; marble_lst.size(); idx++){ if(i == marble_lst[idx].y &amp;&amp; j == marble_lst[idx].x){ temp_cnt++; if(temp_cnt &gt; k){ erase_lst.push_back(idx); remove_cnt++; m--; } } } } // 좌표에 구슬 개수 업데이트 arrmap[i][j] -= remove_cnt; } } // 지워야 하는 구슬 빼고 모두 업데이트 for(int i = 0; i &lt; marble_lst.size(); i++){ bool temp_flag = false; for(int j = 0; j &lt; erase_lst.size(); j++){ if(i == erase_lst[j]){ temp_flag = true; } } if(!temp_flag){ temp_marble_lst.push_back(marble_lst[i]); } } marble_lst.clear(); for(int i = 0; i &lt; temp_marble_lst.size(); i++){ marble_lst.push_back(temp_marble_lst[i]); }}int main() { // n 격자 크기, m 구슬 개수, t 시간, k 각 칸에 살아남을 수 있는 최대 구슬 수 cin &gt;&gt; n &gt;&gt; m &gt;&gt; t &gt;&gt; k; for (int i = 0; i &lt; m; i++) { int r, c, v; char d; int dir = 0; cin &gt;&gt; r &gt;&gt; c &gt;&gt; d &gt;&gt; v; // 0, 1, 2, 3 상, 하, 좌, 우 if(d == 'U'){ dir = 0; } else if(d == 'D'){ dir = 1; } else if(d == 'L'){ dir = 2; } else{ dir = 3; } marble_lst.push_back({i + 1, r, c, dir, v}); arrmap[r][c]++; } for(int i = 0; i &lt; t; i++){ simulate(); } cout &lt;&lt; m &lt;&lt; \"\\n\"; return 0;}" }, { "title": "빙하", "url": "/posts/%EB%B9%99%ED%95%98/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-10-08 00:00:00 +0900", "snippet": "빙하https://www.codetree.ai/ko/trails/complete/chttps://www.codetree.ai/ko/trails/complete/curated-cards/challenge-glacier/description풀이#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;#define MAX_N 200#define MAX_M 200#define DIR_NUM 4enum ELEMENT { WATER = 0, GLACIER = 1};typedef struct{ int y; int x;} loc_t;int N, M;int arrmap[MAX_N][MAX_M] = {0};bool isvisited[MAX_N][MAX_M] = {false}; // 외곽 물 표시용int dy[DIR_NUM] = { -1, 1, 0, 0 };int dx[DIR_NUM] = { 0, 0, -1, 1 };queue&lt;loc_t&gt; q; // 외곽 물 BFS 큐int elapsed_time = 0; // 총 소요 시간int last_melt_cnt = 0; // 마지막에 녹은 빙하 개수inline bool in_range(int y, int x){ return (0 &lt;= y &amp;&amp; y &lt; N &amp;&amp; 0 &lt;= x &amp;&amp; x &lt; M);}inline bool can_go_water(int y, int x){ return in_range(y, x) &amp;&amp; (arrmap[y][x] == WATER) &amp;&amp; (!isvisited[y][x]);}// 외곽 물(경계와 연결된 물)들을 모두 isvisited=true 로 표시한다.void bfs_outside_water(){ // 방문 배열 초기화 for(int i = 0; i &lt; N; i++) for(int j = 0; j &lt; M; j++) isvisited[i][j] = false; // 큐 비우기 while(!q.empty()) q.pop(); // 경계의 물(0)들을 전부 시작점으로 넣는다. for(int i = 0; i &lt; N; i++){ if(arrmap[i][0] == WATER &amp;&amp; !isvisited[i][0]){ isvisited[i][0] = true; loc_t t; t.y = i; t.x = 0; q.push(t); } if(arrmap[i][M - 1] == WATER &amp;&amp; !isvisited[i][M - 1]){ isvisited[i][M - 1] = true; loc_t t; t.y = i; t.x = M - 1; q.push(t); } } for(int j = 0; j &lt; M; j++){ if(arrmap[0][j] == WATER &amp;&amp; !isvisited[0][j]){ isvisited[0][j] = true; loc_t t; t.y = 0; t.x = j; q.push(t); } if(arrmap[N - 1][j] == WATER &amp;&amp; !isvisited[N - 1][j]){ isvisited[N - 1][j] = true; loc_t t; t.y = N - 1; t.x = j; q.push(t); } } // 물(0)만 따라가며 외곽 물 전부 방문 표시 while(!q.empty()){ loc_t cur = q.front(); q.pop(); int cy = cur.y, cx = cur.x; for(int d = 0; d &lt; DIR_NUM; d++){ int ny = cy + dy[d]; int nx = cx + dx[d]; if(can_go_water(ny, nx)){ isvisited[ny][nx] = true; loc_t nxt; nxt.y = ny; nxt.x = nx; q.push(nxt); } } }}// 외곽 물과 인접한 빙하를 찾아 한 번에 녹인다. 녹인 개수를 리턴한다.int melt_once(){ // 좌표를 먼저 모아두고, 한 번에 갱신한다. static loc_t to_melt[MAX_N * MAX_M]; int tm_sz = 0; for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ if(arrmap[i][j] != GLACIER) continue; bool touch_outside = false; for(int d = 0; d &lt; DIR_NUM; d++){ int ny = i + dy[d]; int nx = j + dx[d]; if(in_range(ny, nx) &amp;&amp; isvisited[ny][nx]){ // 외곽 물과 인접 touch_outside = true; break; } } if(touch_outside){ loc_t t; t.y = i; t.x = j; to_melt[tm_sz++] = t; } } } for(int k = 0; k &lt; tm_sz; k++){ int y = to_melt[k].y; int x = to_melt[k].x; arrmap[y][x] = WATER; } return tm_sz;}// 빙하 존재 여부 확인bool glacier_exist(){ for(int i = 0; i &lt; N; i++) for(int j = 0; j &lt; M; j++) if(arrmap[i][j] == GLACIER) return true; return false;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; for(int i = 0; i &lt; N; i++) for(int j = 0; j &lt; M; j++) cin &gt;&gt; arrmap[i][j]; do{ bfs_outside_water(); // 이번 단계 외곽 물 표시 last_melt_cnt = melt_once(); // 외곽 물과 접한 빙하 녹임 elapsed_time++; // 시간 +1 }while(glacier_exist()); // 빙하가 남아 있으면 반복 cout &lt;&lt; elapsed_time &lt;&lt; \" \" &lt;&lt; last_melt_cnt &lt;&lt; \"\\n\"; return 0;} 0-1 BFS 로 문제 해결```cpp#include #include #include #include using namespace std;int N, M;int arrmap[200][200];int distv[200][200]; // 바깥 공기까지 도달하기 위해 지나야 하는 1(cheese) 최소 개수int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct { int y; int x;} loc_t;int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);cin &gt;&gt; N &gt;&gt; M;for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cin &gt;&gt; arrmap[i][j]; }}// dist 초기화for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { distv[i][j] = INT_MAX / 4; }}deque&lt;loc_t&gt; dq;// 경계 0을 모두 시작점으로 pushfor (int i = 0; i &lt; N; i++) { if (arrmap[i][0] == 0 &amp;&amp; distv[i][0] &gt; 0) { distv[i][0] = 0; loc_t t = {i, 0}; dq.push_front(t); } if (arrmap[i][M - 1] == 0 &amp;&amp; distv[i][M - 1] &gt; 0) { distv[i][M - 1] = 0; loc_t t = {i, M - 1}; dq.push_front(t); }}for (int j = 0; j &lt; M; j++) { if (arrmap[0][j] == 0 &amp;&amp; distv[0][j] &gt; 0) { distv[0][j] = 0; loc_t t = {0, j}; dq.push_front(t); } if (arrmap[N - 1][j] == 0 &amp;&amp; distv[N - 1][j] &gt; 0) { distv[N - 1][j] = 0; loc_t t = {N - 1, j}; dq.push_front(t); }}// 0-1 BFSwhile (!dq.empty()) { loc_t cur = dq.front(); dq.pop_front(); int cy = cur.y; int cx = cur.x; for (int d = 0; d &lt; 4; d++) { int ny = cy + dy[d]; int nx = cx + dx[d]; if (ny &lt; 0 || ny &gt;= N || nx &lt; 0 || nx &gt;= M) continue; int w = (arrmap[ny][nx] == 1) ? 1 : 0; if (distv[ny][nx] &gt; distv[cy][cx] + w) { distv[ny][nx] = distv[cy][cx] + w; loc_t next = {ny, nx}; if (w == 0) dq.push_front(next); else dq.push_back(next); } }}// 정답 계산int ans_time = 0;int ans_size = 0;for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { if (arrmap[i][j] != 1) continue; if (distv[i][j] == INT_MAX / 4) continue; if (distv[i][j] &gt; ans_time) { ans_time = distv[i][j]; ans_size = 1; } else if (distv[i][j] == ans_time) { ans_size++; } }}cout &lt;&lt; ans_time &lt;&lt; \" \" &lt;&lt; ans_size &lt;&lt; \"\\n\";return 0; }```" }, { "title": "2차원 바람", "url": "/posts/2%EC%B0%A8%EC%9B%90-%EB%B0%94%EB%9E%8C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-08 00:00:00 +0900", "snippet": "2차원 바람https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-2D-wind-blows/description풀이#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int r1, c1, r2, c2;int n, m, q;int arrmap[100][100];int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };void rotate_func(){ int temp_arrmap[100][100] = { 0 }; memcpy(temp_arrmap, arrmap, sizeof(arrmap)); for(int i = c2; i &gt; c1; i--){ arrmap[r1][i] = temp_arrmap[r1][i - 1]; } for(int i = r2; i &gt; r1; i--){ arrmap[i][c2] = temp_arrmap[i - 1][c2]; } for(int i = c1; i &lt; c2; i++){ arrmap[r2][i] = temp_arrmap[r2][i + 1]; } for(int i = r1; i &lt; r2; i++){ arrmap[i][c1] = temp_arrmap[i + 1][c1]; }}void flatten_avg(){ int temp_arrmap[100][100] = { 0 }; memcpy(temp_arrmap, arrmap, sizeof(arrmap)); for (int i = r1; i &lt;= r2; i++){ for (int j = c1; j &lt;= c2; j++){ int avg_cnt = 1, avg_val = temp_arrmap[i][j]; for(int dir = 0; dir &lt; 4; dir++){ int ny = i + dy[dir]; int nx = j + dx[dir]; if(ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= m) continue; avg_cnt++; avg_val += temp_arrmap[ny][nx]; } avg_val = avg_val / avg_cnt; arrmap[i][j] = avg_val; } }}void print_answer(){ for (int i = 0; i &lt; n; i++){ for (int j = 0; j &lt; m; j++){ cout &lt;&lt; arrmap[i][j] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; } }int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) cin &gt;&gt; arrmap[i][j]; for (int i = 0; i &lt; q; i++) { cin &gt;&gt; r1 &gt;&gt; c1 &gt;&gt; r2 &gt;&gt; c2; r1--; c1--; r2--; c2--; rotate_func(); flatten_avg(); } print_answer(); // Please write your code here. return 0;}" }, { "title": "수들 중 최솟값 최대화하기", "url": "/posts/%EC%88%98%EB%93%A4-%EC%A4%91-%EC%B5%9C%EC%86%9F%EA%B0%92-%EC%B5%9C%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-10-07 00:00:00 +0900", "snippet": "수들 중 최솟값 최대화하기https://www.codetree.ai/ko/trails/complete/curated-cards/test-maximin-of-numbers/description풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int n, answer = INT_MIN;int grid[10][10] = { 0 };bool row_isvisited[10] = { false };bool col_isvisited[10] = { false };bool isvisited[10][10] = { false };vector&lt;int&gt; cand_lst;void dfs(int idx, int cnt){ if(cnt == n){ int temp_answer = INT_MAX; for(int i = 0; i &lt; cand_lst.size(); i++){ temp_answer = min(temp_answer, cand_lst[i]); //cout &lt;&lt; cand_lst[i] &lt;&lt; \" \"; } //cout &lt;&lt; \"\\n\"; answer = max(answer, temp_answer); return ; } for(int i = idx; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ if(col_isvisited[j]) continue; col_isvisited[j] = true; cand_lst.push_back(grid[i][j]); dfs(i + 1, cnt + 1); cand_lst.pop_back(); col_isvisited[j] = false; } }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; } } dfs(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "1차원 폭발 게임", "url": "/posts/1%EC%B0%A8%EC%9B%90-%ED%8F%AD%EB%B0%9C-%EA%B2%8C%EC%9E%84/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-07 00:00:00 +0900", "snippet": "1차원 폭발 게임https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-1D-bomb-game/descriptionn풀이" }, { "title": "우리는 하나", "url": "/posts/%EC%9A%B0%EB%A6%AC%EB%8A%94-%ED%95%98%EB%82%98/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-10-06 00:00:00 +0900", "snippet": "우리는 하나https://www.codetree.ai/ko/trails/complete/curated-cards/test-we-are-the-one/description풀이#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int n, k, u, d, answer = 0;int grid[8][8] = { 0 };bool isvisited[8][8] = { false };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{ int y; int x;}loc_t;vector&lt;loc_t&gt; cand_city;int bfs(int y, int x){ if(isvisited[y][x]) return 0; int visit_cnt = 0; queue&lt;loc_t&gt; q; q.push({y, x}); isvisited[y][x] = true; while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; q.pop(); visit_cnt++; for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= n) continue; int diff = abs(grid[ny][nx] - grid[cy][cx]); if(diff &gt;= u &amp;&amp; diff &lt;= d &amp;&amp; !isvisited[ny][nx]){ q.push({ny, nx}); isvisited[ny][nx] = true; } } } return visit_cnt;}void comb(int idx, int cnt){ if(cnt == k){ int temp_answer = 0; memset(isvisited, 0, sizeof(isvisited)); for(int i = 0; i &lt; cand_city.size(); i++){ temp_answer += bfs(cand_city[i].y, cand_city[i].x); } answer = max(answer, temp_answer); return ; } // 2차원 배열에 대한 조합 for(int i = idx; i &lt; n * n; i++){ int cy = i / n; int cx = i % n; cand_city.push_back({cy, cx}); comb(i + 1, cnt + 1); cand_city.pop_back(); }}int main() { cin &gt;&gt; n &gt;&gt; k &gt;&gt; u &gt;&gt; d; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; } } comb(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "돌 잘 치우기", "url": "/posts/%EB%8F%8C-%EC%9E%98-%EC%B9%98%EC%9A%B0%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-10-06 00:00:00 +0900", "snippet": "돌 잘 치우기https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-clear-stones-well/description풀이조합 + BFS 로 문제 해결#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;climits&gt;using namespace std;int n, k, m, answer = INT_MIN;int grid[100][100] = { 0 };int temp_grid[100][100] = { 0 };int r[10000], c[10000];int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };bool isvisited[100][100] = { false };typedef struct{ int y; int x;}loc_t;vector&lt;loc_t&gt; stone_pos;vector&lt;loc_t&gt; cand_stone_pos;vector&lt;vector&lt;loc_t&gt; &gt; comb_lst;void bfs(int y, int x){ queue&lt;loc_t&gt; q; q.push({y, x}); isvisited[y][x] = true; while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; q.pop(); for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= n) continue; if(temp_grid[ny][nx] == 0 &amp;&amp; !isvisited[ny][nx]){ q.push({ny, nx}); isvisited[ny][nx] = true; } } }}void comb(int idx, int cnt){ if(cnt == m){ comb_lst.push_back(cand_stone_pos); return; } for(int i = idx; i &lt; stone_pos.size(); i++){ cand_stone_pos.push_back(stone_pos[i]); comb(i + 1, cnt + 1); cand_stone_pos.pop_back(); }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; k &gt;&gt; m; for (int i = 0; i &lt; n; i++){ for (int j = 0; j &lt; n; j++){ cin &gt;&gt; grid[i][j]; if(grid[i][j] == 1) stone_pos.push_back({i, j}); } } for (int i = 0; i &lt; k; i++) { cin &gt;&gt; r[i] &gt;&gt; c[i]; r[i]--; c[i]--; } comb(0, 0); for(int i = 0; i &lt; comb_lst.size(); i++){ memset(isvisited, false, sizeof(isvisited)); memcpy(temp_grid, grid, sizeof(grid)); for(int idx = 0; idx &lt; comb_lst[i].size(); idx++){ temp_grid[comb_lst[i][idx].y][comb_lst[i][idx].x] = 0; } int ret = 0; for (int j = 0; j &lt; k; j++) { bfs(r[j], c[j]); } for (int r = 0; r &lt; n; r++){ for (int c = 0; c &lt; n; c++){ if(isvisited[r][c]) ret++; } } answer = max(answer, ret); } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "정수 사각형 최장 증가 수열", "url": "/posts/%EC%A0%95%EC%88%98-%EC%82%AC%EA%B0%81%ED%98%95-%EC%B5%9C%EC%9E%A5-%EC%A6%9D%EA%B0%80-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2025-10-05 00:00:00 +0900", "snippet": "정수 사각형 최장 증가 수열https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-lis-on-the-integer-grid/description풀이backtracking 으로 문제 해결#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int grid[500][500];int dp[500][500];int answer = 0;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };int dfs(int y, int x){ int max_cnt = 1; if(dp[y][x] != -1) return dp[y][x]; for(int dir = 0; dir &lt; 4; dir++){ int ny = y + dy[dir]; int nx = x + dx[dir]; if(ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= n) continue; if(grid[ny][nx] &gt; grid[y][x]) max_cnt = max(max_cnt, dfs(ny, nx) + 1); } dp[y][x] = max_cnt; return dp[y][x];}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; dp[i][j] = -1; } } for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { answer = max(answer, dfs(i, j)); } } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "2차원 최대 증가 수열", "url": "/posts/2%EC%B0%A8%EC%9B%90-%EC%B5%9C%EB%8C%80-%EC%A6%9D%EA%B0%80-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2025-10-05 00:00:00 +0900", "snippet": "2차원 최대 증가 수열https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-longest-increasing-sequence-2d/description풀이#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int n, m, answer = INT_MIN;int grid[50][50];int dp[50][50];void dp_search(int y, int x){ for(int i = 0; i &lt; y; i++){ for(int j = 0; j &lt; x; j++){ if(grid[y][x] &gt; grid[i][j]) dp[y][x] = max(dp[y][x], dp[i][j] + 1); } }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; grid[i][j]; } } dp[0][0] = 1; // 오른쪽으로 한 칸, 아래로 한 칸 이동한 지점 부터 탐색 시작 for(int i = 1; i &lt; n; i++){ for(int j = 1; j &lt; m; j++){ // 현재탐색 좌표에서 grid[0][0] 이 더 클경우 dp search 할 필요 없음 if(grid[i][j] &gt; grid[0][0]) dp_search(i, j); } } for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ answer = max(answer, dp[i][j]); } } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "최대 점프 횟수", "url": "/posts/%EC%B5%9C%EB%8C%80-%EC%A0%90%ED%94%84-%ED%9A%9F%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2025-10-04 00:00:00 +0900", "snippet": "최대 점프 횟수https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-maximum-number-of-jumps/description풀이각 arr 값들은 그 위치에서 최대 점프 가능거리로 그 값보다 더 적게 뛰어도 된다.#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;using namespace std;int n, answer = 0;;int arr[1000];// 점프하여 도착한 마지막 위치가 dp[i] 의 i라면, 가능한 최대 점프 횟수가 값으로 들어감int dp[1000];void init(){ dp[0] = 0; for(int i = 1; i &lt; n; i++){ dp[i] = INT_MIN; }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; arr[i]; } init(); for(int i = 1; i &lt; n; i++){ for(int j = 0; j &lt; i; j++){ if(dp[j] == INT_MIN) continue; if(j + arr[j] &gt;= i){ dp[i] = max(dp[i], dp[j] + 1); } } } for(int i = 0; i &lt; n; i++){ answer = max(answer, dp[i]); } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "K개의 벽 없애기", "url": "/posts/K%EA%B0%9C%EC%9D%98-%EB%B2%BD-%EC%97%86%EC%95%A0%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-04 00:00:00 +0900", "snippet": "K개의 벽 없애기https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-remove-k-walls/description풀이#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int n, k, answer = INT_MAX;int arrmap[101][101];int timemap[101][101][10];bool isvisited[101][101][10];int start_y, start_x, end_y, end_x;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{ int y; int x; int state;}loc_t;void bfs(int y, int x){ queue&lt;loc_t&gt; q; q.push({y, x, 0}); while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; int cstate = q.front().state; q.pop(); if (cy == end_y &amp;&amp; cx == end_x &amp;&amp; cstate == k) return ; for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 1 || ny &gt; n || nx &lt; 1 || nx &gt; n || cstate &gt; k) continue; // 그냥 진행이 가능한 경우 if(arrmap[ny][nx] == 0){ if(timemap[ny][nx][cstate] == 0){ q.push({ny, nx, cstate}); timemap[ny][nx][cstate] = timemap[cy][cx][cstate] + 1; } } // 벽을 부수고 진행해야하는 경우 else{ if(timemap[ny][nx][cstate] == 0){ int nstate = cstate + 1; q.push({ny, nx, nstate}); timemap[ny][nx][nstate] = timemap[cy][cx][cstate] + 1; } } } }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; arrmap[i][j]; } } cin &gt;&gt; start_y &gt;&gt; start_x; cin &gt;&gt; end_y &gt;&gt; end_x; bfs(start_y, start_x); bool check_flag = false; for(int i = 0; i &lt;= k; i++){ if(timemap[end_y][end_x][i] != 0){ answer = min(answer, timemap[end_y][end_x][i]); check_flag = true; } } if (check_flag){ cout &lt;&lt; answer &lt;&lt; \"\\n\"; } else cout &lt;&lt; \"-1\\n\"; return 0;}" }, { "title": "1차원 바람", "url": "/posts/1%EC%B0%A8%EC%9B%90-%EB%B0%94%EB%9E%8C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-04 00:00:00 +0900", "snippet": "1차원 바람https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-The-1D-wind-blows/description풀이#include &lt;iostream&gt;using namespace std;int n, m, q;int arrmap[101][101];void input(){ cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cin &gt;&gt; arrmap[i][j]; } }}void shift_right(int row){ int temp_val = arrmap[row][m]; for(int i = m; i &gt; 1; i--){ arrmap[row][i] = arrmap[row][i - 1]; } arrmap[row][1] = temp_val;}void shift_left(int row){ int temp_val = arrmap[row][1]; for(int i = 1; i &lt; m; i++){ arrmap[row][i] = arrmap[row][i + 1]; } arrmap[row][m] = temp_val;}void print_answer(){ for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= m; j++) { cout &lt;&lt; arrmap[i][j] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; }}void simulate(int r, int d){ int cur_pos = r, uppos = r - 1, downpos = r + 1, updir = d, downdir = d; bool up_flag = true, down_flag = true; if(d == 0){ shift_right(r); updir = 1; downdir = 1; } else{ shift_left(r); updir = 0; downdir = 0; } while(uppos &gt;= 1){ bool temp_flag = false; for(int i = 1; i &lt;= m; i++){ if(arrmap[cur_pos][i] == arrmap[uppos][i]) temp_flag = true; } if(!temp_flag) break; cur_pos--; uppos--; if(updir == 0){ shift_right(cur_pos); updir = 1; } else{ shift_left(cur_pos); updir = 0; } } // current pos 초기화 cur_pos = r; while(downpos &lt;= n){ bool temp_flag = false; for(int i = 1; i &lt;= m; i++){ if(arrmap[cur_pos][i] == arrmap[downpos][i]) temp_flag = true; } if(!temp_flag) break; cur_pos++; downpos++; if(downdir == 0){ shift_right(cur_pos); downdir = 1; } else{ shift_left(cur_pos); downdir = 0; } }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for (int i = 0; i &lt; q; i++) { int r, dir; char d; cin &gt;&gt; r &gt;&gt; d; // d == L, 왼쪽에서 민다는 의미로 실제 이동은 오른쪽 쉬프트 if (d == 'L'){ dir = 0; } // d == R, 오른쪽에서 민다는 의미로 실제 이동은 왼쪽 쉬프트 else{ dir = 1; } simulate(r, dir); } print_answer(); return 0;}" }, { "title": "쌓인 숫자의 순차적 이동", "url": "/posts/%EC%8C%93%EC%9D%B8-%EC%88%AB%EC%9E%90%EC%9D%98-%EC%88%9C%EC%B0%A8%EC%A0%81-%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-03 00:00:00 +0900", "snippet": "쌓인 숫자의 순차적 이동https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-sequential-movement-of-stacked-numbers/description풀이#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;int n, m;deque&lt;int&gt; grid[20][20];int move_nums[100];int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };void input() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { int num; cin &gt;&gt; num; grid[i][j].push_back(num); } } for (int i = 0; i &lt; m; i++) { cin &gt;&gt; move_nums[i]; }}void simulate() { for (int i = 0; i &lt; m; i++) { int search_num = move_nums[i]; int cy = 0, cx = 0, cidx = 0; bool find_flag = false; // 현재 업데이트할 숫자 좌표 탐색 for (int r = 0; (r &lt; n &amp;&amp; !find_flag); r++) { for (int c = 0; (c &lt; n &amp;&amp; !find_flag); c++) { for (int j = 0; j &lt; grid[r][c].size(); j++) { if (grid[r][c][j] == search_num) { find_flag = true; cy = r; cx = c; cidx = j; break; } } if (find_flag) break; } if (find_flag) break; } // 매칭되는 숫자가있는 좌표를 찾을 경우 8방향 최대값 탐색 int max_num = 0, mov_y = cy, mov_x = cx; if (find_flag) { for (int dir = 0; dir &lt; 8; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= n) { continue; } for (int j = 0; j &lt; grid[ny][nx].size(); j++) { if (max_num &lt; grid[ny][nx][j]) { max_num = grid[ny][nx][j]; mov_y = ny; mov_x = nx; } } } // 최종 탐색한 위치로 값 이동 for (int j = cidx; j &gt;= 0; j--) { grid[mov_y][mov_x].push_front(grid[cy][cx][j]); } // 이동한 값은 원래 좌표에서 삭제 cidx += 1; grid[cy][cx].erase(grid[cy][cx].begin(), grid[cy][cx].begin() + cidx); } }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); simulate(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (!grid[i][j].empty()) { for (int k = 0; k &lt; grid[i][j].size(); k++) { cout &lt;&lt; grid[i][j][k] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; } else { cout &lt;&lt; \"None\\n\"; } } } return 0;}" }, { "title": "2N개 중에 N개의 숫자를 적절하게 고르기", "url": "/posts/2N%EA%B0%9C-%EC%A4%91%EC%97%90-N%EA%B0%9C%EC%9D%98-%EC%88%AB%EC%9E%90%EB%A5%BC-%EC%A0%81%EC%A0%88%ED%95%98%EA%B2%8C-%EA%B3%A0%EB%A5%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-10-03 00:00:00 +0900", "snippet": "2N개 중에 N개의 숫자를 적절하게 고르기https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-choose-n-out-of-2n-properly/description풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;int n, answer = INT_MAX;int num[20], isvisited[20];vector&lt;int&gt; group_a;vector&lt;int&gt; group_b;void dfs(int idx, int cnt){ if(cnt == n){ // vector 초기화 필요 group_b.clear(); int sum_a = 0, sum_b = 0; // group_b 에 선택되지 않은 값들 할당 for(int i = 0; i &lt; 2 * n; i++){ if(isvisited[i] == 0){ group_b.push_back(num[i]); } } // 각각 그룹 원소합 계산하고 두 그룹 원소합 차 계산하여 최소값 업데이트 for(int i = 0; i &lt; group_a.size(); i++){ sum_a += group_a[i]; } for(int i = 0; i &lt; group_b.size(); i++){ sum_b += group_b[i]; } answer = min(answer, abs(sum_a - sum_b)); return ; } for(int i = idx; i &lt; 2 * n; i++){ isvisited[i] = 1; group_a.push_back(num[i]); dfs(i + 1, cnt + 1); group_a.pop_back(); isvisited[i] = 0; }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; 2 * n; i++) { cin &gt;&gt; num[i]; } dfs(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "수들의 합 최대화하기", "url": "/posts/%EC%88%98%EB%93%A4%EC%9D%98-%ED%95%A9-%EC%B5%9C%EB%8C%80%ED%99%94%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-10-01 00:00:00 +0900", "snippet": "수들의 합 최대화하기https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-max-sum-of-numbers/description최대값 최소값 defualt 설정할 때 climits 헤더 사용하기 INT_MIN INT_MAX풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int n, answer = INT_MIN;int grid[10][10];bool isvisited[10];vector&lt;int&gt; num_lst;void dfs(int idx, int cnt){ if(cnt == n){ int temp_answer = 0; for(int i = 0; i &lt; n; i++){ temp_answer += num_lst[i]; //cout &lt;&lt; num_lst[i] &lt;&lt; \" \"; } //cout &lt;&lt; \"\\n\"; answer = max(answer, temp_answer); return ; } for(int i = idx; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ if(isvisited[j]) continue; isvisited[j] = true; num_lst.push_back(grid[i][j]); dfs(i + 1, cnt + 1); num_lst.pop_back(); isvisited[j] = false; } }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; } } dfs(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;} Chatgpt 개선 코드#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int n;int grid[10][10];bool used_col[10];int answer = INT_MIN;void dfs(int row, int sum_so_far) { // 모든 행에 대해 선택을 마쳤을 때 if (row == n) { answer = max(answer, sum_so_far); return; } // 현재 행(row)에서 하나의 열(col)을 선택 for (int col = 0; col &lt; n; col++) { if (used_col[col]) continue; // 이미 선택된 열은 스킵 used_col[col] = true; dfs(row + 1, sum_so_far + grid[row][col]); used_col[col] = false; }}int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; } } fill(used_col, used_col + 10, false); dfs(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "대폭발", "url": "/posts/%EB%8C%80%ED%8F%AD%EB%B0%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-10-01 00:00:00 +0900", "snippet": "대폭발https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-big-explosion/description풀이#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define ARR_MAX_LEN 110using namespace std;typedef struct{ int y; int x;}loc_t;int n, m, r, c, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };vector&lt;loc_t&gt; loc_lst;int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; r &gt;&gt; c; arrmap[r][c] = 1; for(int t = 1; t &lt;= m; t++){ loc_lst.clear(); for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(arrmap[i][j] != 0) loc_lst.push_back({i, j}); } } for(int i = 0; i &lt; loc_lst.size(); i++){ int cy = loc_lst[i].y; int cx = loc_lst[i].x; for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + (pow(2, (t - 1)) * dy[dir]); int nx = cx + (pow(2, (t - 1)) * dx[dir]); if(ny &lt; 1 || ny &gt; n || nx &lt; 1 || nx &gt; n) continue; if(arrmap[ny][nx] == 0 &amp;&amp; !isvisited[ny][nx]){ arrmap[ny][nx] = 1; isvisited[ny][nx] = true; } } } } // debug code // for(int i = 1; i &lt;= n; i++){ // for(int j = 1; j &lt;= n; j++){ // cout &lt;&lt; arrmap[i][j] &lt;&lt; \" \"; // } // cout &lt;&lt; \"\\n\"; // } for(int i = 1; i &lt;= n; i++){ for(int j = 1; j &lt;= n; j++){ if(arrmap[i][j] != 0) answer++; } } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "N개의 점 중 M개 고르기", "url": "/posts/N%EA%B0%9C%EC%9D%98-%EC%A0%90-%EC%A4%91-M%EA%B0%9C-%EA%B3%A0%EB%A5%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-09-28 00:00:00 +0900", "snippet": "N개의 점 중 M개 고르기https://www.codetree.ai/ko/trails/complete/curated-cards/test-choose-m-out- -n-points/description풀이#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef struct{ int x; int y;}loc_t;int n, m, answer = 7654321;int x[20], y[20];vector&lt;loc_t&gt; cand_pos;int calc_dist(int x1, int x2, int y1, int y2){ return ((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));}void dfs(int idx, int cnt){ if (cnt == m){ int temp_answer = 0; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; m; j++){ if(i != j){ int dist = calc_dist(cand_pos[i].x, cand_pos[j].x, cand_pos[i].y, cand_pos[j].y); if(temp_answer &lt; dist){ temp_answer = dist; } } } } answer = min(answer, temp_answer); return; } for(int i = idx; i &lt; n; i++){ cand_pos.push_back({x[i], y[i]}); dfs(i + 1, cnt + 1); cand_pos.pop_back(); }}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; x[i] &gt;&gt; y[i]; } dfs(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "방화벽 설치하기", "url": "/posts/K%EB%B2%88-%EC%B5%9C%EB%8C%80-%EA%B0%92%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-09-28 00:00:00 +0900", "snippet": "방화벽 설치하기https://www.codetree.ai/ko/trails/complete/curated-cards/challenge-move-to-max-k-times/descriptionn풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int n, k;int grid[100][100];bool isvisited[100][100] = { false };int r, c;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct { int y; int x;}loc_t;int bfs(int y, int x, int val){ int max_num = 0; queue&lt;loc_t&gt; q; q.push({y, x}); isvisited[y][x] = true; while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; q.pop(); for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &lt; 1 || ny &gt; n || nx &lt; 1 || nx &gt; n) continue; if ((grid[ny][nx] &lt; val) &amp;&amp; !isvisited[ny][nx]) { q.push({ny, nx}); isvisited[ny][nx] = true; // 시작 좌표는 제외하고 MAX 값 구해야 함 max_num = max(max_num, grid[ny][nx]); } } } return max_num;}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); // 입력 시퀀스 cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i++) { for (int j = 1; j &lt;= n; j++) { cin &gt;&gt; grid[i][j]; } } cin &gt;&gt; r &gt;&gt; c; // 문제 풀이 시작 for (int i = 0; i &lt; k; i++) { bool move_flag = false; int max_val = 0; memset(isvisited, false, sizeof(isvisited)); max_val = bfs(r, c, grid[r][c]); if (max_val == 0) break; else { // 다음 좌표 탐색 for (int i = 1; i &lt;= n; i++) { bool find_flag = false; for (int j = 1; j &lt;= n; j++) { if (!find_flag &amp;&amp; isvisited[i][j]) { if (grid[i][j] == max_val) { r = i; c = j; find_flag = true; } } } if (find_flag) break; } } } cout &lt;&lt; r &lt;&lt; \" \" &lt;&lt; c &lt;&lt; \"\\n\"; return 0;}" }, { "title": "정수 사각형 최대 합", "url": "/posts/%EC%A0%95%EC%88%98-%EC%82%AC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80-%ED%95%A9/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2025-09-27 00:00:00 +0900", "snippet": "정수 사각형 최대 합https://www.codetree.ai/ko/trails/complete/curated-cards/intro-maximum-sum-path-in-square/description(1, 1) 에서 (N, N) 까지 이동하며 오른쪽, 밑으로만 이동할 때 거쳐간 값의 합의 최대값을 구하는 문제풀이#include &lt;iostream&gt;using namespace std;int n, answer = 0;int grid[100][100];int dp[100][100] = { 0 };void init(){ dp[0][0] = grid[0][0]; for(int i = 1; i &lt; n; i++){ dp[i][0] = dp[i - 1][0] + grid[i][0]; } for(int i = 1; i &lt; n; i++){ dp[0][i] = dp[0][i - 1] + grid[0][i]; }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { cin &gt;&gt; grid[i][j]; } } init(); for (int i = 1; i &lt; n; i++) { for (int j = 1; j &lt; n; j++) { dp[i][j] = max((dp[i - 1][j] + grid[i][j]), (dp[i][j - 1] + grid[i][j])); } } cout &lt;&lt; dp[n - 1][n - 1] &lt;&lt; \"\\n\"; return 0;}" }, { "title": "새로운 게임 2", "url": "/posts/%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B2%8C%EC%9E%842/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-09-23 00:00:00 +0900", "snippet": "새로운 게임 2문제재현이는 주변을 살펴보던 중 체스판과 말을 이용해서 새로운 게임을 만들기로 했다. 새로운 게임은 크기가 N×N인 체스판에서 진행되고, 사용하는 말의 개수는 K개이다. 말은 원판모양이고, 하나의 말 위에 다른 말을 올릴 수 있다. 체스판의 각 칸은 흰색, 빨간색, 파란색 중 하나로 색칠되어있다.게임은 체스판 위에 말 K개를 놓고 시작한다. 말은 1번부터 K번까지 번호가 매겨져 있고, 이동 방향도 미리 정해져 있다. 이동 방향은 위, 아래, 왼쪽, 오른쪽 4가지 중 하나이다.턴 한 번은 1번 말부터 K번 말까지 순서대로 이동시키는 것이다. 한 말이 이동할 때 위에 올려져 있는 말도 함께 이동한다. 말의 이동 방향에 있는 칸에 따라서 말의 이동이 다르며 아래와 같다. 턴이 진행되던 중에 말이 4개 이상 쌓이는 순간 게임이 종료된다.A번 말이 이동하려는 칸이흰색인 경우에는 그 칸으로 이동한다. 이동하려는 칸에 말이 이미 있는 경우에는 가장 위에 A번 말을 올려놓는다.A번 말의 위에 다른 말이 있는 경우에는 A번 말과 위에 있는 모든 말이 이동한다.예를 들어, A, B, C로 쌓여있고, 이동하려는 칸에 D, E가 있는 경우에는 A번 말이 이동한 후에는 D, E, A, B, C가 된다.빨간색인 경우에는 이동한 후에 A번 말과 그 위에 있는 모든 말의 쌓여있는 순서를 반대로 바꾼다.A, B, C가 이동하고, 이동하려는 칸에 말이 없는 경우에는 C, B, A가 된다.A, D, F, G가 이동하고, 이동하려는 칸에 말이 E, C, B로 있는 경우에는 E, C, B, G, F, D, A가 된다.파란색인 경우에는 A번 말의 이동 방향을 반대로 하고 한 칸 이동한다. 방향을 반대로 바꾼 후에 이동하려는 칸이 파란색인 경우에는 이동하지 않고 가만히 있는다.체스판을 벗어나는 경우에는 파란색과 같은 경우이다.다음은 크기가 4×4인 체스판 위에 말이 4개 있는 경우이다.첫 번째 턴은 다음과 같이 진행된다.두 번째 턴은 다음과 같이 진행된다.체스판의 크기와 말의 위치, 이동 방향이 모두 주어졌을 때, 게임이 종료되는 턴의 번호를 구해보자.입력첫째 줄에 체스판의 크기 N, 말의 개수 K가 주어진다. 둘째 줄부터 N개의 줄에 체스판의 정보가 주어진다. 체스판의 정보는 정수로 이루어져 있고, 각 정수는 칸의 색을 의미한다. 0은 흰색, 1은 빨간색, 2는 파란색이다.다음 K개의 줄에 말의 정보가 1번 말부터 순서대로 주어진다. 말의 정보는 세 개의 정수로 이루어져 있고, 순서대로 행, 열의 번호, 이동 방향이다. 행과 열의 번호는 1부터 시작하고, 이동 방향은 4보다 작거나 같은 자연수이고 1부터 순서대로 →, ←, ↑, ↓의 의미를 갖는다.같은 칸에 말이 두 개 이상 있는 경우는 입력으로 주어지지 않는다.출력게임이 종료되는 턴의 번호를 출력한다. 그 값이 1,000보다 크거나 절대로 게임이 종료되지 않는 경우에는 -1을 출력한다.풀이" }, { "title": "새로운 게임", "url": "/posts/%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B2%8C%EC%9E%84/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-09-23 00:00:00 +0900", "snippet": "새로운 게임문제재현이는 주변을 살펴보던 중 체스판과 말을 이용해서 새로운 게임을 만들기로 했다. 새로운 게임은 크기가 N×N인 체스판에서 진행되고, 사용하는 말의 개수는 K개이다. 말은 원판모양이고, 하나의 말 위에 다른 말을 올릴 수 있다. 체스판의 각 칸은 흰색, 빨간색, 파란색 중 하나로 색칠되어있다.게임은 체스판 위에 말 K개를 놓고 시작한다. 말은 1번부터 K번까지 번호가 매겨져 있고, 이동 방향도 미리 정해져 있다. 이동 방향은 위, 아래, 왼쪽, 오른쪽 4가지 중 하나이다.턴 한 번은 1번 말부터 K번 말까지 순서대로 이동시키는 것이다. 한 말이 이동할 때 위에 올려져 있는 말도 함께 이동하며, 가장 아래에 있는 말만 이동할 수 있다. 말의 이동 방향에 있는 칸에 따라서 말의 이동이 다르며 아래와 같다. 턴이 진행되던 중에 말이 4개 이상 쌓이는 순간 게임이 종료된다.A번 말이 이동하려는 칸이흰색인 경우에는 그 칸으로 이동한다. 이동하려는 칸에 말이 이미 있는 경우에는 가장 위에 A번 말을 올려놓는다.A번 말의 위에 다른 말이 있는 경우에는 A번 말과 위에 있는 모든 말이 이동한다.예를 들어, A, B, C로 쌓여있고, 이동하려는 칸에 D, E가 있는 경우에는 A번 말이 이동한 후에는 D, E, A, B, C가 된다.빨간색인 경우에는 이동한 후에 A번 말과 그 위에 있는 모든 말의 쌓여있는 순서를 반대로 바꾼다.A, B, C가 이동하고, 이동하려는 칸에 말이 없는 경우에는 C, B, A가 된다.A, D, F, G가 이동하고, 이동하려는 칸에 말이 E, C, B로 있는 경우에는 E, C, B, G, F, D, A가 된다.파란색인 경우에는 A번 말의 이동 방향을 반대로 하고 한 칸 이동한다. 방향을 반대로 한 후에 이동하려는 칸이 파란색인 경우에는 이동하지 않고 방향만 반대로 바꾼다.체스판을 벗어나는 경우에는 파란색과 같은 경우이다.다음은 크기가 4×4인 체스판 위에 말이 4개 있는 경우이다.첫 번째 턴은 다음과 같이 진행된다.두 번째 턴은 다음과 같이 진행된다.체스판의 크기와 말의 위치, 이동 방향이 모두 주어졌을 때, 게임이 종료되는 턴의 번호를 구해보자.입력첫째 줄에 체스판의 크기 N, 말의 개수 K가 주어진다. 둘째 줄부터 N개의 줄에 체스판의 정보가 주어진다. 체스판의 정보는 정수로 이루어져 있고, 각 정수는 칸의 색을 의미한다. 0은 흰색, 1은 빨간색, 2는 파란색이다.다음 K개의 줄에 말의 정보가 1번 말부터 순서대로 주어진다. 말의 정보는 세 개의 정수로 이루어져 있고, 순서대로 행, 열의 번호, 이동 방향이다. 행과 열의 번호는 1부터 시작하고, 이동 방향은 4보다 작거나 같은 자연수이고 1부터 순서대로 →, ←, ↑, ↓의 의미를 갖는다.같은 칸에 말이 두 개 이상 있는 경우는 입력으로 주어지지 않는다.출력게임이 종료되는 턴의 번호를 출력한다. 그 값이 1,000보다 크거나 절대로 게임이 종료되지 않는 경우에는 -1을 출력한다.풀이" }, { "title": "방화벽 설치하기", "url": "/posts/%EB%B0%A9%ED%99%94%EB%B2%BD-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS, DFS", "date": "2025-09-23 00:00:00 +0900", "snippet": "방화벽 설치하기https://www.codetree.ai/ko/frequent-problems/samsung-sw/problems/firewall-installation/description풀이#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define ARR_MAX_LEN 10using namespace std;typedef struct { int y; int x;}loc_t;int temp_arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int n, m, answer = 0;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };vector&lt;loc_t&gt; candidate_wall;vector&lt;loc_t&gt; select_wall;vector&lt;loc_t&gt; fire_pos;void input() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { cin &gt;&gt; arrmap[i][j]; if (arrmap[i][j] == 0) { candidate_wall.push_back({ i, j }); } else if (arrmap[i][j] == 2) { fire_pos.push_back({ i, j }); } } }}void bfs() { queue&lt;loc_t&gt; q; for (int i = 0; i &lt; fire_pos.size(); i++) { q.push(fire_pos[i]); } while (!q.empty()) { int cy = q.front().y; int cx = q.front().x; q.pop(); for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &lt; 0 || ny &gt;= n || nx &lt; 0 || nx &gt;= m) continue; if (temp_arrmap[ny][nx] == 0) { temp_arrmap[ny][nx] = 2; q.push({ ny, nx }); } } } int temp_cnt = 0; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { if (temp_arrmap[i][j] == 0) { temp_cnt++; } } } answer = max(answer, temp_cnt);}void comb(int idx, int cnt) { if (cnt == 3) { memcpy(temp_arrmap, arrmap, sizeof(temp_arrmap)); memset(isvisited, 0, sizeof(isvisited)); for (int i = 0; i &lt; select_wall.size(); i++) { temp_arrmap[select_wall[i].y][select_wall[i].x] = 1; } bfs(); return; } for (int i = idx; i &lt; candidate_wall.size(); i++) { select_wall.push_back(candidate_wall[i]); comb(i + 1, cnt + 1); select_wall.pop_back(); }}int main() { input(); comb(0, 0); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "성곽", "url": "/posts/%EC%84%B1%EA%B3%BD/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-09-20 00:00:00 +0900", "snippet": "성곽문제대략 위의 그림과 같이 생긴 성곽이 있다. 굵은 선은 벽을 나타내고, 점선은 벽이 없어서 지나다닐 수 있는 통로를 나타낸다. 이러한 형태의 성의 지도를 입력받아서 다음을 계산하는 프로그램을 작성하시오. 이 성에 있는 방의 개수 가장 넓은 방의 넓이 하나의 벽을 제거하여 얻을 수 있는 가장 넓은 방의 크기위의 예에서는 방은 5개고, 가장 큰 방은 9개의 칸으로 이루어져 있으며, 위의 그림에서 화살표가 가리키는 벽을 제거하면 16인 크기의 방을 얻을 수 있다.성은 M × N(1 ≤ M, N ≤ 50)개의 정사각형 칸으로 이루어진다. 성에는 최소 두 개의 방이 있어서, 항상 하나의 벽을 제거하여 두 방을 합치는 경우가 있다.입력첫째 줄에 두 정수 N, M이 주어진다. 다음 M개의 줄에는 N개의 정수로 벽에 대한 정보가 주어진다. 벽에 대한 정보는 한 정수로 주어지는데, 서쪽에 벽이 있을 때는 1을, 북쪽에 벽이 있을 때는 2를, 동쪽에 벽이 있을 때는 4를, 남쪽에 벽이 있을 때는 8을 더한 값이 주어진다. 참고로 이진수의 각 비트를 생각하면 쉽다. 따라서 이 값은 0부터 15까지의 범위 안에 있다.출력첫째 줄에 1의 답을, 둘째 줄에 2의 답을, 셋째 줄에 3의 답을 출력한다.풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 55using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int N, M, max_space = 0, num_area = 0, max_space_break_wall = 0;// 서북동남int dy[4] = { 0, -1, 0, 1 };int dx[4] = { -1, 0, 1, 0 };typedef struct { int y; int x;}loc_t;void input(void) { cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; M; i++) { for (int j = 0; j &lt; N; j++) { cin &gt;&gt; arrmap[i][j]; } }}int bfs(int y, int x) { int area_cnt = 0; queue&lt;loc_t&gt; q; q.push({ y, x }); isvisited[y][x] = true; while (!q.empty()) { int cy = q.front().y; int cx = q.front().x; area_cnt++; q.pop(); for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &lt; 0 || ny &gt;= M || nx &lt; 0 || nx &gt;= N) continue; if (!isvisited[ny][nx] &amp;&amp; ((arrmap[cy][cx] &amp; (1 &lt;&lt; dir)) == 0)) { q.push({ ny, nx }); isvisited[ny][nx] = true; //cout &lt;&lt; ny &lt;&lt; \" \" &lt;&lt; nx &lt;&lt; \" \" &lt;&lt; dir &lt;&lt; \"\\n\"; } } } return area_cnt;}int main(void) { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for (int i = 0; i &lt; M; i++) { for (int j = 0; j &lt; N; j++) { if (!isvisited[i][j]) { // cout &lt;&lt; \"check\\n\"; max_space = max(max_space, bfs(i, j)); num_area++; } } } // 벽을 하나 무너트리고 최대 영역 탐색 // 해당 위치마다 벽을 확인하고 하나씩 무너트려 보면서 최대 영역을 탐색하여 최종 정답값에 max 값을 찾아 저장 for (int i = 0; i &lt; M; i++) { for (int j = 0; j &lt; N; j++) { for (int check_bit = 1; check_bit &lt;= 8; check_bit *= 2) { if ((arrmap[i][j] &amp; check_bit) != 0) { memset(isvisited, 0, sizeof(isvisited)); arrmap[i][j] -= check_bit; max_space_break_wall = max(max_space_break_wall, bfs(i, j)); arrmap[i][j] += check_bit; } } } } cout &lt;&lt; num_area &lt;&lt; \"\\n\"; cout &lt;&lt; max_space &lt;&lt; \"\\n\"; cout &lt;&lt; max_space_break_wall &lt;&lt; \"\\n\"; return 0;}" }, { "title": "달팽이", "url": "/posts/%EB%8B%AC%ED%8C%BD%EC%9D%B4/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-09-20 00:00:00 +0900", "snippet": "달팽이문제홀수인 자연수 N이 주어지면, 다음과 같이 1부터 N2까지의 자연수를 달팽이 모양으로 N×N의 표에 채울 수 있다.9\t2\t38\t1\t47\t6\t525\t10\t11\t12\t1324\t9\t2\t3\t1423\t8\t1\t4\t1522\t7\t6\t5\t1621\t20\t19\t18\t17N이 주어졌을 때, 이러한 표를 출력하는 프로그램을 작성하시오. 또한 N2 이하의 자연수가 하나 주어졌을 때, 그 좌표도 함께 출력하시오. 예를 들어 N=5인 경우 6의 좌표는 (4,3)이다.입력첫째 줄에 홀수인 자연수 N(3 ≤ N ≤ 999)이 주어진다. 둘째 줄에는 위치를 찾고자 하는 N2 이하의 자연수가 하나 주어진다.출력N개의 줄에 걸쳐 표를 출력한다. 각 줄에 N개의 자연수를 한 칸씩 띄어서 출력하면 되며, 자릿수를 맞출 필요가 없다. N+1번째 줄에는 입력받은 자연수의 좌표를 나타내는 두 정수를 한 칸 띄어서 출력한다.풀이#include &lt;iostream&gt;#define ARR_MAX_LEN 1001using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int N;int dy[4] = { -1, 0, 1, 0 };int dx[4] = { 0, 1, 0, -1 };int main(void) { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int input_num = 0, ans_y = 0, ans_x = 0; cin &gt;&gt; N; cin &gt;&gt; input_num; int cur_y, cur_x; cur_y = cur_x = N / 2 + 1; int mov_point = 1, cur_num = 1, dir = 0, mov_cnt = 0; arrmap[cur_y][cur_x] = cur_num; // 움직이는 칸 수는 방향이 두 번 바뀐 후 1 증가한다 // 마지막의 경우 방향이 세 번 바뀌고 (1, 1) 포인트에 도착하는데, 무시하고 2번 움직이고 칸 수를 1 증가시키더라도 현재 좌표가 (1, 1) 이면 break 하는 코드가 있어 문제가 없음 while (true) { // 현재 위치가 입력한 숫자이면 정답 좌표값 업데이트 if (cur_num == input_num) { ans_y = cur_y; ans_x = cur_x; } // 현재 좌표에 넣을 값 업데이트 (+1) cur_num++; mov_cnt++; // 마지막 지점이면 break if (cur_y == 1 &amp;&amp; cur_x == 1) break; // 다음 이동위치 결정 int ny = cur_y + dy[dir]; int nx = cur_x + dx[dir]; // 좌표와 좌표에 넣을 값 업데이트 cur_y = ny; cur_x = nx; arrmap[cur_y][cur_x] = cur_num; // 디버그 로그 //cout &lt;&lt; \"cur_y : \" &lt;&lt; cur_y &lt;&lt; \" \" &lt;&lt; \"cur_x : \" &lt;&lt; cur_x &lt;&lt; \" \" &lt;&lt; \"cur_num : \" &lt;&lt; cur_num &lt;&lt; \"\\n\"; // 한 방향으로 움직여야 하는 거리를 증가시켜야 할 조건 if (mov_cnt == mov_point) { mov_cnt = 0; // 두 번 방향을 바꿨다면 이동 거리 +1 if ((dir % 2) == 1) mov_point++; // 이후 방향정보 업데이트 dir = (dir + 1) % 4; } } // 정답 출력 for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { cout &lt;&lt; arrmap[i][j] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; } cout &lt;&lt; ans_y &lt;&lt; \" \" &lt;&lt; ans_x &lt;&lt; \"\\n\"; return 0;}" }, { "title": "주사위 윷놀이", "url": "/posts/%EC%A3%BC%EC%82%AC%EC%9C%84-%EC%9C%B7%EB%86%80%EC%9D%B4/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-09-19 00:00:00 +0900", "snippet": "주사위 윷놀이문제주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다. 처음에는 시작 칸에 말 4개가 있다. 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다. 게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다. 말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다. 말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.입력첫째 줄에 주사위에서 나올 수 10개가 순서대로 주어진다.출력얻을 수 있는 점수의 최댓값을 출력한다.풀이" }, { "title": "벽 부수고 이동하기 4", "url": "/posts/%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-4/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-09-13 00:00:00 +0900", "snippet": "벽 부수고 이동하기 4문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.각각의 벽에 대해서 다음을 구해보려고 한다. 벽을 부수고 이동할 수 있는 곳으로 변경한다. 그 위치에서 이동할 수 있는 칸의 개수를 세어본다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다.출력맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.풀이 일반적으로 bfs 로 돌렸던 풀이, 시간초과 발생```cpp#include #include #include #include #include #define ARR_MAX_LEN 1005using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int answermap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };int N, M;typedef struct{\tint y;\tint x;}loc_t;void input(){ cin » N » M;\tfor(int i = 1; i &lt;= N; i++){\t\tstring str;\t\tcin » str;\t\tfor(int j = 1; j &lt;= M; j++){\t\t\tarrmap[i][j] = str[j - 1] - ‘0’;\t\t}\t}}int bfs(int y, int x){\tint cnt = 0;\tqueue q;\tbool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };\tq.push({y, x});\tisvisited[y][x] = true;\twhile(!q.empty()){\t\tint cy = q.front().y;\t\tint cx = q.front().x;\t\tq.pop();\t\tcnt++;\t\tfor(int dir = 0; dir &lt; 4; dir++){\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\tif(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M)\t\t\tcontinue;\t\tif(arrmap[ny][nx] == 0 &amp;&amp; !isvisited[ny][nx]){\t\t\tq.push({ny, nx});\t\t\tisvisited[ny][nx] = true;\t\t}\t}}cnt = cnt return cnt; }int main(){ios::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);int answer = 0;input();for(int i = 1; i &lt;= N; i++){\t\tfor(int j = 1; j &lt;= M; j++){\t\tif(arrmap[i][j] == 1)\t\t\tanswermap[i][j] = bfs(i, j);\t}}for(int i = 1; i &lt;= N; i++){\t\tfor(int j = 1; j &lt;= M; j++){\t\tcout &lt;&lt; answermap[i][j];\t}\tcout &lt;&lt; \"\\n\";}return 0; } ```벽 기준(1) 으로 생각하지 않고 빈 공간(0)을 먼저 labeling 을 해서 벽마다 갈 수 있는 빈 공간을 미리 계산해두면 중복 계산이 많이 줄어듦. 아래 페이지의 풀이를 참조https://yabmoons.tistory.com/216#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;#define ARR_MAX_LEN 1005using namespace std;int N, M;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; // 입력 맵 (0: 빈칸, 1: 벽)int answermap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; // 출력 맵int comp_id[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; // 0-컴포넌트 ID mapping 수행 (벽은 0)bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; // 방문 체크 배열int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{ int y; int x;} loc_t;// ID 방문 체크용int used_id[ARR_MAX_LEN * ARR_MAX_LEN]; int used_ver[ARR_MAX_LEN * ARR_MAX_LEN]; // 전역 각 0-컴포넌트 영역 크기 저장vector&lt;int&gt; comp_size;void input(){ cin &gt;&gt; N &gt;&gt; M; for(int i = 1; i &lt;= N; i++){ string str; cin &gt;&gt; str; for(int j = 1; j &lt;= M; j++){ arrmap[i][j] = str[j - 1] - '0'; } }}void bfs(int y, int x, int id){\tint cnt = 0;\tqueue&lt;loc_t&gt; q;\tq.push({y, x});\tisvisited[y][x] = true;\tcomp_id[y][x] = id;\twhile(!q.empty()){\t\tint cy = q.front().y;\t\tint cx = q.front().x;\t\tq.pop();\t\tcnt++;\t\tfor(int dir = 0; dir &lt; 4; dir++){\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\t\tif(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M)\t\t\t\tcontinue;\t\t\tif(arrmap[ny][nx] != 0 || isvisited[ny][nx])\t\t\t\tcontinue;\t\t\tisvisited[ny][nx] = true; // component id map 에 값 업데이트 \t\t\tcomp_id[ny][nx] = id;\t\t\tq.push({ny, nx});\t\t}\t}\tcomp_size.push_back(cnt); // comp_size[id] = cnt}// 0-컴포넌트 라벨링void label_components(){ comp_size.clear(); comp_size.push_back(0); // ID 0 에는 dummy 값(0) int cur_id = 0; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ if(arrmap[i][j] == 0 &amp;&amp; !isvisited[i][j]){ cur_id++;\t\t\t\tbfs(i, j, cur_id); } } }}// 벽 칸 처리void build_answer(){ // comp_id 값을 비교할 변수 int cur_ver = 0; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ // 벽칸에 대해서 이동 가능한 칸 탐색 (미리 업데이트 해둔 0-component 활용) if(arrmap[i][j] == 1){ int sum = 1; // 벽 칸 포함 // 0-component 관련 comp_id 값 비교하는 변수 cur_ver++; for(int dir = 0; dir &lt; 4; dir++){ int ny = i + dy[dir]; int nx = j + dx[dir]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M) continue; int id = comp_id[ny][nx]; // 더미 값은 pass if(id == 0) continue; if(used_ver[id] == cur_ver) continue; // 이미 더한 ID // 해당 0-component 영역은 방문 처리 used_ver[id] = cur_ver; sum += comp_size[id]; } // 벽이 있는 포인트 별 정답값 업데이트 answermap[i][j] = sum % 10; } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); label_components(); build_answer(); for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ cout &lt;&lt; answermap[i][j]; } cout &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "벽 부수고 이동하기 3", "url": "/posts/%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-3/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-09-07 00:00:00 +0900", "snippet": "벽 부수고 이동하기 3문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다. 이동하지 않고 같은 칸에 머물러있는 경우도 가능하다. 이 경우도 방문한 칸의 개수가 하나 늘어나는 것으로 생각해야 한다.이번 문제에서는 낮과 밤이 번갈아가면서 등장한다. 가장 처음에 이동할 때는 낮이고, 한 번 이동할 때마다 낮과 밤이 바뀌게 된다. 이동하지 않고 같은 칸에 머무르는 경우에도 낮과 밤이 바뀌게 된다.만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다. 단, 벽은 낮에만 부술 수 있다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000), K(1 ≤ K ≤ 10)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#define ARR_MAX_LEN 1005#define MAX_DEST_CNT 11using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// isvisited[y][x][broke_cnt][day_or_night]// day_or_night: 0 = 밤, 1 = 낮 (시간 t 기준으로 t % 2)bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN][MAX_DEST_CNT][2] = { false };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };int N, M, K;typedef struct { int y; int x; int b; // 부순 벽 개수 int t; // 현재 시간(이동 횟수)} node_t;void input(){ cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for(int i = 1; i &lt;= N; i++){ string str; cin &gt;&gt; str; for(int j = 1; j &lt;= M; j++){ arrmap[i][j] = str[j - 1] - '0'; } }}int bfs(){ queue&lt;node_t&gt; q; // 시작 시점 시간 1로 두면 도착 시 정답이 이동 횟수와 일치한다 // 1=낮, 0=밤 q.push({1, 1, 0, 1}); isvisited[1][1][0][1 % 2] = true; while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; int cb = q.front().b; int ct = q.front().t; q.pop(); if(cy == N &amp;&amp; cx == M) return ct; int is_day = ct % 2; // 1=낮, 0=밤 for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M) continue; // 빈 칸으로 이동 if(arrmap[ny][nx] == 0){ int nt = ct + 1; int parity = nt % 2; if(!isvisited[ny][nx][cb][parity]){ isvisited[ny][nx][cb][parity] = true; q.push({ny, nx, cb, nt}); } } // 벽을 만난 경우 else{ // 낮이면 부수고 전진 가능 if(is_day == 1 &amp;&amp; cb &lt; K){ int nt = ct + 1; int parity = nt % 2; if(!isvisited[ny][nx][cb + 1][parity]){ isvisited[ny][nx][cb + 1][parity] = true; q.push({ny, nx, cb + 1, nt}); } } // 밤이면 제자리 대기(시간 +1) 후 다시 시도 else{ int nt = ct + 1; int parity = nt % 2; if(!isvisited[cy][cx][cb][parity]){ isvisited[cy][cx][cb][parity] = true; q.push({cy, cx, cb, nt}); } } } } } return -1;}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); input(); int answer = bfs(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "벽 부수고 이동하기 2", "url": "/posts/%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0-2/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-09-07 00:00:00 +0900", "snippet": "벽 부수고 이동하기 2문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000), K(1 ≤ K ≤ 10)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#define ARR_MAX_LEN 1005using namespace std;int N, M, K;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN][11] = { false };int timemap[ARR_MAX_LEN][ARR_MAX_LEN][11] = { 0 };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{\tint y;\tint x;\tint broke_cnt;}state_t;void input(){\tcin &gt;&gt; N &gt;&gt; M &gt;&gt; K;\tfor(int i = 1; i &lt;= N; i++){ string str;\t\tcin &gt;&gt; str;\t\tfor(int j = 1; j &lt;= M; j++){\t\t\tarrmap[i][j] = str[j - 1] - '0';\t\t}\t}\t}int bfs(){ \tqueue&lt;state_t&gt; q;\ttimemap[1][1][0] = 1;\tisvisited[1][1][0] = true; q.push({1, 1, 0});\twhile(!q.empty()){\t\tint cy = q.front().y;\t\tint cx = q.front().x;\t\tint cb = q.front().broke_cnt;\t\tq.pop();\t\tif(cy == N &amp;&amp; cx == M)\t\t\treturn timemap[cy][cx][cb]; \t\tfor(int dir = 0; dir &lt; 4; dir++){\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\t\tif(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M)\t\t\t\tcontinue;\t\t\t// 벽이 아닌 경우\t\t\tif(arrmap[ny][nx] == 0 &amp;&amp; !isvisited[ny][nx][cb] &amp;&amp; cb &lt;= K){\t\t\t\tq.push({ny, nx, cb});\t\t\t\tisvisited[ny][nx][cb] = true;\t\t\t\ttimemap[ny][nx][cb] = timemap[cy][cx][cb] + 1;\t\t\t}\t\t\t// 벽인데 뚫고 갈 수 있는 경우\t\t\telse if(arrmap[ny][nx] == 1 &amp;&amp; cb &lt; K &amp;&amp; !isvisited[ny][nx][cb + 1]){\t\t\t\tint nb = cb + 1;\t\t\t\tq.push({ny, nx, nb});\t\t\t\tisvisited[ny][nx][nb] = true;\t\t\t\ttimemap[ny][nx][nb] = timemap[cy][cx][cb] + 1;\t\t\t}\t\t}\t}\t\treturn -1;}int main(){\tios::sync_with_stdio(false);\tcin.tie(NULL); \tint answer = 0;\tinput();\tanswer = bfs();\tcout &lt;&lt; answer &lt;&lt; \"\\n\";\treturn 0;}" }, { "title": "벽 부수고 이동하기", "url": "/posts/%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-09-05 00:00:00 +0900", "snippet": "벽 부수고 이동하기문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다..풀이언뜻보면 bfs + dfs 문제같지만, 그냥 bfs 에 상태를 추가해서 탐색하면 되는 문제..몇개 중 몇개를 선택해야하는 조합을 찾는 문제는 아니기 때문에 그냥 bfs 로 풀어야 맞다#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 1100using namespace std;int N, M;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// up, down, right, leftint dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, 1, -1 };typedef struct{ int y; int x; int broke; // 0 : 아직 안부숨, 1 : 이미 한 번 부숨} state_t;// 거리 arrmap 에 상태 개념까지 추가해서 bfs 를 한 번만 탐색해도 되게끔 한다.int distv[ARR_MAX_LEN][ARR_MAX_LEN][2]; // distv[y][x][broke] = 시작에서의 거리(시작을 1로)int bfs(){ memset(distv, 0, sizeof( distv )); queue&lt;state_t&gt; q; // 시작울 1 로 시작해야 함 (거리 개념이라서) distv[1][1][0] = 1; q.push( { 1, 1, 0 } ); while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; int cb = q.front().broke; q.pop(); if(cy == N &amp;&amp; cx == M) return distv[cy][cx][cb]; for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M) continue; // 빈 칸이면 그대로 진행 if(arrmap[ny][nx] == 0 &amp;&amp; distv[ny][nx][cb] == 0){ distv[ny][nx][cb] = distv[cy][cx][cb] + 1; q.push({ ny, nx, cb }); } // 벽이면 아직 안부쉈을 때만 부수고 진행 else if(arrmap[ny][nx] == 1 &amp;&amp; cb == 0 &amp;&amp; distv[ny][nx][1] == 0){ distv[ny][nx][1] = distv[cy][cx][cb] + 1; q.push({ ny, nx, 1 }); } } } return -1; // 도달 불가}void input(){ cin &gt;&gt; N &gt;&gt; M; for( int i = 1; i &lt;= N; i++ ){ string s; cin &gt;&gt; s; for( int j = 1; j &lt;= M; j++ ){ arrmap[i][j] = s[j - 1] - '0'; } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); input(); int answer = bfs(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "스택", "url": "/posts/%EC%8A%A4%ED%83%9D/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-09-04 00:00:00 +0900", "snippet": "스택 (stack)https://www.acmicpc.net/problem/10828문제정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 다섯 가지이다. push X: 정수 X를 스택에 넣는 연산이다. pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 스택에 들어있는 정수의 개수를 출력한다. empty: 스택이 비어있으면 1, 아니면 0을 출력한다. top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.풀이STL 사용#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(NULL); int N; cin &gt;&gt; N; stack&lt;int&gt; st; for (int i = 0; i &lt; N; i++) { string cmd; cin &gt;&gt; cmd;\t\tif(cmd == \"push\"){\t\t\tint num;\t\t\tcin &gt;&gt; num;\t\t\tst.push(num);\t\t}\t\telse if(cmd == \"pop\"){\t\t\tif(st.empty())\t\t\t\tcout &lt;&lt; \"-1\\n\";\t\t\telse{\t\t\t\tcout &lt;&lt; st.top() &lt;&lt; \"\\n\";\t\t\t\tst.pop();\t\t\t}\t\t\t\t\t\t}\t\telse if(cmd == \"size\"){\t\t\tcout &lt;&lt; st.size() &lt;&lt; \"\\n\";\t\t}\t\telse if(cmd == \"empty\"){\t\t\tcout &lt;&lt; (st.empty() ? 1 : 0) &lt;&lt; \"\\n\";\t\t}\t\telse if(cmd == \"top\"){\t\t\tcout &lt;&lt; (st.empty() ? -1 : st.top()) &lt;&lt; \"\\n\";\t\t} } return 0;}" }, { "title": "큐", "url": "/posts/%ED%81%90/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-09-03 00:00:00 +0900", "snippet": "큐 (queue)https://www.acmicpc.net/problem/10845문제정수를 저장하는 큐를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여섯 가지이다. push X: 정수 X를 큐에 넣는 연산이다. pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 큐에 들어있는 정수의 개수를 출력한다. empty: 큐가 비어있으면 1, 아니면 0을 출력한다. front: 큐의 가장 앞에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다. back: 큐의 가장 뒤에 있는 정수를 출력한다. 만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.풀이STL 사용#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;queue&gt;using namespace std;int N;int main() { ios::sync_with_stdio(false); cin.tie(NULL); queue&lt;int&gt; q; cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) { // switch case 문은 string 은 안됨 string cmd; cin &gt;&gt; cmd; if (cmd == \"push\") { int num; cin &gt;&gt; num; q.push(num); } if (cmd == \"front\") { if (q.empty()) cout &lt;&lt; \"-1\\n\"; else cout &lt;&lt; q.front() &lt;&lt; \"\\n\"; } else if (cmd == \"back\") { if (q.empty()) cout &lt;&lt; \"-1\\n\"; else cout &lt;&lt; q.back() &lt;&lt; \"\\n\"; } else if (cmd == \"size\") { cout &lt;&lt; q.size() &lt;&lt; \"\\n\"; } else if (cmd == \"empty\") { cout &lt;&lt; (q.empty() ? 1 : 0) &lt;&lt; \"\\n\"; } else if (cmd == \"pop\") { if (q.empty()) cout &lt;&lt; \"-1\\n\"; else { cout &lt;&lt; q.front() &lt;&lt; \"\\n\"; q.pop(); } } } return 0;}직접 구현" }, { "title": "덱", "url": "/posts/%EB%8D%B1/", "categories": "CodingTest", "tags": "CodingTest, Algorithm", "date": "2025-08-31 00:00:00 +0900", "snippet": "덱 (deque)https://www.acmicpc.net/problem/10866문제정수를 저장하는 덱(Deque)를 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 여덟 가지이다. push_front X: 정수 X를 덱의 앞에 넣는다. push_back X: 정수 X를 덱의 뒤에 넣는다. pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다. 만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. size: 덱에 들어있는 정수의 개수를 출력한다. empty: 덱이 비어있으면 1을, 아니면 0을 출력한다. front: 덱의 가장 앞에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다. back: 덱의 가장 뒤에 있는 정수를 출력한다. 만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.입력첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.출력출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.풀이STL 사용#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;deque&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(NULL); int N; cin &gt;&gt; N; deque&lt;int&gt; dq; for (int i = 0; i &lt; N; i++) { string command; cin &gt;&gt; command;\t\t// string 은 비교 연산(==) 으로 비교 가능 if (command == \"push_front\") { int value; cin &gt;&gt; value; dq.push_front(value); } else if (command == \"push_back\") { int value; cin &gt;&gt; value; dq.push_back(value); } else if (command == \"pop_front\") { if (dq.empty()) { cout &lt;&lt; -1 &lt;&lt; '\\n'; } else { cout &lt;&lt; dq.front() &lt;&lt; '\\n'; dq.pop_front(); } } else if (command == \"pop_back\") { if (dq.empty()) { cout &lt;&lt; -1 &lt;&lt; '\\n'; } else { cout &lt;&lt; dq.back() &lt;&lt; '\\n'; dq.pop_back(); } } else if (command == \"size\") { cout &lt;&lt; dq.size() &lt;&lt; '\\n'; } else if (command == \"empty\") { cout &lt;&lt; (dq.empty() ? 1 : 0) &lt;&lt; '\\n'; } else if (command == \"front\") { cout &lt;&lt; (dq.empty() ? -1 : dq.front()) &lt;&lt; '\\n'; } else if (command == \"back\") { cout &lt;&lt; (dq.empty() ? -1 : dq.back()) &lt;&lt; '\\n'; } } return 0;}직접 구현#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;#define MAX (10000 + 500)#define OFFSET (MAX / 2)int dq[MAX * 2];int front_idx, back_idx;int main() { ios::sync_with_stdio(false); cin.tie(NULL); int N; cin &gt;&gt; N; front_idx = back_idx = OFFSET; for (int i = 0; i &lt; N; i++) { string cmd; cin &gt;&gt; cmd; if (cmd == \"push_front\") { int value; cin &gt;&gt; value; dq[--front_idx] = value; } \t\telse if (cmd == \"push_back\") { int value; cin &gt;&gt; value; dq[back_idx++] = value; } \t\telse if (cmd == \"pop_front\") { if (back_idx == front_idx) { cout &lt;&lt; -1 &lt;&lt; '\\n'; } \t\t\telse { cout &lt;&lt; dq[front_idx++] &lt;&lt; '\\n'; } } \t\telse if (cmd == \"pop_back\") { if (back_idx == front_idx) { cout &lt;&lt; -1 &lt;&lt; '\\n'; } \t\t\telse { cout &lt;&lt; dq[--back_idx] &lt;&lt; '\\n'; } } \t\telse if (cmd == \"size\") { cout &lt;&lt; (back_idx - front_idx) &lt;&lt; '\\n'; } \t\telse if (cmd == \"empty\") { cout &lt;&lt; ((back_idx == front_idx) ? 1 : 0) &lt;&lt; '\\n'; } \t\telse if (cmd == \"front\") { cout &lt;&lt; ((back_idx == front_idx) ? -1 : dq[front_idx]) &lt;&lt; '\\n'; } \t\telse if (cmd == \"back\") { cout &lt;&lt; ((back_idx == front_idx) ? -1 : dq[back_idx - 1]) &lt;&lt; '\\n'; } } return 0;}" }, { "title": "나이트의 이동", "url": "/posts/%EB%82%98%EC%9D%B4%ED%8A%B8%EC%9D%98-%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-08-26 00:00:00 +0900", "snippet": "https://www.acmicpc.net/problem/7562문제체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?입력입력의 첫째 줄에는 테스트 케이스의 개수가 주어진다.각 테스트 케이스는 세 줄로 이루어져 있다. 첫째 줄에는 체스판의 한 변의 길이 l(4 ≤ l ≤ 300)이 주어진다. 체스판의 크기는 l × l이다. 체스판의 각 칸은 두 수의 쌍 {0, …, l-1} × {0, …, l-1}로 나타낼 수 있다. 둘째 줄과 셋째 줄에는 나이트가 현재 있는 칸, 나이트가 이동하려고 하는 칸이 주어진다.출력각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.풀이#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define ARR_MAX_LEN 330using namespace std;typedef struct{\tint y;\tint x;} loc_t;int T, N, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[8] = { -2, -1, 1, 2, 2, 1, -1, -2 };int dx[8] = { 1, 2, 2, 1, -1, -2, -2, -1 };vector&lt;loc_t&gt; src;vector&lt;loc_t&gt; dst;void input(){\tmemset(arrmap, 0, sizeof(arrmap)); memset(isvisited, 0, sizeof(isvisited));\tsrc.clear();\tdst.clear();\tcin &gt;&gt; N;\tint sy, sx, dy, dx;\tcin &gt;&gt; sy &gt;&gt; sx; cin &gt;&gt; dy &gt;&gt; dx;\tsrc.push_back({sy, sx});\tdst.push_back({dy, dx});}void bfs(int y, int x){\tqueue&lt;loc_t&gt; q;\tq.push({y, x});\tisvisited[y][x] = true;\twhile(!q.empty()){\t\tint cy = q.front().y;\t\tint cx = q.front().x;\t\tq.pop();\t\tif(cy == dst[0].y &amp;&amp; cx == dst[0].x)\t\t\treturn;\t\tfor(int dir = 0; dir &lt; 8; dir++){\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\t\tif(ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N){\t\t\t\tif(!isvisited[ny][nx]){\t\t\t\t\tarrmap[ny][nx] = arrmap[cy][cx] + 1;\t\t\t\t\tisvisited[ny][nx] = true; q.push({ny, nx});\t\t\t\t}\t\t\t}\t\t}\t}}int main(){\t\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tcin &gt;&gt; T;\tfor(int i = 0; i &lt; T; i++){\t\tinput();\t\t\t\tbfs(src[0].y, src[0].x); cout &lt;&lt; arrmap[dst[0].y][dst[0].x] &lt;&lt; \"\\n\";\t}\treturn 0;}" }, { "title": "뱀", "url": "/posts/%EB%B1%80/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-24 00:00:00 +0900", "snippet": "https://www.acmicpc.net/problem/3190문제‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다.만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.입력첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데, 정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 ‘L’) 또는 오른쪽(C가 ‘D’)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.출력첫째 줄에 게임이 몇 초에 끝나는지 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#define ARR_MAX_LEN 110#define APPLE 4using namespace std;typedef struct{\tint y;\tint x;}loc_t;typedef struct{\tint x;\tchar c;}dir_t;int N, K, L, answer = 0, snake_len;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };vector&lt;loc_t&gt; apple_pos;vector&lt;dir_t&gt; snake_dir;void input(){\tcin &gt;&gt; N;\tcin &gt;&gt; K; // 뱀 시작정보 arrmap[1][1] = 1; snake_len = 1; \tfor(int i = 0; i &lt; K; i++){\t\tint y, x;\t\tcin &gt;&gt; y &gt;&gt; x;\t\tapple_pos.push_back({y, x}); arrmap[y][x] = APPLE;\t}\tcin &gt;&gt; L;\tfor(int = 0; i &lt; L; i++){\t\tint x;\t\tchar c;\t\tcin &gt;&gt; x &gt;&gt; c;\t\tsnake_dir({x, c});\t}}void simulate(){ // 먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다. // 만약 벽이나 자기자신의 몸과 부딪히면 게임이 끝난다. // 만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다. // 만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.}int main(){\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tinput();\tcout &lt;&lt; answer &lt;&lt; \"\\n\";\t\treturn 0;}" }, { "title": "컨테이너 벨트 위의 로봇", "url": "/posts/%EC%BB%A8%EB%B2%A0%EC%9D%B4%EC%96%B4-%EB%B2%A8%ED%8A%B8-%EC%9C%84%EC%9D%98-%EB%A1%9C%EB%B4%87/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-23 00:00:00 +0900", "snippet": "https://www.acmicpc.net/problem/20055문제길이가 N인 컨베이어 벨트가 있고, 길이가 2N인 벨트가 이 컨베이어 벨트를 위아래로 감싸며 돌고 있다. 벨트는 길이 1 간격으로 2N개의 칸으로 나뉘어져 있으며, 각 칸에는 아래 그림과 같이 1부터 2N까지의 번호가 매겨져 있다.벨트가 한 칸 회전하면 1번부터 2N-1번까지의 칸은 다음 번호의 칸이 있는 위치로 이동하고, 2N번 칸은 1번 칸의 위치로 이동한다. i번 칸의 내구도는 Ai이다. 위의 그림에서 1번 칸이 있는 위치를 “올리는 위치”, N번 칸이 있는 위치를 “내리는 위치”라고 한다.컨베이어 벨트에 박스 모양 로봇을 하나씩 올리려고 한다. 로봇은 올리는 위치에만 올릴 수 있다. 언제든지 로봇이 내리는 위치에 도달하면 그 즉시 내린다. 로봇은 컨베이어 벨트 위에서 스스로 이동할 수 있다. 로봇을 올리는 위치에 올리거나 로봇이 어떤 칸으로 이동하면 그 칸의 내구도는 즉시 1만큼 감소한다.컨베이어 벨트를 이용해 로봇들을 건너편으로 옮기려고 한다. 로봇을 옮기는 과정에서는 아래와 같은 일이 순서대로 일어난다.벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다.가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다. 만약 이동할 수 없다면 가만히 있는다.로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다.올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다.내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다. 그렇지 않다면 1번으로 돌아간다.종료되었을 때 몇 번째 단계가 진행 중이었는지 구해보자. 가장 처음 수행되는 단계는 1번째 단계이다.입력첫째 줄에 N, K가 주어진다. 둘째 줄에는 A1, A2, …, A2N이 주어진다.출력몇 번째 단계가 진행 중일때 종료되었는지 출력한다.풀이#include &lt;iostream&gt;using namespace std;#define ARR_MAX_LEN 220int arr[220] = { 0 };int robot[220] = { 0 };int N, K, answer = 0;void simulate(){\twhile (true){\t\tint temp;\t\tanswer++;\t\t//1. 벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다.\t\ttemp = arr[2 * N];\t\tfor (int i = 2 * N; i &gt; 1; i--) {\t\t\tarr[i] = arr[i - 1];\t\t\tif (i &lt;= N)\t\t\t\trobot[i] = robot[i - 1];\t\t}\t\tarr[1] = temp;\t\t// 컨베이어벨트와 함께 로봇도 시계방향 한칸 움직이므로 [1] index 는 항상 0\t\trobot[1] = 0;\t\t// 내리는 위치에서 항상 하차\t\trobot[N] = 0;\t\t//2. 가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 한 칸 이동할 수 있다면 이동한다.만약 이동할 수 없다면 가만히 있는다.\t\t// 로봇이 이동하기 위해서는 이동하려는 칸에 로봇이 없으며, 그 칸의 내구도가 1 이상 남아 있어야 한다.\t\tfor (int i = N; i &gt; 1; i--) {\t\t\tif (robot[i] == 0 &amp;&amp; robot[i - 1] == 1 &amp;&amp; arr[i] &gt;= 1) {\t\t\t\trobot[i] = 1;\t\t\t\trobot[i - 1] = 0;\t\t\t\tarr[i]--;\t\t\t}\t\t\t\t\t\t} // 내리는 위치에서 하차\t\trobot[N] = 0;\t\t//3. 올리는 위치에 있는 칸의 내구도가 0이 아니면 올리는 위치에 로봇을 올린다.\t\tif (arr[1] != 0) {\t\t\trobot[1] = 1;\t\t\tarr[1]--;\t\t}\t\t\t\t\t//4. 내구도가 0인 칸의 개수가 K개 이상이라면 과정을 종료한다.그렇지 않다면 1번으로 돌아간다.\t\tint zero_cnt = 0;\t\tfor (int i = 1; i &lt;= 2 * N; i++) {\t\t\tif (arr[i] == 0)\t\t\t\tzero_cnt++;\t\t}\t\tif (zero_cnt &gt;= K)\t\t\tbreak;\t}}int main() {\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\t\tcin &gt;&gt; N &gt;&gt; K;\tfor (int i = 1; i &lt;= 2 * N; i++) {\t\tcin &gt;&gt; arr[i];\t}\tsimulate();\tcout &lt;&lt; answer &lt;&lt; \"\\n\";\treturn 0;}" }, { "title": "경사로", "url": "/posts/%EA%B2%BD%EC%82%AC%EB%A1%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-19 00:00:00 +0900", "snippet": "https://www.acmicpc.net/problem/14890문제크기가 N×N인 지도가 있다. 지도의 각 칸에는 그 곳의 높이가 적혀져 있다.오늘은 이 지도에서 지나갈 수 있는 길이 몇 개 있는지 알아보려고 한다. 길이란 한 행 또는 한 열 전부를 나타내며, 한쪽 끝에서 다른쪽 끝까지 지나가는 것이다.다음과 같은 N=6인 경우 지도를 살펴보자.이때, 길은 총 2N개가 있으며, 아래와 같다.길을 지나갈 수 있으려면 길에 속한 모든 칸의 높이가 모두 같아야 한다. 또는, 경사로를 놓아서 지나갈 수 있는 길을 만들 수 있다. 경사로는 높이가 항상 1이며, 길이는 L이다. 또, 개수는 매우 많아 부족할 일이 없다. 경사로는 낮은 칸과 높은 칸을 연결하며, 아래와 같은 조건을 만족해야한다.경사로는 낮은 칸에 놓으며, L개의 연속된 칸에 경사로의 바닥이 모두 접해야 한다.낮은 칸과 높은 칸의 높이 차이는 1이어야 한다.경사로를 놓을 낮은 칸의 높이는 모두 같아야 하고, L개의 칸이 연속되어 있어야 한다.아래와 같은 경우에는 경사로를 놓을 수 없다.경사로를 놓은 곳에 또 경사로를 놓는 경우낮은 칸과 높은 칸의 높이 차이가 1이 아닌 경우낮은 지점의 칸의 높이가 모두 같지 않거나, L개가 연속되지 않은 경우경사로를 놓다가 범위를 벗어나는 경우L = 2인 경우에 경사로를 놓을 수 있는 경우를 그림으로 나타내면 아래와 같다.경사로를 놓을 수 없는 경우는 아래와 같다.위의 그림의 가장 왼쪽부터 1번, 2번, 3번, 4번 예제라고 했을 때, 1번은 높이 차이가 1이 아니라서, 2번은 경사로를 바닥과 접하게 놓지 않아서, 3번은 겹쳐서 놓아서, 4번은 기울이게 놓아서 불가능한 경우이다.가장 위에 주어진 그림 예의 경우에 지나갈 수 있는 길은 파란색으로, 지나갈 수 없는 길은 빨간색으로 표시되어 있으며, 아래와 같다. 경사로의 길이 L = 2이다.지도가 주어졌을 때, 지나갈 수 있는 길의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N (2 ≤ N ≤ 100)과 L (1 ≤ L ≤ N)이 주어진다. 둘째 줄부터 N개의 줄에 지도가 주어진다. 각 칸의 높이는 10보다 작거나 같은 자연수이다.출력첫째 줄에 지나갈 수 있는 길의 개수를 출력한다.풀이#include &lt;iostream&gt;#define ARR_MAX_LEN 110using namespace std;int N, L, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int temp_arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };void input(){ cin &gt;&gt; N &gt;&gt; L; for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ cin &gt;&gt; arrmap[i][j]; } }}//void calcuate_answer(){ // 행 카운트 for(int i = 0; i &lt; N; i++){ bool flag = true; int fnum = arrmap[i][0]; for(int j = 1; j &lt; N; j++){ if(arrmap[i][j] != fnum) flag = false; } if(flag) answer++; } // 열 카운트 for(int i = 0; i &lt; N; i++){ bool flag = true; int fnum = arrmap[0][i]; for(int j = 1; j &lt; N; j++){ if(arrmap[j][i] != fnum) flag = false; } if(flag) answer++; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); calculate_answer(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "나무 재테크", "url": "/posts/%EB%82%98%EB%AC%B4-%EC%9E%AC%ED%85%8C%ED%81%AC/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-17 00:00:00 +0900", "snippet": "나무 재테크문제부동산 투자로 억대의 돈을 번 상도는 최근 N×N 크기의 땅을 구매했다. 상도는 손쉬운 땅 관리를 위해 땅을 1×1 크기의 칸으로 나누어 놓았다. 각각의 칸은 (r, c)로 나타내며, r은 가장 위에서부터 떨어진 칸의 개수, c는 가장 왼쪽으로부터 떨어진 칸의 개수이다. r과 c는 1부터 시작한다.상도는 전자통신공학과 출신답게 땅의 양분을 조사하는 로봇 S2D2를 만들었다. S2D2는 1×1 크기의 칸에 들어있는 양분을 조사해 상도에게 전송하고, 모든 칸에 대해서 조사를 한다. 가장 처음에 양분은 모든 칸에 5만큼 들어있다.매일 매일 넓은 땅을 보면서 뿌듯한 하루를 보내고 있던 어느 날 이런 생각이 들었다.나무 재테크를 하자!나무 재테크란 작은 묘목을 구매해 어느정도 키운 후 팔아서 수익을 얻는 재테크이다. 상도는 나무 재테크로 더 큰 돈을 벌기 위해 M개의 나무를 구매해 땅에 심었다. 같은 1×1 크기의 칸에 여러 개의 나무가 심어져 있을 수도 있다.이 나무는 사계절을 보내며, 아래와 같은 과정을 반복한다.봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다. 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다. 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다. 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.여름에는 봄에 죽은 나무가 양분으로 변하게 된다. 각각의 죽은 나무마다 나이를 2로 나눈 값이 나무가 있던 칸에 양분으로 추가된다. 소수점 아래는 버린다.가을에는 나무가 번식한다. 번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다. 어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1), (r+1, c), (r+1, c+1) 이다. 상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다.겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다. 각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다.K년이 지난 후 상도의 땅에 살아있는 나무의 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N, M, K가 주어진다.둘째 줄부터 N개의 줄에 A배열의 값이 주어진다. r번째 줄의 c번째 값은 A[r][c]이다.다음 M개의 줄에는 상도가 심은 나무의 정보를 나타내는 세 정수 x, y, z가 주어진다. 처음 두 개의 정수는 나무의 위치 (x, y)를 의미하고, 마지막 정수는 그 나무의 나이를 의미한다.출력첫째 줄에 K년이 지난 후 살아남은 나무의 수를 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 15using namespace std;int N, M, K, answer = 0;vector&lt;int&gt; arrmap[ARR_MAX_LEN][ARR_MAX_LEN];// 양분 지도int energymap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// 겨울에 추가되는 양분의 양int add_energymap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// 8방향 (시계 방향): 상, 우상, 우, 우하, 하, 좌하, 좌, 좌상int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };void input() { cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= N; j++) { cin &gt;&gt; add_energymap[i][j]; energymap[i][j] = 5; } }}void simulate() { // 봄 + 여름 for (int y = 1; y &lt;= N; y++) { for (int x = 1; x &lt;= N; x++) { // 해당 칸에 나무가 없을 경우 skip if (arrmap[y][x].empty()) continue; // 죽은 나무의 양분정보 업데이트 int die_tree_energy = 0; // 살아남은 나무 정보 업데이트 vector&lt;int&gt; survived; sort(arrmap[y][x].begin(), arrmap[y][x].end()); for (int k = 0; k &lt; arrmap[y][x].size(); k++) { int age = arrmap[y][x][k]; if (energymap[y][x] &gt;= age) { energymap[y][x] -= age; survived.push_back(age + 1); } else { die_tree_energy += (age / 2); } } arrmap[y][x].clear(); for (int k = 0; k &lt; survived.size(); k++) { arrmap[y][x].push_back(survived[k]); } energymap[y][x] += die_tree_energy; } } // 가을: 번식 for (int y = 1; y &lt;= N; y++) { for (int x = 1; x &lt;= N; x++) { if (arrmap[y][x].empty()) continue; for (int k = 0; k &lt; (int)arrmap[y][x].size(); k++) { if (arrmap[y][x][k] % 5 == 0) { for (int dir = 0; dir &lt; 8; dir++) { int ny = y + dy[dir]; int nx = x + dx[dir]; if (ny &gt;= 1 &amp;&amp; ny &lt;= N &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= N) { arrmap[ny][nx].push_back(1); } } } } } } // 겨울 for (int y = 1; y &lt;= N; y++) { for (int x = 1; x &lt;= N; x++) { energymap[y][x] += add_energymap[y][x]; } }}void calculate_answer() { answer = 0; for (int y = 1; y &lt;= N; y++) { for (int x = 1; x &lt;= N; x++) { answer += (int)arrmap[y][x].size(); } }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); for (int i = 0; i &lt; M; i++) { int r, c, z; cin &gt;&gt; r &gt;&gt; c &gt;&gt; z; arrmap[r][c].push_back(z); } for (int year = 0; year &lt; K; year++) { simulate(); } calculate_answer(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "톱니 바퀴", "url": "/posts/%ED%86%B1%EB%8B%88-%EB%B0%94%ED%80%B4/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-15 00:00:00 +0900", "snippet": "톱니 바퀴문제총 8개의 톱니를 가지고 있는 톱니바퀴 4개가 아래 그림과 같이 일렬로 놓여져 있다. 또, 톱니는 N극 또는 S극 중 하나를 나타내고 있다. 톱니바퀴에는 번호가 매겨져 있는데, 가장 왼쪽 톱니바퀴가 1번, 그 오른쪽은 2번, 그 오른쪽은 3번, 가장 오른쪽 톱니바퀴는 4번이다.이때, 톱니바퀴를 총 K번 회전시키려고 한다. 톱니바퀴의 회전은 한 칸을 기준으로 한다. 회전은 시계 방향과 반시계 방향이 있고, 아래 그림과 같이 회전한다.톱니바퀴를 회전시키려면, 회전시킬 톱니바퀴와 회전시킬 방향을 결정해야 한다. 톱니바퀴가 회전할 때, 서로 맞닿은 극에 따라서 옆에 있는 톱니바퀴를 회전시킬 수도 있고, 회전시키지 않을 수도 있다. 톱니바퀴 A를 회전할 때, 그 옆에 있는 톱니바퀴 B와 서로 맞닿은 톱니의 극이 다르다면, B는 A가 회전한 방향과 반대방향으로 회전하게 된다. 예를 들어, 아래와 같은 경우를 살펴보자.두 톱니바퀴의 맞닿은 부분은 초록색 점선으로 묶여있는 부분이다. 여기서, 3번 톱니바퀴를 반시계 방향으로 회전했다면, 4번 톱니바퀴는 시계 방향으로 회전하게 된다. 2번 톱니바퀴는 맞닿은 부분이 S극으로 서로 같기 때문에, 회전하지 않게 되고, 1번 톱니바퀴는 2번이 회전하지 않았기 때문에, 회전하지 않게 된다. 따라서, 아래 그림과 같은 모양을 만들게 된다.위와 같은 상태에서 1번 톱니바퀴를 시계 방향으로 회전시키면, 2번 톱니바퀴가 반시계 방향으로 회전하게 되고, 2번이 회전하기 때문에, 3번도 동시에 시계 방향으로 회전하게 된다. 4번은 3번이 회전하지만, 맞닿은 극이 같기 때문에 회전하지 않는다. 따라서, 아래와 같은 상태가 된다.톱니바퀴의 초기 상태와 톱니바퀴를 회전시킨 방법이 주어졌을 때, 최종 톱니바퀴의 상태를 구하는 프로그램을 작성하시오.입력첫째 줄에 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다. 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다.다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다. 다음 K개 줄에는 회전시킨 방법이 순서대로 주어진다. 각 방법은 두 개의 정수로 이루어져 있고, 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다. 방향이 1인 경우는 시계 방향이고, -1인 경우는 반시계 방향이다.출력총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다.1번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 1점2번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 2점3번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 4점4번 톱니바퀴의 12시방향이 N극이면 0점, S극이면 8점풀이#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int K, answer = 0;int arrmap[5][8] = { 0 };string str;typedef struct { int n; int d;} wheel_info_t;void input() { for (int i = 1; i &lt;= 4; i++) { cin &gt;&gt; str; // N극은 0, S극은 1 for (int j = 0; j &lt; (int)str.size(); j++) { arrmap[i][j] = str[j] - '0'; } }}void rotate_clockwise(int col) { int temp = arrmap[col][7]; for (int i = 7; i &gt; 0; i--) { arrmap[col][i] = arrmap[col][i - 1]; } arrmap[col][0] = temp;}void rotate_counterclockwise(int col) { int temp = arrmap[col][0]; for (int i = 0; i &lt; 7; i++) { arrmap[col][i] = arrmap[col][i + 1]; } arrmap[col][7] = temp;}// 회전 전 상태로 전파 방향을 모두 결정한 뒤 일괄 회전void simulate(int num, int dir) { int rot[5] = { 0 }; rot[num] = dir; // 오른쪽으로 전파 (현재 상태 기준 비교) for (int i = num; i &lt; 4; i++) { // 극성이 다르면 회전 정보 업데이트 if (arrmap[i][2] != arrmap[i + 1][6]) { rot[i + 1] = -1 * rot[i]; } else { break; } } // 왼쪽으로 전파 (현재 상태 기준 비교) for (int i = num; i &gt; 1; i--) { // 극성이 다르면 회전 정보 업데이트 if (arrmap[i][6] != arrmap[i - 1][2]) { rot[i - 1] = -1 * rot[i]; } else { break; } } // 결정된 방향대로 일괄 회전 for (int i = 1; i &lt;= 4; i++) { if (rot[i] == 1) { rotate_clockwise(i); } else if (rot[i] == -1) { rotate_counterclockwise(i); } }}void calculate_score() { int mul = 1; for (int i = 1; i &lt;= 4; i++) { answer += (arrmap[i][0] * mul); mul *= 2; }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); cin &gt;&gt; K; for (int i = 0; i &lt; K; i++) { int cogwheel_num, dir; // 방향이 1인 경우는 시계 방향, -1인 경우는 반시계 방향 cin &gt;&gt; cogwheel_num &gt;&gt; dir; simulate(cogwheel_num, dir); } calculate_score(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "주사위 굴리기2", "url": "/posts/%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B5%B4%EB%A6%AC%EA%B8%B02/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-15 00:00:00 +0900", "snippet": "주사위 굴리기2문제크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. 가장 왼쪽 위에 있는 칸의 좌표는 (1, 1)이고, 가장 오른쪽 아래에 있는 칸의 좌표는 (N, M)이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 각 면에는 1보다 크거나 같고, 6보다 작거나 같은 정수가 하나씩 있다. 주사위 한 면의 크기와 지도 한 칸의 크기는 같고, 주사위의 전개도는 아래와 같다. 24 1 3 5 6주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (1, 1) 이다. 지도의 각 칸에도 정수가 하나씩 있다. 가장 처음에 주사위의 이동 방향은 동쪽이다. 주사위의 이동 한 번은 다음과 같은 방식으로 이루어진다.주사위가 이동 방향으로 한 칸 굴러간다. 만약, 이동 방향에 칸이 없다면, 이동 방향을 반대로 한 다음 한 칸 굴러간다.주사위가 도착한 칸 (x, y)에 대한 점수를 획득한다.주사위의 아랫면에 있는 정수 A와 주사위가 있는 칸 (x, y)에 있는 정수 B를 비교해 이동 방향을 결정한다. A &gt; B인 경우 이동 방향을 90도 시계 방향으로 회전시킨다. A &lt; B인 경우 이동 방향을 90도 반시계 방향으로 회전시킨다. A = B인 경우 이동 방향에 변화는 없다.칸 (x, y)에 대한 점수는 다음과 같이 구할 수 있다. (x, y)에 있는 정수를 B라고 했을때, (x, y)에서 동서남북 방향으로 연속해서 이동할 수 있는 칸의 수 C를 모두 구한다. 이때 이동할 수 있는 칸에는 모두 정수 B가 있어야 한다. 여기서 점수는 B와 C를 곱한 값이다.보드의 크기와 각 칸에 있는 정수, 주사위의 이동 횟수 K가 주어졌을때, 각 이동에서 획득하는 점수의 합을 구해보자.이 문제의 예제 1부터 7은 같은 지도에서 이동하는 횟수만 증가시키는 방식으로 구성되어 있다. 예제 8은 같은 지도에서 이동하는 횟수를 매우 크게 만들었다.입력첫째 줄에 지도의 세로 크기 N, 가로 크기 M (2 ≤ N, M ≤ 20), 그리고 이동하는 횟수 K (1 ≤ K ≤ 1,000)가 주어진다.둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 지도의 각 칸에 쓰여 있는 수는 10 미만의 자연수이다.출력첫째 줄에 각 이동에서 획득하는 점수의 합을 출력한다.풀이#include &lt;iostream&gt;#include &lt;queue&gt;#define ARR_MAX_LEN 25using namespace std;int N, M, K, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int dy[4] = { 0, 1, 0, -1 };int dx[4] = { 1, 0, -1, 0 };typedef struct{ int top; int bottom; int east; int west; int north; int south;}dice_t;typedef struct{ int y; int x;}cord_t;void input(){ cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ cin &gt;&gt; arrmap[i][j]; } }}int bfs(int y, int x, int v){ queue&lt;cord_t&gt; q; bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; int ret = 0; q.push({y, x}); isvisited[y][x] = true; while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; q.pop(); ret++; for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= N &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= M){ if(!isvisited[ny][nx] &amp;&amp; arrmap[ny][nx] == v){ q.push({ny, nx}); isvisited[ny][nx] = true; } } } } return ret;}void simulate(){ dice_t dice = { 1, 6, 3, 4, 2, 5 }; int dir = 0, cy = 1, cx = 1; for(int i = 0; i &lt; K; i++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; M){ dir = (dir + 2) % 4; ny = cy + dy[dir]; nx = cx + dx[dir]; } int move_dir = dir; // 이번 턴 이동·굴림 방향 고정 cy = ny; cx = nx; int temp; switch(move_dir){ case 0: // 동 temp = dice.west; dice.west = dice.bottom; dice.bottom = dice.east; dice.east = dice.top; dice.top = temp; break; case 1: // 남 temp = dice.north; dice.north = dice.bottom; dice.bottom = dice.south; dice.south = dice.top; dice.top = temp; break; case 2: // 서 temp = dice.east; dice.east = dice.bottom; dice.bottom = dice.west; dice.west = dice.top; dice.top = temp; break; case 3: // 북 ← 누락됐던 부분 temp = dice.south; dice.south = dice.bottom; dice.bottom = dice.north; dice.north = dice.top; dice.top = temp; break; } int B = arrmap[cy][cx]; int C = bfs(cy, cx, B); answer += B * C; int A = dice.bottom; if(A &gt; B) dir = (dir + 1) % 4; // 시계 90도 else if(A &lt; B) dir = (dir + 3) % 4; // 반시계 90도 // 같으면 유지 }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); simulate(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "드래곤 커브", "url": "/posts/%EB%93%9C%EB%9E%98%EA%B3%A4-%EC%BB%A4%EB%B8%8C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-10 00:00:00 +0900", "snippet": "드래곤 커브문제드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은 → 방향, y축은 ↓ 방향이다. 시작 점 시작 방향 세대0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 시작 방향은 오른쪽인 0세대 드래곤 커브이다.1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.2세대 드래곤 커브도 1세대를 만든 방법을 이용해서 만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다)3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다.즉, K(K &gt; 1)세대 드래곤 커브는 K-1세대 드래곤 커브를 끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에 붙인 것이다.크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.입력첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다. 드래곤 커브의 정보는 네 정수 x, y, d, g로 이루어져 있다. x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다. 0: x좌표가 증가하는 방향 (→) 1: y좌표가 감소하는 방향 (↑) 2: x좌표가 감소하는 방향 (←) 3: y좌표가 증가하는 방향 (↓)출력첫째 줄에 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 것의 개수를 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#define ARR_MAX_LEN 100using namespace std;int N;int x, y, d, g, answer = 0; // 시작점, 시작 방향, 세대 int arr[101][101] = { 0 };int dx[4] = {1, 0, -1, 0};int dy[4] = {0, -1, 0, 1};typedef struct{ int x; int y;}cord_t;// 0세대 : 0// 1세대 : 0, 1// 2세대 : 0, 1, 2, 1// 3세대 : 0, 1, 2, 1, 2, 3, 2, 1// 규칙 : 뒤집어서 + 1void make_curve(int x, int y, int dir, int gen){ vector&lt;int&gt; dir_lst; vector&lt;cord_t&gt; cur_cord; dir_lst.push_back(dir); cur_cord.push_back({x + dx[dir], y + dy[dir]}); // 0세대 arr[x][y] = 1; // 0세대 드래곤 커브 업데이트 arr[cur_cord[0].x][cur_cord[0].y] = 1; // 0세대부터 시작하는 것 같지만 보면 1세대부터 시작하는 것을 알 수 있다 for(int i = 0; i &lt; gen ; i++){ int lst_size = dir_lst.size(); for(int j = lst_size - 1; j &gt;= 0; j--){ // 다음 세대의 방향을 업데이트하고 좌표값에도 업데이트를 수행 int ndir = (dir_lst[j] + 1) % 4; dir_lst.push_back(ndir); cur_cord[0].x = (cur_cord[0].x + dx[ndir]); cur_cord[0].y = (cur_cord[0].y + dy[ndir]); if(cur_cord[0].x &gt;= 0 &amp;&amp; cur_cord[0].x &lt;= ARR_MAX_LEN &amp;&amp; cur_cord[0].y &gt;= 0 &amp;&amp; cur_cord[0].y &lt;= ARR_MAX_LEN) arr[cur_cord[0].x][cur_cord[0].y] = 1; } }}void count_rectangular(){ // 정사각형이 있을 경우 정답 count for(int i = 0; i &lt; ARR_MAX_LEN; i++){ for(int j = 0 ; j &lt; ARR_MAX_LEN; j++){ if(arr[i][j] == 1 &amp;&amp; arr[i][j + 1] == 1 &amp;&amp; arr[i + 1][j] == 1 &amp;&amp; arr[i + 1][j + 1] == 1) answer++; } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; x &gt;&gt; y &gt;&gt; d &gt;&gt; g; make_curve(x, y, d, g); } count_rectangular(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "연구소 3", "url": "/posts/%EC%97%B0%EA%B5%AC%EC%86%8C-3/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-08 00:00:00 +0900", "snippet": "연구소 3문제인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 바이러스는 활성 상태와 비활성 상태가 있다. 가장 처음에 모든 바이러스는 비활성 상태이고, 활성 상태인 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다. 승원이는 연구소의 바이러스 M개를 활성 상태로 변경하려고 한다.연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽, 바이러스로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다. 활성 바이러스가 비활성 바이러스가 있는 칸으로 가면 비활성 바이러스가 활성으로 변한다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스의 위치이다.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2M = 3이고, 바이러스를 아래와 같이 활성 상태로 변경한 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 비활성 바이러스는 *, 활성 바이러스는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.* 6 5 4 - - 25 6 - 3 - 0 14 - - 2 - 1 23 - 2 1 2 2 32 2 1 0 1 - -1 - 2 1 2 3 40 - 3 2 3 4 *시간이 최소가 되는 방법은 아래와 같고, 4초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.0 1 2 3 - - 21 2 - 3 - 0 12 - - 2 - 1 23 - 2 1 2 2 33 2 1 0 1 - -4 - 2 1 2 3 4* - 3 2 3 4 *연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.입력첫째 줄에 연구소의 크기 N(4 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 비활성 바이러스의 위치이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.출력연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 55#define MAX_TIME 1000000000using namespace std;int N, M, answer = MAX_TIME;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; // 0/1 저장. 2(바이러스)는 따로 저장 후 0으로 바꿔서 저장int temp_arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; // 0(빈),1(벽),2(활성),3(비활성)bool empty_mask[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; // **원본 입력 기준** 빈칸(0) 표시int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{ int y; int x;} cord_t;vector&lt;cord_t&gt; all_virus_pos;vector&lt;cord_t&gt; cur_virus_pos;int empty_place = 0;void input(){ cin &gt;&gt; N &gt;&gt; M; for( int i = 0; i &lt; N; i++ ){ for( int j = 0; j &lt; N; j++ ){ int val; cin &gt;&gt; val; if(val == 0){ empty_mask[i][j] = true; // **원본 빈칸 마스크** empty_place++; // **원본 빈칸 수** } else { empty_mask[i][j] = false; } if(val == 2){ all_virus_pos.push_back( { i, j } ); val = 0; // 내부 지도에는 빈칸(0)으로 저장 } arrmap[i][j] = val; // 0 또는 1 이 최종적으로 저장됨 } }}void bfs(){ queue&lt;cord_t&gt; q; int time_map[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; int infect_place = 0; // 시작 활성 바이러스 삽입 for( int i = 0; i &lt; N; i++ ){ for( int j = 0; j &lt; N; j++ ){ if( temp_arrmap[i][j] == 2 ){ q.push({ i, j }); } } } while( !q.empty() ){ int cy = q.front().y; int cx = q.front().x; q.pop(); for( int dir = 0; dir &lt; 4; dir++ ){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N){ if(temp_arrmap[ny][nx] == 0 || temp_arrmap[ny][nx] == 3){ int prev = temp_arrmap[ny][nx]; // 0(빈칸) 또는 3(비활성 바이러스) temp_arrmap[ny][nx] = 2; // 방문/감염 처리 // **핵심 규칙: 0이든 3이든 전파에는 1초 걸린다** time_map[ny][nx] = time_map[cy][cx] + 1; if(prev == 0){ infect_place++; // 빈칸 감염 수만 카운트 } q.push({ny, nx}); } } } } // 모든 **원본 빈칸**을 감염시킨 경우만 정답 후보 갱신 if(infect_place == empty_place){ int max_time = 0; // 원본 빈칸(empty_mask==true) 만 대상으로 최대 시간 계산 for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ if( empty_mask[i][j] ){ max_time = max( max_time, time_map[i][j] ); } } } // 최종 정답 업데이트, 모든 빈 칸에 바이러스를 퍼트리는 최소 시간 answer = min(answer, max_time); }}void comb(int idx, int cnt){ if(cnt == M){ // 기본 지도 복사 memcpy(temp_arrmap, arrmap, sizeof(arrmap)); // 모든 바이러스 위치를 비활성(3)으로 설정 for(auto &amp;v : all_virus_pos){ temp_arrmap[v.y][v.x] = 3; } // 선택된 M개의 바이러스만 활성(2)로 설정 for(auto &amp;v : cur_virus_pos){ temp_arrmap[v.y][v.x] = 2; } bfs(); return; } for( int i = idx; i &lt; all_virus_pos.size(); i++ ){ cur_virus_pos.push_back( all_virus_pos[i] ); comb( i + 1, cnt + 1 ); cur_virus_pos.pop_back(); }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); // 빈칸이 아예 없으면 0이 정답이다. if(empty_place == 0){ cout &lt;&lt; 0 &lt;&lt; \"\\n\"; return 0; } comb(0, 0); if(answer == MAX_TIME) cout &lt;&lt; -1 &lt;&lt; \"\\n\"; else cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "조합 순열 개념 정리", "url": "/posts/%EC%A1%B0%ED%95%A9-%EC%88%9C%EC%97%B4-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-06 00:00:00 +0900", "snippet": "조합 DFS 구현 및 재귀 호출 흐름개요조합(combination)을 생성하기 위해 DFS(Depth First Search) 방식을 사용한 C++ 코드 예제와, 이 코드의 재귀 호출 흐름을 ASCII 다이어그램으로 정리했다.C++ 코드 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int N, M; // 전체 원소 개수(N)와 선택할 개수(M) vector&lt;int&gt; arr; // 원소를 담은 배열 vector&lt;int&gt; pick; // 현재 선택된 원소를 담는 배열 vector&lt;vector&lt;int&gt;&gt; result; // 완성된 조합을 저장하는 배열 // start: 다음에 선택할 인덱스, depth: 현재까지 선택한 개수 void combinationDFS(int start, int depth) { if (depth == M) { result.push_back(pick); return; } for (int i = start; i &lt; N; ++i) { pick.push_back(arr[i]); combinationDFS(i + 1, depth + 1); pick.pop_back(); } } int main() { // 예시 입력 N = 5; M = 3; arr = {1, 2, 3, 4, 5}; combinationDFS(0, 0); // 결과 출력 cout &lt;&lt; \"조합 결과:\\n\"; for (const auto&amp; comb : result) { for (int x : comb) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\\n'; } return 0; } using namespace std; 지시문을 사용하여 std:: 생략. vector 컨테이너 사용.재귀 호출 흐름아래 다이어그램은 N=5, M=3, arr={1,2,3,4,5}일 때 combinationDFS(0,0)에서 시작하여 완전 탐색하는 과정을 간략화한 것이다. combinationDFS(0,0) ├─ pick 1 → combinationDFS(1,1) │ ├─ pick 2 → combinationDFS(2,2) │ │ ├─ pick 3 → combinationDFS(3,3) → 저장 [1,2,3] │ │ ├─ pick 4 → combinationDFS(4,3) → 저장 [1,2,4] │ │ └─ pick 5 → combinationDFS(5,3) → 저장 [1,2,5] │ ├─ pick 3 → combinationDFS(3,2) │ │ ├─ pick 4 → … → 저장 [1,3,4] │ │ └─ pick 5 → … → 저장 [1,3,5] │ ├─ pick 4 → … → [1,4,5] │ └─ pick 5 → … → (불가능, 남은 원소 부족) ├─ pick 2 → combinationDFS(2,1) │ ├─ pick 3 → … → [2,3,4], [2,3,5], [2,4,5] │ └─ … ├─ pick 3 → combinationDFS(3,1) │ └─ … └─ pick 4 → combinationDFS(4,1) └─ pick 5 → … → [4,5] 선택 불가 (M=3)위 구조에서 깊이(depth)가 M에 도달하면 pick 내용이 result에 저장된다.순열(DFS) 구현 및 재귀 호출 흐름개요이 문서에서는 DFS(Depth First Search) 기반 순열(permutation) 생성 방법과 재귀 호출 흐름을 정리했다. backtracking 기법을 사용해 중복 없이 모든 순열을 생성하는 방식이다.C++ 코드 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; int N; // 전체 원소 개수 vector&lt;int&gt; arr; // 원소 배열 vector&lt;bool&gt; used; // 사용 여부 체크 배열 vector&lt;int&gt; perm; // 현재 순열 vector&lt;vector&lt;int&gt;&gt; result; // 완성된 순열 결과 // depth: 현재까지 채워진 위치 void permutationDFS(int depth) { if (depth == N) { result.push_back(perm); return; } for (int i = 0; i &lt; N; ++i) { if (used[i]) continue; used[i] = true; perm.push_back(arr[i]); permutationDFS(depth + 1); perm.pop_back(); used[i] = false; } } int main() { N = 3; arr = {1, 2, 3}; used.assign(N, false); permutationDFS(0); cout &lt;&lt; \"순열 결과:\\n\"; for (auto &amp;p : result) { for (int x : p) cout &lt;&lt; x &lt;&lt; ' '; cout &lt;&lt; '\\n'; } return 0; }재귀 호출 흐름 예시 (N=3, arr={1,2,3}) permutationDFS(0) ├─ pick 1 → used[0]=true, perm={1} → permutationDFS(1) │ ├─ pick 2 → used[1]=true, perm={1,2} → permutationDFS(2) │ │ ├─ pick 3 → used[2]=true, perm={1,2,3} → permutationDFS(3) 저장 [1,2,3] │ │ └ backtrack(3) → used[2]=false, perm={1,2} │ └ backtrack(2) → used[1]=false, perm={1} ├─ pick 2 → used[1]=true, perm={2} → permutationDFS(1) │ ├─ pick 1 → used[0]=true, perm={2,1} → permutationDFS(2) 저장 [2,1,3] │ ├─ pick 3 → used[2]=true, perm={2,3} → permutationDFS(2) 저장 [2,3,1] │ └ backtrack → used[0]=false, used[2]=false, perm={2} └─ pick 3 → used[2]=true, perm={3} → permutationDFS(1) ├─ pick 1 → used[0]=true, perm={3,1} → permutationDFS(2) 저장 [3,1,2] ├─ pick 2 → used[1]=true, perm={3,2} → permutationDFS(2) 저장 [3,2,1] └ backtrack → used[0]=false, used[1]=false, perm={3}각 단계에서 아직 사용되지 않은 원소를 선택한 뒤 DFS로 다음 깊이를 탐색한다. 탐색이 끝나면 상태를 되돌리는 backtracking을 수행해 다른 분기를 탐색할 수 있도록 한다." }, { "title": "연구소 2", "url": "/posts/%EC%97%B0%EA%B5%AC%EC%86%8C-2/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-03 00:00:00 +0900", "snippet": "연구소 2문제인체에 치명적인 바이러스를 연구하던 연구소에 승원이가 침입했고, 바이러스를 유출하려고 한다. 승원이는 연구소의 특정 위치에 바이러스 M개를 놓을 것이고, 승원이의 신호와 동시에 바이러스는 퍼지게 된다.연구소는 크기가 N×N인 정사각형으로 나타낼 수 있으며, 정사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.일부 빈 칸은 바이러스를 놓을 수 있는 칸이다. 바이러스는 상하좌우로 인접한 모든 빈 칸으로 동시에 복제되며, 1초가 걸린다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 2 0 1 10 1 0 0 0 0 02 1 0 0 0 0 2M = 3이고, 바이러스를 아래와 같이 놓은 경우 6초면 모든 칸에 바이러스를 퍼뜨릴 수 있다. 벽은 -, 바이러스를 놓은 위치는 0, 빈 칸은 바이러스가 퍼지는 시간으로 표시했다.6 6 5 4 - - 25 6 - 3 - 0 14 - - 2 - 1 23 - 2 1 2 2 32 2 1 0 1 - -1 - 2 1 2 3 40 - 3 2 3 4 5시간이 최소가 되는 방법은 아래와 같고, 5초만에 모든 칸에 바이러스를 퍼뜨릴 수 있다.0 1 2 3 - - 21 2 - 3 - 0 12 - - 2 - 1 23 - 2 1 2 2 33 2 1 0 1 - -4 - 2 1 2 3 45 - 3 2 3 4 5연구소의 상태가 주어졌을 때, 모든 빈 칸에 바이러스를 퍼뜨리는 최소 시간을 구해보자.입력첫째 줄에 연구소의 크기 N(5 ≤ N ≤ 50), 놓을 수 있는 바이러스의 개수 M(1 ≤ M ≤ 10)이 주어진다.둘째 줄부터 N개의 줄에 연구소의 상태가 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스를 놓을 수 있는 칸이다. 2의 개수는 M보다 크거나 같고, 10보다 작거나 같은 자연수이다.출력연구소의 모든 빈 칸에 바이러스가 있게 되는 최소 시간을 출력한다. 바이러스를 어떻게 놓아도 모든 빈 칸에 바이러스를 퍼뜨릴 수 없는 경우에는 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#define ARR_MAX_LEN 55#define MAX_NUM 1e9using namespace std;typedef struct { int y; int x;} pos_t;int N, M;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }, board[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };vector&lt;pos_t&gt; virus_pos;vector&lt;pos_t&gt; cur_virus;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };int answer = MAX_NUM;void bfs() { queue&lt;pos_t&gt; q; int time_map[ARR_MAX_LEN][ARR_MAX_LEN] = { 0, }; // 바이러스 위치 queue 상에 업데이트 for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { if (board[i][j] == 2) { q.push({ i, j }); } } } while (!q.empty()) { int cy = q.front().y; int cx = q.front().x; q.pop(); for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N) { if (board[ny][nx] == 0) { q.push({ ny, nx }); time_map[ny][nx] = time_map[cy][cx] + 1; board[ny][nx] = 2; } } } } bool infect_all = true; // 모두 감염시켰는지 확인 for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { if (board[i][j] == 0) { infect_all = false; return; } } } // 모두 감염시켰다면 모두 감염시키는데 걸린 시간 확인 if (infect_all) { int max_time = 0; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { max_time = max(max_time, time_map[i][j]); } } // 정답 업데이트 answer = min(answer, max_time); }}void comb(int idx, int cnt) { if (cnt == M) { // 바이러스 놓는 위치 확인 memcpy(board, arrmap, sizeof(arrmap)); for (int i = 0; i &lt; cur_virus.size(); i++) { int cy = cur_virus[i].y; int cx = cur_virus[i].x; board[cy][cx] = 2; } bfs(); return; } for (int i = idx; i &lt; virus_pos.size(); i++) { int y = virus_pos[i].y; int x = virus_pos[i].x; cur_virus.push_back({ y, x }); comb(i + 1, cnt + 1); cur_virus.pop_back(); }}int main() { ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { cin &gt;&gt; arrmap[i][j]; // 실제 바이러스가 놓일 위치만 2로 표현하기 위해 virus 위치 정보만 vector 에 저장하고 0으로 변경 if (arrmap[i][j] == 2) { virus_pos.push_back({ i, j }); arrmap[i][j] = 0; } } } // virus 위치 조합을 구하고 bfs 돌리기 comb(0, 0); if (answer == MAX_NUM) cout &lt;&lt; \"-1\\n\"; else cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "이차원 배열과 연산", "url": "/posts/%EC%9D%B4%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4%EA%B3%BC-%EC%97%B0%EC%82%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-08-02 00:00:00 +0900", "snippet": "이차원 배열과 연산문제크기가 3×3인 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 1초가 지날때마다 배열에 연산이 적용된다. R 연산: 배열 A의 모든 행에 대해서 정렬을 수행한다. 행의 개수 ≥ 열의 개수인 경우에 적용된다. C 연산: 배열 A의 모든 열에 대해서 정렬을 수행한다. 행의 개수 &lt; 열의 개수인 경우에 적용된다.= 한 행 또는 열에 있는 수를 정렬하려면, 각각의 수가 몇 번 나왔는지 알아야 한다. 그 다음, 수의 등장 횟수가 커지는 순으로, 그러한 것이 여러가지면 수가 커지는 순으로 정렬한다. 그 다음에는 배열 A에 정렬된 결과를 다시 넣어야 한다. 정렬된 결과를 배열에 넣을 때는, 수와 등장 횟수를 모두 넣으며, 순서는 수가 먼저이다.예를 들어, [3, 1, 1]에는 3이 1번, 1가 2번 등장한다. 따라서, 정렬된 결과는 [3, 1, 1, 2]가 된다. 다시 이 배열에는 3이 1번, 1이 2번, 2가 1번 등장한다. 다시 정렬하면 [2, 1, 3, 1, 1, 2]가 된다.정렬된 결과를 배열에 다시 넣으면 행 또는 열의 크기가 달라질 수 있다. R 연산이 적용된 경우에는 가장 큰 행을 기준으로 모든 행의 크기가 변하고, C 연산이 적용된 경우에는 가장 큰 열을 기준으로 모든 열의 크기가 변한다.행 또는 열의 크기가 커진 곳에는 0이 채워진다. 수를 정렬할 때 0은 무시해야 한다. 예를 들어, [3, 2, 0, 0]을 정렬한 결과는 [3, 2]를 정렬한 결과와 같다.행 또는 열의 크기가 100을 넘어가는 경우에는 처음 100개를 제외한 나머지는 버린다.배열 A에 들어있는 수와 r, c, k가 주어졌을 때, A[r][c]에 들어있는 값이 k가 되기 위한 최소 시간을 구해보자.입력첫째 줄에 r, c, k가 주어진다. (1 ≤ r, c, k ≤ 100)둘째 줄부터 3개의 줄에 배열 A에 들어있는 수가 주어진다. 배열 A에 들어있는 수는 100보다 작거나 같은 자연수이다.출력A[r][c]에 들어있는 값이 k가 되기 위한 연산의 최소 시간을 출력한다. 100초가 지나도 A[r][c] = k가 되지 않으면 -1을 출력한다.풀이#include &lt;iostream&gt;#define ARR_MAX_LEN 110#define MAX_TIME 100using namespace std;int r, c, k, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };void input() {\tcin &gt;&gt; r &gt;&gt; c &gt;&gt; k;\tfor (int i = 0; i &lt; 3; i++) {\t\tfor (int j = 0; j &lt; 3; j++) {\t\t\tcin &gt;&gt; arrmap[i][j];\t\t}\t}}void simulate() {\tint time_cnt = 0;\twhile(answer &lt;= MAX_TIME) {\t\tif (arrmap[r][c] == k)\t\t\tbreak;\t\tanswer++;\t}\tif (answer &gt; MAX_TIME)\t\tcout &lt;&lt; \"-1\\n\";\telse\t\tcout &lt;&lt; answer &lt;&lt; \"\\n\";}int main() {\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\treturn 0;}" }, { "title": "미세먼지 안녕", "url": "/posts/%EB%AF%B8%EC%84%B8%EB%A8%BC%EC%A7%80-%EC%95%88%EB%85%95/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-07-19 00:00:00 +0900", "snippet": "미세먼지 안녕미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다.공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 Ar,c이다.1초 동안 아래 적힌 일이 순서대로 일어난다. 미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다. (r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다. 인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다. 확산되는 양은 Ar,c/5이고 소수점은 버린다. 즉, ⌊Ar,c/5⌋이다. (r, c)에 남은 미세먼지의 양은 Ar,c - ⌊Ar,c/5⌋×(확산된 방향의 개수) 이다. 공기청정기가 작동한다. 공기청정기에서는 바람이 나온다. 위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다. 바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다. 공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다. 다음은 확산의 예시이다.왼쪽과 위쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다.인접한 네 방향으로 모두 확산이 일어난다.공기청정기가 있는 칸으로는 확산이 일어나지 않는다.공기청정기의 바람은 다음과 같은 방향으로 순환한다.방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자.입력첫째 줄에 R, C, T (6 ≤ R, C ≤ 50, 1 ≤ T ≤ 1,000) 가 주어진다.둘째 줄부터 R개의 줄에 Ar,c (-1 ≤ Ar,c ≤ 1,000)가 주어진다. 공기청정기가 설치된 곳은 Ar,c가 -1이고, 나머지 값은 미세먼지의 양이다. -1은 2번 위아래로 붙어져 있고, 가장 윗 행, 아랫 행과 두 칸이상 떨어져 있다.출력첫째 줄에 T초가 지난 후 구사과 방에 남아있는 미세먼지의 양을 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#define ARR_NAX_LEN 55using namespace std;int R, C, T, answer = 0;int arrmap[ARR_NAX_LEN][ARR_NAX_LEN] = { 0 };// 반시계 방향 기준 우 하 좌 상int dy[4] = { 0, -1, 0, 1 };int dx[4] = { 1, 0, -1, 0 };typedef struct { int y; int x;}cord_t;vector &lt;cord_t&gt; aircond_cord;void input() { cin &gt;&gt; R &gt;&gt; C &gt;&gt; T; for (int i = 0; i &lt; R; i++) { for (int j = 0; j &lt; C; j++) { cin &gt;&gt; arrmap[i][j]; if (arrmap[i][j] == -1) { aircond_cord.push_back({ i, j }); } } }}void dust_scenario() { int temp_arrmap[ARR_NAX_LEN][ARR_NAX_LEN] = { 0 }; for (int i = 0; i &lt; R; i++) { for (int j = 0; j &lt; C; j++) { temp_arrmap[i][j] = arrmap[i][j]; } } for (int i = 0; i &lt; R; i++) { for (int j = 0; j &lt; C; j++) { if (arrmap[i][j] != 0) { int cy = i, cx = j; int spread_cnt = 0, spread_val = arrmap[cy][cx] / 5; for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir], nx = cx + dx[dir]; if (ny &gt;= 0 &amp;&amp; ny &lt; R &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; C &amp;&amp; arrmap[ny][nx] != -1) { temp_arrmap[ny][nx] += spread_val; spread_cnt++; } } temp_arrmap[cy][cx] -= (spread_val * spread_cnt); } } } for (int i = 0; i &lt; R; i++) { for (int j = 0; j &lt; C; j++) { arrmap[i][j] = temp_arrmap[i][j]; } }}void air_conditioner_scenario() { int up = aircond_cord[0].y; int down = aircond_cord[1].y; // 위쪽 반시계 방향 순환 for (int i = up - 1; i &gt; 0; i--) // 위로 arrmap[i][0] = arrmap[i - 1][0]; for (int i = 0; i &lt; C - 1; i++) // 왼쪽 → 오른쪽 arrmap[0][i] = arrmap[0][i + 1]; for (int i = 0; i &lt; up; i++) // 아래로 arrmap[i][C - 1] = arrmap[i + 1][C - 1]; for (int i = C - 1; i &gt; 1; i--) // 오른쪽 → 왼쪽 arrmap[up][i] = arrmap[up][i - 1]; arrmap[up][1] = 0; // 공기청정기 바로 오른쪽 칸은 항상 0 // 아래쪽 시계 방향 순환 for (int i = down + 1; i &lt; R - 1; i++) // 아래로 arrmap[i][0] = arrmap[i + 1][0]; for (int i = 0; i &lt; C - 1; i++) // 왼쪽 → 오른쪽 arrmap[R - 1][i] = arrmap[R - 1][i + 1]; for (int i = R - 1; i &gt; down; i--) // 위로 arrmap[i][C - 1] = arrmap[i - 1][C - 1]; for (int i = C - 1; i &gt; 1; i--) // 오른쪽 → 왼쪽 arrmap[down][i] = arrmap[down][i - 1]; arrmap[down][1] = 0; // 공기청정기 바로 오른쪽 칸은 항상 0}void simulate() { int time_cnt = 0; while (time_cnt &lt; T) { // 미세먼지 확장 시나리오 dust_scenario(); // 공기 청정기 동작 시나리오 air_conditioner_scenario(); time_cnt++; }}void print_answer() { for (int i = 0; i &lt; R; i++) { for (int j = 0; j &lt; C; j++) { if (arrmap[i][j] &gt; 0) answer += arrmap[i][j]; } } cout &lt;&lt; answer &lt;&lt; \"\\n\";}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input(); simulate(); print_answer(); return 0;}" }, { "title": "인구이동", "url": "/posts/%EC%9D%B8%EA%B5%AC%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-07-12 00:00:00 +0900", "snippet": "유닛 이동시키기문제N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.오늘부터 인구 이동이 시작되는 날이다.인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다. 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다. 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다. 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다. 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다. 연합을 해체하고, 모든 국경선을 닫는다.각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성하시오.입력첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)인구 이동이 발생하는 일수가 2,000번 보다 작거나 같은 입력만 주어진다.출력인구 이동이 며칠 동안 발생하는지 첫째 줄에 출력한다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 55using namespace std;int N, L, R, answer = 0;int arr[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct{ int y; int x;}loc_t;queue&lt;loc_t&gt; q;int bfs(int y, int x){ int cnt = 1, sum = arr[y][x], flag_cnt = 0; // 연합의 좌표를 저장하고 후에 연합의 값을 모두 평균값으로 저장하는데 사용 vector&lt;loc_t&gt; v; q.push({y, x}); isvisited[y][x] = true; v.push_back({y, x}); while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; q.pop(); for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &lt; 0 || nx &lt; 0 || ny &gt;= N || nx &gt;= N) continue; int pop_diff = abs(arr[cy][cx] - arr[ny][nx]); if(!isvisited[ny][nx] &amp;&amp; (pop_diff &gt;= L &amp;&amp; pop_diff &lt;= R)){ flag_cnt++; v.push_back({ny, nx}); cnt++; sum += arr[ny][nx]; isvisited[ny][nx] = true; q.push({ny, nx}); } } } // 인구이동 업데이트 int avg = sum / cnt; for(int i = 0; i &lt; v.size(); i++){ arr[v[i].y][v[i].x] = avg; } return flag_cnt;}int main(){ bool flag = true; // 1. 입력 시퀀스 cin &gt;&gt; N &gt;&gt; L &gt;&gt; R; for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ cin &gt;&gt; arr[i][j]; } } // 2. 인구이동 시뮬레이션 시퀀스 while(true){ int temp_cnt = 0; // 다시 초기화 for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ isvisited[i][j] = false; } } for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; N; j++){ if(!isvisited[i][j]){ // 연합이 있는지 없는지 확인, bfs 로 연합 탐색 temp_cnt += bfs(i, j); } } } // 인구이동이 없으면 break 하고 정답 리턴 if(temp_cnt == 0) break; // 인구이동 일수 추가 answer++; } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}최적화 코드 isvisited 초기화를 memset 으로 대체해서 속도 개선 flag_cnt는 사실상 bfs() 호출 후 리턴 여부 판단만에 사용되므로, v.size()로 판단 가능 cnt는 사실상 v.size()와 같으므로 제거 가능 q는 전역으로 선언되었으나, 각 bfs()마다 초기화가 필요하므로 지역 변수로 이동 사용하지 않는 변수 및 조건 제거 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#define ARR_MAX_LEN 55using namespace std;int N, L, R, answer = 0;int arr[ARR_MAX_LEN][ARR_MAX_LEN];bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN];int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };typedef struct { int y, x;} loc_t;bool bfs(int y, int x) { queue&lt;loc_t&gt; q; vector&lt;loc_t&gt; v; q.push({y, x}); v.push_back({y, x}); isvisited[y][x] = true; int sum = arr[y][x]; while (!q.empty()) { loc_t cur = q.front(); q.pop(); for (int dir = 0; dir &lt; 4; dir++) { int ny = cur.y + dy[dir]; int nx = cur.x + dx[dir]; if (ny &lt; 0 || nx &lt; 0 || ny &gt;= N || nx &gt;= N) continue; if (isvisited[ny][nx]) continue; int diff = abs(arr[cur.y][cur.x] - arr[ny][nx]); if (diff &gt;= L &amp;&amp; diff &lt;= R) { q.push({ny, nx}); v.push_back({ny, nx}); isvisited[ny][nx] = true; sum += arr[ny][nx]; } } } if (v.size() == 1) // 자기 자신밖에 없다면 이동 없음 return false; int avg = sum / v.size(); for (auto loc : v) { arr[loc.y][loc.x] = avg; } return true;}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; L &gt;&gt; R; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) cin &gt;&gt; arr[i][j]; while (true) { memset(isvisited, false, sizeof(isvisited)); bool moved = false; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { if (!isvisited[i][j]) { if (bfs(i, j)) moved = true; } } } if (!moved) break; answer++; } cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "주사위 굴리기", "url": "/posts/%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B5%B4%EB%A6%AC%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-07-11 00:00:00 +0900", "snippet": "주사위 굴리기문제크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다. 24 1 3 5 6주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.입력첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x, y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10 미만의 자연수 또는 0이다.마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.출력이동할 때마다 주사위의 윗 면에 쓰여 있는 수를 출력한다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.풀이#include &lt;iostream&gt;#define ARR_MAX_LEN 25using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int N, M, START_Y, START_X, K;// 동 서 북 남 int dy[5] = { 0, 0, 0, -1, 1 };int dx[5] = { 0, 1, -1, 0, 0 };typedef struct{ int top; int bottom; int east; int west; int north; int south;}dice_t;void input_func(){ // x, y 로 표현되었지만 지금 설정한 좌표계에서는 Y, X 가 맞음 cin &gt;&gt; N &gt;&gt; M &gt;&gt; START_Y &gt;&gt; START_X &gt;&gt; K; for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ cin &gt;&gt; arrmap[i][j]; } } }void simulate(){ dice_t dice = { 0 }; int cy = START_Y, cx = START_X; for(int i = 0; i &lt; K; i++){ int dir_input; cin &gt;&gt; dir_input; int ny = cy + dy[dir_input]; int nx = cx + dx[dir_input]; // 범위 내여야만 모든 행동을 시작 if(ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M){ // 주사위 회전 if(dir_input == 1){ // 동 int temp = dice.bottom; dice.bottom = dice.east; dice.east = dice.top; dice.top = dice.west; dice.west = temp; } else if(dir_input == 2){ // 서 int temp = dice.bottom; dice.bottom = dice.west; dice.west = dice.top; dice.top = dice.east; dice.east = temp; } else if(dir_input == 3){ // 북 int temp = dice.bottom; dice.bottom = dice.north; dice.north = dice.top; dice.top = dice.south; dice.south = temp; } else if(dir_input == 4){ // 남 int temp = dice.bottom; dice.bottom = dice.south; dice.south = dice.top; dice.top = dice.north; dice.north = temp; } // 바닥면-지도 복사 처리 if(arrmap[ny][nx]){ dice.bottom = arrmap[ny][nx]; arrmap[ny][nx] = 0; } else{ arrmap[ny][nx] = dice.bottom; } // 출력 및 위치 갱신 printf(\"%d\\n\", dice.top); cy = ny; cx = nx; } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input_func(); simulate(); return 0;}" }, { "title": "유닛 이동시키기", "url": "/posts/%EC%9C%A0%EB%8B%9B-%EC%9D%B4%EB%8F%99%EC%8B%9C%ED%82%A4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-06-22 00:00:00 +0900", "snippet": "유닛 이동시키기문제스타크래프트와 같은 게임을 하다 보면 어떤 유닛을 목적지까지 이동시켜야 하는 경우가 종종 발생한다. 편의상 맵을 N×M 크기의 2차원 행렬로 생각하자. 또한 각각의 유닛은 크기를 가질 수 있는데, 이를 A×B 크기의 2차원 행렬로 생각하자. 아래는 5×5 크기의 맵과 2×2 크기의 유닛에 대한 한 예이다. S는 시작점을 나타내며 E는 끝점을 나타낸다.유닛은 상하좌우의 네 방향으로만 움직일 수 있다. 단, 유닛의 일부분이 장애물이 설치된 부분(위의 예에서 색이 칠해진 부분)을 지날 경우, 위의 예에서는 시작 위치에서 위로 이동하는 경우는 허용되지 않는다. 위의 예는 유닛을 오른쪽으로 세 칸, 위쪽으로 세 칸 움직이면 목적지에 도달할 수 있고, 이 경우가 가장 적은 이동 회수를 거치는 경우이다. 이동하는 도중에 유닛이 맵 밖으로 나가는 경우는 허용되지 않는다.맵의 정보와 유닛의 정보가 주어졌을 때, 유닛을 목적지까지 움직이기 위해 필요한 최소의 이동 회수를 구하는 프로그램을 작성하시오.입력첫째 줄에 다섯 개의 정수 N, M(1 ≤ N, M ≤ 500), A, B(1 ≤ A, B ≤ 10), K(0 ≤ K ≤ 100,000)가 주어진다. 다음 K개의 줄에는 장애물이 설치된 위치(행 번호, 열 번호)가 주어진다. 그 다음 줄에는 시작점의 위치와 도착점의 위치가 주어진다. 시작점의 위치와 도착점의 위치는 제일 왼쪽 제일 위의 한 점만 주어진다. 시작점의 위치와 도착점의 위치는 같지 않다.유닛의 시작점에는 장애물이 존재하지 않으며, 시작점과 도착점이 행렬의 범위를 벗어나는 경우는 없다.출력첫째 줄에 답을 출력한다. 이동이 불가능한 경우에는 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;queue&gt;#define ARR_MAX_LEN 550#define BLOCK 9#define ARRIVAL 2using namespace std;typedef struct{ int y; int x; int cnt;}loc_t;int N, M, A, B, K, answer = -1;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };queue&lt;loc_t&gt; q;bool is_arrive(int y, int x){ for(int i = 0; i &lt; A; i++){ for(int j = 0; j &lt; B; j++){ if(arrmap[y + i][x + j] != ARRIVAL) return false; } } return true;}bool can_go(int y, int x){ if(y &lt; 1 || x &lt; 1 || y + A - 1 &gt; N || x + B - 1 &gt; M) return false; for(int i = 0; i &lt; A; i++){ for(int j = 0; j &lt; B; j++){ if(arrmap[y + i][x + j] == BLOCK) return false; } } return true;}void bfs(){ while(!q.empty()){ int cy = q.front().y; int cx = q.front().x; int c_cnt = q.front().cnt; q.pop(); if(is_arrive(cy, cx)){ answer = c_cnt; return; // 최단거리이므로 최초 발견시 종료 } for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; int n_cnt = c_cnt + 1; if(can_go(ny, nx) &amp;&amp; !isvisited[ny][nx]){ q.push({ny, nx, n_cnt}); isvisited[ny][nx] = true; } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M &gt;&gt; A &gt;&gt; B &gt;&gt; K; for(int i = 0; i &lt; K; i++){ int y, x; cin &gt;&gt; y &gt;&gt; x; arrmap[y][x] = BLOCK; } int start_y, start_x, end_y, end_x; cin &gt;&gt; start_y &gt;&gt; start_x; cin &gt;&gt; end_y &gt;&gt; end_x; // 도착 지점이 BLOCK일 경우 처리 for(int i = 0; i &lt; A; i++){ for(int j = 0; j &lt; B; j++){ if(end_y + i &gt; N || end_x + j &gt; M || arrmap[end_y + i][end_x + j] == BLOCK){ cout &lt;&lt; \"-1\\n\"; return 0; } arrmap[end_y + i][end_x + j] = ARRIVAL; } } // 시작 지점이 이미 도착한 경우 체크 if(is_arrive(start_y, start_x)){ cout &lt;&lt; \"0\\n\"; return 0; } q.push({start_y, start_x, 0}); isvisited[start_y][start_x] = true; bfs(); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "차이를 최대로", "url": "/posts/%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%B5%9C%EB%8C%80%EB%A1%9C/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-06-21 00:00:00 +0900", "snippet": "차이를 최대로문제N개의 정수로 이루어진 배열 A가 주어진다. 이때, 배열에 들어있는 정수의 순서를 적절히 바꿔서 다음 식의 최댓값을 구하는 프로그램을 작성하시오.|A[0] - A[1]| + |A[1] - A[2]| + ... + |A[N-2] - A[N-1]|입력첫째 줄에 N (3 ≤ N ≤ 8)이 주어진다. 둘째 줄에는 배열 A에 들어있는 정수가 주어진다. 배열에 들어있는 정수는 -100보다 크거나 같고, 100보다 작거나 같다.출력첫째 줄에 배열에 들어있는 수의 순서를 적절히 바꿔서 얻을 수 있는 식의 최댓값을 출력한다.풀이#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 10using namespace std;int N, answer = 0;int arr[ARR_MAX_LEN] = { 0 };int answer_arr[ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN] = { false };int arr_diff_func(){\tint temp_sum = 0;\tfor(int i = 0; i &lt; N - 1; i++){\t\ttemp_sum += abs(answer_arr[i] - answer_arr[i + 1]);\t}\treturn temp_sum;}void dfs(int idx, int cnt){\tif(cnt == N){ // for(int i = 0; i &lt; N; i++){ // cout &lt;&lt; answer_arr[i] &lt;&lt; \" \"; // } // cout &lt;&lt; \"\\n\";\t\tanswer = max(arr_diff_func(), answer);\t\treturn;\t}\tfor(int i = 0; i &lt; N; i++){\t\tif (isvisited[i])\t\t\tcontinue; isvisited[i] = true;\t\tanswer_arr[cnt] = arr[i];\t\tdfs(i + 1, cnt + 1);\t\tisvisited[i] = false;\t}}int main(){\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tcin &gt;&gt; N;\tfor(int i = 0; i &lt; N; i++)\t\tcin &gt;&gt; arr[i];\t\tdfs(0, 0);\tcout &lt;&lt; answer &lt;&lt; \"\\n\";\t\treturn 0;}" }, { "title": "사다리 조작", "url": "/posts/%EC%82%AC%EB%8B%A4%EB%A6%AC-%EC%A1%B0%EC%9E%91/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-06-20 00:00:00 +0900", "snippet": "사다리 조작문제사다리 게임은 N개의 세로선과 M개의 가로선으로 이루어져 있다. 인접한 세로선 사이에는 가로선을 놓을 수 있는데, 각각의 세로선마다 가로선을 놓을 수 있는 위치의 개수는 H이고, 모든 세로선이 같은 위치를 갖는다. 아래 그림은 N = 5, H = 6 인 경우의 그림이고, 가로선은 없다.초록선은 세로선을 나타내고, 초록선과 점선이 교차하는 점은 가로선을 놓을 수 있는 점이다. 가로선은 인접한 두 세로선을 연결해야 한다. 단, 두 가로선이 연속하거나 서로 접하면 안 된다. 또, 가로선은 점선 위에 있어야 한다.위의 그림에는 가로선이 총 5개 있다. 가로선은 위의 그림과 같이 인접한 두 세로선을 연결해야 하고, 가로선을 놓을 수 있는 위치를 연결해야 한다.사다리 게임은 각각의 세로선마다 게임을 진행하고, 세로선의 가장 위에서부터 아래 방향으로 내려가야 한다. 이때, 가로선을 만나면 가로선을 이용해 옆 세로선으로 이동한 다음, 이동한 세로선에서 아래 방향으로 이동해야 한다.위의 그림에서 1번은 3번으로, 2번은 2번으로, 3번은 5번으로, 4번은 1번으로, 5번은 4번으로 도착하게 된다. 아래 두 그림은 1번과 2번이 어떻게 이동했는지 나타내는 그림이다.1번 세로선\t2번 세로선사다리에 가로선을 추가해서, 사다리 게임의 결과를 조작하려고 한다. 이때, i번 세로선의 결과가 i번이 나와야 한다. 그렇게 하기 위해서 추가해야 하는 가로선 개수의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 세로선의 개수 N, 가로선의 개수 M, 세로선마다 가로선을 놓을 수 있는 위치의 개수 H가 주어진다. (2 ≤ N ≤ 10, 1 ≤ H ≤ 30, 0 ≤ M ≤ (N-1)×H)둘째 줄부터 M개의 줄에는 가로선의 정보가 한 줄에 하나씩 주어진다.가로선의 정보는 두 정수 a과 b로 나타낸다. (1 ≤ a ≤ H, 1 ≤ b ≤ N-1) b번 세로선과 b+1번 세로선을 a번 점선 위치에서 연결했다는 의미이다.가장 위에 있는 점선의 번호는 1번이고, 아래로 내려갈 때마다 1이 증가한다. 세로선은 가장 왼쪽에 있는 것의 번호가 1번이고, 오른쪽으로 갈 때마다 1이 증가한다.입력으로 주어지는 가로선이 서로 연속하는 경우는 없다.출력i번 세로선의 결과가 i번이 나오도록 사다리 게임을 조작하려면, 추가해야 하는 가로선 개수의 최솟값을 출력한다. 만약, 정답이 3보다 큰 값이면 -1을 출력한다. 또, 불가능한 경우에도 -1을 출력한다.풀이#include &lt;iostream&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 100#define MAX_VAL 7654321using namespace std;int N, M, H, answer = MAX_VAL;bool ladder[ARR_MAX_LEN][ARR_MAX_LEN] = { false };bool check_validity(){\tfor(int col = 1; col &lt;= N; col++){\t\tint linenum = col;\t\tfor(int row = 1; row &lt;= H; row++){\t\t\tif(ladder[row][linenum])\t\t\t\tlinenum++;\t\t\t// col 이 1부터 시작하기 때문에 넘어갈 일은 없음\t\t\telse if(ladder[row][linenum - 1])\t\t\t\tlinenum--;\t\t}\t\tif (col != linenum)\t\t\treturn false;\t}\treturn true;}void add_ladder_dfs(int idx, int cnt){\tif(cnt &gt; 3)\t\treturn;\t// 사다리를 3개 이하로 몇개를 설치하든 최소 의 값을 찾는 것이기 때문에 매 idx 마다 탐색\tif(check_validity()){\t\tanswer = min(answer, cnt);\t\treturn;\t}\tfor (int i = idx; i &lt;= H; i++){\t\tfor(int j = 1; j &lt;= N; j++){ // 두 가로선이 연속하거나 서로 접하면 안 된다. 해당 가로선을 그으려면 인접한 점에 가로선이 없어야 한다.\t\t\tif(ladder[i][j])\t\t\t\tcontinue;\t\t\telse if (ladder[i][j - 1])\t\t\t\tcontinue; else if (ladder[i][j + 1]) continue;\t\t\t\t\t\tladder[i][j] = true;\t\t\tadd_ladder_dfs(i, cnt + 1);\t\t\tladder[i][j] = false;\t\t}\t}}int main(){\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tcin &gt;&gt; N &gt;&gt; M &gt;&gt; H;\tfor(int i = 0; i &lt; M; i++){\t\tint a, b;\t\tcin &gt;&gt; a &gt;&gt; b;\t\tladder[a][b] = true;\t} // idx 는 1부터 시작\tadd_ladder_dfs(1, 0); \tif(answer == MAX_VAL)\t\tcout &lt;&lt; \"-1\\n\";\telse\t\tcout &lt;&lt; answer &lt;&lt; \"\\n\";\treturn 0;}" }, { "title": "감시", "url": "/posts/%EA%B0%90%EC%8B%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-06-07 00:00:00 +0900", "snippet": "감시문제 개요N 개의 행과 M 개의 열을 가지는 사무실이 주어진다. 사무실에는 1번에서 5번까지의 CCTV가 설치되어 있고, 각 CCTV는 특정 방향으로 감시가 가능하다. 모든 CCTV의 방향을 적절히 설정해서 사각지대의 최소 크기를 구하는 것이 문제의 목표다.입력 첫 줄: N (1 이상 8 이하), M (1 이상 8 이하) N 행의 M 개 열: 두 개의 수 (0: 빈칸, 6: 벽, 1~5: CCTV 종류)출력 CCTV의 방향을 적절히 설정했을 때 사각지대의 크기의 최소값CCTV 종류 1번: 한 방향 2번: 반대 방향 2개 3번: 직각 방향 2개 4번: 세 방향 5번: 네 방향 모두관찰 목록 모든 CCTV의 방향 조합 탐색 탐색 과정에서 감시 범위 표시 및 최소값 계산 감시 범위는 중복 가능 벽(6)은 감시가 중단되는 지점구현 기능 CCTV 목록을 모아 방향 조합을 완전 탐색 방식으로 구현 감시 가능한 칸을 -1 로 표시 백트래킹 시 이전 상태 복구 최소 사각지대 값 계산 및 갱신#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 15using namespace std;typedef struct { int y; int x; int num;}cctv;int N, M, answer = 7654321, blindspot_count = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// 상하 좌우int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };vector&lt;cctv&gt; cctv_lst;// cctv 종류 리스트 표현 (이중 vector 에 direction 개수 만큼 배열 선언)// vector&lt;int&gt;: 하나의 방향 조합 (예: {0, 1} → 위, 아래)// vector&lt;vector&lt;int&gt;&gt;: 하나의 CCTV가 가질 수 있는 모든 방향 조합 리스트// cctv_dir[6]: 위 구조들을 CCTV 번호(1~5)에 맞춰 정리한 고정 크기 배열vector&lt;vector&lt;int&gt; &gt; cctv_dir[6]{ {{}}, {{0}, {1}, {2}, {3}}, {{2, 3}, {0, 1}}, {{0, 3}, {1, 3}, {1, 2}, {0, 2}}, {{0, 2, 3}, {0, 1, 3}, {1, 2, 3}, {0, 1, 2}}, {{0, 1, 2, 3}},};void input_func() { cin &gt;&gt; N &gt;&gt; M; blindspot_count = N * M; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cin &gt;&gt; arrmap[i][j]; if (arrmap[i][j] &gt;= 1 &amp;&amp; arrmap[i][j] &lt;= 5) { cctv_lst.push_back({ i, j, arrmap[i][j] }); blindspot_count--; } else if (arrmap[i][j] == 6) blindspot_count--; } }}void find_min_blind_spot_func(int level, int cnt) { if (level == cctv_lst.size()) { answer = min(answer, cnt); return; } cctv target_cctv = cctv_lst[level]; vector&lt;vector&lt;int&gt; &gt; cur_cctv_dir = cctv_dir[target_cctv.num]; int by = target_cctv.y; int bx = target_cctv.x; for (int i = 0; i &lt; cur_cctv_dir.size(); i++) { int visible_cnt = 0; vector&lt;pair&lt;int, int&gt; &gt; visible_lst; for (int j = 0; j &lt; cur_cctv_dir[i].size(); j++) { int cur_dir = cur_cctv_dir[i][j]; int cy = by; int cx = bx; while (true) { int ny = cy + dy[cur_dir]; int nx = cx + dx[cur_dir]; if (ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M) { // 벽일 경우 더 이상 해당 방향으로 탐색이 의미없으므로 break if (arrmap[ny][nx] == 6) break; // cctv 가 있을 경우 좌표값만 업데이트 (현재 방향으로 한 칸 이동) if (arrmap[ny][nx] != 0) { cy = ny; cx = nx; continue; } // cctv 도 벽도 아닌 경우 감시 영역으로 판단하고 정보 업데이트(좌표 이동도 같이 수행) arrmap[ny][nx] = -1; visible_lst.push_back({ ny, nx }); cy = ny; cx = nx; visible_cnt++; } else break; } } // 방향 별로 깊이 탐색 수행 find_min_blind_spot_func(level + 1, cnt - visible_cnt); // 재귀 이후 값 원래대로 복원 for (int j = 0; j &lt; visible_lst.size(); j++) { arrmap[visible_lst[j].first][visible_lst[j].second] = 0; } }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); input_func(); find_min_blind_spot_func(0, blindspot_count); cout &lt;&lt; answer &lt;&lt; \"\\n\"; return 0;}" }, { "title": "테트리미노", "url": "/posts/%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-06-06 00:00:00 +0900", "snippet": "테트리미노문제테트리미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다. 정사각형은 서로 겹치면 안 된다. 도형은 모두 연결되어 있어야 한다.정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.입력첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.출력첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.풀이테트리미노 개수 및 고려사항회전 및 대칭을 고려하면 예측 가능한 테트리미노의 총 개수는 19개이다.각 테트리미노의 모양을 고려하여 전체 입력 배열을 탐색하면서 해당 위치에 테트리미노가 놓일 수 있는지를 확인하고, 가능한 경우마다 그 위치에서의 합을 구해 최대값을 갱신한다.배열 범위 초과에 대한 고려일반적으로 테트리미노는 최대 4x4의 형태를 가지므로, 입력 배열에서 테트리미노를 놓을 수 있는 모든 시작 지점을 순회한다.이때 테트리미노 일부가 배열의 범위를 넘어가게 되면 오류가 발생할 수 있으므로, 아래와 같은 방식으로 방지할 수 있다: 입력 배열 외곽에 여유 공간을 확보한 확장 배열을 사용 또는 테트리미노가 놓일 때마다 해당 좌표가 범위 내인지 확인하는 조건문을 추가이렇게 하면 테트리미노가 배열의 경계를 넘지 않도록 하면서도 모든 가능한 위치에 대해 최대 합을 계산할 수 있다.#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 550using namespace std;int N, M, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };// 2 + 1 + 8 + 4 + 4int tetrimino[19][4][4] = {\t// ----\t{\t\t{1, 1, 1, 1},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 0, 0, 0},\t\t{1, 0, 0, 0},\t\t{1, 0, 0, 0},\t\t{1, 0, 0, 0},\t},\t// --\t// --\t{\t\t{1, 1, 0, 0},\t\t{1, 1, 0, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t// -\t// -\t// --\t{\t\t{1, 0, 0, 0},\t\t{1, 0, 0, 0},\t\t{1, 1, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 1, 1, 0},\t\t{1, 0, 0, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 1, 0, 0},\t\t{0, 1, 0, 0},\t\t{0, 1, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{0, 0, 1, 0},\t\t{1, 1, 1, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t// -\t// -\t// --\t{\t\t{0, 1, 0, 0},\t\t{0, 1, 0, 0},\t\t{1, 1, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 0, 0, 0},\t\t{1, 1, 1, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 1, 0, 0},\t\t{1, 0, 0, 0},\t\t{1, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 1, 1, 0},\t\t{0, 0, 1, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t// -\t// --\t// -\t{\t\t{1, 0, 0, 0},\t\t{1, 1, 0, 0},\t\t{0, 1, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{0, 1, 1, 0},\t\t{1, 1, 0, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t// -\t// --\t// -\t{\t\t{0, 1, 0, 0},\t\t{1, 1, 0, 0},\t\t{1, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 1, 0, 0},\t\t{0, 1, 1, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t// -\t// ---\t{\t\t{0, 1, 0, 0},\t\t{1, 1, 1, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 0, 0, 0},\t\t{1, 1, 0, 0},\t\t{1, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{1, 1, 1, 0},\t\t{0, 1, 0, 0},\t\t{0, 0, 0, 0},\t\t{0, 0, 0, 0},\t},\t{\t\t{0, 1, 0, 0},\t\t{1, 1, 0, 0},\t\t{0, 1, 0, 0},\t\t{0, 0, 0, 0},\t},};void input_func() {\tcin &gt;&gt; N &gt;&gt; M;\tfor (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tcin &gt;&gt; arrmap[i][j];\t\t}\t}}void simulate() {\t\tfor (int k = 0; k &lt; 19; k++) {\t\tfor (int i = 0; i &lt; N; i++) {\t\t\tfor (int j = 0; j &lt; M; j++) {\t\t\t\tint temp_sum = 0;\t\t\t\tfor (int y = 0; y &lt; 4; y++) {\t\t\t\t\tfor (int x = 0; x &lt; 4; x++) {\t\t\t\t\t\t// 어차피 0, 아니면 1이기 때문에 이 방식도 사용 가능 (속도는 더 느릴듯..)\t\t\t\t\t\t// temp_sum += arrmap[i + y][j + x] * tetrimino[k][y][x];\t\t\t\t\t\t\t\t\t\t\t\tif (tetrimino[k][y][x] == 1)\t\t\t\t\t\t\ttemp_sum += arrmap[i + y][j + x];\t\t\t\t\t\t\t\t\t\t\t}\t\t\t\t}\t\t\t\tanswer = max(answer, temp_sum);\t\t\t}\t\t}\t\t\t}}int main() {\t\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tinput_func();\tsimulate();\tcout &lt;&lt; answer &lt;&lt; \"\\n\";\treturn 0;}" }, { "title": "자동차 분류 AI 경진대회", "url": "/posts/DACON-%EC%9E%90%EB%8F%99%EC%B0%A8-%EB%B6%84%EB%A5%98-AI-%EA%B2%BD%EC%A7%84%EB%8C%80%ED%9A%8C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-06-06 00:00:00 +0900", "snippet": "자동차 분류 AI 경진대회📌 대회 개요 주제: 중고차 이미지 차종 분류 AI 모델 개발 목적: 헥토(Hecto)의 우수 인재 발굴 및 채용 연계 참가 자격: 일반인, 학생 등 누구나 참여 가능 주최: 헥토(Hecto) 주관: 데이콘(DACON)🏆 상금 및 채용 특전 총 상금: 2,600만원 (제세공과금 포함) 채용 특전: 대회 입상자에게 헥토그룹 채용 1차 면접 패스권 부여 대회 상위 30팀 헥토그룹 채용 인재풀 등록 📅 주요 일정 참가 신청 시작: 2025년 5월 7일 대회 시작: 2025년 5월 19일 팀 병합 마감: 2025년 6월 9일 대회 종료: 2025년 6월 16일 코드 및 발표자료 제출 마감: 2025년 6월 19일 코드 검증 및 평가 마감: 2025년 6월 27일 오프라인 시상식: 2025년 7월 4일🔍 대회 설명최근 자동차 산업의 디지털 전환과 더불어, 다양한 차종을 빠르고 정확하게 인식하는 기술의 중요성이 커지고 있습니다. 특히 중고차 거래 플랫폼, 차량 관리 시스템, 자동 주차 및 보안 시스템 등 실생활에 밀접한 분야에서는 정확한 차종 분류가 핵심 기술로 떠오르고 있습니다.이미지 기반 차종 인식 기술은 기존의 수작업 방식에 비해 높은 정확도와 효율성을 제공하며, 인공지능(AI)을 활용한 자동화 기술이 빠르게 발전하고 있습니다. 그중에서도 다양한 차종을 세밀하게 구분할 수 있는 능력은 실제 서비스 도입 시 차별화된 경쟁력을 좌우하는 요소로 작용합니다.이에 따라, ‘HAI(하이)! - Hecto AI Challenge : 2025 상반기 헥토 채용 AI 경진대회’는 실제 중고차 차량 이미지를 기반으로 한 차종 분류 AI 모델 개발을 주제로 개최됩니다.본 대회는 헥토의 우수 인재 발굴 및 채용 연계를 목적으로 기획된 정기적인 AI 챌린지 시리즈의 일환이며, 참가자들은 창의적이고 고도화된 AI 모델링 전략을 통해 높은 분류 성능을 달성하는 데 도전하게 됩니다.제출 코드아래 github 페이지 참조DK_Hecto-AI-Challenge GitHub Repository" }, { "title": "원자 소멸 시뮬레이션", "url": "/posts/%EC%9B%90%EC%9E%90-%EC%86%8C%EB%A9%B8-%EC%8B%9C%EB%AE%AC%EB%A0%88%EC%9D%B4%EC%85%98/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-06-03 00:00:00 +0900", "snippet": "원자 소멸 시뮬레이션1. 문제 설명 2차원 평면 위에서 여러 개의 원자가 이동한다. 각 원자는 위치(x, y), 이동 방향, 에너지를 가진다. 모든 원자는 1초마다 0.5초씩 이동한다. 두 개 이상의 원자가 같은 위치에 오면 충돌 후 소멸한다. 충돌한 원자들의 에너지는 합산되어 소멸 에너지로 누적된다. 소멸 에너지의 총합을 구하는 것이 목적이다.2. 입력 및 출력 예시입력 첫 줄: 테스트 케이스 수 T 각 테스트 케이스의 첫 줄: 원자 개수 N 다음 N줄: x, y, 방향, 에너지출력 각 테스트 케이스마다: #테스트케이스번호 결과입력 예시240 0 1 100 2 2 202 0 3 302 2 0 4030 0 1 50 1 0 52 2 2 10출력 예시#1 60#2 103. 좌표 변환 및 시뮬레이션 포인트 좌표 범위: 입력에서 -1000 이상 1000 이하로 주어진다. 원자가 0.5초마다 이동하므로, 모든 좌표에 2를 곱해 정수로 변환하여 시뮬레이션한다. 시뮬레이션을 편하게 하기 위해서 원자 위치를 맵에 기록하여 관리한다.4. 방향 정의 0: 상(Up, y+1) 1: 하(Down, y-1) 2: 좌(Left, x-1) 3: 우(Right, x+1)5. 풀이여기서는 첫 번째 인덱스를 x로, 두 번째 인덱스를 y로 쓰겠다는 전제를 깔고 짠 코드즉, 2차원 배열을 수학적 좌표계처럼 쓰려는 의도가 담긴 설계임.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;#define MAX_ARR_LEN 4001int T, N, answer = 0;typedef struct {\tint x;\tint y;\tint dir;\tint energy;\tbool islive;}atom;vector&lt;atom&gt; ainfo;int arrmap[MAX_ARR_LEN][MAX_ARR_LEN] = { };int dx[4] = { 0, 0, -1, 1 };int dy[4] = { 1, -1, 0, 0 }; void input_func() {\tint x, y, dir, K;\tcin &gt;&gt; N;\tanswer = 0;\tmemset(arrmap, 0, sizeof(arrmap));\tainfo.clear();\tfor (int i = 0; i &lt; N; i++) {\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; dir &gt;&gt; K;\t\ty = (y + 1000) * 2;\t\tx = (x + 1000) * 2;\t\tainfo.push_back({ x, y, dir, K, true }); \t\tarrmap[x][y] = 1;\t}\t}bool all_vanish_check_func() {\tfor (int i = 0; i &lt; ainfo.size(); i++) {\t\tif (ainfo[i].islive)\t\t\treturn false;\t}\treturn true;}bool edge_check_func(int x, int y) {\treturn (x &gt;= 0 &amp;&amp; x &lt; MAX_ARR_LEN &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; MAX_ARR_LEN);}// 방향은 바뀌지않고, 좌표 범위는 무한이지만 정해진 범위를 넘어가면 사실상 영원히 충돌하지 않아 소멸되지 않기 때문에 그냥 islive 를 false 처리 한다.void simulate() {\twhile (!all_vanish_check_func()) {\t\t// 원자 좌표 업데이트\t\tfor (int i = 0; i &lt; ainfo.size(); i++) {\t\t\tif (!ainfo[i].islive)\t\t\t\tcontinue;\t\t\tint cx = ainfo[i].x;\t\t\tint cy = ainfo[i].y;\t\t\t\t\t\tint dir = ainfo[i].dir;\t\t\tint nx = cx + dx[dir];\t\t\tint ny = cy + dy[dir];\t\t\t\t\t\tif (edge_check_func(ny, nx)) {\t\t\t\t//arrmap[ny][nx] -= 1;\t\t\t\tarrmap[cx][cy] = 0;\t\t\t\tarrmap[nx][ny] += 1;\t\t\t\tainfo[i].y = ny;\t\t\t\tainfo[i].x = nx;\t\t\t\t\t\t\t}\t\t\t// 범위 벗어날 경우 그냥 소멸 처리\t\t\telse {\t\t\t\tarrmap[cx][cy] = 0;\t\t\t\tainfo[i].islive = false;\t\t\t}\t\t}\t\t// 충돌하는 경우 소멸시키고 에너지 방출\t\tfor (int i = 0; i &lt; ainfo.size(); i++) {\t\t\tif (!ainfo[i].islive)\t\t\t\tcontinue;\t\t\tint cx = ainfo[i].x;\t\t\tint cy = ainfo[i].y;\t\t\t\t\t\tif (arrmap[cx][cy] &gt;= 2) {\t\t\t\tfor (int j = 0; j &lt; ainfo.size(); j++) {\t\t\t\t\tif (i == j)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (!ainfo[j].islive)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (cy == ainfo[j].y &amp;&amp; cx == ainfo[j].x) {\t\t\t\t\t\tanswer += ainfo[j].energy;\t\t\t\t\t\tainfo[j].islive = false;\t\t\t\t\t}\t\t\t\t}\t\t\t\tanswer += ainfo[i].energy;\t\t\t\tainfo[i].islive = false;\t\t\t\tarrmap[cx][cy] = 0;\t\t\t}\t\t}\t\t\t}\t}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\tcin &gt;&gt; T;\tfor (int tc = 1; tc &lt;= T; tc++) {\t\tinput_func();\t\tsimulate();\t\tcout &lt;&lt; \"#\" &lt;&lt; tc &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\";\t}\treturn 0;}6. 알고리즘 풀이 순서 요약 입력을 받아 원자 구조체 벡터에 저장한다. 모든 좌표를 0.5초 단위의 정수 좌표로 변환하여 관리한다. 각 스텝마다 살아있는 원자만 이동시킨다. 이동 후 각 위치에 원자가 몇 개가 있는지 맵으로 관리한다. 같은 위치에 2개 이상 원자가 있으면 모두 소멸시키고 에너지를 누적한다. 맵 밖으로 나간 원자는 소멸 처리한다. 더 이상 충돌이 일어나지 않을 때까지 반복한다. 최종 소멸 에너지를 출력한다.7. 주요 포인트 0.5초 단위 이동을 위해 좌표 스케일을 2배로 늘려서 계산해야 한다. 같은 위치에서만 충돌이 발생한다는 점에 주의한다. map, vector, struct 등 STL 컨테이너를 적극 활용하면 편리하다. 무한 루프가 돌지 않도록, 시뮬레이션은 충분한 step 후 종료한다. 살아있는 원자의 수가 0이 되면 더이상 시뮬레이션할 필요 없다." }, { "title": "C++ STL 정리", "url": "/posts/C++-STL-%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-06-01 00:00:00 +0900", "snippet": "C++ STL 정리C++ 코딩테스트에서 반드시 알아야 하는 STL(Standard Template Library) 컨테이너와 자주 사용하는 알고리즘 함수들을 정리한다.각 컨테이너의 특징, 주요 멤버 함수, 실전 예시를 포함했다.1. vector특징 동적 배열 임의 접근 O(1) 끝에 삽입/삭제 O(1), 중간/앞 삽입/삭제 O(N)주요 함수 push_back(val): 마지막에 원소 추가 pop_back(): 마지막 원소 삭제 size(): 원소 개수 반환 empty(): 비었는지 확인 clear(): 모든 원소 삭제 begin(), end(): 반복자 반환 insert(위치, 값): 위치에 원소 삽입 erase(위치): 위치의 원소 삭제예시#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() { vector&lt;int&gt; v; v.push_back(10); v.push_back(20); v.pop_back(); // 20 제거 v.insert(v.begin(), 5); // 앞에 5 추가 v.erase(v.begin()); // 5 제거 for (int x : v) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}주 사용 상황 정렬, 슬라이딩 윈도우, DP 테이블, 백트래킹 등활용 예시: 정렬 후 이진 탐색#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int main() { vector&lt;int&gt; v = {5, 3, 8, 1}; sort(v.begin(), v.end()); if (binary_search(v.begin(), v.end(), 3)) { cout &lt;&lt; \"3 found\" &lt;&lt; endl; } return 0;}2. deque특징 양쪽 끝 모두 O(1) 삽입/삭제 임의 접근 O(1), 중간 삽입/삭제 O(N) 큐/스택 모두 대체 가능주요 함수 push_front(val), push_back(val): 앞/뒤에 원소 추가 pop_front(), pop_back(): 앞/뒤 원소 삭제 front(), back(): 양쪽 끝 원소 참조 size(), empty(), clear(), begin(), end() 등예시#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;int main() { deque&lt;int&gt; dq; dq.push_back(1); dq.push_front(2); dq.pop_back(); dq.pop_front(); dq.push_back(3); cout &lt;&lt; dq.front() &lt;&lt; \" \" &lt;&lt; dq.back() &lt;&lt; endl; return 0;}주 사용 상황 0-1 BFS, 슬라이딩 윈도우 최대/최소값활용 예시: 0-1 BFS#include &lt;deque&gt;#include &lt;vector&gt;using namespace std;void bfs_01(int start, vector&lt;vector&lt;pair&lt;int,int&gt;&gt;&gt; &amp;graph, vector&lt;int&gt; &amp;dist) { deque&lt;int&gt; dq; dq.push_back(start); dist[start] = 0; while (!dq.empty()) { int u = dq.front(); dq.pop_front(); for (auto [v, w] : graph[u]) { if (dist[v] &gt; dist[u] + w) { dist[v] = dist[u] + w; if (w == 0) dq.push_front(v); else dq.push_back(v); } } }}3. queue특징 FIFO(선입선출) 큐 front()에서 pop, back()에 push주요 함수 push(val): 뒤에 원소 추가 pop(): 앞 원소 삭제 front(): 앞 원소 참조 back(): 뒤 원소 참조 size(), empty()예시#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int main() { queue&lt;int&gt; q; q.push(4); q.push(5); cout &lt;&lt; q.front() &lt;&lt; endl; // 4 q.pop(); cout &lt;&lt; q.front() &lt;&lt; endl; // 5 return 0;}주 사용 상황 BFS, 토폴로지 정렬, 단계별 시뮬레이션활용 예시: BFS#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;void bfs(int start, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited) { queue&lt;int&gt; q; q.push(start); visited[start] = true; while (!q.empty()) { int cur = q.front(); q.pop(); cout &lt;&lt; cur &lt;&lt; \" \"; for (int next : adj[cur]) { if (!visited[next]) { visited[next] = true; q.push(next); } } }}4. stack특징 LIFO(후입선출) 스택 top()에서 push/pop주요 함수 push(val): 위에 원소 추가 pop(): 위 원소 삭제 top(): 위 원소 참조 size(), empty()예시#include &lt;stack&gt;#include &lt;iostream&gt;using namespace std;int main() { stack&lt;int&gt; st; st.push(7); st.push(8); cout &lt;&lt; st.top() &lt;&lt; endl; // 8 st.pop(); cout &lt;&lt; st.top() &lt;&lt; endl; // 7 return 0;}주 사용 상황 DFS, 수식 계산, 괄호 검사, 모노톤 스택활용 예시: 괄호 검사#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;bool isValid(string s) { stack&lt;char&gt; st; for (char c : s) { if (c == '(') st.push(c); else { if (st.empty()) return false; st.pop(); } } return st.empty();}5. priority_queue특징 힙(기본 최대 힙) top()에서 가장 큰 값 반환(최소 힙은 greater 사용)주요 함수 push(val): 값 추가 pop(): 최대(최소)값 삭제 top(): 현재 최대(최소)값 size(), empty()최소 힙 선언 방법priority_queue&lt;int, vector, greater&gt; pq;예시#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int main() { priority_queue&lt;int&gt; pq; pq.push(3); pq.push(1); pq.push(5); cout &lt;&lt; pq.top() &lt;&lt; endl; // 5 (최대값) pq.pop(); cout &lt;&lt; pq.top() &lt;&lt; endl; // 3 // 최소 힙 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; min_pq; min_pq.push(3); min_pq.push(1); cout &lt;&lt; min_pq.top() &lt;&lt; endl; // 1 return 0;}5. priority_queue주 사용 상황 다익스트라, 힙 문제, k번째 수활용 예시: 다익스트라#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;void dijkstra(int start, vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; dist) { priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq; dist[start] = 0; pq.push({0, start}); while (!pq.empty()) { auto [cost, u] = pq.top(); pq.pop(); if (cost &gt; dist[u]) continue; for (auto [v, w] : graph[u]) { if (dist[v] &gt; cost + w) { dist[v] = cost + w; pq.push({dist[v], v}); } } }}6. set / multiset특징 set: 중복 불가, 자동 오름차순 정렬 multiset: 중복 허용, 자동 오름차순 정렬주요 함수 insert(val): 원소 추가 erase(val): 원소 삭제 find(val): 원소 탐색(없으면 end 반환) count(val): 원소 개수 반환(multiset만) size(), empty(), clear(), begin(), end()예시#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;int main() { set&lt;int&gt; s; s.insert(2); s.insert(1); s.insert(2); s.erase(1); if (s.find(2) != s.end()) cout &lt;&lt; \"2 found\" &lt;&lt; endl; for (int x : s) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}주 사용 상황 정렬된 값 유지, 범위 탐색, 중복 허용(multiset)활용 예시: sliding window + 정렬 값 유지#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;int main() { multiset&lt;int&gt; ms; ms.insert(5); ms.insert(3); ms.insert(5); ms.erase(ms.find(5)); // 하나만 삭제 for (int x : ms) cout &lt;&lt; x &lt;&lt; \" \"; return 0;}7. map / multimap특징 map: 키-값 저장, 키 중복 불가, 자동 정렬 multimap: 키 중복 허용 키 기반 탐색/삽입/삭제 O(log N)주요 함수 insert({key, val}) / m[key] = val: 원소 추가 erase(key): 원소 삭제 find(key): 키 탐색(없으면 end) size(), empty(), clear(), begin(), end()예시#include &lt;map&gt;#include &lt;iostream&gt;using namespace std;int main() { map&lt;string, int&gt; m; m[\"apple\"] = 10; m[\"banana\"] = 20; m.erase(\"apple\"); if (m.find(\"banana\") != m.end()) cout &lt;&lt; m[\"banana\"] &lt;&lt; endl; for (auto x : m) { cout &lt;&lt; x.first &lt;&lt; \" \" &lt;&lt; x.second &lt;&lt; endl; } return 0;}주 사용 상황 빈도수 카운팅, 좌표 압축, 키 기반 정렬 자료활용 예시: 좌표 압축#include &lt;map&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() { vector&lt;int&gt; arr = {50, 20, 50}; map&lt;int, int&gt; mp; multimap&lt;string, int&gt; students; int idx = 0; for (int x : arr) mp[x] = 0; for (int x : arr) cout &lt;&lt; mp[x] &lt;&lt; \" \"; for (auto ar : mp) cout &lt;&lt; ar.first &lt;&lt; \" : \" &lt;&lt; ar.second &lt;&lt; endl; students.insert({ \"Kim\", 90 }); students.insert({ \"Lee\", 85 }); students.insert({ \"Kim\", 95 }); // for(auto st : students) 사용 for (auto st : students) { cout &lt;&lt; st.first &lt;&lt; \" : \" &lt;&lt; st.second &lt;&lt; endl; } return 0;}8. unordered_set / unordered_map특징 해시 기반, 평균 O(1) 탐색/삽입/삭제 정렬 없음 중복 불가(unordered_set), 키 중복 불가(unordered_map)주요 함수 insert(val) / um[key] = val: 원소 추가 erase(val) / erase(key): 원소 삭제 find(val) / find(key): 탐색 size(), empty(), clear(), begin(), end()예시#include &lt;unordered_map&gt;#include &lt;iostream&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; um; um[\"cat\"] = 1; um[\"dog\"] = 2; if (um.find(\"cat\") != um.end()) cout &lt;&lt; um[\"cat\"] &lt;&lt; endl; return 0;}주 사용 상황 빠른 탐색/삽입/삭제, 정렬 불필요한 문제활용 예시: 문자열 빈도수 카운팅#include &lt;unordered_map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; um; um[\"apple\"]++; um[\"banana\"]++; um[\"apple\"]++; for (auto&amp; [k, v] : um) { cout &lt;&lt; k &lt;&lt; \": \" &lt;&lt; v &lt;&lt; endl; } return 0;}자주 쓰는 STL 알고리즘sort, reverse, count, find, max_element, min_element예시#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() { vector&lt;int&gt; v = {3, 1, 4, 1, 5}; sort(v.begin(), v.end()); // 오름차순 정렬 sort(v.rbegin(), v.rend()); // 내림차순 정렬 reverse(v.begin(), v.end()); int cnt = count(v.begin(), v.end(), 1); auto it = find(v.begin(), v.end(), 4); int mx = *max_element(v.begin(), v.end()); int mn = *min_element(v.begin(), v.end()); return 0;}binary_search, lower_bound, upper_bound설명 binary_search: 정렬된 컨테이너에서 값 존재 여부 O(log N) lower_bound: 정렬된 컨테이너에서 이상 첫 위치 반복자 upper_bound: 초과 첫 위치 반복자예시#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() { vector&lt;int&gt; v = {1, 2, 2, 3, 4, 5}; bool ok = binary_search(v.begin(), v.end(), 3); // true auto lb = lower_bound(v.begin(), v.end(), 2); // 2 이상 첫 위치 auto ub = upper_bound(v.begin(), v.end(), 2); // 2 초과 첫 위치 cout &lt;&lt; (lb - v.begin()) &lt;&lt; \" \" &lt;&lt; (ub - v.begin()) &lt;&lt; endl; // 1 3 return 0;}next_permutation, prev_permutation예시#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int main() { vector&lt;int&gt; v = {1, 2, 3}; do { for (int x : v) cout &lt;&lt; x &lt;&lt; \" \"; cout &lt;&lt; endl; } while (next_permutation(v.begin(), v.end())); return 0;}" }, { "title": "홈 방범 서비스", "url": "/posts/%ED%99%88-%EB%B0%A9%EB%B2%94-%EC%84%9C%EB%B9%84%EC%8A%A4/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2025-05-18 00:00:00 +0900", "snippet": "홈 방범 서비스📌 문제 설명N x N 크기의 격자 마을이 있다. 각 칸은 집이 있거나(1), 없거나(0) 로 구성되어 있으며, 홈 방범 서비스를 제공할 수 있는 영역은 마름모 모양이다.마름모의 중심 좌표를 기준으로 서비스 범위 K를 정하면, 방범 서비스 영역은 아래와 같은 범위로 커버된다. 서비스 영역 크기: K일 때 비용 = K * K + (K - 1) * (K - 1)단, 각 집에서는 1만큼의 수익이 발생조건 서비스를 제공할 수 있는 영역은 어느 곳이든 선택 가능 손해가 나지 않으면서 가장 많은 집에 서비스를 제공하는 경우를 찾는 문제📥 입력 조건 테스트 케이스 수 T 각 테스트 케이스: 첫 줄: N M N: 마을 크기 (5 ≤ N ≤ 20) M: 집 1채 당 얻는 수익 (1 ≤ M ≤ 10) 다음 N줄: 0 또는 1로 구성된 마을 정보 ✅ 출력 조건 손해 없이 서비스를 제공할 수 있는 최대 집 수🧠 풀이 전략 마을의 모든 좌표를 마름모 중심점으로 잡는다 K 값을 1부터 2N까지 반복 마름모 범위에 포함된 집의 수를 계산 수익 = 집의 수 * M비용 = K*K + (K-1)*(K-1)→ 손해 여부 판별 후 최대값 갱신🔧 핵심 로직 (아이디어) BFS 혹은 마름모 범위 수학적 계산을 이용해 커버 영역 탐색 손익 여부 판단을 위한 수식 사용 완전탐색 (NNK)의 범위는 제한 내에서 충분히 가능풀이 시간초과가 나는 오답 마름모 모양으로 퍼져나가는 방식 때문에 bfs 를 고려했으나 bfs 를 너무 많이 호출하여 시간초과 발생#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 25using namespace std;int N, M, T, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };typedef struct { int y; int x;} cord;int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };void input_func() { cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) cin &gt;&gt; arrmap[i][j];}int manage_cost(int k) { return k * k + (k - 1) * (k - 1);}int bfs(int y, int x, int len) { queue&lt;cord&gt; q; int home_cnt = 0; int cntmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 }; bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false }; q.push({ y, x }); isvisited[y][x] = true; cntmap[y][x] = 1; while (!q.empty()) { int cy = q.front().y; int cx = q.front().x; q.pop(); if (cntmap[cy][cx] &gt; len) continue; if (arrmap[cy][cx] == 1) home_cnt++; for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &lt; 0 || ny &gt;= N || nx &lt; 0 || nx &gt;= N) continue; if (!isvisited[ny][nx]) { q.push({ ny, nx }); isvisited[ny][nx] = true; cntmap[ny][nx] = cntmap[cy][cx] + 1; } } } return home_cnt;}void simulate() { int max_len = N + 1; for (int len = 1; len &lt;= max_len; len++) { int cost = manage_cost(len); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { int home_cnt_temp = bfs(i, j, len); int profit = home_cnt_temp * M; if (profit &gt;= cost) { answer = max(answer, home_cnt_temp); } } } }}int main() { cin &gt;&gt; T; for (int tc = 1; tc &lt;= T; tc++) { answer = 0; input_func(); simulate(); cout &lt;&lt; \"#\" &lt;&lt; tc &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\"; } return 0;} 시간초과가 안나는 옳은 정답 모든 집의 좌표를 미리 저장해서 → 현재 마름모 안에 포함된 집만 따져라 → BFS 자체를 없애고 수학적 거리 비교로 해결 마름모 안에 포함되는 좌표는 dy + dx &lt;= K - 1 조건만 만족하면 됨 #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define ARR_MAX_LEN 25using namespace std;int N, M, T, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };typedef struct { int y; int x;} cord;vector&lt;cord&gt; house_list;int manage_cost(int k) { return k * k + (k - 1) * (k - 1);}void input_func() { cin &gt;&gt; N &gt;&gt; M; house_list.clear(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { cin &gt;&gt; arrmap[i][j]; //모든 집의 좌표를 미리 저장해서 현재 마름모 안에 포함된 집만 따지기 if (arrmap[i][j] == 1) house_list.push_back({ i, j }); } }}void simulate() { int max_len = 2 * N; for (int len = 1; len &lt;= max_len; len++) { int cost = manage_cost(len); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { int home_cnt = 0;\t//마름모 안에 포함되는 좌표는 |dy| + |dx| &lt;= K - 1 조건만 만족하면 됨 for (int idx = 0; idx &lt; house_list.size(); idx++) { int dist = abs(i - house_list[idx].y) + abs(j - house_list[idx].x); if (dist &lt; len) home_cnt++; } int profit = home_cnt * M; if (profit &gt;= cost) answer = max(answer, home_cnt); } } }}int main() { cin &gt;&gt; T; for (int tc = 1; tc &lt;= T; tc++) { answer = 0; input_func(); simulate(); cout &lt;&lt; \"#\" &lt;&lt; tc &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "미생물 격리", "url": "/posts/%EB%AF%B8%EC%83%9D%EB%AC%BC-%EA%B2%A9%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest, simulation, BFS", "date": "2025-05-18 00:00:00 +0900", "snippet": "미생물 격리문제 번호: SWEA 2382문제 이름: 미생물 격리출처: SWEA 2382번 문제 링크NxN 격자 안에서 미생물 군집들이 상하좌우로 이동한다. 격자 가장자리에 도달하면 미생물 수가 절반으로 줄고 방향이 반대로 바뀐다. 이동 후 같은 칸에 여러 군집이 모이면 가장 큰 군집이 다른 군집을 흡수한다.입력 테스트 케이스 개수 T 각 테스트 케이스마다 다음 정보가 주어진다. N (격자 크기) M (격리 시간) K (군집 개수) K개의 줄에 걸쳐 다음 정보 y, x (위치), 미생물 수, 이동 방향 방향 정보 번호 방향 1 상 2 하 3 좌 4 우 출력각 테스트 케이스마다 다음과 같이 출력#tc_number 정답접근 방식 시뮬레이션 기반 구현 매 시간마다 모든 군집 이동 경계 체크 후 반전 및 수 절반 같은 칸에 모이는 군집 통합 자료 구조 vector 또는 queue 로 군집 저장 map이나 2차원 배열로 군집 위치 추적 및 충돌 처리 주의사항 시간 순서마다 군집 통합은 이동 후에 진행해야 함 가장자리 도달 후 미생물 수가 0이 되면 바로 제거 같은 칸 병합 시 기준 군집은 미생물 수가 가장 많은 군집 #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;#define ARR_MAX_LEN 110typedef struct { int y; int x; int bio_cnt; int dir;}bio_info;int dy[5] = { 0, -1, 1, 0, 0 };int dx[5] = { 0, 0, 0, -1, 1 };int T, N, K, M, answer = 0;vector&lt;bio_info&gt; bio_vec;void init_func() { answer = 0; bio_vec.clear();}void input_func() { int pos_y, pos_x, bio_num, mov_dir; for (int i = 0; i &lt; K; i++) { cin &gt;&gt; pos_y &gt;&gt; pos_x &gt;&gt; bio_num &gt;&gt; mov_dir; bio_vec.push_back({ pos_y, pos_x, bio_num, mov_dir }); }}bool out_of_range_check_func(int y, int x) { // **N-1이 아니라 N-2임에 주의!** return (y &gt;= 1 &amp;&amp; y &lt;= N - 2 &amp;&amp; x &gt;= 1 &amp;&amp; x &lt;= N - 2);}void simulate() { for (int t = 0; t &lt; M; t++) { vector&lt;bio_info&gt; temp_map[N][N]; for (int i = 0; i &lt; bio_vec.size(); i++) { int cy = bio_vec[i].y; int cx = bio_vec[i].x; int dir = bio_vec[i].dir; int cnt = bio_vec[i].bio_cnt; int ny = cy + dy[dir]; int nx = cx + dx[dir]; // 경계에 닿으면 절반 소멸 + 방향 반전 if (!out_of_range_check_func(ny, nx)) { cnt /= 2; if (cnt == 0) continue; if (dir == 1) dir = 2; else if (dir == 2) dir = 1; else if (dir == 3) dir = 4; else if (dir == 4) dir = 3; } bio_info moved; moved.y = ny; moved.x = nx; moved.bio_cnt = cnt; moved.dir = dir; temp_map[ny][nx].push_back(moved); } // 원형 vector clear 후 다시 vec 값 설정(좌표 겹치는 경우 merge 수행) bio_vec.clear(); for (int y = 0; y &lt; N; y++) { for (int x = 0; x &lt; N; x++) { int sz = temp_map[y][x].size(); if (sz == 1) { bio_vec.push_back(temp_map[y][x][0]); } else if (sz &gt; 1) { int total_cnt = 0; int max_cnt = 0; int max_dir = 0; for (int k = 0; k &lt; sz; k++) { total_cnt += temp_map[y][x][k].bio_cnt; if (temp_map[y][x][k].bio_cnt &gt; max_cnt) { max_cnt = temp_map[y][x][k].bio_cnt; max_dir = temp_map[y][x][k].dir; } } bio_info merged; merged.y = y; merged.x = x; merged.bio_cnt = total_cnt; merged.dir = max_dir; bio_vec.push_back(merged); } } } }}void get_answer_func() { for (int i = 0; i &lt; bio_vec.size(); i++) { answer += bio_vec[i].bio_cnt; }}int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; T; for (int tc = 1; tc &lt;= T; tc++) { cin &gt;&gt; N &gt;&gt; M &gt;&gt; K; init_func(); input_func(); simulate(); get_answer_func(); cout &lt;&lt; \"#\" &lt;&lt; tc &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\"; } return 0;}" }, { "title": "아두이노 에어컨 자동 제어", "url": "/posts/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EC%97%90%EC%96%B4%EC%BB%A8-%EC%9E%90%EB%8F%99-%EC%A0%9C%EC%96%B4/", "categories": "CodingTest", "tags": "CodingTest, Embedded Engineering", "date": "2025-05-18 00:00:00 +0900", "snippet": "[아두이노] 에어컨 자동 제어아두이노를 활용하여 에어컨의 리모컨 신호를 복사하고, 원하는 시간에 자동으로 송신하여 에어컨을 제어하는 프로젝트를 진행할 수 있다. 이를 위해 필요한 부품, 회로 연결 방법, 아두이노 코드 예제, 그리고 시간 기반 제어 방법을 자세히 설명한다.1. 필요한 부품 아두이노 보드 (Arduino Uno, ATmega328P) IR 송신 LED (940nm IR LED) IR 수신기 모듈 (VS1838B) 220Ω 저항 RTC 모듈 (DS3231) 브레드보드 및 점퍼 와이어2. 회로 연결 방법IR 수신기 연결| IR 수신기 핀 | 아두이노 핀 || — | — || VCC | 5V || GND | GND || OUT | 디지털 핀 2 |IR 송신기 연결| IR 송신기 핀 | 아두이노 핀 || — | — || IR LED (+) | 디지털 핀 3 (220Ω 저항과 직렬 연결) || IR LED (-) | GND |RTC 모듈 연결 (DS3231)| RTC 모듈 핀 | 아두이노 핀 || — | — || VCC | 5V || GND | GND || SDA | A4 || SCL | A5 |3. 아두이노 코드 예제IR 신호 수신 및 RAW 데이터 획득#include &lt;IRremote.h&gt;#define RECV_PIN = 2;IRrecv irrecv(RECV_PIN);decode_results results;void setup() { Serial.begin(9600); irrecv.enableIRIn(); // IR 수신기 시작}void loop() { if (irrecv.decode(&amp;results)) { Serial.println(\"IR Signal Received:\"); Serial.print(\"Raw Data: \"); for (int i = 0; i &lt; results.rawlen; i++) { Serial.print(results.rawbuf[i], DEC); Serial.print(\",\"); } Serial.println(); irrecv.resume(); // 다음 신호 수신 준비 }}시간에 맞춰 IR 신호 송신하는 코드#include &lt;IRremote.h&gt;#include &lt;Wire.h&gt;#include &lt;RTClib.h&gt;#define EXTERNAL_LED 5#define INTERNAL_LED 13#define IR_LED_PIN 3#define HIGH 1#define LOW 0// Global Variable InitailizeIRsend irsend(IR_LED_PIN);RTC_DS3231 rtc;// 저장된 RAW 데이터 (예시)unsigned int rawData[] = {9000, 4500, 560, 560, 560, 560, /* ... */};unsigned int rawDataLength = sizeof(rawData) / sizeof(rawData[0]);void setup() { Serial.begin(9600); irsend.begin(IR_LED_PIN); if (!rtc.begin()) { Serial.println(\"RTC 모듈을 찾을 수 없습니다.\"); while (1); } if (rtc.lostPower()) { Serial.println(\"RTC 전원이 끊겼습니다. 시간을 설정하세요.\"); rtc.adjust(DateTime(F(__DATE__), F(__TIME__))); }}void loop() { DateTime now = rtc.now(); // 현재 시간 시리얼 출력 Serial.print(\"현재 시간: \"); Serial.print(now.year(), DEC); Serial.print(\"/\"); Serial.print(now.month(), DEC); Serial.print(\"/\"); Serial.print(now.day(), DEC); Serial.print(\" \"); Serial.print(now.hour(), DEC); Serial.print(\":\"); Serial.print(now.minute(), DEC); Serial.print(\":\"); Serial.println(now.second(), DEC); // 동작 디버깅용 내장 LED ON digitalWrite(INTERNAL_LED, HIGH); // digitalWrite(EXTERNAL_LED, HIGH); if (now.hour() == 10 &amp;&amp; now.minute() == 3 &amp;&amp; now.second() == 0) { Serial.println(\"18:00:00 - IR 신호 송신\"); irsend.sendRaw(rawData, rawDataLength, 38); // 38kHz 주파수로 송신 delay(1000); // 중복 송신 방지 } delay(500); // 0.5초 대기 digitalWrite(INTERNAL_LED, LOW); // digitalWrite(EXTERNAL_LED, LOW); delay(500); // 0.5초 대기}" }, { "title": "탈주범 검거", "url": "/posts/%ED%83%88%EC%A3%BC%EB%B2%94-%EA%B2%80%EA%B1%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-05-17 00:00:00 +0900", "snippet": "탈주범 검거📘 문제 개요탈주범이 지하 터널을 통해 도주 중입니다. 경찰은 터널 구조가 주어진 맵에서 탈주범을 추적하려고 합니다. 주어진 시간 L 이내에 도달할 수 있는 위치의 개수를 구하는 것이 목표입니다.🧩 입력 조건 맵은 N x M 크기의 2차원 배열입니다. 각 셀에는 터널의 타입이 들어 있습니다 (0~7). 각 타입에 따라 이동 가능한 방향이 다릅니다. 시작 지점 (x, y)에서 출발하여, 최대 L시간 동안 이동할 수 있습니다. 이동은 터널이 양방향 연결된 경우에만 가능합니다.🔀 터널 타입 및 이동 가능 방향 타입 설명 이동 가능 방향 (상:0, 하:1, 좌:2, 우:3) 0 없음 [] 1 상하좌우 [0, 1, 2, 3] 2 상하 [0, 1] 3 좌우 [2, 3] 4 상우 [0, 3] 5 하우 [1, 3] 6 하좌 [1, 2] 7 상좌 [0, 2] 연결 가능 방향은 양방향이어야 이동할 수 있습니다.💡 BFS 핵심 로직 시작점에서 BFS 탐색 시작 현재 위치에서 연결 가능한 방향으로 이동 이동할 위치의 터널도 해당 방향에서 진입 가능해야 함 시간(L)이 초과되면 탐색 종료#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define ARR_MAX_LEN 55int T, N, M, R, C, L, answer = 0;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int timemap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };typedef struct {\tint y;\tint x;}cord;queue&lt;cord&gt; q;// 상하좌우int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };// vector 도 아래와 같이 배열처럼 초기화 가능vector&lt;vector&lt;int&gt; &gt; tunnel = {\t{},\t{0, 1, 2, 3}, // 1 \t{0, 1}, // 2\t{2, 3}, // 3\t{0, 3}, // 4\t{1, 3}, // 5\t{1, 2}, // 6\t{0, 2}// 7 }; void input_func() {\tcin &gt;&gt; N &gt;&gt; M &gt;&gt; R &gt;&gt; C &gt;&gt; L;\tfor (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tcin &gt;&gt; arrmap[i][j]; \t\t}\t}}void init_func() {\tanswer = 0;\twhile (!q.empty())\t\tq.pop();\tfor (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tisvisited[i][j] = false; timemap[i][j] = 0;\t\t}\t}}void answer_update_func() {\tfor (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tif (isvisited[i][j])\t\t\t\tanswer++;\t\t}\t}}void debug_func(){ for (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tcout &lt;&lt; isvisited[i][j] &lt;&lt; \" \";\t\t} cout &lt;&lt; \"\\n\";\t}}void bfs(int y, int x) {\tq.push({ y, x });\tisvisited[y][x] = true; timemap[y][x] = 0;\twhile (!q.empty()) {\t\tint cy = q.front().y;\t\tint cx = q.front().x;\t\tvector&lt;int&gt; cur_type = tunnel[arrmap[cy][cx]];\t\tq.pop();\t\t//cout &lt;&lt; type.size() &lt;&lt; \"\\n\";\t\t//cout &lt;&lt; \"\\n\";\t\tif (timemap[cy][cx] &gt;= L - 1)\t\t\tcontinue;\t\tfor (int dir = 0; dir &lt; cur_type.size(); dir++) {\t\t\tbool flag = false;\t\t\tint ny = cy + dy[cur_type[dir]];\t\t\tint nx = cx + dx[cur_type[dir]];\t\t\t\t\t\tif (ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M) {\t\t\t\tvector&lt;int&gt; next_type = tunnel[arrmap[ny][nx]];\t\t\t\t// 실수한 부분 현재 방향을 이미 이전 for 문을 통해 알고 있고, 다음 방향이 현재 방향과 반대인지 (ex 좌 &lt;-&gt; 우, 상 &lt;-&gt; 하 인지만 파악하면 됨) \tfor(int j = 0; j &lt; next_type.size(); j++) { \t\tif(cur_type[dir] == 0 &amp;&amp; next_type[j] == 1) \t\t\tflag = true; \t\telse if(cur_type[dir] == 1 &amp;&amp; next_type[j] == 0) \t\t\tflag = true; \t\telse if(cur_type[dir] == 2 &amp;&amp; next_type[j] == 3) \t\t\tflag = true; \t\telse if(cur_type[dir] == 3 &amp;&amp; next_type[j] == 2) \t\t\tflag = true; \t}\t\t\t\tif (!isvisited[ny][nx] &amp;&amp; arrmap[ny][nx] != 0 &amp;&amp; flag) {\t\t\t\t\t//cout &lt;&lt; \"check\\n\";\t\t\t\t\tq.push({ ny, nx });\t\t\t\t\tisvisited[ny][nx] = true;\t\t\t\t\ttimemap[ny][nx] = timemap[cy][cx] + 1;\t\t\t\t}\t\t\t}\t\t}\t}}int main() {\tcin &gt;&gt; T;\tfor (int tc = 1; tc &lt;= T; tc++) {\t\t\t\tinput_func();\t\tinit_func();\t\tbfs(R, C);\t\tanswer_update_func();\t\t // debug_func();\t\tcout &lt;&lt; \"#\" &lt;&lt; tc &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\";\t}\treturn 0;}" }, { "title": "요리사", "url": "/posts/%EC%9A%94%EB%A6%AC%EC%82%AC/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-05-11 00:00:00 +0900", "snippet": "요리사식재료를 나누어 두 개의 음식을 만들고, 두 음식의 맛의 차이가 최소가 되도록 설계해야하는 문제조합을 찾는 문제로 DFS 로 문제를 해결한다. 먼저 조합을 찾아 A 음식에 들어가는 재료를 고르고, A 음식에 들어가지 않은 재료들은 자동으로 B 음식의 재료로 선택된다. 맛을 계산하는 함수를 선언하고 설계하여 재료의 시너지를 모두 더해 맛을 계산한다. 그 맛의 차이가 최소가 되는 최종적인 정답을 찾는다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int synergy[20][20] = { 0 };bool isvisited[20] = { false };int answer = 98765432;int N, T;void init() { \tanswer = 98765432; }void input_func(){\tcin &gt;&gt; N;\tfor(int i = 1; i &lt;= N; i++){\t\tfor(int j = 1; j &lt;= N; j++){\t\t\tcin &gt;&gt; synergy[i][j];\t\t}\t}}int calc_taste(){\tvector&lt;int&gt; A;\tvector&lt;int&gt; B;\tint asum = 0, bsum = 0;\tfor(int i = 1; i &lt;= N; i++){\t\tif(isvisited[i])\t\t\tA.push_back(i);\t\telse\t\t\tB.push_back(i);\t}\tint len = A.size();\t// 순열\tfor(int i = 0; i &lt; len - 1; i++){\t\tfor(int j = i + 1; j &lt; len; j++){\t\t\tasum += (synergy[A[i]][A[j]] + synergy[A[j]][A[i]]); \t\t\tbsum += (synergy[B[i]][B[j]] + synergy[B[j]][B[i]]); \t\t}\t}\treturn abs(asum - bsum);}void dfs(int cnt, int start){\tif(cnt == (N / 2)){\t\tanswer = min(answer, calc_taste());\t\treturn ;\t}\tfor(int i = start; i &lt;= N; i++){\t\tif(isvisited[i])\t\t\tcontinue;\t\tisvisited[i] = true;\t\tdfs(cnt + 1, i + 1);\t\tisvisited[i] = false;\t}}int main(){\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tcin &gt;&gt; T;\tfor(int i = 1; i &lt;= T; i++){ init(); input_func();\t\tdfs(0, 1);\t\tcout &lt;&lt; \"#\" &lt;&lt; i &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\";\t}\treturn 0;}" }, { "title": "로또", "url": "/posts/%EB%A1%9C%EB%98%90/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-05-11 00:00:00 +0900", "snippet": "로또 (BOJ 6603)📘 문제 설명독일 로또는 {1, 2, …, 49} 중에서 서로 다른 6개의 수를 고른다.로또 번호를 고르는 경우의 수를 구하는 프로그램을 작성해야 한다.입력으로 주어지는 수들의 집합 S 중에서 6개를 고르는 모든 조합을사전 순으로 출력해야 한다.📥 입력 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 구성되며,맨 앞의 숫자 k는 수의 개수 (6 &lt; k &lt; 13)그 다음 k개의 수는 집합 S의 원소 입력의 마지막 줄에는 0이 주어진다. (종료 조건)📤 출력 각 테스트 케이스에 대해 집합 S에서 고른 6개의 수를사전 순으로 한 줄에 하나씩 출력한다. 각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.💡 해결 전략 백트래킹(Backtracking) 또는 DFS(깊이 우선 탐색) 를 사용해주어진 수들 중 6개를 고르는 모든 조합 생성풀이#include &lt;iostream&gt;#define LOTTO_COUNT 6using namespace std;int k = 1;int arr[15] = { 0 };int answer[15] = { 0 };bool isvisited[15] = { 0 };void dfs(int cnt, int start){\tif(cnt == LOTTO_COUNT){\t\tfor(int i = 0; i &lt; LOTTO_COUNT; i++){\t\t\tcout &lt;&lt; answer[i] &lt;&lt; \" \";\t\t}\t\tcout &lt;&lt; \"\\n\";\t\treturn ;\t}\tfor(int i = start; i &lt; k; i++){\t\tif(isvisited[i])\t\t\tcontinue;\t\tanswer[cnt] = arr[i];\t\tisvisited[i] = true;\t\tdfs(cnt + 1, i + 1);\t\tisvisited[i] = false;\t}}int main(){\t\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tdo{\t\tcin &gt;&gt; k; if(k == 0) break;\t\tfor(int i = 0; i &lt; k; i++){\t\t\tcin &gt;&gt; arr[i];\t\t}\t\t// 방문 배열의 경우 false 처리로 모두 다시 돌려놓기 때문에 tc가 여러개이더라도 초기화 할 필요는 없음 dfs(0, 0); cout &lt;&lt; \"\\n\";\t}while(true); \treturn 0;}📎 문제 링크https://www.acmicpc.net/problem/6603" }, { "title": "디저트 카페", "url": "/posts/%EB%94%94%EC%A0%80%ED%8A%B8-%EC%B9%B4%ED%8E%98/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-05-11 00:00:00 +0900", "snippet": "디저트 카페문제 설명 및 풀이이 방법 요약N×N 크기의 정사각형 모양의 디저트 카페 지도가 주어진다.각 칸에는 1부터 100 사이의 디저트 종류가 적혀 있다.한 지점에서 출발하여 사각형 모양의 경로를 따라 이동하면서, 각 디저트를 한 번씩만 먹고 출발점으로 돌아오는 경로 중, 가장 많은 디저트를 먹을 수 있는 경로를 찾아야 한다.대각선 방향으로 움직이며 사각형을 그리며 출발한 카페로 돌아오는 루트에서 디저트가 겹치지 않는 경로 중 가장 긴 경로를 찾는 문제이다.미로 탐색과 비슷한 경우로 보이지만, 겹치지 않는 경로 중 가장 긴 이라는 말로 보았을 때 BFS 보단 DFS 로 푸는 문제임을 유추해볼 수 있다.제약 조건 지도 크기 N은 4 이상 20 이하의 정수이다. 한 번 이동할 때, 대각선 방향으로만 이동할 수 있다. 같은 디저트를 두 번 이상 먹을 수 없다. 출발점으로 돌아오는 경로만 유효하다 풀이#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arrmap[21][21] = { 0 };bool check[101] = { false };// 우하 ↘, 우상 ↗, 좌상 ↖, 좌하 ↙int dy[4] = { 1,-1,-1,1 };int dx[4] = { 1,1,-1,-1 };int N, curpos_y, curpos_x, answer;void init_func() { for (int i = 0; i &lt; 101; i++) { check[i] = false; }}void input_func() { cin &gt;&gt; N; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { cin &gt;&gt; arrmap[i][j]; } }}void dfs(int y, int x, int cnt, int dir) { if (dir == 3) { if (y + 1 == curpos_y &amp;&amp; x - 1 == curpos_x) { answer = max(answer, cnt); return; } } int ny = y + dy[dir]; int nx = x + dx[dir]; if (nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N) { if (!check[arrmap[ny][nx]]) { check[arrmap[ny][nx]] = true; dfs(ny, nx, cnt + 1, dir); dfs(ny, nx, cnt + 1, dir + 1); check[arrmap[ny][nx]] = false; } }}int main() { ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); int T; cin &gt;&gt; T; for (int tc = 1; tc &lt;= T; tc++) { answer = -1; // 리셋하는 초기화 필요없음 init_func(); input_func(); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; N; j++) { curpos_y = i; curpos_x = j; check[arrmap[i][j]] = true; dfs(i, j, 1, 0); check[arrmap[i][j]] = false; } } cout &lt;&lt; \"#\" &lt;&lt; tc &lt;&lt; \" \" &lt;&lt; answer &lt;&lt; \"\\n\"; }}" }, { "title": "배열 돌리기 3", "url": "/posts/%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0-3/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-05-10 00:00:00 +0900", "snippet": "배열 돌리기 3 (BOJ 16935)📘 문제 설명크기가 N×M인 2차원 배열 A가 주어진다.이 배열에 대해 R번의 연산을 수행해야 하며, 연산은 총 6가지가 존재한다.각 연산은 배열을 특정 방식으로 변형한다.🔢 연산 설명 상하 반전 (연산 1)배열을 위아래로 뒤집는다. 좌우 반전 (연산 2)배열을 왼쪽과 오른쪽으로 뒤집는다. 오른쪽 90도 회전 (연산 3)배열을 시계 방향으로 90도 회전시킨다.(배열의 행과 열이 뒤바뀜) 왼쪽 90도 회전 (연산 4)배열을 반시계 방향으로 90도 회전시킨다.(배열의 행과 열이 뒤바뀜) 부분 배열 시계 방향 회전 (연산 5)배열을 4개의 동일한 크기의 부분 배열로 나눈 후,각 부분 배열을 시계 방향으로 회전시킨다. 부분 배열 반시계 방향 회전 (연산 6)배열을 4개의 동일한 크기의 부분 배열로 나눈 후,각 부분 배열을 반시계 방향으로 회전시킨다. 📥 입력 첫째 줄: 배열의 크기 N, M과 수행해야 하는 연산의 수 R 둘째 줄부터 N개의 줄: 배열 A의 원소 마지막 줄: 수행할 연산 번호들이 공백으로 구분되어 R개 주어짐📤 출력 R개의 연산을 순서대로 수행한 결과 배열을 출력💡 해결 전략 각 연산을 함수로 정의하여 순차적으로 배열에 적용 회전 연산은 배열 크기가 변경되므로 주의 필요 부분 배열 연산은 배열을 4등분한 후, 해당 위치 이동풀이#include &lt;iostream&gt;#define ARR_MAX_LEN 101using namespace std;int arr[ARR_MAX_LEN][ARR_MAX_LEN] = { {0, }, };int temp[ARR_MAX_LEN][ARR_MAX_LEN] = { {0,}, };int N, M, R;int calc_type = 0;// 우 하 좌 상int dy[4] = { 0,1,0,-1 };int dx[4] = { 1,0,-1,0 };void input_func(){ cin &gt;&gt; N &gt;&gt; M &gt;&gt; R; for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cin &gt;&gt; arr[i][j]; } } }void print_answer_func(){\tfor (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cout &lt;&lt; arr[i][j] &lt;&lt; \" \"; }\t\tcout &lt;&lt; \"\\n\"; }}void copy_arr(){ for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { arr[i][j] = temp[i][j]; } }}// 상하 반전void func1(){\tfor (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[N - 1 - i][j] = arr[i][j]; } } copy_arr();}// 좌우 반전void func2(){\tfor (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[i][M - 1 - j] = arr[i][j]; } } copy_arr();}// 오른쪽 90도 회전 (행을 열으로, 열을 행으로, 대신 행 열 진행 순서는 하나는 달라지므로 이를 생)void func3(){\tfor (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[j][N - 1 - i] = arr[i][j]; } }\tint temp_num = N; N = M; M = temp_num;\tcopy_arr();}// 왼쪽 90도 회전void func4(){\tfor (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[M - 1 - j][i] = arr[i][j]; } }\tint temp_num = N; N = M; M = temp_num;\tcopy_arr();}// 부분 배열 시계 방향 회전 // 반시계 회전은 3번 돌리면 반시계 회전이 되므로 함수를 공유void func5(){ int div_n = N / 2; int div_m = M / 2; // 1 ==&gt; 2 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i][j + div_m] = arr[i][j]; } } // 2 ==&gt; 3 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i + div_n][j + div_m] = arr[i][j + div_m]; } } // 3 ==&gt; 4 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i+ div_n][j] = arr[i + div_n][j + div_m]; } } // 4 ==&gt; 1 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i][j] = arr[i + div_n][j]; } } copy_arr();}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\tinput_func(); \tfor(int i = 0; i &lt; R; i++){\t\tcin &gt;&gt; calc_type;\t\tswitch(calc_type){\t\t\tcase 1:\t\t\t\tfunc1();\t\t\t\tbreak;\t\t\tcase 2:\t\t\t\tfunc2();\t\t\t\tbreak;\t\t\tcase 3:\t\t\t\tfunc3();\t\t\t\tbreak;\t\t\tcase 4:\t\t\t\tfunc4();\t\t\t\tbreak;\t\t\tcase 5:\t\t\t\tfunc5();\t\t\t\tbreak;\t\t\tcase 6:\t\t\t\tfor(int i = 0; i &lt; 3; i++){\t\t\t\t\tfunc5();\t\t\t\t}\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tbreak;\t\t}\t}\tprint_answer_func();\treturn 0;}📎 문제 링크https://www.acmicpc.net/problem/16935" }, { "title": "스타트 택시", "url": "/posts/%EC%8A%A4%ED%83%80%ED%8A%B8-%ED%83%9D%EC%8B%9C/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-09 00:00:00 +0900", "snippet": "스타트 택시 (BOJ 19238)문제 설명스타트링크가 스타트 택시라는 이름의 택시 사업을 시작했다. 스타트 택시는 특이하게도 손님을 도착지로 데려다줄 때마다 연료가 충전되고, 연료가 바닥나면 그 날의 업무가 끝난다.택시 기사 최백준은 오늘 M명의 승객을 태우는 것이 목표이다. 백준이 활동할 영역은 N×N 크기의 격자로 나타낼 수 있고, 각 칸은 비어 있거나 벽이 놓여 있다. 택시가 빈칸에 있을 때, 상하좌우로 인접한 빈칸 중 하나로 이동할 수 있다. 백준은 항상 최단 경로로만 이동한다.택시 운행 규칙 승객은 빈칸 중 하나에 서 있으며, 다른 빈칸으로 이동하려고 한다. 여러 승객이 같이 탑승하지 않는다. 승객은 출발지에서만 탈 수 있고, 목적지에서만 내릴 수 있다. 한 승객을 목적지까지 데려다주는 과정을 M번 반복한다. 택시는 최단거리가 가장 짧은 승객을 우선으로 태운다. 동일 거리일 경우, 행 번호가 작은 승객 → 열 번호가 작은 승객 우선. 한 칸 이동마다 연료 1 소모. 승객 목적지 도착 시, 소모한 연료의 두 배가 충전된다. 이동 도중 연료가 바닥나면 실패하고 업무 종료. 단, 도착과 동시에 연료가 0이 되는 경우는 성공으로 간주한다. 입력 첫 줄: N, M, 초기 연료 (2 ≤ N ≤ 20, 1 ≤ M ≤ N², 1 ≤ 초기 연료 ≤ 500,000) 다음 N줄: 지도 정보 (0: 빈칸, 1: 벽) 다음 줄: 택시 시작 위치 (행, 열) 다음 M줄: 각 승객의 출발지 (행, 열) 와 목적지 (행, 열)모든 좌표는 1-based index.출력 모든 손님을 이동시키고 난 후 남은 연료 출력 단, 이동 중 연료가 부족하거나 손님에게 도달 불가하면 -1 출력예시 설명초기 연료: 15 승객 2까지 거리: 6 → 이동 후 연료 9 → 도착까지 6 소비 → 연료 3 → 충전 12 → 최종 15 승객 1까지 거리: 7 → 목적지까지 7 → 소비 14 → 충전 14 → 연료 15 승객 3까지 거리: 5 → 목적지까지 4 → 소비 9 → 충전 8 → 최종 연료 14#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LEN_2D_MAX 21using namespace std;int N, M, F;int arr[LEN_2D_MAX][LEN_2D_MAX] = { 0, };bool isvisited[LEN_2D_MAX][LEN_2D_MAX] = { false, };int dist[LEN_2D_MAX][LEN_2D_MAX] = { 0, };int dy[4] = { 0,1,0,-1 };int dx[4] = { 1,0,-1,0 };struct pos{\tint y;\tint x;};vector&lt;pos&gt; people; // 손님 시작 위치vector&lt;pos&gt; dst; // 손님 도착 위치pos taxi; // 현재 택시 위치void bfs(int y, int x){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tq.push(make_pair(y, x));\tisvisited[y][x] = true;\tdist[y][x] = 0;\twhile (!q.empty())\t{\t\tint cy = q.front().first;\t\tint cx = q.front().second;\t\tq.pop();\t\tfor (int dir = 0; dir &lt; 4; dir++)\t\t{\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\t\tif (ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N)\t\t\t{\t\t\t\tif (!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == 0)\t\t\t\t{\t\t\t\t\tq.push(make_pair(ny, nx));\t\t\t\t\tisvisited[ny][nx] = true;\t\t\t\t\tdist[ny][nx] = dist[cy][cx] + 1;\t\t\t\t}\t\t\t}\t\t}\t}}void simulate(){\tfor (int pn = 0; pn &lt; M; pn++)\t{\t\t// 초기화 후 손님까지 거리 계산\t\tmemset(isvisited, false, sizeof(isvisited));\t\tmemset(dist, 0, sizeof(dist));\t\tbfs(taxi.y, taxi.x);\t\tint min_dist = 87654321;\t\tint ny = 0, nx = 0, idx = -1;\t\t// 가장 가까운 손님 찾기 (거리 → 행 → 열 우선순위)\t\tfor (int i = 0; i &lt; people.size(); i++)\t\t{\t\t\tint cy = people[i].y;\t\t\tint cx = people[i].x;\t\t\tif (!isvisited[cy][cx]) {\t\t\t\t// 손님에게 도달 불가\t\t\t\tprintf(\"-1\\n\");\t\t\t\texit(0);\t\t\t}\t\t\tif (dist[cy][cx] &lt; min_dist)\t\t\t{\t\t\t\tny = cy;\t\t\t\tnx = cx;\t\t\t\tidx = i;\t\t\t\tmin_dist = dist[cy][cx];\t\t\t}\t\t\telse if (dist[cy][cx] == min_dist)\t\t\t{\t\t\t\tif (ny &gt; cy || (ny == cy &amp;&amp; nx &gt; cx))\t\t\t\t{\t\t\t\t\tny = cy;\t\t\t\t\tnx = cx;\t\t\t\t\tidx = i;\t\t\t\t}\t\t\t}\t\t\t\t\t\t}\t\t// 손님 위치로 이동 및 기름 업데이트\t\tF -= dist[ny][nx];\t\tif (F &lt; 0) {\t\t\tF = -1;\t\t\tbreak;\t\t}\t\t// 택시 위치 갱신 및 손님 제거\t\ttaxi.y = ny;\t\ttaxi.x = nx;\t\tpos dest = dst[idx];\t\tpeople.erase(people.begin() + idx);\t\t\t\t// 목적지까지 거리 구하기\t\tmemset(isvisited, false, sizeof(isvisited));\t\tmemset(dist, 0, sizeof(dist));\t\tbfs(taxi.y, taxi.x);\t\t// 손님과 매칭되는 목적지\t\tint cy = dest.y;\t\tint cx = dest.x;\t\tif (!isvisited[cy][cx]) {\t\t\tprintf(\"-1\\n\");\t\t\texit(0);\t\t}\t\t// 목적지 제거\t\tdst.erase(dst.begin() + idx);\t\t// 기름 업데이트\t\tF -= dist[cy][cx];\t\tif (F &lt; 0) {\t\t\tF = -1;\t\t\tbreak;\t\t}\t\t// 목적지에 도착한 경우 택시 위치 업데이트 및 연료 보충\t\tF += (dist[cy][cx] * 2);\t\ttaxi.y = cy;\t\ttaxi.x = cx;\t}\treturn;}int main(int argc, char** argv){\tscanf(\"%d %d %d\", &amp;N, &amp;M, &amp;F);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\tscanf(\"%d %d\", &amp;taxi.y, &amp;taxi.x);\ttaxi.y--; taxi.x--; // 0-based로 좌표 변경\tfor (int i = 0; i &lt; M; i++)\t{\t\tint a, b, c, d;\t\tscanf(\"%d %d %d %d\", &amp;a, &amp;b, &amp;c, &amp;d);\t\t// 0-base 로 좌표 변경\t\ta--;\t\tb--;\t\tc--;\t\td--;\t\tpeople.push_back({ a, b });\t\tdst.push_back({ c, d });\t}\tsimulate();\t// 예외처리는 이미 수행하고 -1 인 경우는 프로그램이 종료되므로 바로 답 출력\tprintf(\"%d\\n\", F);\treturn 0;}" }, { "title": "배열 돌리기", "url": "/posts/%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-08 00:00:00 +0900", "snippet": "배열 돌리기 (BOJ 17276)문제 설명n x n 크기의 배열 X가 있다. 이 배열을 특정 각도 d만큼 회전시키는 작업을 수행해야 한다. 회전은 배열의 중심을 기준으로 시계 방향 또는 반시계 방향으로 이루어진다. 각도 d는 45의 배수이며, 양수이면 시계 방향, 음수이면 반시계 방향으로 회전한다. 반시계 45° 회전           원본 배열 X           시계 45° 회전         3 2 5 4 15   1 2 3 4 5   11 2 1 4 3 6 8 9 14 10   6 7 8 9 10   6 12 7 8 10 1 7 13 19 25   11 12 13 14 15   21 17 13 9 5 16 12 17 18 20   16 17 18 19 20   16 18 19 14 20 11 22 21 24 23   21 22 23 24 25   23 22 25 24 15 입력 첫째 줄에 테스트 케이스의 수 T가 주어진다. (1 ≤ T ≤ 10) 각 테스트 케이스에 대해: 첫째 줄에 배열의 크기 n (1 ≤ n &lt; 500, n은 홀수)과 회전 각도 d가 주어진다. (0 ≤ d ≤ 360, d 는 45의 배수) 다음 n개의 줄에는 배열 X의 각 행이 주어진다. 각 원소는 1 이상 1,000,000 이하의 정수이다. 출력각 테스트 케이스에 대해 회전 연산을 마친 후 배열의 상태를 출력한다. n개의 줄에 걸쳐 각 줄에 n개의 정수를 공백으로 구분하여 출력한다.#include &lt;iostream&gt;using namespace std;#define ARR_MAX_LEN 550int T, n, d;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int tempmap[ARR_MAX_LEN][ARR_MAX_LEN]={ 0 };void input_func() {\t\tcin &gt;&gt; n &gt;&gt; d;\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++) {\t\t\tcin &gt;&gt; arrmap[i][j];\t\t}\t}}void rotate45() {\tint center = n / 2;\tfor (int i = 0; i &lt; n; i++)\t\ttempmap[i][center] = arrmap[i][i];\tfor (int i = 0; i &lt; n; i++)\t\ttempmap[i][n - 1 - i] = arrmap[i][center];\tfor (int i = 0; i &lt; n; i++)\t\ttempmap[center][n - 1 - i] = arrmap[i][n - 1 - i];\tfor (int i = 0; i &lt; n; i++)\t\ttempmap[n - 1 - i][n - 1 - i] = arrmap[center][n - 1 - i];}void copy_arr() {\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++) {\t\t\tarrmap[i][j] = tempmap[i][j];\t\t}\t}}void print_answer() {\tfor (int i = 0; i &lt; n; i++) {\t\tfor (int j = 0; j &lt; n; j++) {\t\t\tcout &lt;&lt; arrmap[i][j] &lt;&lt; \" \";\t\t}\t\tcout &lt;&lt; \"\\n\";\t}}int main() {\t\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\tcin &gt;&gt; T;\tfor (int i = 0; i &lt; T; i++) {\t\t// 0. 입력값 받기 및 회전 횟수 카운팅하기\t\tinput_func();\t\tint cnt = ((d + 360) % 360) / 45;\t\t// 1. 최초 임시 배열에 값 업데이트\t\tfor (int r = 0; r &lt; n; r++) {\t\t\tfor (int c = 0; c &lt; n; c++) {\t\t\t\ttempmap[r][c] = arrmap[r][c];\t\t\t}\t\t}\t\tfor (int rot = 0; rot &lt; cnt; rot++) {\t\t\t// 2. 회전하고 값 업데이트, 회전할 때 변하지 않는 값은 임시배열에는 최초 한번만 업데이트 하면됨 (1번에서 수행)\t\t\trotate45();\t\t\tcopy_arr();\t\t}\t\t// 3. 정답 출력\t\tprint_answer();\t}\treturn 0;}" }, { "title": "배열 돌리기1,2", "url": "/posts/%EB%B0%B0%EC%97%B4-%EB%8F%8C%EB%A6%AC%EA%B8%B01,2/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-07 00:00:00 +0900", "snippet": "배열 돌리기1,2 (BOJ 16926, 16927)배열 돌리기1https://www.acmicpc.net/problem/16926문제 설명문제크기가 N×M인 배열이 있을 때, 배열에 저장된 값을 시계 방향으로 돌리는 연산을 수행하려고 한다.배열을 돌릴 때는 다음과 같은 방식으로 연산이 수행된다.A[1][1] ← A[1][2] ← A[1][3] ← A[1][4] ← A[1][5] ↓ ↑A[2][1] A[2][2] ← A[2][3] ← A[2][4] A[2][5] ↓ ↓ ↑ ↑A[3][1] A[3][2] → A[3][3] → A[3][4] A[3][5] ↓ ↑A[4][1] → A[4][2] → A[4][3] → A[4][4] → A[4][5] 가장 바깥쪽에 있는 배열의 모든 원소를 시계 방향으로 한 칸 이동한다. 그 다음 바깥쪽에서 두 번째에 있는 배열의 모든 원소를 시계 방향으로 한 칸 이동한다. 위의 과정을 R번 반복한다.예를 들어 아래와 같은 배열을 2번 회전시키면 다음과 같이 변하게 된다.예시1 2 3 4 2 3 4 8 3 4 8 65 6 7 8 1 7 7 6 2 7 8 29 8 7 6 → 5 6 8 2 → 1 7 6 35 4 3 2 9 5 4 3 5 9 5 4 &lt;시작&gt; &lt;회전1&gt; &lt;회전2&gt;입력첫째 줄에 배열의 크기 N, M과 수행해야 하는 회전 수 R이 주어진다. (2 ≤ N, M ≤ 300, 1 ≤ R ≤ 1,000)둘째 줄부터 N개의 줄에 배열의 원소 Aij가 주어진다. (1 ≤ Aij ≤ 10⁸)출력입력으로 주어진 배열을 R번 회전시킨 결과를 출력한다.돌릴 수 없는 케이스는 문제 조건을 통해 제외됨#include &lt;iostream&gt;using namespace std;#define ARR_MAX_LEN 550int N, M, R;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int tempmap[ARR_MAX_LEN][ARR_MAX_LEN]={ 0 };int flattenarr[ARR_MAX_LEN * ARR_MAX_LEN] = { 0 };void input_func() {\tcin &gt;&gt; N &gt;&gt; M &gt;&gt; R;\tfor (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tcin &gt;&gt; arrmap[i][j];\t\t}\t}}void print_answer() {\tfor (int i = 0; i &lt; N; i++) {\t\tfor (int j = 0; j &lt; M; j++) {\t\t\tcout &lt;&lt; arrmap[i][j] &lt;&lt; \" \";\t\t}\t\tcout &lt;&lt; \"\\n\";\t}}void rotate_func() {\tint roatate_cnt = N &gt; M ? (M / 2) : (N / 2);\t\t// 회전할 사각형의 갯수만큼 회전\tfor (int i = 0; i &lt; roatate_cnt; i++) {\t\tint up = i, down = N - 1 - i, left = i, right = M - 1 - i;\t\t// 시작포인트 백업\t\tint start_point = arrmap[i][i];\t\t// 좌\t\tfor (int j = left; j &lt; right; j++) {\t\t\tarrmap[up][j] = arrmap[up][j + 1];\t\t}\t\t// 상\t\tfor (int j = up; j &lt; down; j++) {\t\t\tarrmap[j][right] = arrmap[j + 1][right];\t\t}\t\t// 우\t\tfor (int j = right; j &gt; left; j--) {\t\t\tarrmap[down][j] = arrmap[down][j - 1];\t\t}\t\t// 하\t\tfor (int j = down; j &gt; up; j--) {\t\t\tarrmap[j][left] = arrmap[j - 1][left];\t\t}\t\t// 시작포인트 값 이동\t\tarrmap[i + 1][i] = start_point;\t}}int main() {\t\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL);\t\t\tinput_func();\tfor (int i = 0; i &lt; R; i++) {\t\trotate_func();\t}\tprint_answer();\treturn 0;}배열 돌리기2문제크기가 N×M인 배열이 있을 때, 배열을 돌려보려고 한다. 배열은 다음과 같이 반시계 방향으로 돌려야 한다.A[1][1] ← A[1][2] ← A[1][3] ← A[1][4] ← A[1][5] ↓ ↑A[2][1] A[2][2] ← A[2][3] ← A[2][4] A[2][5] ↓ ↓ ↑ ↑A[3][1] A[3][2] → A[3][3] → A[3][4] A[3][5] ↓ ↑A[4][1] → A[4][2] → A[4][3] → A[4][4] → A[4][5]예를 들어, 아래와 같은 배열을 2번 회전시키면 다음과 같이 변하게 된다.배열과 정수 R이 주어졌을 때, 배열을 R번 회전시킨 결과를 구해보자.예시1 2 3 4 2 3 4 8 3 4 8 65 6 7 8 1 7 7 6 2 7 8 29 8 7 6 → 5 6 8 2 → 1 7 6 35 4 3 2 9 5 4 3 5 9 5 4 &lt;시작&gt; &lt;회전1&gt; &lt;회전2&gt;입력첫째 줄에 배열의 크기 N, M과 수행해야 하는 회전의 수 R이 주어진다.둘째 줄부터 N개의 줄에 배열 A의 원소 Aij가 주어진다.출력입력으로 주어진 배열을 R번 회전시킨 결과를 출력한다.https://www.acmicpc.net/problem/16927배열 돌리기 1과 다른 점은 회전 횟수가 훨씬 많아진다는 것 따라서 이를 보완할 필요가 있다.#include &lt;iostream&gt;using namespace std;#define ARR_MAX_LEN 330int arr[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int N, M, R;// 우 하 좌 상int dy[4] = { 0,1,0,-1 };int dx[4] = { 1,0,-1,0 };void input_func(){\tcin &gt;&gt; N &gt;&gt; M &gt;&gt; R; scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;R); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cin &gt;&gt; arr[i][j]; } }}void rotate_func(int startp,int rot_cnt) { int rot_iter = R % rot_cnt; //회전 횟수 설정 for (int i = 0; i &lt; rot_iter; i++) { int startPoint = arr[startp][startp]; // 박스 시작 포인트 설정(시작 지점 백업) int cy = startp; int cx = startp; int dir = 0;\t\t// 좌 상 우 하 순으로 옮겨짐 while (dir &lt; 4) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &gt;= startp &amp;&amp; ny &lt;= N - 1 - startp &amp;&amp; nx &gt;= startp &amp;&amp; nx &lt;= M - 1- startp) { //차례로 시계 반대방향으로 옮김 arr[cy][cx] = arr[ny][nx]; cy = ny; cx = nx; }\t\t\t//다음에 옮길 칸이 배열 범위 넘어가버리면 해당 방향은 다 옮긴 것이므로 k 증가 else { dir++; } } arr[startp + 1][startp] = startPoint; //백업 데이터 저장 }}void print_answer_func(){ //결과 출력 for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cout &lt;&lt; arr[i][j] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; }}int main() {\tios::sync_with_stdio(false);\tcin.tie(NULL);\tcout.tie(NULL); input_func(); \t// 회전할 사각형의 갯수를 계산 int cnt = N &gt; M ? (M / 2) : (N / 2); int n = N, m = M; for (int i = 0; i &lt; cnt; i++) { \t\t// rotate 가 필요한 횟수를 계산한다. (사각형 각 변에 길이 * 2 에 겹치는 꼭지점을 빼주면 됨) int rot_cnt = (2 * n) + (2 * m) - 4;\t\t// 시작포인트, 회전 횟수를 매개변수로 받는 함수를 호출한다. (시작 포인트의 좌표는 행 열 변의 길이가 달라도 0,0 -&gt; 1,1 -&gt; 2,2 로 변하므로 하나만 넘겨줘도 된다다) rotate_func(i, rot_cnt);\t\t// 다음 사각형의 길이는 길이가 2 줄어드니까 길이를 업데이트 해준다. n -= 2; m -= 2; } print_answer_func(); return 0;}" }, { "title": "미로 탐색", "url": "/posts/%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-07 00:00:00 +0900", "snippet": "미로 탐색문제N×M크기의 배열로 표현되는 미로가 있다.1\t0\t1\t1\t1\t11\t0\t1\t0\t1\t01\t0\t1\t0\t1\t11\t1\t1\t0\t1\t1미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.입력첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.출력첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.예제4 6101111101010101011111011풀이#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int N, M;char arrmap[101][101];bool isvisited[100][100] = { { false } };int check[100][100] = { { 0 } };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int x, int y){ isvisited[x][y] = true; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(make_pair(x, y)); while(!q.empty()) { int cx = q.front().first; int cy = q.front().second; q.pop(); for(int i = 0; i &lt; 4; i++) { int nx = cx + dx[i]; int ny = cy + dy[i]; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) { if(isvisited[nx][ny] == false &amp;&amp; arrmap[nx][ny] == '1') { q.push(make_pair(nx, ny)); isvisited[nx][ny] = true; check[nx][ny] = check[cx][cy] + 1; } } } }}int main(void){ scanf(\"%d %d1\", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) { scanf(\"%s\", arrmap[i]); } bfs(0, 0); printf(\"%d\", check[N-1][M-1] + 1); return 0;}" }, { "title": "활주로 건설", "url": "/posts/%ED%99%9C%EC%A3%BC%EB%A1%9C-%EA%B1%B4%EC%84%A4/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-05 00:00:00 +0900", "snippet": "활주로 건설" }, { "title": "순열과 조합", "url": "/posts/%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-05-05 00:00:00 +0900", "snippet": "순열과 조합순열정복 1 (중복 순열)문제 설명양의 정수 N과 M이 주어졌을 때,1부터 N까지의 정수를 M번 나열할 수 있는 모든 경우를 출력하는 프로그램을 작성하시오.나열되는 숫자는 중복해서 사용이 가능하다.입력양의 정수 N과 M이 공백을 사이에 두고 주어진다.(1 ≤ N ≤ 6, 1 ≤ M ≤ 6)출력1부터 N까지의 자연수를 M번 나열하는 모든 경우를 출력한다.출력은 사전 순(앞 자리 오름차순)으로 출력한다.풀이#include &lt;iostream&gt;using namespace std;int N, M;int answer[6] = { 0 };void dfs(int cnt){ if(cnt == M){ for(int i = 0; i &lt; M; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; } for(int i = 1; i &lt;= N; i++){ answer[cnt] = i; dfs(cnt + 1); }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; dfs(0); return 0;}순열(중복 없이)문제 설명1부터 N까지의 정수들을 M번 나열하는 모든 경우를 출력하는 프로그램을 작성하시오.단, 중복되는 숫자는 사용할 수 없다.입력한 줄에 두 자연수 N과 M이 공백을 사이에 두고 주어진다.(1 ≤ M ≤ N ≤ 7)출력1부터 N까지의 자연수를 중복 없이 M개 나열한 모든 경우를 출력한다.출력은 사전 순으로 증가하는 순서로 출력해야 한다.#include &lt;iostream&gt;using namespace std;// N: 1부터 N까지의 숫자 사용// M: M개를 선택하여 나열int N, M;// 정답 배열: 현재 선택된 수열을 저장int answer[7] = { 0 };// 방문 여부 체크 배열: 같은 숫자를 중복해서 사용하지 않도록 하기 위해 사용bool isvisited[7] = { 0 };// 깊이 우선 탐색 함수// cnt: 현재까지 선택한 수의 개수 (depth)void dfs(int cnt){ // M개의 수를 모두 선택한 경우 출력 if(cnt == M){ for(int i = 0; i &lt; M; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; } // 1부터 N까지의 수 중 하나 선택 for(int i = 1; i &lt;= N; i++){ // 이미 방문한 숫자면 건너뛴다 (중복 방지) if(isvisited[i]) continue; // 현재 위치(cnt)에 숫자 i 저장 answer[cnt] = i; // 숫자 i를 사용했으므로 방문 표시 isvisited[i] = true; // 다음 위치(cnt + 1)를 채우기 위해 재귀 호출 dfs(cnt + 1); // 재귀가 끝나고 돌아오면, i를 다시 사용할 수 있도록 방문 해제 // → 백트래킹의 핵심: 선택을 원상복구해서 다음 경우 탐색 isvisited[i] = false; }}int main(){ // 입출력 최적화 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); // 입력 받기 cin &gt;&gt; N &gt;&gt; M; // DFS 시작 (0개 선택된 상태에서 시작) dfs(0); return 0;}입력을 따로 받는 순열(중복 없이)문제 설명이번 문제는 1부터 N까지의 자연수를 자동으로 쓰는 게 아니라,사용자가 직접 입력한 N개의 서로 다른 자연수 중에서중복 없이 M개를 나열하는 모든 경우를 출력하는 것이다. 단, 같은 수는 한 번만 사용할 수 있고,출력 순서는 사전 순(오름차순)이어야 한다.입력 첫째 줄: 두 자연수 N, M이 주어진다(1 ≤ M ≤ N ≤ 7) 둘째 줄: 오름차순으로 정렬된 서로 다른 N개의 자연수가 주어진다(1 ≤ ai ≤ 100) 출력 N개의 자연수 중에서 M개를 중복 없이 나열한 모든 경우를 출력한다 각 수열은 한 줄에 출력하며, 출력 순서는 사전 순(오름차순)이다#include &lt;iostream&gt;using namespace std;int N, M;int answer[7] = { 0 };int input_arr[7] = { 0 };bool isvisited[7] = { false }; void dfs(int cnt){ if(cnt == M){ for(int i =0; i &lt; M; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; } for(int i = 0; i &lt; N; i++){ if(isvisited[i]) continue; answer[cnt] = input_arr[i]; isvisited[i] = true; dfs(cnt + 1); isvisited[i] = false; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; input_arr[i]; } dfs(0); return 0;}순열정복 4 (중복 조합)문제여러분은 세상에서 제일 재밌기로 소문난 순열정복 과정을 진행중이다.오늘의 목표는 두구두구두구두구….1..N까지의 자연수를 중복을 허용하여 M번 나열하는데, 같은 조합은 한 번만 출력되게 하는 것이다.예를 들어 1 1 2, 1 2 1, 2 1 1 는 모두 같은 조합이다.즉, 1 1 2만 출력되고 나머지 두 경우는 출력되지 않아야 한다.입력자연수 N과 M이 주어진다. (1≤N≤7 , 1≤M≤7)출력N개의 자연수를 중복을 허용하여 M번 나열하는 경우를 모두 출력하되, 같은 조합은 한 번만 출력되게 하라.당연히 출력순서는 오름차순이다.풀이내 풀이#include &lt;iostream&gt;using namespace std;int N, M;int answer[8] = { 0 };bool isvisited[8] = { false }; void dfs(int cnt){ if(cnt == M){ // 같은 조합은 한번만 출력되도록 그리고 오름차순으로만 출력되도록 조건 추가 for(int i = 0; i &lt; M - 1; i++){ if(answer[i] &gt; answer[i + 1]) return ; } for(int i = 0; i &lt; M; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; } for(int i = 1; i &lt;= N; i++){ answer[cnt] = i; dfs(cnt + 1); }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; dfs(0); return 0;}정석 풀이#include &lt;iostream&gt;using namespace std;int N, M;int answer[8] = { 0 };bool isvisited[8] = { false }; void dfs(int cnt, int start){ if(cnt == M){ for(int i = 0; i &lt; M; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; }\t// 시작 포인트를 매개변수로 받아 for(int i = start; i &lt;= N; i++){ answer[cnt] = i; dfs(cnt + 1, i); }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M;\t// 시작 숫자는 1부터 시작하므로 0, 1 을 입력으로 넣어준다. dfs(0, 1); return 0;}순열정복 5문제여러분들이 가장 좋아하는 바로 그 시간, 순열정복 과정 5탄!오늘의 목표는 1..N까지의 숫자를 중복을 허용하여 M개를 나열하되, 합이 정확히 S가 되는 경우를 출력하는 것이다.입력첫 줄에 자연수 N,M,S가 주어진다. (1≤N≤​6 , 1≤​M≤​6 , 1≤​S≤​N*M )출력문제의 조건에 맞는 모든 경우를 오름차순으로 출력한다.풀이내 풀이 (71ms)#include &lt;iostream&gt;using namespace std;int answer[7] = { 0 };int N, M, S;void dfs(int cnt){ if(cnt == M){ int sum = 0; for(int i =0; i &lt; M; i++) sum += answer[i]; if(sum != S) return ; for(int i =0; i &lt; M; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; } for(int i = 1; i &lt;= N; i++){ answer[cnt] = i; dfs(cnt + 1); }}int main(){ cin &gt;&gt; N &gt;&gt; M &gt;&gt; S; dfs(0); return 0;}정석 풀이#include &lt;iostream&gt;using namespace std;int N, M, S;int seq[8]; void dfs(int depth, int sum) { // M개를 모두 선택한 경우 if (depth == M) { if (sum == S) { for (int i = 0; i &lt; M; i++) { cout &lt;&lt; seq[i] &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; } return; } for (int i = 1; i &lt;= N; i++) { if (sum + i &gt; S) continue; // 합이 초과되면 가지치기 seq[depth] = i; dfs(depth + 1, sum + i); // 배열은 덮어쓰므로 별도 백트래킹 필요 없음 }}int main() { cin &gt;&gt; N &gt;&gt; M &gt;&gt; S; dfs(0, 0); return 0;}순열 정복 6문제사실 진짜 재밌는 순열정복은 지금부터 시작이다.참고로 너무 재밌어서 둘이 풀다가 하나가 죽어도 정올에서는 책임지지 않는다.오늘은 자연수 S만 입력받는다.여러분은 합이 S가 되는 모든 자연수들의 조합을 출력하면 된다.이미 알고 있겠지만, “조합”이라고 하면 같은 구성으로 된 순열은 하나로 친다.예를 들어, 아래의 순열들은 하나의 조합이므로, 헷갈리지 말자1 1 2 21 2 2 11 2 1 22 2 1 12 1 2 12 1 1 2입력첫 줄에 자연수 S가 주어진다. (1 ≤ S ≤ 20)출력합이 S가 되는 모든 자연수 조합을 출력한다.같은 조합중에서는 … 엄… 맨날 오름차순만 하면 재미없으니깐 오늘은 내림차순으로 먼저 나오는 조합만 출력한다.자세한 사항은 출력예시를 보면 이해하기 쉬울 것이다.#include &lt;iostream&gt;using namespace std;// 결과를 저장할 배열 (최대 20개 정도로 충분)int answer[21] = { 0 };// 목표 합int S;// DFS 함수// cnt : 현재까지 선택한 수의 개수 (깊이)// sum : 현재까지 선택된 수들의 합// start: 다음 선택할 수의 최대값 (내림차순 유지하기 위해 사용)void dfs(int cnt, int sum, int start){ // 종료 조건 1: 정확히 합이 S가 되었을 때 → 출력 if(sum == S){ for(int i = 0; i &lt; cnt; i++){ cout &lt;&lt; answer[i] &lt;&lt; \" \"; } cout &lt;&lt; '\\n'; return ; } // 종료 조건 2: 현재 합이 S를 넘었거나, 너무 많이 선택한 경우 if(cnt == S || sum &gt; S) return ; // 1부터 start까지 수 중 선택 (내림차순) for(int i = start; i &gt;= 1; i--){ // i를 현재 위치에 넣고 누적합 업데이트 answer[cnt] = i; sum += i; // 다음 숫자도 i 이하만 선택 (중복 허용, 내림차순 유지) dfs(cnt + 1, sum, i); // 백트래킹: 원상복구 sum -= i; }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); // 입력: 목표 합 S cin &gt;&gt; S; // DFS 시작 (깊이 0, 현재 합 0, 최대 선택값 S) dfs(0, 0, S); return 0;}순열 정복(문자열, 조합)문제순열정복 과정이 너무 재밌어서 춤을 추고 싶을 정도로 신난다면, 지금 추고 오도록 하자.자, 이제부터가 진짜 실전이다. 연습의 성과를 내보도록 하자.패션여왕은 매일 N종류의 옷을 입는다. 예를 들어서 모자,상의,하의,양말,신발,핸드백이라면, 6종류가 되는 것이다.패션여왕은 패션여왕이기 때문에, 그녀가 가지고 있는 옷으로 매일매일 다른 패션을 선보이려고 한다.패션여왕의 옷으로 만들 수 있는 모든 조합을 출력하는 프로그램을 작성한다.입력첫 줄에 옷의 종류인 N이 주어진다.(N≤6)다음 줄부터 두 줄에 걸쳐서 다음 정보가 들어온다.첫번째 줄엔 i번째 의류의 개수인 Mi가 들어오고,두번째 줄에는 Mi개의 의류 이름이 공백을 사이에 두고 주어진다. ( Mi≤5, 그렇다. 소위 “패션여왕”은 사실 상의든 하의든 신발이든 5개씩밖에 없나보다.)의류 이름은 25자 이내의 공백 없는 문자열이다.자세한 사항은 입출력 예시를 참고하라.출력나올 수 있는 모든 옷의 조합을 출력한다.([의류1],[의류2],…,[의류N])의 형식으로 출력한다. 조합 순서는 입력받은 순서의 오름차순이다.입출력 예시를 보면 이해하기 쉬울 것 같다.풀이#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int N, M;vector&lt;vector&lt;string&gt;&gt; clothes;vector&lt;string&gt; combination;void dfs(int depth){ if(depth == N){ cout &lt;&lt; \"(\"; for(int i = 0; i &lt; N; i++){ if(i != N - 1) cout &lt;&lt; combination[i] &lt;&lt; \",\"; else cout &lt;&lt; combination[i]; } cout &lt;&lt; \")\\n\"; return ; } for(int i = 0; i &lt; clothes[depth].size(); i++){ combination[depth] = clothes[depth][i]; dfs(depth + 1); }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; clothes.resize(N); combination.resize(N); for(int i = 0; i &lt; N; i++){ cin &gt;&gt; M; clothes[i].resize(M); for(int j = 0; j &lt; M; j++) cin &gt;&gt; clothes[i][j]; } dfs(0); return 0;}순열정복 8문제순열정복 과정의 대단원이다. 아~~하고 여러분들이 아쉬워하는 소리가 여기까지 들린다.“더 이상 이 Fun Fun한 재미를 느낄 수 없다니 ㅠㅠ”오늘 여러분들에게는 배열이 하나 주어진다. 여러분들의 목적은 아래 조건을 만족하는 모든 부분 배열을 출력하는 것이다. 조건 : 부분 배열에서 인접한 수의 차이가 K를 넘지 않는다.이 문제에서 “부분 배열”이라 함은, 원래 순서를 바꾸지 않고 배열에서 한개 이상의 수를 골라서 만든 배열을 말한다.예를 들어 배열 원소 {7,2,5,3} 을 가지고 부분 배열을 만든다면,{7,2,3}은 부분 배열이지만, {2,3,5}는 부분 배열이 아니다.입력첫 줄에 배열의 크기인 N과 부분 배열에서 인접한 수끼리의 차의 상한선인 K값이 주어진다.둘째 줄에 N개의 배열의 원소 Ai가 주어진다.(1≤N≤​10 , 1≤​K≤​100 , 1≤​Ai​≤​100)출력조건에 맞는 모든 부분 배열을 출력한다.출력순서는, A1이 포함된 부분 배열을 우선해서 출력하고 포함되지 않은 부분 배열보다,같은 우선순위끼리는 A2가 포함된 부분 배열을 우선해서 출력하고…같은 우선순위끼리는 AN이 포함된 부분 배열을 우선해서 출력하는 순서이다.(길이가 1인 배열도 답이 될 수 있음에 유의한다. 그러나 길이가 0인 빈 배열은 답이 될 수 없다.)풀이" }, { "title": "단지번호붙이기", "url": "/posts/%EB%8B%A8%EC%A7%80%EB%B2%88%ED%98%B8%EB%B6%99%EC%9D%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-04 00:00:00 +0900", "snippet": "단지번호붙이기문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다.철수는 이 지도를 가지고 연결된 집들의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다.여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다.대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다.지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고,그 다음 N줄에는 각각 N개의 자료(0 혹은 1)이 입력된다.출력첫 번째 줄에는 총 단지수를 출력하시오.그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오풀이bfs 로 문제를 해결한다. 영역 갯수는 bfs 를 돌리는 count 로 해결하고 영역 넓이는 queue 에 넣은 원소의 갯수로 구한다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define ARR_MAX_LEN 26int N, sector_cnt = 0, house_cnt = 0;int arr[ARR_MAX_LEN][ARR_MAX_LEN] = { 0, };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false, }; int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1};vector&lt;int&gt; sector;queue&lt;pair&lt;int, int&gt; &gt;q;void bfs(){\t\twhile(!q.empty()){\t\tint cy = q.front().first;\t\tint cx = q.front().second;\t\tq.pop();\t\thouse_cnt++;\t\tfor(int dir = 0; dir &lt; 4; dir++){\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\t\t\t\t\t if(ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N){\t\t\t \tif(!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == 1){\t\t\t \t\tq.push({ny, nx});\t\t\t \t\tisvisited[ny][nx] = true;\t\t\t \t}\t\t\t } \t\t}\t}\t}int main(){\tcin &gt;&gt; N; \tfor(int i = 0; i &lt; N; i++){\t\tfor(int j = 0; j &lt; N; j++){\t\t\tscanf(\"%1d\", &amp;arr[i][j]);\t\t}\t} \tfor(int i = 0; i &lt; N; i++){\t\tfor(int j = 0; j &lt; N; j++){\t\t\tif(arr[i][j] == 1 &amp;&amp; !isvisited[i][j]){\t\t\t\thouse_cnt = 0;\t\t\t\tq.push({i, j});\t\t\t\tisvisited[i][j] = true; \t\t\t\tbfs();\t\t\t\tsector_cnt++;\t\t\t\tsector.push_back(house_cnt);\t\t\t} \t\t}\t}\t\tcout &lt;&lt; sector_cnt &lt;&lt; '\\n';\t\tsort(sector.begin(), sector.end());\t\tfor(int i = 0; i &lt; sector.size(); i++){\t\tcout &lt;&lt; sector[i] &lt;&lt; '\\n';\t}\t\treturn 0;}" }, { "title": "치즈", "url": "/posts/%EC%B9%98%EC%A6%88/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-05-03 00:00:00 +0900", "snippet": "치즈문제아래 &lt;그림 1&gt;과 같이 정사각형 칸들로 이루어진 사각형 모양의 판이 있고, 그 위에 얇은 치즈(회색으로 표시된 부분)가 놓여 있다. 판의 가장자리(&lt;그림 1&gt;에서 네모칸에 엑스친 부분)에는 치즈가 놓여 있지 않으며 치즈에는 하나 이상의 구멍이 있을 수 있다. 이 치즈를 공기 중에 놓으면 녹게 되는데 공기와 접촉된 칸은 한 시간이 지나면 녹아 없어진다. 치즈의 구멍 속에는 공기가 없지만 구멍을 둘러싼 치즈가 녹아서 구멍이 열리면 구멍 속으로 공기가 들어 가게 된다. &lt;그림 1&gt;의 경우, 치즈의 구멍을 둘러싼 치즈는 녹지 않고 ‘c’로 표시된 부분만 한 시간 후 에 녹아 없어져서 &lt;그림 2&gt;와 같이 된다.다시 한 시간 후에는 &lt;그림 2&gt;에서 ‘c’로 표시된 부분이 녹아 없어져서 &lt;그림 3&gt;과 같이 된다.&lt;그림 3&gt;은 원래 치즈의 두 시간 후 모양을 나타내고 있으며, 남은 조각들은 한 시간이 더 지나면 모두 녹아 없어진다. 그러므로 처음 치즈가 모두 녹아 없어지는 데는 세 시간이 걸린다. &lt;그림 3&gt;과 같이 치즈가 녹는 과정에서 여러 조각으로 나누어 질 수도 있다. 입력으로 사각형 모양의 판의 크기와 한 조각의 치즈가 판 위에 주어졌을 때, 공기 중에서 치즈가 모두 녹아 없어지는 데 걸리는 시간과 모두 녹기 한 시간 전에 남아있는 치즈 조각이 놓여 있는 칸의 개수를 구하는 프로그램을 작성하시오.입력입력 파일의 첫째 줄에는 사각형 모양 판의 세로와 가로의 길이가 양의 정수로 주어진다.세로와 가로의 길이는 최대 100이다. 판의 각 가로 줄의 모양이 윗 줄부터 차례로 입력 파일의 둘째 줄부터 마지막 줄까지 주어진다. 치즈가 없는 칸은 0, 치즈가 있는 칸은 1로 주어 지며 각 숫자 사이에는 빈칸이 하나씩 있다.출력첫째 줄에는 치즈가 모두 녹아서 없어지는 데 걸리는 시간을 출력하고, 둘째 줄에는 모두 녹기 한 시간 전에 남아있는 치즈 조각이 놓여 있는 칸의 개수를 출력한다.풀이가운데에 구멍이 뚫려 있어 이 부분을 예외 처리 생각하느라 어려움이 있었는데, 반대로 생각해보면 치즈가 위치하지 않는 0, 0 지점부터 bfs 를 돌려서 치즈가 없는(0) 영역을 q에 넣으면서 탐색하면 저절로 에지의 치즈만 골라낼 수 있다. (가운데 구멍은 막혀있어 bfs를 해도 탐색할 수 없기 때문) 이를 이용해서 bfs 를 돌려 문제를 해결한다.#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define ARR_MAR_NUM 105int R, C, duration = 0, cheese_cnt = 0;int arr[ARR_MAR_NUM][ARR_MAR_NUM] = { 0 };bool isvisited[ARR_MAR_NUM][ARR_MAR_NUM] = { false };int cnt_arr[ARR_MAR_NUM][ARR_MAR_NUM] = { 0 };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};queue&lt;pair&lt;int, int&gt; &gt; q;vector&lt;int&gt; cheese;void bfs(){ while(!q.empty()){ int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt;= R &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt;= C){ // 치즈가 없는 영역은 queue 에 넣어준다. if(!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == 0){ q.push({ny, nx}); isvisited[ny][nx] = true; } // 치즈가 있는 구간은 에지 이므로 카운트를 세주고 0 으로 바꿔준다 else if(!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == 1){ arr[ny][nx] = 0; isvisited[ny][nx] = true; cheese_cnt++; } } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; R &gt;&gt; C; for(int i = 1; i &lt;= R; i++){ for(int j = 1; j &lt;= C; j++){ cin &gt;&gt; arr[i][j]; } } while(1){ q.push({0, 0}); bfs(); // 더이상 cheese 가 없다면 break if(cheese_cnt == 0) break; // bfs 를 돌리고 나서 시간을 늘려주고, cheese 갯수를 vector 에 저장한다. duration++; cheese.push_back(cheese_cnt); cheese_cnt = 0; // 방문 초기화 for(int i = 0; i &lt;= R; i++){ for(int j = 0; j &lt;= C; j++){ isvisited[i][j] = false; } } } int last_idx = cheese.size() - 1; cout &lt;&lt; duration &lt;&lt; '\\n'; // cheese 가 시작부터 아예 없는 경우 예외처리 if(last_idx == -1) cout &lt;&lt; \"0\\n\"; else cout &lt;&lt; cheese[last_idx] &lt;&lt; '\\n'; return 0;}" }, { "title": "DFS 와 BFS", "url": "/posts/DFS%EC%99%80BFS/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-05-02 00:00:00 +0900", "snippet": "DFS, BFS, 백트래킹 선택 기준과 예제 정리문제를 해결할 때 어떤 탐색 방식(DFS, BFS, 백트래킹)을 적용할지 결정하는 것은 문제의 본질과 요구사항에 따라 달라진다. 아래에 각 방식의 선택 기준, 유형, 그리고 예제 코드를 정리한다.✅ 알고리즘 선택 기준 구분 DFS BFS Backtracking 탐색 깊이 깊게 탐색 넓게 탐색 DFS 기반, 조건 만족 안 되면 되돌림 목적 조합/순열/경로 추적 최단거리, 최소 연산 조건 만족하는 결과만 탐색 자료구조 스택(재귀) 큐 스택(재귀 + 조건분기) ✅ 알고리즘 선택 유형별 정리BFS가 유리한 문제 유형 문제 유형 설명 최단 거리 미로 탐색, 최소 점프 수, 최소 연산 횟수 단계적 탐색 레벨 기반 확산, 감염 전파 문제 동시 전파 바이러스, 불, 전염병 문제 등 DFS가 유리한 문제 유형 문제 유형 설명 모든 경로 탐색 특정 노드까지 도달 가능한 경로 수, 경로 자체 필요할 때 트리/그래프 탐색 사이클 유무 확인, 연결성 판단 조합 탐색 기반 문제 경우의 수 탐색, 퍼즐 탐색, 백트래킹 활용 전제 DFS + 백트래킹이 필요한 경우 문제 유형 설명 조건을 만족하는 해만 필요 N-Queen, 부분합 문제, 제약조건이 강한 문제 가지치기 필요 탐색 중 조건 불만족 시 조기 종료 ✅ 문제별 알고리즘 추천 및 예제 코드1. 미로에서 최단 거리 구하기 선택 알고리즘: BFS#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int N, M;int map[100][100];bool visited[100][100];int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};struct Pos { int y, x, dist; };int main() { cin &gt;&gt; N &gt;&gt; M; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; M; j++) cin &gt;&gt; map[i][j]; queue&lt;Pos&gt; q; q.push({0, 0, 1}); visited[0][0] = true; while (!q.empty()) { Pos cur = q.front(); q.pop(); if (cur.y == N-1 &amp;&amp; cur.x == M-1) { cout &lt;&lt; cur.dist &lt;&lt; '\\n'; break; } for (int d = 0; d &lt; 4; d++) { int ny = cur.y + dy[d]; int nx = cur.x + dx[d]; if (ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M &amp;&amp; map[ny][nx] &amp;&amp; !visited[ny][nx]) { visited[ny][nx] = true; q.push({ny, nx, cur.dist + 1}); } } } return 0;}2. N-Queen 선택 알고리즘: DFS + 백트래킹#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int N, result = 0;int col[15];bool isValid(int row) { for (int i = 0; i &lt; row; i++) { if (col[row] == col[i] || abs(col[row] - col[i]) == row - i) return false; } return true;}void dfs(int row) { if (row == N) { result++; return; } for (int i = 0; i &lt; N; i++) { col[row] = i; if (isValid(row)) dfs(row + 1); }}int main() { cin &gt;&gt; N; dfs(0); cout &lt;&lt; result &lt;&lt; endl;}3. 단어 변환 최소 단계 선택 알고리즘: BFS#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;string beginWord, target;vector&lt;string&gt; words;bool oneDiff(string a, string b) { int cnt = 0; for (int i = 0; i &lt; a.size(); i++) { if (a[i] != b[i]) cnt++; } return cnt == 1;}int main() { int n; cin &gt;&gt; beginWord &gt;&gt; target &gt;&gt; n; words.resize(n); for (int i = 0; i &lt; n; i++) cin &gt;&gt; words[i]; queue&lt;pair&lt;string, int&gt;&gt; q; vector&lt;bool&gt; visited(n, false); q.push({beginWord, 0}); while (!q.empty()) { auto [cur, cnt] = q.front(); q.pop(); if (cur == target) { cout &lt;&lt; cnt &lt;&lt; '\\n'; return 0; } for (int i = 0; i &lt; n; i++) { if (!visited[i] &amp;&amp; oneDiff(cur, words[i])) { visited[i] = true; q.push({words[i], cnt + 1}); } } } cout &lt;&lt; 0 &lt;&lt; '\\n'; return 0;}4. 부분 수열의 합이 특정 값이 되는 조합 선택 알고리즘: DFS + 백트래킹#include &lt;iostream&gt;using namespace std;int N, S, arr[20], result = 0;void dfs(int idx, int sum) { if (idx == N) { if (sum == S) result++; return; } dfs(idx + 1, sum + arr[idx]); // 포함 dfs(idx + 1, sum); // 제외}int main() { cin &gt;&gt; N &gt;&gt; S; for (int i = 0; i &lt; N; i++) cin &gt;&gt; arr[i]; dfs(0, 0); if (S == 0) result--; // 공집합 제외 cout &lt;&lt; result &lt;&lt; endl;}✅ 결론 문제 알고리즘 이유 미로 최단 거리 BFS 가장 빠른 도달 순서가 정답 N-Queen DFS + 백트래킹 조건 만족하는 경우만 탐색, pruning 필요 단어 변환 BFS 최소 단계로 도달하는 순서를 구함 부분수열의 합 DFS + 백트래킹 전체 조합 탐색, pruning 가능 " }, { "title": "STL_Queue", "url": "/posts/STL_Queue/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-05-01 00:00:00 +0900", "snippet": "C++ STL Queue 컨테이너 정리개요Queue(큐)는 선입선출(FIFO, First-In-First-Out) 구조를 따르는 컨테이너이다. 먼저 들어간 데이터가 먼저 나오는 구조로, 줄 서기, 버퍼링, 작업 처리 큐 등에 활용된다.C++에서는 &lt;queue&gt; 헤더를 통해 제공되며, 내부적으로는 deque 또는 list를 기반으로 동작한다.헤더 파일#include &lt;queue&gt;선언 방법queue&lt;int&gt; q; // int형 큐queue&lt;string&gt; q2; // string형 큐queue&lt;int, deque&lt;int&gt;&gt; q3; // 내부 컨테이너 지정도 가능주요 멤버 함수 및 동작 함수 설명 push(val) 큐의 뒤에 요소 삽입 pop() 큐의 앞 요소 제거 front() 맨 앞 요소 반환 back() 맨 뒤 요소 반환 empty() 큐가 비어 있는지 여부 반환 size() 큐의 현재 요소 개수 반환 예제 코드#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() { queue&lt;int&gt; q; q.push(10); q.push(20); q.push(30); cout &lt;&lt; \"Front: \" &lt;&lt; q.front() &lt;&lt; endl; // 10 cout &lt;&lt; \"Back: \" &lt;&lt; q.back() &lt;&lt; endl; // 30 q.pop(); // 10 제거 cout &lt;&lt; \"Front after pop: \" &lt;&lt; q.front() &lt;&lt; endl; // 20 cout &lt;&lt; \"Size: \" &lt;&lt; q.size() &lt;&lt; endl; // 2 return 0;}구조체(struct) 또는 pair 활용큐에는 사용자 정의 타입도 저장할 수 있다. 예를 들어, pair나 struct 타입을 큐에 넣어서 두 개 이상의 값을 함께 저장할 수 있다.pair 사용 예시#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;int main() { queue&lt;pair&lt;int, string&gt;&gt; q; q.push({1, \"apple\"}); q.push({2, \"banana\"}); while (!q.empty()) { cout &lt;&lt; q.front().first &lt;&lt; \" : \" &lt;&lt; q.front().second &lt;&lt; '\\n'; q.pop(); } return 0;}구조체 사용 예시#include &lt;queue&gt;#include &lt;iostream&gt;using namespace std;struct Task { int id; string desc;};int main() { queue&lt;Task&gt; q; q.push({1, \"Do homework\"}); q.push({2, \"Read book\"}); while (!q.empty()) { Task t = q.front(); cout &lt;&lt; t.id &lt;&lt; \" : \" &lt;&lt; t.desc &lt;&lt; '\\n'; q.pop(); } return 0;}주의사항 pop() 함수는 반환값이 없다(void) → 제거만 수행 비어 있는 큐에서 front() 또는 pop() 호출 시 런타임 에러 발생 → empty() 먼저 확인 필요활용 예시 BFS(너비 우선 탐색) 프린터 대기열, 작업 스케줄러 등 입력 순서를 유지한 채 처리해야 하는 경우큐 vs 스택 비교 구분 Stack Queue 구조 후입선출(LIFO) 선입선출(FIFO) 삽입 top에 삽입 back에 삽입 제거 top에서 제거 front에서 제거 C++에서 제공하는 queue는 추상화된 구조 덕분에 구현 부담이 적고, 다양한 알고리즘에서 유용하게 활용된다. 특히 BFS와 같은 탐색 알고리즘의 기본 자료구조로 자주 사용된다.예제 문제처리조건:주어진 명령은 다음의 4가지이다. i x y z : (x, y, z) 구조체를 큐에 삽입한다. o : 큐의 맨 앞 구조체를 삭제 후, 그 구조체의 x, y, z 값을 출력. 비어 있으면 “empty” 출력. c : 큐의 크기 출력. z a : 맨 앞 구조체의 z 값이 a와 같으면 “yes”, 다르면 “no” 출력. 비어 있으면 “no” 출력.입력첫 줄에 N이 주어진다. (1 ≤ N ≤ 10000)둘째 줄부터 N개의 명령이 한 줄에 하나씩 주어진다.출력출력을 요구하는 명령의 결과를 한 줄씩 출력한다.코드 예시#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int N;typedef struct{ int x; int y; int z;}data_t;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); char cmd; queue&lt;data_t&gt; q; cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; cmd; // 명령 ` if(cmd == 'i'){ int cx, cy, cz; cin &gt;&gt; cx &gt;&gt; cy &gt;&gt; cz; q.push({cx, cy, cz}); } // 명령 2 else if(cmd == 'o'){ if(q.empty()) cout &lt;&lt; \"empty\" &lt;&lt; '\\n'; else{ cout &lt;&lt; q.front().x &lt;&lt; \" \" &lt;&lt; q.front().y &lt;&lt; \" \" &lt;&lt; q.front().z &lt;&lt; '\\n'; q.pop(); } } // 명령 3 else if(cmd == 'c'){ cout &lt;&lt; q.size() &lt;&lt; '\\n'; } // 명령 4 else if(cmd == 'z'){ int num; cin &gt;&gt; num; if (q.empty()){ cout &lt;&lt; \"no\" &lt;&lt; '\\n'; continue; } if(q.front().z == num) cout &lt;&lt; \"yes\" &lt;&lt; '\\n'; else cout &lt;&lt; \"no\" &lt;&lt; '\\n'; } } return 0;}" }, { "title": "STL_String", "url": "/posts/STL_String/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-04-27 00:00:00 +0900", "snippet": "STL_Stringstring 개요C++ 표준 라이브러리(STL, Standard Template Library)에서 제공하는 문자열 클래스로,문자열을 보다 편리하게 다룰 수 있도록 다양한 기능과 연산자를 제공한다.헤더 파일#include &lt;string&gt;string 클래스는 동적 메모리를 내부적으로 관리하여 크기가 자동으로 조정된다.주요 특징 가변 길이 문자열 관리 문자열 연결, 비교, 검색, 수정 등의 다양한 기능 지원 C 스타일 문자열(char 배열)보다 안전하고 편리함기본 사용법#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string str1 = \"Hello\"; string str2 = \"World\"; // 문자열 합치기 string str3 = str1 + \" \" + str2; cout &lt;&lt; str3 &lt;&lt; endl; // Hello World // 문자열 길이 cout &lt;&lt; str3.length() &lt;&lt; endl; // 부분 문자열 접근 cout &lt;&lt; str3[0] &lt;&lt; endl; // 'H' // 문자열 비교 if (str1 == \"Hello\") { cout &lt;&lt; \"str1 is Hello\" &lt;&lt; endl; } return 0;}주요 멤버 함수문자열 생성 및 대입 기본 생성자: string s; 문자열 초기화: string s = \"text\"; 복사 생성자: string s2 = s1; 대입 연산자: s1 = s2;문자열 크기 size(), length(): 문자열 길이 반환 empty(): 문자열이 비었는지 확인문자열 수정 push_back(char c): 문자열 끝에 문자 추가 pop_back(): 문자열 끝 문자 제거 append(string s): 문자열 뒤에 추가 insert(pos, string): pos 위치에 문자열 삽입 erase(pos, len): pos 위치부터 len만큼 삭제 replace(pos, len, string): pos부터 len길이만큼 다른 문자열로 교체문자열 접근 at(pos): pos 위치 문자 접근 (범위 검사 O) operator[]: pos 위치 문자 접근 (범위 검사 X) front(), back(): 첫 문자, 마지막 문자 접근문자열 검색 find(string): 해당 문자열이 처음 등장하는 위치 반환, 없으면 string::npos 반환 (string::npos 는 size_type 으로 정의된 특수 값으로 -1 의 상수값을 의미) rfind(string): 마지막 등장 위치 반환 substr(pos, len): pos부터 len 길이만큼 부분 문자열 반환문자열 비교 ==, !=, &lt;, &gt; 등 연산자 지원 compare(string): 두 문자열 비교, 같으면 0, 다르면 음수 또는 양수 반환주요 예제문자열 연결string a = \"abc\";string b = \"def\";string c = a + b; // \"abcdef\"문자열 삽입, 삭제string s = \"abcdef\";s.insert(3, \"123\"); // \"abc123def\"s.erase(1, 2); // \"a123def\"문자열 찾기// string::npos = -1string s = \"abcdefg\";size_t pos = s.find(\"cde\");if (pos != string::npos) { cout &lt;&lt; \"Found at: \" &lt;&lt; pos &lt;&lt; endl;}부분 문자열 추출string s = \"abcdefg\";string sub = s.substr(2, 3); // \"cde\"string과 C 문자열(char*) 변환 string -&gt; char 배열string s = \"hello\";const char* c = s.c_str(); char 배열 -&gt; stringconst char* c = \"hello\";string s(c);요약 string 클래스는 동적 크기 관리, 편리한 수정, 검색 기능 제공 다양한 연산자 오버로딩으로 직관적인 사용 가능 C 스타일 문자열에 비해 메모리 관리와 오류 방지 측면에서 안전하다정올 문제 풀이String 자료형 (C++) / Python아래 조건을 만족하는 프로그램을 작성하시오.ⓐ. 문자열 S와 T를 입력 받는다.ⓑ. 문자열 S의 첫 문자부터 검열하다가 T문자열을 만나면 삭제하고 이후 문자열을 이어 붙인다.ⓒ. 문자열 S에서 금지된 문자열 T가 발견되지 않을 때까지 ⓑ를 반복한다.ⓓ. S의 남은 문자열을 출력한다.​ 입력첫 번째 줄에 문자열 S를 입력받으시오. (1 &lt;= S의 길이 &lt;= 100)두 번째 줄에 문자열 T를 입력받으시오. (1 &lt;=​ T의 길이 &lt;= S의 길이)​출력문제에서 제시된 작업을 수행한 후 첫 번째 문자열 S에 남은 문자열을 출력한다. 출력할 문자열이 남아 있음을 보증한다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string S, T; // a cin &gt;&gt; S &gt;&gt; T; int idx, subword_len = T.length(); // b, c idx = S.find(T); while(idx &gt;= 0){ S.erase(idx, subword_len); idx = S.find(T); } cout &lt;&lt; S &lt;&lt; '\\n'; return 0;}SubString (부분 문자열)[문제]공백이 포함된 문장을 입력받아 위의 작업을 처리한 후 짝수 번째(첫 번째는 홀수 번째이다) 문자열만 입력 순서 반대로 출력하는 프로그램을 작성하시오.입력길이가 100을 넘지 않는 공백을 포함한 문자열 S를 입력받는다.출력한 줄에 짝수 번째 문자열만 입력의 반대순으로 출력한다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); string S; string answer[100]; int cnt = 0; getline(cin, S); // 공백 포함 문자열 입력 받고싶을 때 사용 // 시작 포인트와, len 값을 저장하는 local 변수 int start = 0, tmp_cnt = 0; for(int i = 0; i &lt; S.length(); i++){ tmp_cnt++; if(S[i] == ' '){ answer[cnt++] = S.substr(start, tmp_cnt - 1); tmp_cnt = 0; start = i + 1; } if(i == S.length() - 1) answer[cnt++] = S.substr(start, tmp_cnt); } for(int i = cnt - 1; i &gt;= 0; i--){ // 연산자 우선순위 때문에 괄호를 쳐줘야 함 if((i &amp; 1) == 1) cout &lt;&lt; answer[i] &lt;&lt; \" \"; } return 0;}" }, { "title": "N Queen", "url": "/posts/N-Queen/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-04-27 00:00:00 +0900", "snippet": "N Queen문제체스에서 queen은 가로, 세로, 대각선 방향으로 어느 곳이나 한 번에 움직일 수 있다.즉 다음과 같은 체스판에서 queen이 X라고 표시된 위치에 있을 때,그 다음 queen이 움직여 갈수 있는 부분은 어둡게 칠해진 부분 중의 하나이다.N×NN×N 크기의 정방형 체스판이 주어졌다.우리는 거기에 N개의 queen을 배치하려고 하는데, 모든 queen들은 서로 잡아먹을 수 없어야 한다.그렇다면 queen들을 어떻게 배치해야만 할까?가능한 모든 경우의 개수를 출력한다.입력queen의 수 N(1≤N≤13)을 입력 받는다.출력N×N의 체스판에서 N개의 queen들이 서로 잡아먹지 않는 위치로 놓을 수 있는 방법의 수를 출력한다.풀이 col 배열을 통해 행과 열을 쉽게 관리한다. (NxN 행렬이기 때문에 1차원 배열로도 행과 열을 표현 가능) 매 퀸을 놓을 때마다 기존에 놓은 퀸들과 충돌하는지 검사한다. 유망하지 않은 경우에는 백트래킹하여 다른 열을 탐색한다. 시간 복잡도는 최악의 경우 O(N!) 이지만, 백트래킹을 통해 많은 경우를 가지치기(Pruning) 한다.문제 풀이 Flow 0번째 행부터 시작하여 가능한 열에 퀸을 놓는다. 놓은 후 다른 퀸과 충돌하지 않으면 다음 행으로 넘어간다. 모든 행에 퀸을 놓았을 때 정답을 1 증가시킨다. 모든 경우를 탐색할 때까지 반복한다.#include &lt;iostream&gt;using namespace std;int N, answer= 0;int col[13]; // 인덱스는 행(row), 값은 열(column)bool checkfunc(int row){ for(int i = 0; i &lt; row; i++){ // 같은 행, 같은 열에 위치하거나, 대각에 위치한 경우 // 인덱스가 같은 경우 (행이 같은 경우) 값이 같은 경우 (열이 같은 경우) // 대각의 경우 행과 열의 변화량은 항상 일정하다. (앞이 행 뒤가 열) if(col[row] == col[i] || abs(col[row] - col[i]) == row - i) return false; } return true;}void dfs(int r){ // 퀸을 모두 놓았을 경우 answer++ 수행 if(r == N){ answer++; return ; } // 행 별로 탐색 for(int i = 0; i &lt; N; i++){ col[r] = i; // 행 별로 조건을 탐색해서 특정 열에 퀸이 위치할 수 있는지 확인하고 가능하면 재귀로 호출 if(checkfunc(r)) dfs(r + 1); }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; dfs(0); cout &lt;&lt; answer &lt;&lt; '\\n'; return 0;}" }, { "title": "토마토(고)", "url": "/posts/%ED%86%A0%EB%A7%88%ED%86%A0(%EA%B3%A0)/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-04-20 00:00:00 +0900", "snippet": "토마토(고)문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다.토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다.보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다.하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다.대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다.철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때,며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라.단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.입력입력파일의 첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다.M은 상자의 가로 칸의 수, N 은 상자의 세로 칸의 수를 나타낸다. 단, 2≤M,N≤1,000 이다.둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다.즉, 둘째 줄부터 N 개의 줄에는 상자에 담긴 토마토의 정보가 주어진다.하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M 개의 정수로 주어진다.정수 1 은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1 은 토마토가 들어있지 않은 칸을 나타낸다.출력여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다.만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고,토마토가 모두 익지는 못하는 상황이면 -1 을 출력해야 한다.#include &lt;iostream&gt;#include &lt;queue&gt;#define MAX_ARR_NUM 1001using namespace std;int N, M, answer = 0;int arrmap[MAX_ARR_NUM][MAX_ARR_NUM] = { 0 };int daycount[MAX_ARR_NUM][MAX_ARR_NUM] = { 0 };bool isvisited[MAX_ARR_NUM][MAX_ARR_NUM] = { false };int dy[4] = {-1, 0, 1, 0};int dx[4] = {0, -1, 0, 1};queue&lt;pair &lt;int, int&gt; &gt; q;void bfs(){ while(!q.empty()){ int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M){ if(!isvisited[ny][nx] &amp;&amp; arrmap[ny][nx] == 0){ q.push({ny, nx}); isvisited[ny][nx] = true; arrmap[ny][nx] = 1; daycount[ny][nx] = daycount[cy][cx] + 1; } } } }}int main(){ cin &gt;&gt; M &gt;&gt; N; for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ cin &gt;&gt; arrmap[i][j]; } } for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ if(arrmap[i][j] == 1){ q.push({i, j}); isvisited[i][j] = true; } } } bfs(); // 익지않은 토마토가 있을 경우 -1 출력하고 종료 for(int i = 0; i &lt; N; i++){ for(int j = 0; j &lt; M; j++){ answer = max(answer, daycount[i][j]); if(arrmap[i][j] == 0){ cout &lt;&lt; -1 &lt;&lt; '\\n'; exit(0); } } } cout &lt;&lt; answer &lt;&lt; '\\n'; return 0;}" }, { "title": "장기 (DFS)", "url": "/posts/%EC%9E%A5%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-04-19 00:00:00 +0900", "snippet": "장기 (DFS)문제N×M장기판에 졸 한개와 말 한개가 놓여 있다. 말의 이동 방향이 다음과 같다고 할 때, 말이 최소의 이동횟수로 졸을 잡으려고 한다.말이 졸을 잡기 위한 최소 이동 횟수를 구하는 프로그램을 작성해보자.입력첫 줄은 장기판 행의 수(N)와 열의 수(M)를 받는다(4 ≤ N, M ≤ 1000).둘째 줄은 말이 있는 위치의 행(R), 열(C)의 수와 졸이 있는 위치의 행(S), 열(K)의 수를 입력받는다.단, 장기판의 제일 왼쪽 위의 위치가 (1,1)이다.각 행과 열은 R(1≤R≤N), C(1≤C≤M), S(1≤S≤N), K(1≤K≤M)이다.출력말이 졸을 잡기 위한 최소 이동 횟수를 출력한다.​9 10 2 5 7 5#include &lt;iostream&gt;#define ARR_MAX_LEN 1001using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int cntmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int dx[8] = {1, 2, 2, 1, -1, -2, -2, -1};int N, M, R, C, S, K, min_count = 1e9;void dfs(int y, int x, int cnt){ // 이미 기존 최소 이동횟수 만큼을 넘어섰다면 깊이 탐색을 종료한다. if(min_count &lt;= cnt) return; // 최소 이동 횟수를 배열로 저장해서 backtracking 시에도 시간초과가 발생하는 문제를 방지한다. // 해당 위치에서 최소 이동횟수를 배열에 저장해놓고 비교해서 많으면 깊이 탐색을 종료한다. if(cntmap[y][x] != 0 &amp;&amp; cntmap[y][x] &lt;= cnt) return; cntmap[y][x] = cnt; if(arrmap[y][x] == 2){ min_count = min(min_count, cnt); return; } isvisited[y][x] = true; for(int dir = 0; dir &lt; 8; dir++){ int ny = y + dy[dir]; int nx = x + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= N &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= M){ if(!isvisited[ny][nx]){ dfs(ny, nx, cnt + 1); } } } // 백트래킹 isvisited[y][x] = false;} int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cin.tie(NULL); cin &gt;&gt; N &gt;&gt; M; cin &gt;&gt; R &gt;&gt; C &gt;&gt; S &gt;&gt; K; arrmap[R][C] = 1; // 목표 지점 설정 arrmap[S][K] = 2; dfs(R, C, 0); if(min_count == 1e9) cout &lt;&lt; 0 &lt;&lt; '\\n'; else cout &lt;&lt; min_count &lt;&lt; '\\n'; return 0;}" }, { "title": "좋은 수열", "url": "/posts/%EC%A2%8B%EC%9D%80-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2025-04-13 00:00:00 +0900", "snippet": "좋은 수열문제숫자 1 2 3으로만 이루어지는 수열이 있다.임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면,그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다.다음은 나쁜 수열의 예이다. (밑줄 부분때문에 나쁜 수열이다.)3332121323123123213다음은 좋은 수열의 예이다.232321231232123길이가 N인 좋은 수열들을 N자리의 정수로 보아 그 중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라.예를 들면 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열 1213121이다.​입력입력파일은 숫자 N 하나로 이루어진다.N은 1 이상 80 이하이다.출력첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 N인 좋은 수열들 중에서가장 작은 수를 나타내는 수열만 출력한다.수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int N;// 좋은 수열인지 확인하는 함수// 홀수나 짝수 케이스로 분리해서 생각할 필요는 없음bool isValid(string result){ int len = result.size(); // 인접한 부분 문자열이 같은 경우가 있으면 false for(int i = 1; i &lt;= len / 2; i++){ string str1 = result.substr(len - 2 * i, i); string str2 = result.substr(len - i, i); // if(str1 == str2) return false; } return true;}// DFS로 좋은 수열 생성void dfs(int cnt, string result){ // 항상 VALID 조건 검사를 먼저 해야함 if(!isValid(result)){ return; } if(cnt == N){ cout &lt;&lt; result &lt;&lt; '\\n'; exit(0); } // 가장 작은 수열이 나올 수 있도록 '1' 부터 DFS 를 돌린다. dfs(cnt + 1, result + '1'); dfs(cnt + 1, result + '2'); dfs(cnt + 1, result + '3');}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; dfs(0, \"\"); return 0;}" }, { "title": "장기 2", "url": "/posts/%EC%9E%A5%EA%B8%B0-2/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-04-13 00:00:00 +0900", "snippet": "장기 2문제N×M장기판에 졸 한개와 말 한개가 놓여 있다. 말의 이동 방향이 다음과 같다고 할 때, 말이 최소의 이동횟수로 졸을 잡으려고 한다.말이 졸을 잡기 위한 최소 이동 횟수를 구하는 프로그램을 작성해보자.입력첫 줄은 장기판 행의 수(N)와 열의 수(M)를 받는다(4 ≤ N, M ≤ 1000).둘째 줄은 말이 있는 위치의 행(R), 열(C)의 수와 졸이 있는 위치의 행(S), 열(K)의 수를 입력받는다.단, 장기판의 제일 왼쪽 위의 위치가 (1,1)이다.각 행과 열은 R(1≤R≤N), C(1≤C≤M), S(1≤S≤N), K(1≤K≤M)이다.출력말이 졸을 잡기 위한 최소 이동 횟수를 출력한다.​#include &lt;iostream&gt;#include &lt;queue&gt;#define ARR_MAX_LEN 1001using namespace std;int arrmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };int cntmap[ARR_MAX_LEN][ARR_MAX_LEN] = { 0 };bool isvisited[ARR_MAX_LEN][ARR_MAX_LEN] = { false };int dy[8] = {-2, -1, 1, 2, 2, 1, -1, -2};int dx[8] = {1, 2, 2, 1, -1, -2, -2, -1};int N, M, R, C, S, K;queue&lt;pair&lt;int, int&gt; &gt; q;void bfs(){ while(!q.empty()){ int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 8; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= N &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= M){ if(!isvisited[ny][nx]){ q.push({ny, nx}); isvisited[ny][nx] = true; cntmap[ny][nx] = cntmap[cy][cx] + 1; } if(arrmap[ny][nx] == 2) return; } } }}int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N &gt;&gt; M; cin &gt;&gt; R &gt;&gt; C &gt;&gt; S &gt;&gt; K; arrmap[R][C] = 1; arrmap[S][K] = 2; q.push({R, C}); isvisited[R][C] = true; bfs(); cout &lt;&lt; cntmap[S][K] &lt;&lt; '\\n'; return 0;}" }, { "title": "STL_Vector", "url": "/posts/STL_Vector/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-04-12 00:00:00 +0900", "snippet": "STL_Vector1. 개요vector는 C++ STL(Standard Template Library)의 대표적인 시퀀스 컨테이너로, 동적 배열(dynamic array)을 제공한다. 메모리 크기를 자동으로 조절하면서 데이터를 저장할 수 있으며, 배열처럼 임의 접근(random access)이 가능하다.&lt;/br&gt;&lt;/br&gt;2. 헤더와 선언#include &lt;vector&gt;using namespace std;vector&lt;int&gt; v; // 기본 생성자vector&lt;int&gt; v2(10); // 10개의 요소를 0으로 초기화vector&lt;int&gt; v3(5, 100); // 5개의 요소를 100으로 초기화vector&lt;int&gt; v4 = {1, 2, 3}; // 초기화 리스트&lt;/br&gt;3. 주요 멤버 함수&lt;/br&gt;3.1 요소 삽입v.push_back(10); // 마지막에 삽입v.insert(v.begin(), 5); // 맨 앞에 삽입&lt;/br&gt;3.2 요소 삭제v.pop_back(); // 마지막 요소 삭제v.erase(v.begin()); // 첫 번째 요소 삭제v.erase(v.begin() + 1, v.end()); // 일부 구간 삭제v.clear(); // 전체 삭제&lt;/br&gt;3.3 접근v[i]; // 인덱스 접근 (범위 검사 없음)v.at(i); // 인덱스 접근 (범위 검사 있음)v.front(); // 첫 번째 요소v.back(); // 마지막 요소&lt;/br&gt;4. 용량 관련 함수v.size(); // 현재 요소 개수v.capacity(); // 현재 할당된 용량v.resize(20); // 크기 변경 (자동 초기화됨)v.reserve(100); // 용량 미리 확보v.shrink_to_fit(); // 여유 메모리 반환&lt;/br&gt;&lt;/br&gt;5. 반복자(iterator)vector&lt;int&gt;::iterator it = v.begin();for (it = v.begin(); it != v.end(); ++it) { cout &lt;&lt; *it &lt;&lt; \" \";}&lt;/br&gt;범위 기반 for 문for (int i = 0; i &lt; v.size(); i++) { cout &lt;&lt; v[i] &lt;&lt; \" \";}for (int x : v) { cout &lt;&lt; x &lt;&lt; \" \";}6. 복사 및 비교&lt;/br&gt;vector&lt;int&gt; a = {1, 2, 3};vector&lt;int&gt; b = a; // 복사bool equal = (a == b); // 비교7. 2차원 vector&lt;/br&gt;vector&lt;vector&lt;int&gt;&gt; matrix(3, vector&lt;int&gt;(4, 0)); // 3x4 2차원 벡터 0으로 초기화8. vector와 포인터&lt;/br&gt;vector&lt;int*&gt; ptrVec;int a = 10;ptrVec.push_back(&amp;a);주의: 포인터를 사용한 vector는 메모리 관리를 수동으로 해야 함.9. vector의 내부 동작 vector는 동적 배열을 사용한다 용량(capacity)이 부족할 때는 더 큰 메모리를 할당하고 기존 데이터를 복사한다 push_back 시 capacity가 늘어날 수 있으며, 복사 비용이 발생한다 메모리 증가 방식은 구현체마다 다르지만 일반적으로 1.5~2배씩 증가함&lt;/br&gt;10. vector 사용 시 주의사항 중간 삽입/삭제는 비효율적이다 (O(n)) 메모리 할당/복사 오버헤드 고려 필요 iterator는 재할당 후 무효화될 수 있다&lt;/br&gt;11. 정리 vector는 임의 접근(random access)이 가능하고 크기 조절이 자동인 배열 삽입/삭제는 끝에서 할 때 가장 효율적 다양한 STL 알고리즘과 함께 사용할 수 있는 범용 컨테이너" }, { "title": "STL_Sort", "url": "/posts/STL_Sort/", "categories": "CodingTest", "tags": "CodingTest, STL", "date": "2025-04-10 00:00:00 +0900", "snippet": "STL_Sort1. 개요C++에서 정렬을 수행할 때 가장 많이 사용하는 함수는 std::sort 이다. 이 함수는 C++ 표준 라이브러리 algorithm 헤더에 정의되어 있으며, 빠르고 유연한 정렬 기능을 제공한다.2. 기본 문법#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; vec = {3, 1, 4, 1, 5, 9};sort(vec.begin(), vec.end());위 예제는 벡터 vec의 요소를 오름차순으로 정렬한다.3. 정렬 순서 지정오름차순 (기본)기본 정렬 방식은 오름차순이다. operator&lt;를 기준으로 정렬한다.내림차순sort(vec.begin(), vec.end(), greater&lt;int&gt;());또는 람다식을 사용할 수도 있다.sort(vec.begin(), vec.end(), [](int a, int b) { return a &gt; b;});3.1 배열로 sort 하는 예제 오름차순 정렬#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(){ int N, start, end; int arr[100000] = { 0 }; ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; arr[i]; } cin &gt;&gt; start &gt;&gt; end; // 구간 정렬은 시작 포인트 ~ 끝 포인트 + 1 sort(arr+start, arr+end+1); for(int i = 0; i &lt; N; i++){ cout &lt;&lt; arr[i] &lt;&lt; ' '; } cout &lt;&lt; '\\n'; sort(arr, arr+N); for(int i = 0; i &lt; N; i++){ cout &lt;&lt; arr[i] &lt;&lt; ' '; } cout &lt;&lt; '\\n'; return 0;} 내림차순 정렬#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool compare(int &amp;a, int &amp;b){ return a &gt; b;}int main(){ int N; int arr[100000] = { 0 }; ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin &gt;&gt; N; for(int i = 0; i &lt; N; i++){ cin &gt;&gt; arr[i]; } // 비교 함수를 사용하는 예제 sort(arr, arr+N, compare); for(int i = 0; i &lt; N; i++){ cout &lt;&lt; arr[i] &lt;&lt; ' '; } cout &lt;&lt; '\\n'; // reverse 함수를 사용하는 예제 reverse(arr, arr+N); for(int i = 0; i &lt; N; i++){ cout &lt;&lt; arr[i] &lt;&lt; ' '; } cout &lt;&lt; '\\n'; return 0;}4. 사용자 정의 타입 정렬사용자 정의 타입의 경우, 비교 연산자를 정의하거나 비교 함수를 따로 전달해야 한다.struct Data { int key; string value;};vector&lt;Data&gt; arr = {{2, \"b\"}, {1, \"a\"}, {3, \"c\"}};sort(arr.begin(), arr.end(), [](const Data&amp; a, const Data&amp; b) { return a.key &lt; b.key;});5. bool compare 함수 이용비교 함수를 별도로 정의해서 정렬에 사용하는 방식도 자주 사용된다.bool compare(int a, int b) { return a &gt; b; // 내림차순 정렬}int main() { vector&lt;int&gt; vec = {3, 1, 4, 1, 5, 9}; sort(vec.begin(), vec.end(), compare); return 0;}사용자 정의 타입에도 적용 가능하다.struct Data { int key; string value;};bool compareData(const Data&amp; a, const Data&amp; b) { return a.key &lt; b.key;}int main() { vector&lt;Data&gt; arr = {{2, \"b\"}, {1, \"a\"}, {3, \"c\"}}; sort(arr.begin(), arr.end(), compareData); return 0;}코드 외부에 비교 함수를 두면 코드 재사용성과 가독성이 높아지는 장점이 있다.6. 정렬 알고리즘 특성 std::sort는 평균적으로 O(n log n)의 시간복잡도를 가진다 내부적으로 IntroSort(Introspective Sort) 알고리즘을 사용함 Quick Sort, Heap Sort, Insertion Sort를 혼합하여 구현함 7. stable_sort 와의 차이 std::sort: 정렬된 값들 사이의 원래 순서를 보장하지 않음 (unstable sort) std::stable_sort: 정렬된 값들 사이의 원래 순서를 보장함#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Data { int group; string name;};vector&lt;Data&gt; arr = {{1, \"apple\"}, {2, \"banana\"}, {1, \"cherry\"}};stable_sort(arr.begin(), arr.end(), [](const Data&amp; a, const Data&amp; b) { return a.group &lt; b.group;});8. 정렬 시 주의사항 정렬 대상 컨테이너의 iterator가 랜덤 액세스를 지원해야 함 (e.g. vector, deque) list 같은 시퀀스 컨테이너는 std::list::sort 같은 멤버 함수를 사용해야 함 비교 함수는 strict weak ordering을 만족해야 함 compare(a, b)가 true이면 compare(b, a)는 false여야 하고, compare(a, b)와 compare(b, c)가 true이면 compare(a, c)도 true여야 한다 9. 관련 함수들 std::sort: 빠른 정렬, 불안정 std::stable_sort: 안정 정렬, 느릴 수 있음 std::partial_sort: 일부 정렬 std::nth_element: 특정 위치 원소 찾기 (정렬 아님) std::is_sorted: 정렬 여부 확인 std::sort_heap: heap 정렬 std::make_heap / std::push_heap / std::pop_heap: heap 관련 유틸 함수들10. 정리C++의 std::sort는 강력하고 유연한 정렬 기능을 제공하며, 사용자 정의 타입에도 쉽게 적용 가능하다. 단, 내부 정렬 순서를 보장하려면 std::stable_sort를 사용해야 하며, 정렬 대상 컨테이너의 iterator 특성에 따라 사용 가능한 정렬 함수가 달라질 수 있다. 또한 비교 함수는 정렬 알고리즘이 제대로 작동하기 위해 반드시 엄격 약순서를 만족해야 한다." }, { "title": "저글링 방사능 오염", "url": "/posts/%EC%A0%80%EA%B8%80%EB%A7%81-%EB%B0%A9%EC%82%AC%EB%8A%A5-%EC%98%A4%EC%97%BC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-04-06 00:00:00 +0900", "snippet": "저글링 방사능 오염문제승훈이는 심심한 시간에 스타크래프트(Starcraft) 게임을 하며 놀고 있었다.스타크래프트 유닛중 하나인 저글링을 한 곳에 몰아세운 뒤, 방사능 오염 공격으로 없애보려고 했다.그런데 좀 더 재미있게 게임을 하기 위해서 게임을 개조하여 방사능 오염 공격을 가하면 방사능은 1초마다 이웃한 저글링에 오염된다.그리고 방사능에 오염된 저글링은 3초 후에 죽게 된다.예를 들어 아래 왼쪽그림과 같이 모여 있는 저글링 중에 빨간 동그라미 표시를 한 저글링에게 방사능 오염공격을 가하면,총 9초 후에 모든 저글링들이 죽게 된다. 아래 오른쪽에 있는 그림의 숫자들은 각 저글링들이 죽는 시간이다.저글링을 모아놓은 지도의 크기와 지도상에 저글링들이 놓여 있는 격자 위치가 주어질 때,총 몇 초 만에 저글링들을 모두 없앨 수 있는지 알아보는 프로그램을 작성하시오.입력첫째 줄은 지도의 열의 크기와 행의 크기가 주어진다. 지도는 격자 구조로 이루어져 있으며 크기는 100×100칸을 넘지 않는다.둘째 줄부터는 지도상에 저글링들이 놓여있는 상황이 주어진다. 1은 저글링이 있는 곳의 표시이고 0은 없는 곳이다.마지막 줄에는 방사능오염을 가하는 위치가 열 번호 행 번호 순으로 주어지며 x, y 좌표의 시작은 1이다.출력죽을 수 있는 저글링들이 모두 죽을 때까지 몇 초가 걸리는지 첫 번째 줄에 출력하고 둘째 줄에는 죽지 않고 남아 있게 되는 저글링의 수를 출력하시오.해결방사능오염은 특정 한 포인트에서 시작하고, 그 방사능으로 죽는 날짜를 세는 문제이다.날짜를 세는 배열을 선언해서 이전 포인트에서 +1 로만 카운트하면 되는 간단한 문제.기존에 풀었던 토마토와 비슷한 유형의 문제로 보면 될 것 같다.다만 입력이 붙어있는 형태로 나와서 scanf %1d 를 썼고 이 부분만 잘 염두해 두면 될 것 같다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int arr[101][101] = { 0 };int day[101][101] = { 0 };bool isvisited[101][101] = { false }; int N, M, remain = 0, max_day = 0;int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};queue&lt;pair&lt;int, int&gt; &gt; q;void bfs(int y, int x){ q.push({y, x}); isvisited[y][x] = true; while(!q.empty()){ int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= N &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= M){ if(!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == 1){ q.push({ny, nx}); isvisited[ny][nx] = true; day[ny][nx] = day[cy][cx] + 1; arr[ny][nx] = 0; } } } }}int main() { int tx, ty; cin &gt;&gt; M &gt;&gt; N; // 입력이 붙어있는 문자열로 나올경우 다음과 같이 입력 받는다. for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ scanf(\"%1d\", &amp;arr[i][j]); } } cin &gt;&gt; tx &gt;&gt; ty; // 방사능 오염 시작 포인트로 bfs 를 돌리고, arr 상태를 업데이트 한다. (arr 현재상태, 방문 여부) for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ day[ty][tx] = 3; bfs(ty, tx); arr[ty][tx] = 0; } } for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ max_day = max(max_day, day[i][j]); if(arr[i][j] == 1) remain++; } } // 디버깅용 프린트 // cout &lt;&lt; '\\n'; // for(int i = 1; i &lt;= N; i++){ // for(int j = 1; j &lt;= M; j++){ // printf(\"%d \", day[i][j]); // } // cout &lt;&lt; '\\n'; // } cout &lt;&lt; max_day &lt;&lt; '\\n'; cout &lt;&lt; remain &lt;&lt; '\\n'; return 0;}" }, { "title": "코딩테스트에 필요한 Cpp 개념", "url": "/posts/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%97%90-%ED%95%84%EC%9A%94%ED%95%9C-Cpp-%EA%B0%9C%EB%85%90/", "categories": "CodingTest", "tags": "CodingTest, C++", "date": "2025-04-05 00:00:00 +0900", "snippet": "코딩테스트에 필요한 Cpp 개념TestCase 가 여러개인 경우 사용하는 전역변수는 초기화 함수에 모두 초기화를 수행한다.#include &lt;cstring&gt;vector&lt;int&gt; data;int answer = 0;int arrmap[5][5] = { 0 };void init_func() {\tanswer = 0;\tmemset(arrmap, 0, sizeof(arrmap));\tdata.clear();}문제에서 표현한 좌표계를 사용한다SWEA 원자 소멸 시뮬레이션 문제처럼 방향에 대한 정의가 다음과 같이 이루어지는 경우 상: y 가 증가하는 방향 하: y 가 감소하는 방향 좌: x 가 감소하는 방향 우: x 가 증가하는 방향 0: 상(Up, y+1) 1: 하(Down, y-1) 2: 좌(Left, x-1) 3: 우(Right, x+1)int arrmap[MAX_ARR_LEN][MAX_ARR_LEN] = { };int dx[4] = { 0, 0, -1, 1 };int dy[4] = { 1, -1, 0, 0 }; void input_func() {\tint x, y, dir, K;\tcin &gt;&gt; N;\tanswer = 0;\tmemset(arrmap, 0, sizeof(arrmap));\tainfo.clear();\tfor (int i = 0; i &lt; N; i++) {\t\tcin &gt;&gt; x &gt;&gt; y &gt;&gt; dir &gt;&gt; K;\t\ty = (y + 1000) * 2;\t\tx = (x + 1000) * 2;\t\tainfo.push_back({ x, y, dir, K, true }); \t\tarrmap[x][y] = 1;\t}\t}입력이 x, y 순으로 주어지고 방향의 순서도 저렇게 특정 변수가 증감하는 방향으로 주어지면 되도록이면 변수의 순서를 따르고 2차원 배열도 그 구조를 따라가게 설계한다.C++에서 priority_queue의 비교 함수가 구조체 형태로 작성되어야 하는 이유1. 개요C++의 priority_queue는 내부적으로 요소들을 정렬하기 위해 비교 연산자를 필요로 하며, 이 비교 연산자는 함수 객체(Functor) 형태로 제공되어야 합니다. 본 문서에서는 함수 객체가 필요한 이유와 일반 함수 형태가 아닌 구조체 형태로 제공되어야 하는 이유에 대해 설명합니다.2. priority_queue의 템플릿 정의template&lt; class T, class Container = std::vector&lt;T&gt;, class Compare = std::less&lt;typename Container::value_type&gt;&gt; class priority_queue;템플릿 인자 중 Compare Compare는 두 요소를 비교하여 우선순위를 정하는 함수 객체(Functor)입니다. 기본값은 std::less로, 이는 operator()를 정의한 구조체입니다.3. 함수 객체(Functor)란?함수 객체란 operator()를 오버로드하여 함수처럼 동작하는 객체를 말합니다. 일반 함수와 달리 함수 객체는 상태를 가질 수 있고, 템플릿 인자로 전달될 수 있는 특징이 있습니다.예시: 구조체 형태의 함수 객체struct compare { bool operator()(const T&amp; a, const T&amp; b) const { // 우선순위 조건 정의 }};4. 왜 일반 함수가 아닌 구조체인가?일반 함수bool compare(const T&amp; a, const T&amp; b) { return a &lt; b;}이러한 일반 함수는 priority_queue의 템플릿 인자로 전달할 수 없습니다. priority_queue는 템플릿 인자로 함수 객체 타입(예: std::less, 사용자 정의 비교 구조체 등)을 요구합니다. 함수 포인터(bool(*)(const T&amp;, const T&amp;)) 형태는 priority_queue의 세 번째 인자 형식과 호환되지 않습니다.구조체는 가능priority_queue&lt;T, vector&lt;T&gt;, compare&gt; pq;compare는 함수 객체로서 operator()를 제공하므로 템플릿 인자로 전달 가능하며, 이를 통해 priority_queue는 내부적으로 정렬 기준을 동작시킬 수 있습니다.5. C++11 이후: 람다(lambda)를 사용하는 방법C++11부터는 std::function을 활용해 람다를 비교 함수로 전달할 수도 있습니다. 이 방식은 가독성이 좋지만 약간의 성능 손실이 있습니다.auto cmp = [](const T&amp; a, const T&amp; b) { return a &lt; b;};priority_queue&lt;T, vector&lt;T&gt;, decltype(cmp)&gt; pq(cmp);6. 요약 방식 사용 가능 여부 설명 구조체 (Functor) 가능 operator()가 정의되어 있어 템플릿 인자로 전달 가능 일반 함수 불가능 함수는 템플릿 인자로 전달할 수 없음 람다 함수 가능 (C++11 이상) decltype과 std::function 사용 시 가능 7. 결론priority_queue는 정렬을 위해 함수 객체 형태의 비교 연산자를 요구하며, 이는 구조체에 operator()를 오버로드하여 제공하는 것이 일반적이다. 일반 함수는 템플릿 인자로 직접 전달할 수 없기 때문에 우선순위 비교를 위한 구조체 형태의 함수 객체가 필수적이다.C++에서 cin / cout 최적화 방법1. 개요C++에서 표준 입출력 방식인 cin과 cout은 간단하고 직관적이지만, 입출력이 빈번하게 발생하는 문제에서는 속도 면에서 느릴 수 있습니다. 이럴 때 scanf/printf와 유사한 성능을 내기 위해 cin과 cout에 대한 최적화가 필요합니다.2. 입출력 최적화 방법방법 1: sync_with_stdio(false) 비활성화ios::sync_with_stdio(false); C++의 cin/cout은 기본적으로 C의 scanf/printf와 동기화되어 있습니다. 이 옵션을 false로 설정하면 동기화를 끊고 C++만의 빠른 스트림 버퍼를 사용하게 되어 속도가 개선됩니다. 그리고 이 방식의 경우 기존 scanf, printf 와 혼용에서 사용하면 안된다. 동기화를 끊는 것이므로 어떤 문제가 발생할지 모릅니다. 방법 2: cin.tie(NULL)로 tie 해제cin.tie(NULL); 기본적으로 cin은 cout과 묶여 있어 cin을 호출하기 전에는 cout을 flush(출력)합니다. cin.tie(NULL)을 통해 이 연결을 해제하면 cin 호출 시 불필요한 flush를 방지할 수 있어 입출력 속도가 더욱 빨라집니다.3. 전체 적용 예시#include &lt;iostream&gt;using namespace std;int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)L int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; '\\n'; return 0;}이렇게 설정하면 cin/cout의 성능이 대폭 향상되며, 대용량 입출력 문제에서도 scanf/printf에 가까운 속도를 낼 수 있습니다.4. 주의사항 위 최적화를 사용한 후에는 scanf/printf 등 C 스타일 입출력과 혼용하면 안 됩니다. 입력이 매우 많고 빠른 처리가 필요한 경우에만 사용하는 것이 좋습니다. endl은 줄바꿈과 함께 flush를 수행하므로 속도 저하의 원인이 됩니다. \\n을 대신 사용하는 것이 좋습니다.5. 요약 최적화 방식 설명 ios::sync_with_stdio(false); C와의 동기화 비활성화 → 성능 향상 cin.tie(NULL); cin과 cout 연결 해제 → 불필요한 flush 제거 \\n 사용 endl 대신 \\n 사용 → flush 방지 6. 결론cin과 cout은 기본 상태에서는 느릴 수 있지만, ios::sync_with_stdio(false);와 cin.tie(NULL);을 적절히 활용하면 C 스타일의 빠른 입출력에 근접한 성능을 낼 수 있습니다. 특히, 대용량 데이터를 다루는 알고리즘 문제에서는 이러한 최적화가 매우 중요합니다.2차원 배열 입력값이 붙어서 문자열 형태로 나오는 경우가끔 bfs, dfs 문제에서 입력 값이 붙어 나오는 경우가 있다.7 8 0010000 0011000 0001100 1011111 1111010 0011110 0011100 0001000 3 5이럴 경우 아래와 같이 scanf 를 사용한다. for(int i = 1; i &lt;= N; i++){ for(int j = 1; j &lt;= M; j++){ scanf(\"%1d\", &amp;arr[i][j]); } }C++ Range-based for문C++11부터 도입된 range-based for문은 배열이나 STL 컨테이너와 같은 범위 기반 객체를 간결하게 순회할 수 있도록 해주는 문법이다.기본 문법for (자료형 변수명 : 컨테이너) { // 반복할 코드}위 문법은 컨테이너 내부의 원소들을 앞에서부터 차례대로 하나씩 변수명에 대입하여 반복 실행한다.예제#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() { vector&lt;int&gt; vec = {1, 2, 3, 4, 5}; for (int x : vec) { cout &lt;&lt; x &lt;&lt; \" \"; } return 0;}출력1 2 3 4 5참조(Reference)와 상수 참조(Const Reference) 복사 방식: 원소를 복사하여 사용 참조 방식: 원소에 직접 접근하여 수정 가능 상수 참조 방식: 원소를 복사하지 않으면서 수정은 불가능vector&lt;string&gt; names = {\"kim\", \"lee\", \"park\"};// 복사 (읽기 전용, 복사 비용 발생)for (string name : names) { ... }// 참조 (수정 가능)for (string &amp;name : names) { ... }// 상수 참조 (수정 불가, 복사 비용 없음)for (const string &amp;name : names) { ... }배열에도 사용 가능int arr[] = {10, 20, 30};for (int &amp;x : arr) { x += 5;}주의사항 컨테이너가 범위 기반 반복을 지원해야 한다 참조 타입을 사용할 때는 데이터 타입이 일치해야 한다 auto를 사용하면 타입 추론이 가능해 가독성이 높아진다for (auto &amp;elem : vec) { // vec의 원소를 참조하여 사용}예제 문제#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;char alphabet[26] = { 0 };int main(){ int cnt = 0; for(char &amp;x : alphabet){ x = 'A' + cnt; cnt++; } for(char x : alphabet) printf(\"%c \", x); return 0;}요약 구문 종류 의미 수정 가능 여부 복사 발생 여부 for (T x : container) 값 복사 후 사용 불가 O for (T&amp; x : container) 참조로 원소 직접 접근 가능 X for (const T&amp; x : container) 참조로 원소 접근 (수정 불가) 불가 X range-based for문은 코드의 간결성과 가독성을 높여주며, 특히 STL 컨테이너를 다룰 때 유용하다. 성능 측면에서도 참조나 상수 참조 방식을 활용하면 불필요한 복사를 방지할 수 있다." }, { "title": "중앙값값", "url": "/posts/%EC%A4%91%EC%95%99%EA%B0%92/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-04-05 00:00:00 +0900", "snippet": "중앙값통계에 있어서 어떤 몇 개의 수들을 대표하는 값으로 자주 사용되는 것에는, 평균(mean), 최빈값(mode), 중앙값(median)이 있다.이 문제에서 다룰 것은 중앙값(median)으로,어떤 수들을 오름차순(혹은 내림차순)으로 정렬했을 때 가운데에 오는 값을 그 수들의 중앙값이라고 부른다.동현이는 N(N은 홀수)개의 공에 각각 적당한 정수를 쓴 후, 그 공들을 상자에 넣었다.맨 처음에는 한 개의 공을 꺼내고, 그 뒤로부터는 한 번에 두 개의 공을 꺼낸다.이 때, 꺼낸 공들에 써져 있는 모든 정수들의 중앙값을 구하는 것이 문제이다.예를 들어, N=7이고, 공에 써져있는 수가 각각 1, 2, 3, 4, 5, 6, 7 이라 하고, 처음에는 5번 공을, 그 뒤로 (1, 2), (7, 4), (6, 3)의 공을 순서대로 꺼냈다고 해보자. 이때 각각의 중앙값들을 구하면 5, 2, 4, 4 가 된다.[1회] 5[2회] 1 2 5[3회] 1 2 4 5 7[4회] 1 2 3 4 5 6 7N과 꺼내는 공들이 주어질 때, 각각에 걸쳐 중앙값들을 출력하는 프로그램을 작성하자.해결#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() { int N; cin &gt;&gt; N; // 숫자 저장 vector&lt;int&gt; sequence(N); // 입력 받기 for (int i = 0; i &lt; N; ++i) { cin &gt;&gt; sequence[i]; } // maxHeap: 중앙값 이하 값 저장 (큰 값이 top) priority_queue&lt;int&gt; maxHeap; // minHeap: 중앙값 초과 값 저장 (작은 값이 top) priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minHeap; // 첫 번째 공: 하나만 꺼냄 maxHeap.push(sequence[0]); cout &lt;&lt; maxHeap.top() &lt;&lt; '\\n'; // 이후 2개씩 꺼냄 for (int i = 1; i &lt; N; i += 2) { maxHeap.push(sequence[i]); if (i + 1 &lt; N) maxHeap.push(sequence[i + 1]); // 힙 간 밸런스 유지 while (maxHeap.size() &gt; minHeap.size() + 1) { minHeap.push(maxHeap.top()); maxHeap.pop(); } while (!minHeap.empty() &amp;&amp; maxHeap.top() &gt; minHeap.top()) { int maxTop = maxHeap.top(); maxHeap.pop(); int minTop = minHeap.top(); minHeap.pop(); maxHeap.push(minTop); minHeap.push(maxTop); } cout &lt;&lt; maxHeap.top() &lt;&lt; '\\n'; // 중앙값 출력 } return 0;}" }, { "title": "해밍 경로", "url": "/posts/%ED%95%B4%EB%B0%8D%EA%B2%BD%EB%A1%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-03-30 00:00:00 +0900", "snippet": "해밍 경로해밍 경로는 모든 인접한 두 코드사이의 해밍 거리가 1인 경로이다.위의 예에서 (w_1, w_3, w_4)는 길이가 3인 해밍 경로이지만, (w_1, w_5, w_2)는 해밍 경로가 아니다.두 코드 사이에 해밍 경로가 여러 개가 있을 경우 가장 짧은 경로를 찾고자 한다.이 문제는 1번 코드에서부터 질의로 주어진 여러 개의 코드까지의 해밍 경로를 각각 구하는 프로그램을 작성하는 것이다.해결“해밍 거리가 1인 코드”만 연결하자.→ 즉, 각 코드에서 비트 하나만 바꾼 경우를 만들어서 그것이 전체 코드에 존재하는지 빠르게 확인해야 해.이를 위해 모든 코드를 map/set에 넣고, 각 코드에 대해 비트 하나씩 바꾼 변형된 코드를 만들어 lookup하는 방식으로 그래프를 구성하면 O(N × K) 로 해결 가능해!#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;int N, K, M;vector&lt;string&gt; codes;unordered_map&lt;string, int&gt; code_to_index;vector&lt;vector&lt;int&gt;&gt; adj;// 해밍 거리 1인 코드들만 간선으로 연결void build_graph() { adj.resize(N); for (int i = 0; i &lt; N; ++i) { string original = codes[i]; for (int j = 0; j &lt; K; ++j) { string modified = original; modified[j] = (modified[j] == '0') ? '1' : '0'; // flip bit if (code_to_index.count(modified)) { int neighbor = code_to_index[modified]; adj[i].push_back(neighbor); // 양방향 간선 adj[neighbor].push_back(i); } } }}// BFS + 경로 복원vector&lt;int&gt; bfs(int target) { vector&lt;int&gt; parent(N, -1); vector&lt;bool&gt; visited(N, false); queue&lt;int&gt; q; q.push(0); visited[0] = true; while (!q.empty()) { int cur = q.front(); q.pop(); if (cur == target) break; for (int next : adj[cur]) { if (!visited[next]) { visited[next] = true; parent[next] = cur; q.push(next); } } } if (!visited[target]) return {}; vector&lt;int&gt; path; for (int at = target; at != -1; at = parent[at]) path.push_back(at + 1); // algorithm 헤더에 포함된 뒤집기 함수, vector string 모두 뒤집을 수 있는 함수 reverse(path.begin(), path.end()); return path;}int main() { scanf(\"%d %d\", &amp;N, &amp;K); codes.resize(N); for (int i = 0; i &lt; N; ++i) { cin &gt;&gt; codes[i]; code_to_index[codes[i]] = i; } build_graph(); scanf(\"%d\", &amp;M); for (int i = 0; i &lt; M; ++i) { int J; scanf(\"%d\", &amp;J); vector&lt;int&gt; path = bfs(J - 1); if (path.empty()) { printf(\"-1\\n\"); } else { for (int p : path) printf(\"%d \", p); printf(\"\\n\"); } } return 0;}" }, { "title": "STL_Priority_Queue", "url": "/posts/STL_Priority_Queue/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-03-29 00:00:00 +0900", "snippet": "개요priority_queue 는 우선순위 큐(Priority Queue) 를 구현하는 STL 컨테이너 어댑터이다.내부적으로 heap(힙) 자료구조를 사용하며, 기본적으로 최대 힙(Max-Heap) 형태를 가진다.std::priority_queue 는 가장 큰 원소(우선순위가 높은 값) 가 top() 에 위치한다.이를 통해 항상 최대 혹은 최소 원소를 빠르게 접근할 수 있다.헤더와 기본 선언#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;int main() { priority_queue&lt;int&gt; pq; // 기본: 최대 힙 (std::less&lt;int&gt;) priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; minPQ; // 최소 힙} 내부 컨테이너로 std::vector 가 기본 사용됨 비교 객체(comparator)는 기본적으로 **std::less** → 최대 힙 최소 힙을 만들고 싶다면 **std::greater** 사용주요 특징 항상 가장 우선순위가 높은 값 을 O(1) 에 top() 으로 조회 가능 삽입(push) / 삭제(pop) 은 O(log n) 임의 접근(random access) 불가능 (heap 구조이기 때문) 내부적으로 make_heap, push_heap, pop_heap 연산 사용멤버 함수 정리 함수 설명 push(const T&amp; val) 원소 삽입 (O(log n)) emplace(args…) 원소 직접 생성 후 삽입 pop() top 원소 제거 (O(log n)) top() 가장 우선순위 높은 원소 반환 empty() 비어있는지 여부 확인 size() 원소 개수 반환 기본 사용 예제#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() { priority_queue&lt;int&gt; pq; // 최대 힙 pq.push(10); pq.push(5); pq.push(20); cout &lt;&lt; \"Top: \" &lt;&lt; pq.top() &lt;&lt; \"\\n\"; // 20 while (!pq.empty()) { cout &lt;&lt; pq.top() &lt;&lt; \" \"; pq.pop(); } cout &lt;&lt; \"\\n\"; return 0;}출력Top: 2020 10 5최소 힙 예제#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;functional&gt;using namespace std;int main() { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; // 최소 힙 pq.push(10); pq.push(5); pq.push(20); cout &lt;&lt; \"Top: \" &lt;&lt; pq.top() &lt;&lt; \"\\n\"; // 5 while (!pq.empty()) { cout &lt;&lt; pq.top() &lt;&lt; \" \"; pq.pop(); } cout &lt;&lt; \"\\n\";}출력Top: 55 10 20사용자 정의 구조체 예제 (커스텀 우선순위)#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Person { string name; int age;};// 나이 많은 순서대로 정렬struct Compare { bool operator()(const Person&amp; a, const Person&amp; b) const { return a.age &lt; b.age; // 큰 age가 먼저 }};int main() { priority_queue&lt;Person, vector&lt;Person&gt;, Compare&gt; pq; pq.push({\"Alice\", 25}); pq.push({\"Bob\", 30}); pq.push({\"Charlie\", 22}); while (!pq.empty()) { cout &lt;&lt; pq.top().name &lt;&lt; \" (\" &lt;&lt; pq.top().age &lt;&lt; \")\\n\"; pq.pop(); }}출력Bob (30)Alice (25)Charlie (22)lambda 를 이용한 커스텀 정렬 (modern C++)#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;int main() { auto cmp = [](const pair&lt;string,int&gt;&amp; a, const pair&lt;string,int&gt;&amp; b) { return a.second &lt; b.second; // 점수가 높은 순 }; priority_queue&lt;pair&lt;string,int&gt;, vector&lt;pair&lt;string,int&gt;&gt;, decltype(cmp)&gt; pq(cmp); pq.push({\"A\", 90}); pq.push({\"B\", 75}); pq.push({\"C\", 95}); while (!pq.empty()) { cout &lt;&lt; pq.top().first &lt;&lt; \" : \" &lt;&lt; pq.top().second &lt;&lt; \"\\n\"; pq.pop(); }}출력C : 95A : 90B : 75emplace 사용 예시#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;struct Data { string name; int score; Data(string n, int s) : name(n), score(s) {} bool operator&lt;(const Data&amp; other) const { return score &lt; other.score; // 높은 점수 우선 }};int main() { priority_queue&lt;Data&gt; pq; pq.emplace(\"Alice\", 90); pq.emplace(\"Bob\", 85); pq.emplace(\"Charlie\", 95); while (!pq.empty()) { cout &lt;&lt; pq.top().name &lt;&lt; \" : \" &lt;&lt; pq.top().score &lt;&lt; \"\\n\"; pq.pop(); }}출력Charlie : 95Alice : 90Bob : 85주의 사항 priority_queue 는 직접 순회(iterator) 불가능 내부 데이터 접근은 top() 으로만 가능 정렬 기준을 변경하려면 반드시 생성 시 comparator 를 지정해야 함 중간 변경, erase, 특정 원소 삭제 기능 없음 (heap 재구성 필요)응용 예시1️⃣ K번째 큰 원소 찾기#include &lt;bits/stdc++.h&gt;using namespace std;int main() { vector&lt;int&gt; nums = {3,2,1,5,6,4}; int k = 2; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; // 최소 힙 for (int n : nums) { pq.push(n); if (pq.size() &gt; k) pq.pop(); } cout &lt;&lt; k &lt;&lt; \"번째 큰 수: \" &lt;&lt; pq.top() &lt;&lt; \"\\n\"; // 5}Dijkstra 최단경로#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;typedef struct { int to; int cost;} Edge;struct cmp { bool operator()(const Edge&amp; a, const Edge&amp; b) const { return a.cost &gt; b.cost; }};int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;Edge&gt;&gt; graph(n); for (int i = 0; i &lt; m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; graph[u].push_back({v, w}); graph[v].push_back({u, w}); } vector&lt;int&gt; dist(n, 1e9); priority_queue&lt;Edge, vector&lt;Edge&gt;, cmp&gt; pq; dist[0] = 0; pq.push({0, 0}); // to=0, cost=0 while (!pq.empty()) { Edge cur = pq.top(); pq.pop(); int u = cur.to; int d = cur.cost; if (d &gt; dist[u]) continue; for (auto next : graph[u]) { int v = next.to; int w = next.cost; if (dist[v] &gt; d + w) { dist[v] = d + w; pq.push({v, dist[v]}); } } } for (int i = 0; i &lt; n; ++i) cout &lt;&lt; i &lt;&lt; \": \" &lt;&lt; dist[i] &lt;&lt; \"\\n\";}시간복잡도 표 연산 복잡도 push / emplace O(log n) pop O(log n) top O(1) size / empty O(1) 요약 구분 기본 비교자 내부 컨테이너 기본 정렬 방향 priority_queue std::less std::vector 최대 힙 priority_queue (min) std::greater std::vector 최소 힙 priority_queue 는 최대/최소값 관리, 탐욕 알고리즘, Dijkstra, Huffman, Kth 문제 등우선순위 기반 연산에 필수적인 STL 도구이다.예시 문제정올 외과 응급실에서는 환자들을 입원시킬 때 환자의 나이와 출혈량을 물어본다.출혈량이 높을 수록 더 먼저 수술을 받게 되는데, 출혈량이 같다면 고령의 환자를 먼저 수술한다. 환자의 입원과 수술 데이터를 실시간으로 처리하는 프로그램을 작성하라.입원 데이터는 “push Thomas 37 ​120.6” 와 같이 이름, 나이, 출혈량(ml) 순서로 주어지며,수술 데이터는 “pop”으로 주어진다. 이 경우 환자가 없다면 무시된다.#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;struct pat_info { string name; int age; float blood;};// 우선순위 비교: 출혈량이 높을수록 우선, 같으면 나이 많은 사람이 우선// 부등호의 방향은 우선순위 방향으로 정한다// 우선 순위 큐에서는 우선순위를 따지고 a의 우선순위가 b보다 낮으므로 a가 뒤로 가야 한다// 우선 순위가 높을 수록 top 으로 가야한다. // 이는 vector 에서 sort 할 때 compare 함수 할 때와는 다르다. 그 때는 출혈량이 높은(값이 큰) 경우 앞으로 가야하므로 부등호의 방향이 반대여야 한다.struct compare { bool operator()(const pat_info&amp; a, const pat_info&amp; b) { int blood_a = a.blood * 10; int blood_b = b.blood * 10; if (blood_a &lt; blood_b) return true; if (blood_a == blood_b &amp;&amp; a.age &lt; b.age) return true; return false; }};int main() { ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int Q; cin &gt;&gt; Q; priority_queue&lt;pat_info, vector&lt;pat_info&gt;, compare&gt; max_heap; for (int i = 0; i &lt; Q; i++) { string cmd; cin &gt;&gt; cmd; if (cmd == \"push\") { pat_info input; cin &gt;&gt; input.name &gt;&gt; input.age &gt;&gt; input.blood; max_heap.push(input); } else if (cmd == \"pop\") { if (!max_heap.empty()) { cout &lt;&lt; max_heap.top().name &lt;&lt; '\\n'; max_heap.pop(); } } } return 0;}" }, { "title": "STL_Map", "url": "/posts/STL_MAP/", "categories": "CodingTest", "tags": "CodingTest, STL, Container", "date": "2025-03-29 00:00:00 +0900", "snippet": "STL_MapC++ Standard Library map 컨테이너 정리기본적으로 key, value 값이 있는 파이썬의 dictionary 타입과 유사한 라이브러리📘 map 개요 헤더 파일: &lt;map&gt; 네임스페이스: std 내부 구조: Red-Black Tree (이진 탐색 트리의 일종) 키 중복: 허용하지 않음 (같은 키로 삽입하면 기존 값을 덮어씀) 정렬 기준: 기본적으로 std::less (오름차순 정렬) 시간 복잡도: 삽입/삭제/탐색 O(log n)📌 주요 특징 특징 설명 자동 정렬 키 기준으로 자동 정렬됨 (기본 오름차순) 유일한 키 동일 키 허용 안 됨 Key, Value 타입 지정 std::map&lt;Key, Value&gt; 형태 탐색 최적화 find, lower_bound, upper_bound 등 탐색 함수 제공 반복자 지원 begin(), end(), rbegin(), rend() 등 지원 🛠 기본 사용법 예시#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;// 내림차순 정렬 comparatorstruct Desc { bool operator()(const string&amp; a, const string&amp; b) const { return a &gt; b; // key가 큰 순서로 정렬 }};int main() { ios::sync_with_stdio(false); cin.tie(nullptr); // map 선언 (기본: 오름차순) map&lt;string, int&gt; score; // ① 삽입 score[\"Kim\"] = 90; // operator[] 방식 score.insert({\"Lee\", 85}); // initializer_list score.insert(make_pair(\"Park\", 95)); // make_pair() // ② 탐색(find) 및 수정 if (auto it = score.find(\"Lee\"); it != score.end()) { cout &lt;&lt; \"[탐색 성공] \" &lt;&lt; it-&gt;first &lt;&lt; \" : \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; it-&gt;second = 88; cout &lt;&lt; \"[수정 완료] Lee → \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; } // ③ 삭제(erase) score.erase(\"Kim\"); if (!score.count(\"Kim\")) cout &lt;&lt; \"[삭제 확인] Kim 없음\\n\"; // ④ iterator 기반 for loop 순회 cout &lt;&lt; \"\\n[Iterator 기반 순회]\\n\"; for (auto it = score.begin(); it != score.end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; \" : \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; // ⑤ range-based for 순회 cout &lt;&lt; \"\\n[Range-based for 순회]\\n\"; for (auto &amp;p : score) cout &lt;&lt; p.first &lt;&lt; \" = \" &lt;&lt; p.second &lt;&lt; '\\n'; // ⑥ lower_bound / upper_bound 테스트 cout &lt;&lt; \"\\n[lower_bound / upper_bound 테스트]\\n\"; if (auto lb = score.lower_bound(\"Lee\"); lb != score.end()) cout &lt;&lt; \"lower_bound(Lee) → \" &lt;&lt; lb-&gt;first &lt;&lt; '\\n'; if (auto ub = score.upper_bound(\"Lee\"); ub != score.end()) cout &lt;&lt; \"upper_bound(Lee) → \" &lt;&lt; ub-&gt;first &lt;&lt; '\\n'; // ⑦ map 크기 cout &lt;&lt; \"\\n현재 map 크기: \" &lt;&lt; score.size() &lt;&lt; '\\n'; // ⑧ custom comparator (내림차순) map&lt;string, int, Desc&gt; descScore; descScore[\"Ahn\"] = 70; descScore[\"Choi\"] = 92; descScore[\"Baek\"] = 88; cout &lt;&lt; \"\\n[내림차순 정렬된 map]\\n\"; for (auto it = descScore.begin(); it != descScore.end(); ++it) cout &lt;&lt; it-&gt;first &lt;&lt; \" : \" &lt;&lt; it-&gt;second &lt;&lt; '\\n'; // ⑨ 전체 삭제 및 empty 확인 descScore.clear(); if (descScore.empty()) cout &lt;&lt; \"\\n모든 데이터 삭제 완료\\n\"; return 0;}📚 주요 함수 정리 함수 설명 operator[] 키를 기준으로 값에 접근 또는 생성 insert(pair) 새 키-값 쌍 삽입 find(key) 키로 탐색, 없으면 end() 반환 erase(key) 키에 해당하는 원소 삭제 clear() 모든 원소 삭제 size() 현재 원소 개수 반환 count(key) 키 존재 여부 확인 (0 또는 1 반환) lower_bound(key) 주어진 키 이상인 첫 원소 반복자 반환 upper_bound(key) 주어진 키 초과하는 첫 원소 반복자 반환 💡 응용 예제1. Frequency Counter#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;int main() { string text = \"hello world\"; map&lt;char, int&gt; freq; for (char ch : text) { if (ch != ' ') freq[ch]++; } for (const auto&amp; [c, count] : freq) { std::cout &lt;&lt; c &lt;&lt; \": \" &lt;&lt; count &lt;&lt; \"\\n\"; } return 0;}2. 사용자 정의 정렬 (내림차순)#include &lt;iostream&gt;#include &lt;map&gt;struct Descending { bool operator()(int a, int b) const { return a &gt; b; }};int main() { map&lt;int, string, Descending&gt; my_map; my_map[3] = \"three\"; my_map[1] = \"one\"; my_map[2] = \"two\"; for (const auto&amp; [k, v] : my_map) { cout &lt;&lt; k &lt;&lt; \": \" &lt;&lt; v &lt;&lt; \"\\n\"; } return 0;}🆚 map vs unordered_map 특징 map unordered_map 내부 구조 Red-Black Tree Hash Table 정렬 키 기준 자동 정렬 정렬 없음 탐색 속도 O(log n) 평균 O(1), 최악 O(n) 사용자 정의 정렬 가능 불가능 키 타입 비교 가능한 타입 해시 가능한 타입 🔁 관련 컨테이너 multimap: 키 중복 허용하는 버전 (insert로 동일 키 여러 개 저장 가능) unordered_map: 해시 기반 map, 정렬은 안 되지만 평균 탐색 속도 빠름필요한 경우 특정 상황에 맞는 map 응용 예제나 성능 비교도 추가로 설명해줄 수 있음.예시 문제N개의 정수로 이루어진 수열에서 각 원소의 개수를 출력하는 프로그램을 작성하시오.#include&lt;cstdio&gt;#include&lt;map&gt;using namespace std;int main(){ map&lt;int, int&gt; m; int num, key, value; scanf(\"%d\", &amp;num); for(int i = 0; i &lt; num; i++){ scanf(\"%d\", &amp;key); m[key]++; } for(auto x : m){ printf(\"%d : %d\\n\", x.first, x.second); } /* for(auto [key, value] : m){ printf(\"%d : %d\\n\", key, value); } */ return 0;}" }, { "title": "2진수를 10진수로", "url": "/posts/2%EC%A7%84%EC%88%98%EB%A5%BC-10%EC%A7%84%EC%88%98%EB%A1%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2025-03-29 00:00:00 +0900", "snippet": "2진수를 10진수로2진수를 입력받아 10진수로 바꾸어주는 프로그램을 생각해보자.주어지는  2진수는 8비트로 구성되어있으며 최상위비트는 부호비트이다. 최상위 비트의 값이 0이면 양수, 1이면 음수이며 음수의 경우 2의 보수로 나타낸다.해결양수와 음수로 경우를 나눠 함수를 작성#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int negative_convt(string str){ // 음수의 경우 2의 보수를 계산하기 위해 먼저 - 값을 세팅하고 이를 위해 ret 값을 1로 설정한다. int size = str.size(), ret = 1, temp_mul = 1; // 음수 부호비트를 음수값으로 변환 for(int i = 0; i &lt; size - 1; i++){ ret *= 2; } ret *= -1; // 이후로는 양의 이진수 계산과 동일하게 계산 for(int i = size - 1; i &gt;= 1; i--){ if(str[i] == '1') ret += temp_mul; temp_mul *= 2; } return ret;}int positive_convt(string str){ int size = str.size(), ret = 0, temp_mul = 1; for(int i = size - 1; i &gt;= 1; i--){ if(str[i] == '1') ret += temp_mul; temp_mul *= 2; } return ret;}int main(){ string str; int answer; cin &gt;&gt; str; if(str[0] == '0'){ answer = positive_convt(str); } else{ answer = negative_convt(str); } printf(\"%d\\n\", answer); return 0;}" }, { "title": "토마토", "url": "/posts/%ED%86%A0%EB%A7%88%ED%86%A0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2025-03-21 00:00:00 +0900", "snippet": "토마토(3차원 BFS 탐색 문제, BFS 는 한번만 호출해서 한번에 상태 업데이트하기기)토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다. 창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라.단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다. 입력입력파일의 첫 줄에는 상자의 크기를 나타내는 두 정수 M, N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다.M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2≤M≤100, 2≤N≤100, 1≤H≤100이다.둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다.즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다.각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다.정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.이러한 N개의 줄이 H번 반복하여 주어진다.출력여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다.만약 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야하고토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_VAL 100using namespace std;int dy[4] = {-1, 1, 0, 0 };int dx[4] = {0, 0, -1, 1};int arrmap[MAX_VAL][MAX_VAL][MAX_VAL] = { 0 };bool isvisited[MAX_VAL][MAX_VAL][MAX_VAL] = { false };int day[MAX_VAL][MAX_VAL][MAX_VAL] = { 0 };typedef struct Cord { int y, x, z;};int m, n, h, max_day = 0;queue&lt;Cord&gt; q;void bfs(){ while(!q.empty()){ Cord temp_val = q.front(); int cy = temp_val.y; int cx = temp_val.x; int ch = temp_val.z; q.pop(); for(int dir = 0; dir &lt; 4; dir++){ int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; m){ if(!isvisited[ny][nx][ch] &amp;&amp; arrmap[ny][nx][ch] == 0){ q.push({ny, nx, ch}); arrmap[ny][nx][ch] = 1; day[ny][nx][ch] = day[cy][cx][ch] + 1; isvisited[ny][nx][ch] = true; } } } if(ch != 0){ int tmp_height = ch - 1; if(!isvisited[cy][cx][tmp_height] &amp;&amp; (arrmap[cy][cx][tmp_height] == 0)){ q.push({cy, cx, tmp_height}); arrmap[cy][cx][tmp_height] = 1; day[cy][cx][tmp_height] = day[cy][cx][ch] + 1; isvisited[cy][cx][tmp_height] = true; } } if(ch != h -1){ int tmp_height = ch + 1; if(!isvisited[cy][cx][tmp_height] &amp;&amp; arrmap[cy][cx][tmp_height] == 0){ q.push({cy, cx, tmp_height}); arrmap[cy][cx][tmp_height] = 1; day[cy][cx][tmp_height] = day[cy][cx][ch] + 1; isvisited[cy][cx][tmp_height] = true; } } }}int main(){ scanf(\"%d %d %d\",&amp;m, &amp;n, &amp;h); for(int height = 0; height &lt; h; height++){ for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ scanf(\"%d\", &amp;arrmap[i][j][height]); } } } // 입력을 한번에 넣어 bfs 는 한번만 돌아야 함, 아니면 순차적으로 돌게 되서 NG for(int height = 0; height &lt; h; height++){ for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(arrmap[i][j][height] == 1 &amp; !isvisited[i][j][height]){ q.push({i, j, height}); isvisited[i][j][height] = true; } } } } bfs(); for(int height = 0; height &lt; h; height++){ for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; m; j++){ if(arrmap[i][j][height] == 0){ printf(\"-1\\n\"); return 0; } max_day = max(day[i][j][height], max_day); } } } printf(\"%d\\n\", max_day); return 0;}" }, { "title": "C언어 XOR Swap 알고리즘", "url": "/posts/C%EC%96%B8%EC%96%B4-XOR-Swap-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/", "categories": "C", "tags": "C", "date": "2025-03-02 00:00:00 +0900", "snippet": "C언어 XOR Swap 알고리즘XOR 교체 알고리즘은 대부분의 현대적인 프로세서에서는 임시 변수를 사용하는 방법보다 더 느린데, 그 이유 중 하나로는 임시 변수를 사용하는 방법은 여러 명령어를 동시에 실행할 수 있도록 (명령어 수준 병렬성) 최적화하기가 더 쉽기 때문이다.반면, XOR 교체 알고리즘은 속도가 그리 빠르지 않아도 되고 메모리 (혹은 캐시) 사용을 최소화해야 하는 환경에서는 유용하게 사용될 수 있다. 따라서 이 방식은 임베디드 개발 환경에서 많이 이용된다.void swap(int *x, int *y){\t// x 가 1010 y가 0011 일 때 if (x != y) { *x ^= *y; // x = 1001 *y ^= *x; // y = 1010 *x ^= *y; // x = 0011 }}" }, { "title": "C언어 1인 비트 수 세기", "url": "/posts/C%EC%96%B8%EC%96%B4-1%EC%9D%B8-%EB%B9%84%ED%8A%B8-%EC%88%98-%EC%84%B8%EA%B8%B0/", "categories": "C", "tags": "C", "date": "2025-03-02 00:00:00 +0900", "snippet": "C언어 1인 비트 수 세기hamming weight32bit 입력이 들어왔을 때 사용할 수 있는 방법,분할정복 알고리즘을 이용하는 방식#include &lt;stdio.h&gt;const int m1 = 0x55555555; const int m2 = 0x33333333; const int m4 = 0x0f0f0f0f; const int m8 = 0x00ff00ff; const int m16 = 0x0000ffff; const int h01 = 0x01010101; int popcount_a(int x){\tx = (x &amp; m1 ) + ((x &gt;&gt; 1) &amp; m1 ); \tx = (x &amp; m2 ) + ((x &gt;&gt; 2) &amp; m2 ); \tx = (x &amp; m4 ) + ((x &gt;&gt; 4) &amp; m4 ); \tx = (x &amp; m8 ) + ((x &gt;&gt; 8) &amp; m8 ); \tx = (x &amp; m16) + ((x &gt;&gt; 16) &amp; m16); \treturn x;}int main(){\tint bitmap = 0x12345678;\tint count;\tcount = popcount_a(bitmap);\tprintf(\"count=%d\\n\", count );\treturn 0;}" }, { "title": "비트 제어", "url": "/posts/C%EC%96%B8%EC%96%B4-%EB%B9%84%ED%8A%B8-%EC%A0%9C%EC%96%B4/", "categories": "C", "tags": "C", "date": "2025-03-01 00:00:00 +0900", "snippet": "비트 제어논리식 사용특정 비트 ON OFF CHECK#define BIT2 (0x2)unsigned char bitmap;if(bitmap &amp; BIT2){}else{}특정 비트 클리어#define BIT2 (0x2)unsigned char bitmap;bitmap &amp;= (~BIT2);특정 비트 반전앞에선 특정 비트만 클리어하고 뒤에선 특정 비트만 XOR 연산한다.#define BIT2 (0x2)unsigned char bitmap;bitmap = (bitmap &amp; ~BIT2) | ((bitmap &amp; BIT2) ^ BIT2)비트 필드 사용typedef union { unsigned char bitmap; struct bitflag{ unsigned bit0 : 1; unsigned bit1 : 1; unsigned bit2 : 1; unsigned bit3 : 1; unsigned bit4 : 1; unsigned bit5 : 1; unsigned bit6 : 1; unsigned bit7 : 1; }bitflag;} bitdata_t;// 2번째 비트를 판단하여 분기 수행 if(bitdata.bitflag.bit1){ }else{}" }, { "title": "C언어 word alignment", "url": "/posts/C%EC%96%B8%EC%96%B4-word-alignment/", "categories": "C", "tags": "C", "date": "2025-03-01 00:00:00 +0900", "snippet": "C 언어 Union을 활용한 Word Alignment1. Word Alignment란?Word Alignment(워드 정렬)는 메모리에서 데이터를 효과적으로 정렬하여 접근 속도를 향상시키는 기법입니다. CPU는 특정 주소에서 데이터를 읽고 쓸 때 정렬된 주소(예: 4바이트 정렬, 8바이트 정렬)에서 수행하는 것이 더 효율적입니다.정렬되지 않은 데이터는 추가적인 연산이 필요할 수 있어 성능 저하를 유발할 수 있습니다.2. C 언어에서 Union을 활용한 Word AlignmentC 언어의 union을 사용하면 메모리를 공유하여 정렬을 맞추는 데 유용하게 활용할 수 있습니다. 이를 통해 구조체 내에서 자동으로 정렬을 조정할 수 있습니다.2.1 예제 코드#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// Word Alignment를 맞추기 위한 Union 활용union WordAligned { uint32_t aligned; // 4바이트 정렬 struct { uint16_t lower; uint16_t upper; } parts;};int main() { union WordAligned data; data.aligned = 0x12345678; printf(\"Full word: 0x%X\\n\", data.aligned); printf(\"Lower 16 bits: 0x%X\\n\", data.parts.lower); printf(\"Upper 16 bits: 0x%X\\n\", data.parts.upper); return 0;}2.2 코드 설명 union WordAligned는 4바이트 정렬을 유지하면서, 내부적으로 16비트(lower, upper) 단위로 접근할 수 있도록 설계되었습니다. aligned 변수는 32비트(4바이트) 정렬을 유지합니다. parts 구조체를 사용하여 하위 16비트(lower)와 상위 16비트(upper)를 접근할 수 있습니다. 이 방식은 Word Alignment를 유지하면서도 개별 바이트 조작이 필요한 경우 유용합니다.3. Union을 활용한 패딩 문제 해결일반적으로 구조체를 사용할 때, 정렬을 맞추기 위해 추가적인 패딩이 발생할 수 있습니다. 하지만 union을 활용하면 메모리를 공유하여 불필요한 패딩을 줄일 수 있습니다.예제 코드#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// 패딩을 줄이기 위한 Union 활용union PackedData { uint32_t value; // 4바이트 정렬 유지 struct { uint8_t byte1; uint8_t byte2; uint8_t byte3; uint8_t byte4; } bytes;};int main() { union PackedData data; data.value = 0xAABBCCDD; printf(\"Byte 1: 0x%X\\n\", data.bytes.byte1); printf(\"Byte 2: 0x%X\\n\", data.bytes.byte2); printf(\"Byte 3: 0x%X\\n\", data.bytes.byte3); printf(\"Byte 4: 0x%X\\n\", data.bytes.byte4); return 0;}코드 설명 union PackedData는 4바이트 정렬을 유지하면서도 바이트 단위로 접근할 수 있도록 합니다. 이를 통해 바이트 단위로 데이터를 조작하면서도 Word Alignment를 유지할 수 있습니다.4. 결론C 언어에서 union을 활용하면 Word Alignment를 유지하면서도 메모리 접근을 유연하게 할 수 있습니다. 이를 통해 데이터 정렬을 효율적으로 관리하고, 불필요한 패딩을 줄이며, 메모리 공간을 절약할 수 있습니다.이러한 기법은 시스템 프로그래밍, 네트워크 패킷 처리, 임베디드 시스템에서 유용하게 활용됩니다." }, { "title": "# 연산자와 ## 연산자", "url": "/posts/%EC%83%B5%EC%97%B0%EC%82%B0%EC%9E%90%EC%99%80-%EC%83%B5%EC%83%B5%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "C", "tags": "C", "date": "2025-02-16 00:00:00 +0900", "snippet": "C 언어의 “#” 연산자와 “##” 연산자C 언어에서 “#”(문자열화 연산자)와 “##”(토큰 결합 연산자)는 전처리기에서 사용되는 연산자로, 매크로를 정의할 때 유용하게 활용할 수 있습니다.”#” 연산자 (문자열화 연산자)”#” 연산자는 매크로의 인수를 문자열로 변환하는 역할을 합니다. 주로 디버깅 메시지를 출력할 때 유용합니다.예제 코드#include &lt;stdio.h&gt;#define STRINGIFY(x) #xint main() { printf(\"%s\\n\", STRINGIFY(Hello World!)); printf(\"%s\\n\", STRINGIFY(123 + 456)); return 0;}출력 결과Hello World!123 + 456STRINGIFY(x) 매크로는 x를 문자열로 변환하여 출력합니다.”##” 연산자 (토큰 결합 연산자)”##” 연산자는 매크로 인수를 결합하여 새로운 토큰을 생성하는 역할을 합니다. 주로 변수명이나 함수명을 동적으로 생성할 때 유용합니다.예제 코드#include &lt;stdio.h&gt;#define CONCAT(a, b) a##bint main() { int num1 = 10; int num2 = 20; int num12 = 100; printf(\"num1: %d\\n\", num1); printf(\"num2: %d\\n\", num2); printf(\"num12: %d\\n\", CONCAT(num, 12)); // num12를 참조 return 0;}출력 결과num1: 10num2: 20num12: 100CONCAT(num, 12)는 num12로 변환되어 해당 변수를 참조하게 됩니다.”#” 연산자와 “##” 연산자 함께 사용하기두 연산자를 조합하여 좀 더 복잡한 매크로를 만들 수도 있습니다.예제 코드#include &lt;stdio.h&gt;#define MAKE_VAR(name) var_##name#define PRINT_VAR(name) printf(\"%s = %d\\n\", #name, name)int main() { int MAKE_VAR(x) = 42; // var_x라는 변수 생성 PRINT_VAR(var_x); return 0;}출력 결과var_x = 42MAKE_VAR(x)는 var_x로 변환되고, PRINT_VAR(var_x)는 var_x = 42를 출력하게 됩니다.정리| 연산자 | 기능 ||——–|——————————–|| “#” | 매크로의 인수를 문자열로 변환 || “##” | 매크로의 인수를 결합하여 새로운 토큰 생성 |이 두 연산자는 전처리기 매크로를 보다 강력하게 활용할 수 있도록 도와줍니다." }, { "title": "LTE, NR Band Graph", "url": "/posts/LTE,-NR-Band-%EA%B7%B8%EB%A6%BC%EC%A0%95%EB%A6%AC/", "categories": "Telecommunication", "tags": "Telecommunication", "date": "2025-01-18 00:00:00 +0900", "snippet": "LTENR" }, { "title": "함수 포인터 활용 예시", "url": "/posts/%ED%95%A8%EC%88%98-%ED%8F%AC%EC%9D%B8%ED%84%B0-%ED%99%9C%EC%9A%A9-%EC%98%88%EC%8B%9C/", "categories": "C", "tags": "C", "date": "2025-01-05 00:00:00 +0900", "snippet": "함수 포인터 활용 예시#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct { int (*add)(int, int); int (*subtract)(int, int); int (*multiply)(int, int); int (*divide)(int, int);} FunctionAPI;// 함수 정의int add(int a, int b) { return a + b;}int subtract(int a, int b) { return a - b;}int multiply(int a, int b) { return a * b;}int divide(int a, int b) { if (b == 0) { printf(\"Error: Division by zero!\\n\"); return 0; } return a / b;}// API 인스턴스 생성FunctionAPI* function_api() { static FunctionAPI api = { .add = add, .subtract = subtract, .multiply = multiply, .divide = divide }; return &amp;api;}int main() { int x = 10, y = 5; // API를 이용한 연산 호출 printf(\"Addition: %d\\n\", function_api()-&gt;add(x, y)); printf(\"Subtraction: %d\\n\", function_api()-&gt;subtract(x, y)); printf(\"Multiplication: %d\\n\", function_api()-&gt;multiply(x, y)); printf(\"Division: %d\\n\", function_api()-&gt;divide(x, y)); return 0;}" }, { "title": "C++ 알고리즘 정리", "url": "/posts/C++-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest, DFS, BFS", "date": "2024-08-27 00:00:00 +0900", "snippet": "C++ 알고리즘 정리C++ STL 라이브러리 정리C++ DFS (깊이 우선 탐색) 정리🧭 개요DFS(Depth First Search)는 그래프나 트리에서 모든 노드를 방문하는 방법 중 하나이다.한 방향으로 갈 수 있을 만큼 깊게 탐색하다가, 더 이상 갈 곳이 없으면 되돌아(backtrack)와서 다른 경로를 탐색하는 방식이다.주로 재귀 호출(recursion) 이나 스택(stack) 자료구조를 이용하여 구현한다.🧠 특징 스택 기반 (재귀 함수 또는 명시적 스택 사용 가능) 그래프의 모든 정점 탐색 가능 경로 찾기, 순환 탐지, 연결 요소 탐색 등에 사용🔧 DFS 구현 방식1️⃣ 재귀 함수 방식#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; graph;vector&lt;bool&gt; visited;void dfs(int node) { visited[node] = true; cout &lt;&lt; node &lt;&lt; ' '; for (int next : graph[node]) { if (!visited[next]) { dfs(next); } }}int main() { int n = 5; // 정점 수 graph.resize(n + 1); visited.resize(n + 1, false); // 예제 간선 추가 graph[1] = {2, 3}; graph[2] = {4}; graph[3] = {5}; dfs(1); // 1번 노드부터 시작}2️⃣ 스택을 이용한 비재귀 방식#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; graph;vector&lt;bool&gt; visited;void dfs_iterative(int start) { stack&lt;int&gt; s; s.push(start); while (!s.empty()) { int node = s.top(); s.pop(); if (visited[node]) continue; visited[node] = true; cout &lt;&lt; node &lt;&lt; ' '; for (int i = graph[node].size() - 1; i &gt;= 0; --i) { int next = graph[node][i]; if (!visited[next]) { s.push(next); } } }}DFS 기본 구조 (그래프)#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; graph;bool visited[100];void dfs(int node) { visited[node] = true; cout &lt;&lt; node &lt;&lt; \" \"; for (int next : graph[node]) { if (!visited[next]) { dfs(next); } }}int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; // 노드 수와 엣지 수 입력 graph.resize(n + 1); for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; graph[u].push_back(v); graph[v].push_back(u); } dfs(1); // 1번 노드부터 탐색 시작}백트래킹(Backtracking) 개념백트래킹은 현재 상태에서 가능한 모든 후보군을 따라 들어가며 탐색하다가,문제의 조건을 만족하지 않으면 다시 이전 상태로 돌아가서 다른 경로를 탐색하는 기법이다.DFS를 기반으로 구현하는 경우가 많으며, 모든 경우의 수를 탐색할 때 주로 사용된다.대표적인 예시로는 N-Queen 문제, 부분 집합 구하기, 순열(permutation) 문제 등이 있다.DFS + 백트래킹 기본 구조#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n;bool isvisited[10]; // 숫자 사용 여부 체크void dfs(vector&lt;int&gt;&amp; perm, int depth) { if (depth == n) { for (int num : perm) { cout &lt;&lt; num &lt;&lt; \" \"; } cout &lt;&lt; \"\\n\"; return; } for (int i = 1; i &lt;= n; i++) { if (!isvisited[i]) { isvisited[i] = true; perm.push_back(i); dfs(perm, depth + 1); perm.pop_back(); isvisited[i] = false; } }}int main() { cin &gt;&gt; n; vector&lt;int&gt; perm; dfs(perm, 0);}DFS와 백트래킹의 차이점 DFS 는 단순히 깊이 우선으로 모든 경로를 탐색하는 것 백트래킹 은 DFS 탐색 중 조건을 만족하지 못하는 경로를 조기에 차단하고 돌아가는 것DFS 백트래킹 최적화 방법 가지치기(Pruning) 유망하지 않은 노드에 대해 탐색을 중단하여 불필요한 계산을 줄인다. 조건 검사 순서 최적화 빠르게 실패를 발견할 수 있도록 조건을 먼저 검사한다. 상태 복원 최소화 가능한 한 상태 복원 비용을 줄이는 방법을 설계한다. 요약 DFS는 깊이 우선 탐색이다. 백트래킹은 DFS에 조건 검사를 추가하여 불필요한 탐색을 줄이는 기법이다. DFS + 백트래킹 조합은 많은 경우의 수를 효율적으로 탐색할 때 유용하다. 최적화를 위해 가지치기를 적극적으로 활용한다.📌 주요 응용 예시 그래프 탐색 (모든 정점 방문) 경로 찾기 (두 노드 사이의 경로) 사이클 검사 (방문 중에 다시 방문하는 정점 존재 여부) 미로 탐색 (출구 찾기) 위상 정렬, 트리의 깊이 계산 등🔍 시간 및 공간 복잡도 항목 복잡도 시간 복잡도 O(V + E) 공간 복잡도 O(V) + 호출 스택 or 명시적 스택 (V: 정점 개수, E: 간선 개수)C++ BFS (너비 우선 탐색) 정리🧭 개요BFS(Breadth-First Search, 너비 우선 탐색)는 시작 노드에서 가까운 노드부터 탐색해나가는 그래프 탐색 알고리즘입니다. 주로 큐(queue) 를 사용하여 구현됩니다.🧠 특징 큐 기반 가장 가까운 거리의 정점을 먼저 방문함 최단 경로 탐색에 활용 무방향/유향 그래프 모두 사용 가능🔧 BFS 구현 예시#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; graph;vector&lt;bool&gt; visited;void bfs(int start) { queue&lt;int&gt; q; visited[start] = true; q.push(start); while (!q.empty()) { int node = q.front(); q.pop(); cout &lt;&lt; node &lt;&lt; ' '; for (int next : graph[node]) { if (!visited[next]) { visited[next] = true; q.push(next); } } }}int main() { int n = 5; graph.resize(n + 1); visited.resize(n + 1, false); // 예제 간선 추가 graph[1] = {2, 3}; graph[2] = {4}; graph[3] = {5}; bfs(1); // 1번 노드부터 BFS 시작}📌 주요 응용 예시 최단 거리 탐색 (가중치 없는 그래프) 미로 탐색 문제 다단계 탐색 (소셜 그래프) 레벨 순서 탐색 (트리) 최소 이동 횟수 계산🔍 시간 및 공간 복잡도 항목 복잡도 시간 복잡도 O(V + E) 공간 복잡도 O(V) + 큐 공간 (V: 정점 개수, E: 간선 개수)DFS BFS 알고리즘 요약#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define MAX_SIZE 25using namespace std;// 위, 오른, 아래, 왼int dx[] = {-1, 0, 1, 0};int dy[] = {0, 1, 0, -1};int n; // 행과 열의 수int group_id; // 단지의 번호로 첫번째 단지부터 1로 시작int groups[MAX_SIZE * MAX_SIZE]; // 각 단지별 집의 수int map[MAX_SIZE][MAX_SIZE]; // 지도bool visited[MAX_SIZE][MAX_SIZE]; // 방문했는지를 표시하는 지도// DFS - Recursionvoid dfs_recursion(int x, int y) { // 함수에 들어왔으면 -&gt; 방문으로 표시 visited[x][y] = true; // 해당 단지의 집의 수를 증가시킴 groups[group_id]++; // 해당 위치의 주변을 확인 for(int i = 0; i &lt; 4; i++){ int nx = x + dx[i]; int ny = y + dy[i]; // 지도를 벗어나지 않고 if(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n){ // 집이면서 방문하지 않았다면 -&gt; 방문 if(map[nx][ny] == 1 &amp;&amp; visited[nx][ny] == false){ dfs_recursion(nx, ny); } } }}// DFS - Stackvoid dfs_stack(int x, int y) { stack&lt; pair&lt;int,int&gt; &gt; s; // 이용할 스택, (x,y) -&gt; (행, 열) s.push(make_pair(x,y)); // pair를 만들어서 stack에 넣습니다. // 처음 x,y를 방문 했기때문에 visited[x][y] = true; groups[group_id]++; while(!s.empty()){ // 스택의 top 원소 꺼내기 x = s.top().first; y = s.top().second; s.pop(); // 해당 위치의 주변을 확인 for(int i = 0; i &lt; 4; i++){ int nx = x + dx[i]; int ny = y + dy[i]; // 지도를 벗어나지 않고 if(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n){ // 집이면서 방문하지 않았다면 -&gt; 방문 if(map[nx][ny] == 1 &amp;&amp; visited[nx][ny] == false){ visited[nx][ny]=true; // 해당 단지의 집의 수를 증가시킴 groups[group_id]++; s.push(make_pair(x,y)); // push하는 경우이기 때문에 현재 위치도 넣어준다. s.push(make_pair(nx,ny)); // 스택에 현재 nx,ny도 푸시 } } } }}// BFSvoid bfs(int x, int y){ queue&lt; pair&lt;int,int&gt; &gt; q; // 이용할 큐, (x,y) -&gt; (행, 열) q.push(make_pair(x,y)); // pair를 만들어서 queue에 넣습니다. // 처음 x,y를 방문 했기때문에 visited[x][y] = true; groups[group_id]++; while(!q.empty()){ // 큐의 현재 원소를 꺼내기 x = q.front().first; y = q.front().second; q.pop(); // 해당 위치의 주변을 확인 for(int i = 0; i &lt; 4; i++){ int nx = x + dx[i]; int ny = y + dy[i]; // 지도를 벗어나지 않고 if(0 &lt;= nx &amp;&amp; nx &lt; n &amp;&amp; 0 &lt;= ny &amp;&amp; ny &lt; n){ // 집이면서 방문하지 않았다면 -&gt; 방문 if(map[nx][ny] == 1 &amp;&amp; visited[nx][ny] == false){ visited[nx][ny]=true; // 해당 단지의 집의 수를 증가시킴 groups[group_id]++; // 큐에 현재 nx,ny를 추가 q.push(make_pair(nx,ny)); } } } }}int main (){ scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++) //입력을 1개씩 숫자로 끊어서 받습니다 -&gt; %1d scanf(\"%1d\", &amp;map[i][j]); } // 전체 지도 탐색 for(int i = 0; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ // 집이면서 방문하지 않았다면 -&gt; 방문 if(map[i][j]==1 &amp;&amp; visited[i][j]==false){ // 해당 지역에 단지 id를 부여하고 group_id++; // 탐색 //dfs_recursion(i, j); //dfs_stack(i, j); //bfs(i, j); } } } sort(groups + 1, groups + group_id + 1); printf(\"%d\\n\", group_id); for (int i = 1; i &lt;= group_id; i++) { printf(\"%d\\n\", groups[i]); }}그리디(Greedy) 알고리즘 최적해를 구하는 과정에서 결정을 하는 순간 최적이라고 생각되는 것을 선택해 나가는 것으로 최종해를 얻는 방법이다.    일반적으로 부분 문제의 최적해가 항상 전체 문제의 최적해에 적용되는 것은 아니나탐욕 알고리즘으로 해결되는 문제는 부분 문제의 최적해가 전체 문제의 최적해에 그대로 적용​된다. 탐욕알고리즘으로 최적해를 구하는 문제는 다음 두 가지 특성을 만족한다. (1) 탐욕적인 선택조건(Greedy Choice Property) : 현재 최적이라 선택한 것이 이후의 선택에 영향을 주지 않는다.  (이후에 최적해를 구할때 현재 선택을 번복하는 일이 없다.) (2) 최적 부분 구조(Optimal property) : 큰 문제의 최적해는 보다 작은 부분 문제의 최적해를 포함한다.  (보다 작은 부분 문제의 최적해가 큰 문제의 최적해에 그대로 사용된다.) 위의 조건을 만족하지 않는경우 탐욕알고리즘은 최적해를 구하는 방법으로 사용하기 어렵다.  이 경우 동적계획법 등 다른 알고리즘을 생각해볼 수 있다. 어떤 문제의 경우, 그리디 알고리즘을 적용하기 위해서는  입력된 데이터를 어떤 기준으로 정렬하는등 전처리가 필요한 경우도 있다예제 문제[문제]1, 2, 4, 8, 16그램 추가 a, b, c, d, e개 주어진다.N그램 짜리 물건을 측정하는데 추의 개수를 최소로 사용하고자 한다.사용된 최소 개수의 추를 출력하는 프로그램을 작성하시오.입력1, 2, 4, 8, 16그램 추 a, b, c, d, e개와 정수 N이 공백으로 구분되어 입력된다.(1 &lt;= N &lt;= 200)단, a, b, c, d, e 는 모두 정수이다.모든 추의 개수의 합은 50개 이하이다.출력N그램 짜리 물건을 측정하는데 사용된 최소 개수의 추를 하나의 정수로 출력한다.주어진 입력으로 물건을 잴 수 없는 경우 impossible을 출력한다.풀이 추 무게를 큰 것부터 사용한다 (16g → 8g → 4g → 2g → 1g) 각 무게에서 가능한 만큼 최대한 사용해서 N그램을 줄여간다 남은 N이 0이 되면 성공, 아니라면 impossible #include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int weight[5] = {16, 8, 4, 2, 1};int main(){ int a, b, c, d, e, N, answer = 0; vector&lt;int&gt; arr; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e &gt;&gt; N; arr.push_back(e); arr.push_back(d); arr.push_back(c); arr.push_back(b); arr.push_back(a); for(int i = 0; i &lt; 5; i++){ int used = N / weight[i]; if(used &gt; arr[i]) used = arr[i]; N -= (used * weight[i]); answer += used; } if(N == 0) cout &lt;&lt; answer &lt;&lt; '\\n'; else cout &lt;&lt; \"impossible\" &lt;&lt; '\\n'; return 0;}HashSTL 에서는 map container 를 통해 간단히 구현 가능#define MAX_TABLE (10007)unsigned long hash(const char* str){ unsigned long hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;}Union FindBinary search부분합Segment TreePriority QueueTrie정렬KMP" }, { "title": "ARM 강의 (Arm 아키텍처의 구조와 원리)", "url": "/posts/ARM-%EA%B0%95%EC%9D%98(Arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%9B%90%EB%A6%AC)/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2024-08-18 00:00:00 +0900", "snippet": "ARM 아키텍처 소개1. ARM 프로세서와 시스템 반도체시스템 반도체 개발 과정시스템 반도체의 핵심은 ARM 프로세서입니다. ARM은 다양한 기술적 요소를 집약한 핵심 IP(Intellectual Property)를 제공하며, 이러한 IP를 바탕으로 파운드리에서 SoC(System-on-Chip)와 같은 시스템 반도체가 양산됩니다.ARM의 비즈니스 모델ARM은 라이선스 비즈니스를 통해 수익을 창출합니다. 주요 IP를 라이선스하는 방식으로, 시스템 반도체 개발 기업들에게 제공됩니다.2. ARM의 역사ARM의 설립과 초기 1978년: 영국 캠브리지에서 크리스 커리와 헤르만 하우저가 Acorn Computers라는 회사를 설립했습니다. 1985년: RISC 기반의 첫 번째 ARM 프로세서인 ARM1이 개발되었습니다.ARM의 발전 1990년: 애플과 VLSI Technology와의 조인트 벤처로 ARM Ltd.가 설립되었습니다. 2005년: Cortex 시리즈가 발표되었고, 고성능 애플리케이션 프로세서(Cortex-A), 실시간 프로세서(Cortex-R), 마이크로 컨트롤러(Cortex-M)로 제품군이 세분화되었습니다.최근 역사 2011년: ARMv8 아키텍처가 발표되었으며, 64비트 동작 모드를 지원하여 스마트폰 및 서버 시장에 진출했습니다. 2021년: ARMv9 아키텍처가 발표되었고, AI 및 클라우드 컴퓨팅 시장을 목표로 하고 있습니다.3. ARM의 라이선스 모델IP(Intellectual Property)IP는 재사용 가능하도록 모듈화된 핵심 기능 설계입니다. ARM은 이러한 IP를 라이선스하여 다양한 반도체 기업들에게 제공하고 있습니다.개발 과정시스템 반도체 개발은 다음과 같은 과정을 거칩니다: 스펙 확정 RTL 설계(Verilog) 합성 및 검증 FPGA 검증 공정 개발 및 Wafer 작업 패키징 및 브링업 특성 평가 및 시스템 통합4. ARM 프로세서의 패밀리Cortex 시리즈 Cortex-A: 높은 성능이 요구되는 스마트폰, 넷북, 디지털 TV 등에서 사용되는 애플리케이션 프로세서. Cortex-R: 실시간 응답이 필요한 통신 모뎀 및 산업용 컨트롤러 등에 사용되는 리얼타임 프로세서. Cortex-M: 저전력 소모와 저비용이 중요한 마이크로 컨트롤러에서 사용.5. ARM 아키텍처 진화 과정주요 아키텍처 ARMv6: ARM11 제품군으로 SIMD 및 TrustZone 기술을 도입. ARMv7: Cortex 시리즈로 확장되며 멀티코어 지원과 가상화 기술을 추가. ARMv8: 64비트 지원, 저전력 설계, 서버 시장 진출을 목표로 한 아키텍처. ARMv9: AI와 클라우드 컴퓨팅을 지원하는 최신 아키텍처로, 보안 기능이 강화되었습니다.6. ARM 프로세서와 관련된 용어ARM 아키텍처 ARM 아키텍처는 ARM 프로세서를 설계하는 기본적인 디자인입니다. 소프트웨어 개발자가 알아야 할 레지스터, 메모리 구조, 어셈블리 명령어 등이 포함됩니다.PE(Processing Element) PE는 ARM 아키텍처를 구현한 프로세서의 요소로, 예를 들어 Cortex-A8은 싱글 코어 프로세서로 구성되며, Cortex-A53은 멀티코어 프로세서로 각각의 코어가 PE로 명시됩니다.7. ARM 아키텍처와 Cortex 프로세서의 종류ARM 아키텍처별 Cortex 프로세서 ARMv7-A: Cortex-A5, Cortex-A7, Cortex-A9 ARMv8-A: Cortex-A53, Cortex-A57, Cortex-A72ARM 아키텍처 학습 방법1. ARM 프로세서를 배워야 하는 이유1.1 보드 브링업(Board Bring-up)과 ARM 아키텍처ARM 아키텍처를 배우는 것은 보드 브링업 과정에서 매우 중요합니다. 브링업 단계에서는 부트로더의 ‘스타트업’ 코드를 작성하며, 이는 시스템 자원(메모리, 캐시 등)과 주변 장치(키보드, USB 등)를 초기화하는 작업을 포함합니다. 이 과정을 성공적으로 수행하려면 ARM 어셈블리 명령어와 ARM 아키텍처의 동작 원리를 잘 이해해야 합니다.1.2 디바이스 드라이버 개발ARM 프로세서의 동작 원리를 이해하면, 디바이스 드라이버 개발 시 성능을 최적화할 수 있습니다. 예를 들어, ARM의 Generic Interrupt Controller(GIC)가 인터럽트를 처리하는 방식을 알면, 인터럽트 우선순위 설정이나 IRQ/FIQ 설정을 효과적으로 수행할 수 있습니다.1.3 RTOS나 리눅스 커널의 이해리눅스 커널이나 RTOS의 핵심 루틴은 ARM 어셈블리 명령어로 구현된 경우가 많습니다. 인터럽트 핸들러, 컨텍스트 스위칭, 선점 스케줄링, 시스템 콜 핸들러 등의 기능을 깊이 이해하기 위해서는 ARM 프로세서의 동작 원리를 잘 파악해야 합니다.1.4 디버깅 능력 향상ARM 아키텍처를 깊이 이해하면, 디버깅 과정에서 문제 해결 능력을 크게 향상시킬 수 있습니다. 예를 들어, 메모리 어보트가 발생할 때 ARM 아키텍처의 익셉션 처리와 관련 레지스터의 용법을 이해하면, 문제의 원인을 효율적으로 파악할 수 있습니다.2. ARM 아키텍처를 학습하는 방법의 문제점2.1 이론과 실습의 불일치ARM 아키텍처의 기능을 이해하는 것뿐만 아니라, 이러한 기능이 리눅스 커널이나 RTOS에서 어떻게 활용되는지 파악하는 과정이 중요합니다. ARM 아키텍처의 익셉션 벡터 테이블이 운영체제에서 어떤 방식으로 구현되는지를 이해하지 않으면 시스템의 동작 원리를 완전히 파악하기 어렵습니다.2.2 실전 프로젝트에서의 활용 부족실습을 통해 ARM 프로세서의 주요 개념을 학습하는 것은 중요하지만, 이 학습된 내용을 실전 프로젝트에서 어떻게 활용할 수 있는지 이해하지 않으면 학습한 내용을 내재화하기 어렵습니다. 시간이 지나면 학습한 내용을 잊기 쉬우며, 이를 방지하기 위해서는 실전에서의 활용 경험이 필요합니다.3. ARM 아키텍처 학습 방법3.1 디버깅을 통한 학습디버깅 과정에서 ARM 어셈블리 명령어를 익히는 것이 효과적입니다. GDB와 같은 디버깅 도구를 사용해 실습을 진행하면, 배운 내용을 더 오래 기억할 수 있습니다.3.2 운영체제와 함께 학습운영체제의 기본 원리를 ARM 아키텍처와 함께 학습하는 것이 중요합니다. ARM 아키텍처에서 정의된 주요 기능이 리눅스 커널에서 어떻게 구현되는지를 파악하는 것이 필수적입니다.3.3 실전 프로젝트에서의 확인실전 프로젝트에서 배운 내용이 어떻게 구현되는지 확인하는 것이 중요합니다. 이를 통해 학습한 내용을 실전에서 적용할 수 있게 되며, 학습의 효과를 극대화할 수 있습니다.ARM 아키텍처: 레지스터1. 레지스터란 무엇인가?1.1 기본 개념 레지스터는 CPU가 직접 접근하고 사용하는 변수입니다. 다른 메모리와 비교해 개수가 적지만, 속도가 빠릅니다. ARM 프로그래밍에서 레지스터는 중요한 역할을 하며, ARMv7과 ARMv8에서의 레지스터 사용 방식이 다릅니다. ARMv7: R13은 스택 포인터, R14는 링크 레지스터로 사용됩니다. ARMv8: SP는 스택 포인터, X30은 링크 레지스터로 사용됩니다. 1.2 레지스터의 중요성 레지스터는 어셈블리 명령어와 함께 사용되며, ARM 코어의 작업을 최적화하는 데 중요한 역할을 합니다. 대부분의 프로그래밍에서 레지스터가 어떻게 사용되는지 이해하는 것이 중요합니다.2. ARMv7 아키텍처에서의 레지스터2.1 범용 레지스터 R0 ~ R15: ARMv7 아키텍처에서 주로 사용되는 범용 레지스터입니다. 이들 레지스터는 어셈블리 명령어의 입력과 출력으로 사용되며, 프로세스의 실행 흐름을 나타냅니다. CPSR, SPSRs: 프로세스 상태를 나타내는 레지스터로, 인터럽트 및 예외 처리에 관련된 플래그와 모드 정보를 담고 있습니다.2.2 뱅크드 레지스터 ARMv7에서는 각 작업 모드(SVC, UND, IRQ, FIQ 등)별로 다른 뱅크드 레지스터가 있습니다. 이는 각 모드에서 다른 스택 포인터(R13)와 링크 레지스터(R14)를 사용하게 합니다. 동작 모드가 변경될 때마다 관련된 레지스터가 전환되어, 각 작업 모드가 독립적으로 관리될 수 있도록 합니다.3. ARMv8 아키텍처에서의 레지스터3.1 범용 레지스터 X0 ~ X30: ARMv8 아키텍처에서 사용되는 64비트 범용 레지스터입니다. 이들 레지스터는 어셈블리 명령어의 입력과 출력으로 사용됩니다. W0 ~ W30: X0 ~ X30의 하위 32비트로, 32비트 연산에 사용됩니다.3.2 스페셜 레지스터 PSTATE: 이전의 CPSR와 유사한 역할을 하는 레지스터로, 프로세서의 상태를 관리합니다. 이 레지스터는 인터럽트 마스크, 조건 플래그, 익셉션 레벨 등을 포함합니다. SPSR_ELx: 예외 처리 시 PSTATE 값을 백업하는 레지스터입니다. 익셉션 레벨별로 존재하며, 익셉션을 처리한 후 복귀할 때 사용됩니다.3.3 시스템 레지스터 TTBR_EL1, TTBR_EL2, TTBR_EL3: 메모리 관리와 가상화 등을 제어하는 데 사용되는 시스템 레지스터입니다. 이들 레지스터는 각 익셉션 레벨에서 접근할 수 있는 권한이 다릅니다. SCTLR_ELx: 시스템 제어 레지스터로, MMU, 캐시, 얼라인먼트 검사 등 주요 아키텍처 기능을 제어합니다.4. 레지스터의 사용 예시4.1 리눅스 커널에서의 레지스터 사용 리눅스 커널에서 범용 레지스터는 다양한 작업을 수행하는 데 사용됩니다. 예를 들어, 컨텍스트 스위칭 과정에서는 X19 ~ X28 범용 레지스터가 스택에 저장되고 복원됩니다.4.2 디버깅에서의 레지스터 활용 레지스터는 디버깅 과정에서도 중요한 역할을 합니다. 예를 들어, 커널 패닉 로그를 분석할 때, 범용 레지스터와 스페셜 레지스터의 상태를 확인하여 문제의 원인을 추적할 수 있습니다.5. 레지스터 학습 방법5.1 실습을 통한 학습 레지스터는 기계적으로 학습하는 것보다 RTOS나 커널과 함께 실습을 통해 배우는 것이 효과적입니다. 디버깅 툴을 사용하여 어셈블리 명령어와 레지스터의 관계를 이해하는 것이 중요합니다.5.2 운영체제와 함께 배우기 ARM 아키텍처의 레지스터를 학습할 때, 운영체제의 기본 원리와 함께 학습하는 것이 도움이 됩니다. 이는 학습한 내용을 실전 프로젝트에서 효과적으로 활용할 수 있게 도와줍니다.어셈블리 명령어1. 어셈블리 명령어가 어렵다고 느끼는 이유1.1 입문자에게 어셈블리 명령어란 ARM 아키텍처를 처음 학습할 때 어셈블리 명령어는 큰 장벽으로 느껴질 수 있습니다. 어셈블리 명령어는 매우 간단하고 명료하지만, 해당 프로시저의 목적을 파악하기 어려운 경우가 많습니다. 어셈블리 명령어를 학습할 때는 명령어 자체뿐만 아니라, 루틴을 통해 동작을 이해하는 것이 중요합니다.1.2 예시 코드로 설명 예를 들어, C 언어로 작성된 함수와 이를 어셈블리 코드로 표현한 경우를 비교하면 어셈블리 코드가 구체적으로 어떤 동작을 수행하는지 이해하기 어려울 수 있습니다.2. 어셈블리 명령어로 할 수 있는 것들2.1 부트 시퀀스 관점에서의 소프트웨어 스택 어셈블리 명령어는 부트로더 개발에서 매우 중요한 역할을 합니다. 하드웨어 초기화, 메모리 초기화, 커널 이미지 로딩 등을 처리합니다. ARM 아키텍처의 기능을 활용한 드라이버 구현이나 리눅스 커널에서 SMC(시큐어 모니터 콜) 호출 관련 드라이버도 어셈블리 명령어로 구현할 수 있습니다.2.2 디버깅에서의 활용 디버깅 시, 커널의 NULL 포인터 역참조 등과 같은 문제를 추적하기 위해 어셈블리 명령어의 동작을 분석하는 것이 필요합니다.3. 어셈블리 명령어의 기본 포맷3.1 명령어 형식 어셈블리 명령어는 주로 OP Code와 레지스터로 구성됩니다. 예를 들어, MOV 명령어는 레지스터에 값을 이동시키는 역할을 하며, ADD 명령어는 덧셈을 수행합니다.3.2 예시 간단한 예로, MOV R0, #7은 R0 레지스터에 7을 저장합니다. ADD R0, R1, R2는 R1과 R2의 값을 더하여 R0에 저장합니다.4. 산술 연산 명령어4.1 ADD 명령어 ADD 명령어는 두 개의 값을 더하여 결과를 특정 레지스터에 저장합니다. 예제: ADD R0, R1, #7은 R1에 7을 더한 결과를 R0에 저장합니다.4.2 SUB, SBC, RSB, RSC 명령어 SUB 명령어는 두 값을 빼는 연산을 수행하며, SBC는 캐리를 고려한 뺄셈 연산을 수행합니다. RSB는 뺄셈의 피연산자 순서를 반대로 수행하며, RSC는 캐리를 적용하여 피연산자의 순서를 반대로 수행합니다.5. 비트 시프트 명령어5.1 LSL, LSR, ASR, ROR 명령어 LSL은 왼쪽으로 비트를 시프트하고, LSR은 오른쪽으로 비트를 시프트합니다. ASR은 오른쪽으로 비트를 시프트하면서 부호 비트를 유지하고, ROR은 오른쪽으로 시프트한 결과를 순환시킵니다.6. 논리 연산 명령어6.1 AND, ORR, ORN, EOR, BIC 명령어 AND 명령어는 두 값의 비트 AND 연산을 수행합니다. ORR 명령어는 OR 연산을, ORN은 OR NOT 연산을 수행합니다. EOR는 XOR 연산을, BIC는 특정 비트를 클리어하는 연산을 수행합니다.7. 메모리 액세스 명령어: Load/Store7.1 LDR 명령어 LDR 명령어는 메모리에서 데이터를 로드하여 레지스터에 저장하는 역할을 합니다. 예제: LDR R0, [R1]은 R1이 가리키는 주소에서 값을 로드하여 R0에 저장합니다.7.2 STR 명령어 STR 명령어는 레지스터의 값을 메모리에 저장하는 역할을 합니다. 예제: STR R3, [R1]은 R3의 값을 R1이 가리키는 메모리 주소에 저장합니다.8. 브랜치 명령어8.1 B, BL, BLX, BLR 명령어 B 명령어는 지정된 주소로 무조건 분기합니다. BL은 서브루틴을 호출하고 복귀 주소를 링크 레지스터에 저장합니다. BLX, BLR 명령어는 함수 포인터로 호출하여 분기하는 데 사용됩니다.9. 조건부 브랜치 명령어9.1 CBZ, CBNZ, TBZ, TBNZ 명령어 CBZ는 레지스터 값이 0이면 분기하고, CBNZ는 0이 아니면 분기합니다. TBZ는 특정 비트가 0이면 분기하고, TBNZ는 특정 비트가 1이면 분기합니다.10. SVC, HVC, SMC 명령어10.1 SVC 명령어 SVC는 유저 애플리케이션에서 커널로 진입하기 위해 사용됩니다.10.2 HVC 명령어 HVC는 하이퍼바이저 호출에 사용되며, 주로 가상화 환경에서 사용됩니다.10.3 SMC 명령어 SMC는 시큐어 월드와 논 시큐어 월드 간의 전환을 수행합니다.11. xPSR(CPSR, SPSRs) 레지스터 설정11.1 xPSR이란 xPSR은 프로세서의 상태를 나타내는 레지스터로, CPSR과 SPSR_가 포함됩니다.11.2 xPSR 레지스터 읽기/쓰기 명령어 MRS 명령어를 통해 xPSR의 값을 읽을 수 있으며, MSR 명령어로 값을 쓸 수 있습니다.ARM 아키텍처: 동작 모드1. 동작 모드를 알아야 하는 이유1.1 익셉션 처리와 동작 모드 ARM 아키텍처에서 익셉션이 발생하면, 프로세서는 특정 동작 모드로 전환됩니다. 이 과정에서 동작 모드에 대한 이해가 필수적입니다. 동작 모드는 프로세서가 특정 작업을 수행할 때 필요한 특권 레벨과 연관됩니다. 예를 들어, 메모리 관리나 인터럽트 처리는 특정 동작 모드에서만 가능합니다.1.2 범용 레지스터와 동작 모드의 관계 각 동작 모드에는 고유의 범용 레지스터 집합이 있으며, 이러한 레지스터는 동작 모드에 따라 다르게 동작합니다. 예를 들어, 슈퍼바이저 모드에서는 범용 레지스터 R13과 R14가 SVC 모드에 특화된 값으로 설정됩니다.1.3 어셈블리 명령어와 동작 모드 ARM 어셈블리 명령어를 통해 동작 모드를 전환할 수 있습니다. 이러한 전환은 특히 시스템 소프트웨어나 커널을 개발할 때 중요합니다.2. ARMv7 아키텍처의 동작 모드2.1 동작 모드와 특권 레벨 유저 모드(USR): 유저 애플리케이션이 실행되는 모드로, 가장 낮은 특권 레벨(PL0)을 가집니다. 슈퍼바이저 모드(SVC): 운영체제의 커널이 구동되는 모드로, SVC 명령어를 통해 진입하며, 특권 레벨은 PL1입니다. IRQ 모드: 일반 인터럽트가 발생했을 때 진입하는 모드로, PL1 특권 레벨을 가집니다. FIQ 모드: 고속 인터럽트가 발생했을 때 진입하는 모드로, PL1 특권 레벨을 가집니다. Abort 모드(ABT): 메모리 어보트 익셉션이 발생했을 때 진입하는 모드로, PL1 특권 레벨을 가집니다. Undefined 모드(UND): 정의되지 않은 명령어가 실행될 때 진입하는 모드로, PL1 특권 레벨을 가집니다. System 모드(SYS): 유저 모드의 레지스터 뷰를 공유하며 PL1에서 실행됩니다.2.2 동작 모드 전환 방법 동작 모드는 MSR CPSR_C 명령어를 통해 소프트웨어적으로 전환할 수 있습니다. 이 명령어는 CPSR 레지스터의 M[4:0] 비트를 수정하여 새로운 동작 모드로 전환합니다.2.3 동작 모드 변경 시 주의 사항 유저 모드(PL0)에서는 PL1 모드로의 직접적인 전환이 불가능하며, 반드시 SVC 명령어 등을 통해 익셉션을 유발해야 합니다. 특정 동작 모드로 전환한 후에는 해당 모드에서만 사용할 수 있는 레지스터와 특권 명령어를 활용하여 시스템을 제어할 수 있습니다.3. ARMv7 동작 모드와 Privilege Level(특권 레벨)3.1 특권 레벨의 정의 ARM 아키텍처에서 특권 레벨은 소프트웨어가 시스템 리소스에 접근할 수 있는 권한을 정의합니다. PL0부터 PL3까지의 특권 레벨이 존재하며, PL0는 유저 애플리케이션이, PL1은 운영체제 커널이 주로 사용하는 레벨입니다.3.2 PL0 (Privilege Level 0) PL0는 비특권 레벨로, 유저 모드에서 애플리케이션이 실행됩니다. 이 레벨에서는 시스템 설정이나 메모리 관리에 대한 접근 권한이 제한됩니다.3.3 PL1 (Privilege Level 1) PL1은 대부분의 시스템 소프트웨어가 실행되는 특권 레벨로, 운영체제 커널이나 인터럽트 핸들러가 이 레벨에서 동작합니다.4. CPSR 레지스터와 동작 모드4.1 CPSR 레지스터란? CPSR(Current Program Status Register)은 ARM 프로세서의 현재 상태를 나타내는 레지스터입니다. 이 레지스터는 프로세서의 동작 모드, 인터럽트 상태, 조건 플래그 등을 관리합니다.4.2 CPSR 레지스터의 M[4:0] 비트 M[4:0] 비트는 현재 동작 모드를 인코딩하여 나타냅니다. 예를 들어, 유저 모드는 0b10000 (0x10)으로, 슈퍼바이저 모드는 0b10011 (0x13)으로 설정됩니다.4.3 CPSR 접근 권한 PL0에서는 CPSR 레지스터에 직접 접근할 수 없으며, PL1 이상의 특권 레벨에서만 직접 접근이 가능합니다.5. 동작 모드 전환을 위한 어셈블리 명령어5.1 MSR CPSR_C 명령어 MSR CPSR_C 명령어는 CPSR 레지스터의 특정 필드를 수정하여 동작 모드를 변경하는 데 사용됩니다. 이 명령어를 사용하여 프로세서를 슈퍼바이저 모드, IRQ 모드 등으로 전환할 수 있습니다.5.2 SUBS 및 MOVS 명령어 SUBS PC LR 혹은 MOVS PC LR 명령어는 레지스터 값을 기반으로 동작 모드를 전환합니다. 이 명령어는 주로 익셉션 처리 루틴에서 사용됩니다.6. 리눅스 커널에서의 동작 모드 전환6.1 리눅스 커널의 실행 흐름 리눅스 커널에서 유저 모드에서 발생한 인터럽트를 처리할 때, IRQ 모드로 진입한 후 슈퍼바이저 모드로 전환합니다. 이 과정에서 ARM 어셈블리 명령어를 사용하여 모드를 전환하고, 필요한 처리를 수행합니다.6.2 리눅스 커널의 어셈블리 코드 예시 리눅스 커널의 setup.c 파일에서 MSR CPSR_C 명령어를 사용하여 다양한 동작 모드에서 스택 포인터를 설정하는 과정을 확인할 수 있습니다.6.3 IRQ 모드에서 슈퍼바이저 모드로의 전환 IRQ 모드에서 인터럽트 처리 후 슈퍼바이저 모드로 진입하는 과정을 통해, 리눅스 커널이 시스템의 안정성을 어떻게 유지하는지 확인할 수 있습니다.ARM 아키텍처: 익셉션 레벨 (Exception Levels)1. 익셉션 레벨의 핵심 개념1.1 익셉션 레벨이란? 익셉션 레벨(Exception Level, EL)은 ARM 프로세서에서 소프트웨어가 실행되는 권한 수준(Privilege Level)을 정의합니다. ARMv8 아키텍처는 EL0에서 EL3까지의 4가지 익셉션 레벨을 제공합니다. EL0: 일반 애플리케이션이 실행되는 비특권(Unprivileged) 모드. EL1: 운영체제 커널(OS Kernel)과 같은 특권(Privileged) 모드. EL2: 하이퍼바이저(Hypervisor) 모드로, 가상화를 지원하는 특권 레벨. EL3: 시큐어 모니터(Secure Monitor) 모드로, 시스템의 가장 높은 특권을 가지며, 시큐어 상태와 논 시큐어 상태 간 전환을 담당. 1.2 익셉션 레벨을 알아야 하는 이유 ARMv8 아키텍처를 제대로 이해하기 위해서는 익셉션 레벨에 대한 이해가 필수적입니다. 익셉션 레벨은 시스템의 보안 및 가상화 기술을 구현하는 데 중요한 역할을 합니다. 특히, 트러스트존(TrustZone)과 하이퍼바이저 등의 기능은 각각 EL3와 EL2에서 실행됩니다.2. 익셉션 레벨과 Privilege Level2.1 Privilege Level이란? Privilege Level(PL)은 메모리, 명령어, 레지스터 등에 접근할 수 있는 권한을 의미합니다. 각 익셉션 레벨은 특정 Privilege Level을 가지며, 이 권한에 따라 시스템 자원에 대한 접근이 결정됩니다.2.2 익셉션 레벨과 관련된 소프트웨어 스택 EL0: 애플리케이션이 실행됩니다. EL1: 리눅스 커널 또는 RTOS 커널이 실행됩니다. EL2: 하이퍼바이저가 실행되며, 가상화된 환경에서 여러 운영체제를 관리합니다. EL3: 시큐어 모니터가 실행되며, 보안 상태 전환을 관리합니다.3. 익셉션 레벨 전환3.1 높은 익셉션 레벨로 전환 익셉션(예: 인터럽트, 시스템 호출)이 발생하면, 프로세서는 높은 익셉션 레벨로 전환하여 이를 처리합니다. 이 과정에서 시스템의 안정성과 보안을 유지하기 위해 각 레벨에서 적절한 처리가 이루어집니다.3.2 낮은 익셉션 레벨로 복귀 익셉션 처리 후, 프로세서는 원래 실행 중이던 코드로 복귀하기 위해 낮은 익셉션 레벨로 돌아갑니다. 복귀 과정은 SPSR_ELx 및 ELR_ELx 레지스터를 설정하고, ERET 명령어를 실행함으로써 이루어집니다.4. 익셉션 레벨과 PSTATE4.1 PSTATE란? PSTATE는 프로세서의 상태를 나타내는 레지스터로, 현재 익셉션 레벨(CurrentEL)을 포함한 여러 상태 정보를 관리합니다. CurrentEL 시스템 레지스터: 현재 익셉션 레벨을 확인할 수 있는 레지스터입니다.4.2 PSTATE와 익셉션 레벨 읽기 MRS 명령어를 사용하여 CurrentEL 레지스터에서 현재 익셉션 레벨을 읽어올 수 있습니다. 이러한 정보는 디버깅 및 시스템 상태를 확인하는 데 유용합니다.5. 익셉션 레벨 관련 어셈블리 명령어5.1 SVC, HVC, SMC 명령어 SVC: EL0에서 EL1로 익셉션 레벨을 변경합니다. HVC: EL1에서 EL2로 익셉션 레벨을 변경합니다. SMC: EL1에서 EL3로 익셉션 레벨을 변경합니다.5.2 ERET 명령어 ERET 명령어는 익셉션을 처리한 후, 원래의 익셉션 레벨로 복귀합니다. 이 명령어는 익셉션 처리 루틴에서 사용되며, PSTATE와 ELR_ELx 레지스터를 이용해 원래의 코드 실행 위치로 복귀합니다.6. 익셉션 레벨에 따른 실행 흐름6.1 애플리케이션에서 하이퍼바이저까지 EL0: 유저 애플리케이션이 실행되는 비특권 모드. EL1: 시스템 자원에 접근할 수 있는 커널 모드. EL2: 가상화 환경을 관리하는 하이퍼바이저 모드. EL3: 시스템의 가장 높은 특권을 가지며, 보안과 관련된 작업을 수행하는 시큐어 모니터 모드.6.2 익셉션 처리의 전체 흐름 시스템에서 발생하는 모든 익셉션은 익셉션 벡터 테이블에 의해 관리되며, 각 익셉션 레벨에 대응하는 핸들러가 처리합니다.이 문서는 ARM 아키텍처의 익셉션 레벨에 대해 깊이 있는 설명을 제공하며, 시스템 소프트웨어 개발자가 익셉션 레벨을 이해하고 효과적으로 활용할 수 있도록 돕습니다." }, { "title": "ARM 강의(시스템 반도체와 전기 자동차 중심)", "url": "/posts/ARM-%EA%B0%95%EC%9D%98(%EC%8B%9C%EC%8A%A4%ED%85%9C-%EB%B0%98%EB%8F%84%EC%B2%B4%EC%99%80-%EC%A0%84%EA%B8%B0-%EC%9E%90%EB%8F%99%EC%B0%A8-%EC%A4%91%EC%8B%AC)/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2024-08-10 00:00:00 +0900", "snippet": "시스템 소프트웨어 업계 동향: 2023년 이후 전망1. 시스템 소프트웨어 분야 개요시스템 소프트웨어는 컴퓨터 하드웨어와 사용자가 서로 상호작용할 수 있게 해주는 소프트웨어의 한 종류로, 주요하게는 운영 체제, 유틸리티 프로그램, 디바이스 드라이버 등을 포함합니다. 2023년 이후, 시스템 소프트웨어 업계는 다양한 기술적 발전과 글로벌 시장의 변화로 인해 급격한 성장을 기대하고 있습니다.주요 동향 시스템 반도체: 시스템 반도체는 컴퓨터나 전자 시스템 부품을 하나의 집적 회로에 통합한 SoC(System-on-Chip)와 같은 기술을 포함합니다. 이 분야는 자율 주행 자동차, IoT(사물 인터넷), 의료기기, 항공기 등의 기술 발전과 함께 중요성이 더욱 커지고 있습니다. 전기 자동차: 전기 자동차는 자율 주행 및 인포테인먼트 시스템의 발전과 함께 시스템 소프트웨어의 핵심 응용 분야로 부상하고 있습니다. IoT 및 의료기기: IoT와 의료기기는 시스템 소프트웨어를 통해 다양한 스마트 기능과 연결성을 제공하며, 이는 앞으로도 더 많은 발전 가능성을 내포하고 있습니다. AR/VR 디바이스: 메타버스의 발전에 따라 AR(증강 현실) 및 VR(가상 현실) 디바이스의 개발이 활발히 이루어지고 있습니다. 이러한 디바이스들은 고성능의 시스템 소프트웨어를 필요로 하며, 이 시장의 성장과 함께 관련 소프트웨어의 수요도 증가하고 있습니다.2. 시스템 반도체와 시스템 소프트웨어의 관계시스템 반도체는 시스템 소프트웨어와 밀접한 관계를 맺고 있습니다. 시스템 반도체는 특정 하드웨어 기능을 지원하는 소프트웨어가 필요하며, 이로 인해 시스템 소프트웨어의 중요성이 부각됩니다.주요 발전 동향 국가 차원의 시스템 반도체 육성: 시스템 반도체는 국가 전략적으로 중요한 기술로, 많은 국가들이 이를 육성하기 위해 다양한 정책적 지원을 하고 있습니다. 예를 들어, 채용 계약 학과의 설치를 통해 시스템 반도체 관련 인력을 양성하고, 펩리스 스타트업에 대한 지원을 확대하고 있습니다. 미국의 투자: 미국은 시스템 반도체 산업에 많은 투자를 하고 있으며, 관련 대학원에 예산을 지원하고 기업들에게 다양한 혜택을 제공합니다.시스템 반도체 관련 소프트웨어 스택 Bootloader: Little Kernel(LK), uboot 등. RTOS(실시간 운영 체제): 다양한 실시간 응용 프로그램을 지원하기 위한 운영 체제. Linux Kernel Driver: 디바이스 드라이버, 시스템 프로그래밍 등을 포함하는 핵심 소프트웨어. HAL(Hardware Adaptation Layer) 라이브러리: 하드웨어 적응층으로서, 하드웨어와 소프트웨어 간의 상호작용을 지원.3. 전기 자동차와 시스템 소프트웨어의 발전전기 자동차 분야는 시스템 소프트웨어가 중요한 역할을 하는 대표적인 산업입니다. 자율 주행 시스템 및 인포테인먼트 시스템의 발전은 전기 자동차의 성능과 사용자 경험을 크게 향상시키고 있습니다.주요 동향 전기 자동차 엔지니어의 증가: 2022년 대비 2030년까지 전기 자동차 소프트웨어와 전자 엔지니어의 수는 10배 이상 증가할 것으로 예상됩니다. SW와 전자 기술의 성장: 전기 자동차 산업에서 소프트웨어와 전자 기술의 성장이 전체 시장의 성장을 앞지를 것으로 예상됩니다.전기 자동차 개발 관련 소프트웨어 스택 Bootloader: 전기 자동차에서 중요한 역할을 하는 소프트웨어 초기화 과정. Linux Kernel Driver: 전기 자동차 내 다양한 장치와 시스템을 제어하는 핵심 소프트웨어. HAL: 하드웨어와 소프트웨어 간의 인터페이스를 관리. 하이퍼바이저: 가상화 기술을 통해 여러 운영 체제를 동시에 실행할 수 있게 함. 도메인 기술: ISO26262 등 자동차 안전 기준과 OEM 스펙에 맞는 소프트웨어 개발이 필요.전기 자동차 주요 요소 기술 자율 주행(ADAS): 고도화된 운전 보조 시스템으로, 안전성과 편의성을 제공. 인포테인먼트 시스템: 운전자와 승객에게 다양한 정보와 엔터테인먼트를 제공하는 시스템. Cyber Security: 전기 자동차의 데이터 보호와 사이버 공격 방지를 위한 보안 기술.#시스템 소프트웨어 개발자가 되기 위해 필요한 준비 사항1. 시스템 반도체 개발 과정 이해시스템 반도체 개발은 여러 단계의 복잡한 과정으로 이루어집니다. 이를 이해하는 것은 시스템 소프트웨어 개발자에게 필수적입니다.개발 과정 IP란?: IP(Intellectual Property)는 재사용 가능하도록 기능을 모듈화하여 설계한 코어 디자인입니다. 이는 Digital IP와 Mixed IP로 나뉩니다. 개발 단계: Spec 확정 RTL 설계 (Verilog) 합성/검증 공정 개발 Wafer 작업 Packaging Bring-up 특성 평가 FPGA 검증 Back-End 개발 BSP 개발 System Integration Engineering sample 개발 단계 세부 설명 1단계: 로직 설계: 로직 설계 단계에서 로직 설계 개발자와 시스템 소프트웨어 개발자가 소통합니다. 이는 매우 중요한 단계입니다. 2단계: 파운드리 업체와의 협업: 펩리스 업체는 주로 로직 설계를 담당하고, 파운드리 업체에서 칩 공정 개발을 수행합니다. 3단계: 브링업 (Bring-up): 전원이나 클럭을 조정하면서 특성 평가 테스트를 수행합니다. IP와 시스템을 안정화하는 디버깅 작업이 포함됩니다. 2. SoC(시스템 온 칩) 개발 프로세스 및 생태계SoC는 시스템 반도체의 핵심 구성 요소로, 시스템 소프트웨어 개발자는 이를 깊이 이해해야 합니다.SoC의 구성 요소와 생태계 SoC 벤더 개발 프로세스: SoC 벤더는 고객과 긴밀하게 협업하여 IP 설계, BSP 개발, 최종 SW 개발 등을 수행합니다. 각종 소프트웨어 버전 릴리즈, 주요 버그 수정 및 성능 개선, SW 기능 구현이 포함됩니다. 주요 소프트웨어 스택: Bootloader: 초기 부팅 과정에서의 소프트웨어 스택. HAL (Hardware Adaptation Layer): 하드웨어와 소프트웨어 간의 상호작용을 지원하는 계층입니다. 리눅스 커널: SoC에서 다양한 장치와 시스템을 제어하는 핵심 소프트웨어. 하이퍼바이저: 가상화 기술을 통해 여러 운영 체제를 동시에 실행할 수 있습니다. 3. 전기 자동차 개발과 시스템 소프트웨어전기 자동차는 자율 주행, 인포테인먼트 시스템 등에서 시스템 소프트웨어가 중요한 역할을 합니다.전기 자동차 개발 프로세스 자율 주행(ADAS): CPU: Cortex-Ax(Cortex-A72), Cortex-R 계열 하이퍼바이저, RTOS 등의 사용이 증가하고 있습니다. 인포테인먼트 시스템: CPU: Cortex-Ax(Cortex-A72) 계열 리눅스 커널과 하이퍼바이저를 활용한 소프트웨어 개발이 필요합니다. 전기 자동차 주요 요소 기술 AI 기능 설계: NPU 설계 AI 기능을 Chipset IP로 설계하는 기술이 필요합니다. 핵심 소프트웨어 스택: 하이퍼바이저의 사용 증가 Rich OS 적용 (리눅스 운영체제) 4. 시스템 소프트웨어 개발자의 주요 기술 영역시스템 소프트웨어 개발자는 다양한 기술을 익혀야 하며, 각 산업에 따라 요구되는 기술 스택이 다를 수 있습니다.핵심 기술 영역 (Tech Area) Arm 아키텍처: Cortex-A5x, Cortex-M3 등의 프로세서와 관련된 기술. 익셉션 레벨, 어셈블리 명령어 등 하드웨어 관련 기술. SoC 아키텍처: SoC의 설계 및 디버그 아키텍처 이해. Boot Sequence 및 Memory 아키텍처 이해. 리눅스 커널: 디바이스 드라이버 개발, 프로세스 및 메모리 관리, 파일 시스템 관련 기술. Ftrace 등의 디버깅 도구 사용. 개발 유틸리티: 빌드 아키텍처, 크로스 컴파일러, GIT 등 개발 도구 사용 능력. Automotive 시스템 소프트웨어: ISO26262, OEM Feature, Cyber Security, Safety 등 자동차 관련 도메인 지식. #리눅스 시스템 소프트웨어 개발 관련 생태계1. 리눅스 커널 오픈 소스 프로젝트리눅스 커널 커뮤니티란? 리눅스 커널 커뮤니티는 리눅스 커널 개발의 중심으로, 커널의 기능 개발, 서브시스템 기능 개선, 논리적 오류 수정 등을 논의하는 공간입니다. 주요 링크: 리눅스 커널 메일링 리스트 Kernel.org 리눅스 커널 브랜치 메인 라인 커널: 가장 최신의 커널 버전. Stable Kernel (LTS): 장기 지원 버전으로, 안정성을 중시하는 사용자들에게 적합.주요 리눅스 커널 오픈 소스 개발자 리누스 토발즈: 리눅스 커널 개발의 총책임자로 전체 개발 방향을 관리. 리드 개발자: Kroah-Hartman, Thomas Gleixner, Ingo Molnar, Peter Zijlstra, Steven Rostedt, Russell King 등. 메인테이너: 각 서브시스템의 책임자로, GIT 관리 및 패치 리뷰를 수행. 리뷰어: 서브시스템 내에서 활발히 활동하며 메인테이너가 지정하는 역할. 컨트리뷰터: 모든 개발자가 해당되며, 커널 코드에 기여.2. SoC 벤더SoC란? SoC(System-on-Chip)는 하나의 칩에 컴퓨터 또는 다른 전자 시스템의 모든 구성 요소를 통합한 집적 회로를 의미합니다. 독립적인 컴퓨팅 기능을 수행할 수 있으며, 대표적인 SoC 벤더로는 브로드컴, 퀄컴, 미디어텍, 엔비디아 등이 있습니다.SoC 벤더 개발자의 역할 리눅스 커널 버전(LTS) 선택: 각 SoC에 맞는 커널 버전을 선택하여 적용. 부트 롬과 부트로더 개발: 칩을 초기화하고, 하드웨어 IP를 브링업하며 최적화하는 커널 드라이버를 구현. 협업: Customer(OEM)와 긴밀하게 협력하여 개발을 진행.주요 SoC 제품군 엔비디아: 테그라 시리즈. 브로드컴: BCM 시리즈 (예: 라즈베리 파이). 퀄컴: 스냅드래곤 시리즈. 미디어텍: 헬리오 시리즈.SoC 벤더 개발 프로세스 및 생태계 SoC 벤더는 IP 설계부터 BSP 개발, 최종 소프트웨어 개발까지 여러 단계에서 리눅스 커널 커뮤니티 및 OEM 업체와 협력합니다.3. OEM 제품 개발 업체OEM 업체 개발자의 역할 SoC 벤더가 릴리스한 BSP(리눅스 커널 코드, 드라이버, 부트로더)를 받아 제품 스펙과 시나리오에 맞게 제품을 개발. SoC 벤더 개발자와 협력하여 제품을 브링업하고, 새로운 기능을 구현하며, 안정화 작업(버그 수정)을 진행.OEM 제품 시스템 소프트웨어 개발자의 역할 제품을 브링업하고 모든 기능을 안정화하며, SoC 벤더와 솔루션 업체와 협업하여 안정적인 제품을 개발.4. 자동차 OEM전기 자동차 개발 프로세스 및 생태계 마이컴(ECU): 운전자의 주행을 제어하는 CPU로, Cortex-M3 계열을 주로 사용하며 베어메탈 또는 RTOS로 운영. 자율 주행(ADAS): 차선 감지, 레이더 정보 제어 등을 위해 Cortex-Ax(Cortex-A72), Cortex-R 계열의 CPU를 사용하며, 하이퍼바이저와 RTOS를 활용. 인포테인먼트 시스템: 네비게이션 및 운전자의 UX를 위한 시스템으로, Cortex-Ax 계열의 CPU와 리눅스 커널, 하이퍼바이저를 사용.전기 자동차 시스템 소프트웨어 개발자의 역할 전장 솔루션의 모든 기능을 안정화하고, SoC 벤더 및 여러 솔루션 업체와 협력하여 안정적인 전기 자동차 시스템을 개발.5. 리눅스 시스템 소프트웨어 개발자의 종류1. OEM 업체 완성품 제조 업체(휴대폰, 디지털 TV, 스마트 가전)에서 부트로더와 리눅스 디바이스 드라이버를 개발.2. 전장(전기자동차) 업체 자율 주행, 인포테인먼트, 마이컴을 위한 부트로더, 리눅스 디바이스 드라이버, 인증 프로세스를 개발.3. 로컬 국내 임베디드 업체 수주를 받아 프로젝트를 진행하며, 제품 전체를 턴키로 개발. 하드웨어 성능 비중이 높은 업무를 수행.4. SoC 시스템 소프트웨어 개발자 각 IP를 브링업하고 최적화하는 드라이버를 구현하며, GPU, 모뎀 인터페이스, Peripheral 드라이버 등을 개발.5. CPU 아키텍처 개발자 컴파일러 커스터마이즈 및 신규 기능 구현, 운영체제(리눅스 커널, XEN 하이퍼바이저)에 CPU 아키텍처 코드 기여.6. Linux Kernel Contributor 리눅스 커널 오픈 소스 프로젝트에 참여하여 서브 시스템의 기능 개선 및 안정화 작업을 수행.#시스템 소프트웨어 개발 과정 소개1. 개요 (Overview)시스템 소프트웨어 개발 과정은 매우 체계적이며, 각각의 단계가 중요합니다. 이 과정은 주로 하드웨어와 소프트웨어 간의 긴밀한 협력과 문제 해결 능력을 요구합니다.업무 특징 시스템 소프트웨어 개발자의 기본 역량은 대부분 유사합니다. 개발 과정은 스펙 검토, 브링업, 버그 수정, 공장 양산 대응, 그리고 사후 관리로 구성됩니다.2. 스펙 검토 (Specification Review)시스템 소프트웨어 개발의 첫 단계는 스펙 검토입니다. 이 단계에서 하드웨어와 소프트웨어 요구사항을 철저히 분석합니다.주요 활동 하드웨어 부품 검토: 제품의 특성에 따라 부품을 선정하고, 가격 경쟁력을 위해 부품을 교체할 수 있습니다. 회로도 리뷰: 저항, 전원 등에 대한 점검을 하드웨어 개발자와 공유하며 부트 모드를 설정합니다. 소프트웨어 스펙 검토: 리눅스 커널 버전을 선택하고, 디바이스의 스펙에 맞출 수 있는지를 검토합니다.3. 브링업 (Bring-up)브링업은 시스템 소프트웨어 개발의 첫 단계로, 디바이스를 처음으로 부팅시키는 작업입니다.브링업 과정 브링업이란?: 한 번도 부팅되지 않은 디바이스를 작동시키는 과정입니다. 주요 활동: 부트로더, 리눅스 드라이버 코드 수정. UART 콘솔을 사용해 디바이스를 디버깅. 디바이스의 부팅 문제 해결. 브링업 시 주의 사항 철저한 준비가 필요하며, 프로젝트 전체 일정에 영향을 미칩니다. 브링업 과정에서 발생하는 스트레스 관리가 중요합니다. 부팅이 안되면 빠르게 팀에 알리고, 다른 개발자의 도움을 받아야 합니다.4. 버그 수정 (Bug Fix)브링업과 기능 구현이 완료되면, 프로젝트는 안정화 단계로 넘어가며, 다양한 테스트를 통해 버그를 수정합니다.버그 수정 과정 문제 증상 확인: 로그나 메모리 덤프를 통해 문제의 원인을 분석합니다. 디버깅: 문제를 분석하고, 원인을 파악합니다. 패치 생성: 문제를 해결할 수 있는 패치를 만들고, 이를 테스트하여 유효성을 검증합니다.버그의 종류 크래시, 리셋. 성능 이슈: 시스템 느려짐, 화면 깨짐. 기능 동작 이슈: 스펙에 맞지 않는 동작.5. 공장 양산 대응 (Factory Software)소프트웨어 버전이 Freeze된 후에는 양산 대응이 시작됩니다. 이 과정에서 양산 라인에서 제품이 정상적으로 동작하는지 확인합니다.주요 활동 Factory Software: 부품이나 양산 제품이 제대로 동작하는지 체크하며, 이 과정에서 문제가 발생하면 시스템 소프트웨어 개발자가 공장을 방문하여 해결합니다. Quality Control: 센서, 카메라, 오디오 등 각종 부품이 정상적으로 동작하는지 검사합니다.6. 사후 관리 (Post-Production Support)제품이 시장에 출시된 후에는 사후 관리가 필요합니다. OTA를 통한 소프트웨어 업그레이드 및 고객 불만 대응이 포함됩니다.주요 활동 OTA 업그레이드: 제품의 소프트웨어를 무선으로 업그레이드. 고객 불만 대응: 시장에서 발생하는 문제에 대해 빠르게 대응하고 해결합니다.7. 시스템 소프트웨어 개발 과정 요약시스템 소프트웨어 개발 과정은 다음과 같은 주요 단계로 이루어집니다: 스펙 검토: 하드웨어 및 소프트웨어 요구사항 분석. 브링업: 디바이스 부팅 및 초기화. 버그 수정: 시스템 안정화. 공장 양산 대응: 양산 라인에서의 소프트웨어 동작 확인. 사후 관리: 시장 출시 후 소프트웨어 유지보수 및 문제 해결.이 모든 과정을 통해 제품이 성공적으로 시장에 출시되고, 안정적으로 운영될 수 있도록 지원합니다.#시스템 소프트웨어 개발 핵심 업무: 트러블 슈팅1. 트러블슈팅이란?트러블슈팅은 시스템 소프트웨어 개발에서 발생하는 다양한 문제를 해결하는 과정을 말합니다. 이는 개발 과정의 대부분을 차지하며, 크래시나 시스템 Freeze 이슈, 또는 브링업 도중 발생하는 문제들을 해결하는 데 주로 집중합니다.트러블슈팅 프로세스트러블슈팅 과정은 다음과 같은 단계로 진행됩니다: 문제 증상 파악: 로그나 덤프 파일을 분석하여 문제의 증상을 이해합니다. 문제가 발생한 커널 소스 코드를 처음부터 분석하거나 디버깅 툴을 사용해 현상을 확인합니다. 디버깅 및 패치 생성: 문제의 원인을 파악한 후, 해당 문제를 해결할 수 있는 패치를 생성합니다. 패치를 적용한 후 충분한 테스트를 진행합니다. 자체 스트레스 테스트: 패치 적용 후 시스템에 사이드 이펙트(부작용)가 없는지 확인하기 위해 전체 테스트를 진행합니다. 모든 테스트가 완료된 후 문제가 해결되었는지 최종 검증을 합니다. 2. 크래시란 무엇인가?크래시는 컴퓨터 프로그램이나 운영체제가 정상적으로 작동하지 않고 중지되는 현상을 말합니다. 크래시는 주로 소프트웨어 버그로 인해 발생하며, 다양한 원인이 있을 수 있습니다.크래시의 유형 논리적인 오류: BUG, Panic, Fault, Exception, Watchdog Reset, Race Condition 등. 하드웨어 문제: 메모리 비트 플립, 전원 불안정, 클락/파워 게이팅, 프로세서 내 버그 등. 크래시의 카테고리 Userspace Crash: 예: Segmentation fault (core dumped) System Crash: 예: Kernel panic, BUG, Watchdog Reset 3. 크래시 분석을 위한 주요 지식크래시를 분석하고 문제를 해결하기 위해서는 다음과 같은 지식이 필요합니다: Arm 아키텍처: 레지스터 세트, 어셈블리 언어, 익셉션 및 인터럽트 처리 방식. 커널 주요 서브 시스템: 프로세스 관리, 인터럽트 처리, 시스템 콜, 시그널 메모리 관리, 동기화, 워크큐, Soft IRQ 등. 디버깅 도구: 커널 로그, GDB, crash-utility, TRACE32, ftrace, vmcore 등의 사용법. 크래시 증상 예시 Userspace Crash: GDB로 분석한 백트레이스 (Backtrace) 예시. System Crash: Kernel panic 발생 시의 로그 예시. BUG 발생 시의 로그 예시. 메모리 오염 (Memory Corruption) 시의 로그 예시. 4. 트러블슈팅의 중요성 트러블슈팅은 시스템의 안정성을 유지하기 위해 필수적인 과정입니다. 개발자가 이러한 과정을 통해 시스템의 문제를 빠르게 해결함으로써 제품의 품질을 보장할 수 있습니다. 트러블슈팅 과정에서 얻은 경험은 향후 비슷한 문제를 예방하는 데에도 큰 도움이 됩니다." }, { "title": "OSEK", "url": "/posts/OSEK-%EC%9E%90%EB%A3%8C%EC%A0%95%EB%A6%AC/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2024-07-28 00:00:00 +0900", "snippet": "OSEK OS 2.2.3 스펙 요약OSEK/VDX 운영체제버전 2.2.3 (2005년 2월 17일)서문OSEK/VDX는 자동차 산업의 공동 프로젝트로, 차량 내 분산 제어 장치들을 위한 개방형 아키텍처의 산업 표준을 목표로 합니다. 이 문서는 특정 구현과 관련된 제품 설명이 아닌, 멀티태스킹이 가능한 실시간 운영체제의 개념을 다루고 있습니다.목차 소개 요약 OSEK 운영체제의 아키텍처 태스크 관리 애플리케이션 모드 인터럽트 처리 이벤트 메커니즘 자원 관리 알람 메시지 에러 처리, 추적 및 디버깅 시스템 서비스 설명 운영체제 서비스 명세 구현 및 응용 특정 주제 스펙 변경사항 인덱스 히스토리1. 소개1.1 시스템 철학 OSEK 운영체제는 자동차 제어 장치 소프트웨어의 효율적인 자원 활용을 지원하기 위해 설계되었습니다. OSEK 운영체제는 분산 임베디드 제어 장치를 위한 단일 프로세서 운영체제입니다. 이 운영체제는 하드웨어와 무관하게 소프트웨어 모듈의 통합을 가능하게 하는 운영체제 서비스를 제공합니다. 다양한 하드웨어에서 시간 크리티컬 애플리케이션을 지원하기 위해 높은 모듈화와 유연한 구성 기능을 제공합니다.1.2 문서 목적 이 문서는 OSEK 운영체제의 전략과 기능, 호출 인터페이스, 파라미터의 의미와 선언, 가능한 에러 코드에 대한 일반적인 설명을 제공합니다.1.3 문서 구조 문서의 각 장은 OSEK 운영체제의 다양한 측면을 다룹니다. 예를 들어, 태스크 관리, 애플리케이션 모드, 인터럽트 처리, 이벤트 메커니즘, 자원 관리, 알람, 메시지, 에러 처리, 시스템 서비스 설명, 운영체제 서비스 명세, 구현 및 응용 특정 주제 등을 다룹니다.2. 요약 OSEK 운영체제는 다양한 서비스와 처리 메커니즘을 제공합니다. 사용자 요구에 따라 운영체제를 구성할 수 있으며, 실행 시간 동안에는 수정할 수 없습니다. 다양한 요구사항을 충족시키기 위해 네 가지 적합성 클래스가 정의되어 있습니다. 태스크 관리, 동기화, 인터럽트 관리, 알람, 메시지 처리, 에러 처리를 포함한 서비스 그룹이 제공됩니다.3. OSEK 운영체제의 아키텍처3.1 처리 수준 OSEK 운영체제는 독립적인 애플리케이션 프로그램을 위한 기반을 제공하며, 여러 프로세스를 실시간으로 제어된 방식으로 실행할 수 있게 합니다. OSEK는 인터럽트 수준, 스케줄러의 논리적 수준, 태스크 수준의 세 가지 처리 수준을 정의합니다.3.2 적합성 클래스 애플리케이션 소프트웨어의 다양한 요구사항과 시스템의 다양한 기능을 지원하기 위해 여러 적합성 클래스가 정의되었습니다. 각 적합성 클래스는 시스템 생성 시 요구되는 기능과 태스크의 타입, 우선순위 등의 속성에 따라 구분됩니다.3.3 OSEK OS와 OSEKtime OS의 관계 OSEKtime OS는 시간 기반 아키텍처의 요구에 맞춘 운영체제로, OSEK OS와 공존할 수 있습니다. OSEKtime은 유휴 시간을 OSEK가 사용할 수 있게 하며, OSEK의 인터페이스와 시스템 호출 정의는 변경되지 않습니다.4. 태스크 관리4.1 태스크 개념 복잡한 제어 소프트웨어를 실시간 요구사항에 따라 부분으로 나눠 실행할 수 있습니다. OSEK 운영체제는 기본 태스크와 확장 태스크를 제공합니다.4.2 태스크 상태 모델 확장 태스크는 실행 중, 준비 상태, 대기 상태, 중단 상태의 네 가지 상태를 가집니다. 기본 태스크는 대기 상태가 없으며, 실행 중, 준비 상태, 중단 상태의 세 가지 상태를 가집니다.4.3 태스크 활성화 태스크 활성화는 ActivateTask 또는 ChainTask 서비스를 사용합니다. OSEK 운영체제는 태스크 시작 시 매개변수 전달을 지원하지 않으며, 메시지 통신 또는 전역 변수를 통해 전달해야 합니다.4.4 태스크 전환 메커니즘 OSEK 운영체제는 멀티태스킹을 지원하며, 스케줄러가 태스크 전환을 관리합니다.4.5 태스크 우선순위 스케줄러는 태스크의 우선순위를 기준으로 실행할 태스크를 결정합니다. 우선순위는 정적으로 할당되며, 실행 중에는 변경할 수 없습니다.4.6 스케줄링 정책 OSEK는 완전 선점형 스케줄링과 비선점형 스케줄링을 지원합니다. 그룹 태스크와 혼합 선점형 스케줄링도 지원합니다.4.7 태스크 종료 태스크는 스스로 종료할 수 있으며, ChainTask 서비스를 통해 특정 태스크 활성화를 보장할 수 있습니다.5. 애플리케이션 모드5.1 애플리케이션 모드의 범위 OSEK 운영체제는 다른 모드의 운영을 지원합니다. 모드 간 전환은 지원하지 않습니다.5.2 시작 성능 자동차 애플리케이션에서 시작 성능은 중요합니다. 운영체제 시작 전 모드를 결정하고 StartOS 서비스에 전달해야 합니다.5.3 애플리케이션 모드 지원 모든 적합성 클래스에서 애플리케이션 모드를 지원해야 합니다.6. 인터럽트 처리 인터럽트 서비스 루틴(ISR)은 카테고리 1과 카테고리 2로 나뉩니다. 카테고리 1 ISR은 운영체제 서비스를 사용하지 않으며, 카테고리 2 ISR은 운영체제 프레임을 사용합니다. ISR 내에서 재스케줄링은 일어나지 않으며, 카테고리 2 ISR이 종료된 후에만 재스케줄링이 발생할 수 있습니다.7. 이벤트 메커니즘 이벤트 메커니즘은 동기화 수단으로서 확장 태스크에만 제공됩니다. 이벤트는 태스크 상태 전환을 유발할 수 있습니다.8. 자원 관리8.1 자원 접근 중 행동 OSEK OS는 자원 점유 중 동작을 규정하며, 우선순위 역전을 방지하기 위한 OSEK 우선순위 천장 프로토콜을 사용합니다.8.2 자원 사용 시 제한사항 자원 점유 중에는 TerminateTask, ChainTask, Schedule, WaitEvent 호출이 불가능합니다.8.3 스케줄러를 자원으로 사용 태스크가 자신을 다른 태스크로부터 보호하기 위해 스케줄러를 자원으로 잠글 수 있습니다.8.4 동기화 메커니즘의 일반적인 문제8.4.1 우선순위 역전 설명 일반적인 동기화 메커니즘의 문제는 우선순위 역전입니다. 8.4.2 교착상태 교착상태는 상호 잠금된 자원을 무한히 대기함으로써 발생할 수 있습니다.8.5 OSEK 우선순위 천장 프로토콜 우선순위 역전과 교착상태를 방지하기 위해, OSEK 운영체제는 우선순위 천장 프로토콜을 요구합니다.8.6 인터럽트 레벨 확장을 포함한 OSEK 우선순위 천장 프로토콜 자원 관리의 인터럽트 레벨 확장은 선택 사항입니다.8.7 내부 자원 내부 자원은 사용자가 접근할 수 없으며, 엄격하게 내부 시스템 함수 내에서 관리됩니다.9. 알람 알람 메커니즘은 시간 기반 및 비시간 기반 이벤트를 지원합니다.10. 메시지 메시지 처리는 프로세서 내 통신을 위한 서비스를 제공합니다.11. 에러 처리, 추적 및 디버깅 중앙 집중식 에러 처리를 위한 메커니즘을 제공합니다. 시스템 초기화 및 종료 서비스를 포함합니다.12. 시스템 서비스 설명 시스템 서비스에 대한 정의와 설명을 제공합니다.13. 운영체제 서비스 명세 사용자에게 제공되는 모든 운영체제 서비스를 설명합니다.14. 구현 및 응용 특정 주제 운영체제의 구현 및 응용에 대한 특정 주제를 다룹니다.15. 스펙 변경사항 스펙 버전 1.0에서 2.2까지의 주요 변경사항을 설명합니다.16. 인덱스 운영체제 서비스와 그림 목록을 포함합니다.17. 히스토리 모든 공식 릴리스 목록을 포함합니다." }, { "title": "ARM 강의(Cortex-M Software Development Fundamentals)", "url": "/posts/ARM-%EA%B0%95%EC%9D%98(Cortex-M-Software-Development-Fundamentals)/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2024-06-03 00:00:00 +0900", "snippet": "Arm 컴파일러 개요 및 사용법Arm 컴파일러 개요이 슬라이드에서는 베어 시스템에서 Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴봅니다. Arm 라이선스 기간에는 두 가지 옵션을 사용할 수 있습니다: Arm 컴파일러 6: 모든 A 프로파일, R 프로파일, M 프로파일 변형을 지원하며, 최신 아키텍처 기능 및 확장을 가장 강력하고 완벽하게 지원합니다. Arm 컴파일러 5: 레거시 툴 체인으로, Armv4에서 Armv7까지의 아키텍처만 지원하며 수명이 거의 끝나가고 있습니다.그 외에도 GCC와 같은 오픈 소스 컴파일러와 타사 도구 공급업체 컴파일러가 있습니다. 이러한 모든 컴파일러 도구 체인은 Arm 아키텍처용 ABI를 준수해야 합니다.기능 안전을 위한 컴파일러 지원기능 안전을 위한 컴파일러는 특정 기능 안전 표준에 따라 인증을 받아야 합니다. Arm에서는 이를 장기 유지 관리 릴리스(LTM)라고 합니다. LTM은 버그를 수정하는 데 중점을 두며, 기능 안전 시스템의 개발을 단순화하고 가속화할 수 있습니다. 기능 안전 릴리스에는 검증 키트가 포함되어 있으며, 이는 안전 매뉴얼, 철저히 테스트된 라이브러리 목록, 결함 보고서를 제공합니다.Arm 컴파일러 6 소개Arm Compiler 6은 오픈 소스 LLVM Clang을 기반으로 하여 오픈 소스 세계와의 규정 준수를 보장하며, 최신 아키텍처 기능 및 확장을 가장 빠르고 완벽하게 지원합니다. Arm 컴파일러는 Arm DS 및 Keil-MDK와 함께 제공되며, 독립 실행형 버전은 웹사이트에서 다운로드할 수 있습니다. 기능 안전 버전이 아닌 경우 독립 실행형 라이선스가 없습니다.Arm Compiler 5에서 Arm Compiler 6으로 마이그레이션Arm Compiler 5는 이제 레거시 툴 체인이므로, Arm Compiler 6으로 마이그레이션하는 것이 좋습니다. Arm Compiler 6은 Clang과 LLVM 기술을 기반으로 구축되어 있으며, 프로덕션 환경에서 사용하기에 적합한 제품 기능을 제공합니다. 커뮤니티 기능은 프로덕션 코드에서 사용하지 않는 것이 좋습니다.언어 지원Arm Compiler 6은 여러 언어 표준을 지원합니다: C 언어: c90, c99, c11, gnu90, gnu99, gnu11 C++ 언어: C++03, C++11, C++14, C++17, GNU++03, GNU++11, GNU++14, GNU++17데이터 유형Cortex-M 프로세서는 AArch32 아키텍처를 사용하며, 다음과 같은 데이터 유형을 지원합니다: 32비트 정수: int, long 64비트 정수: long long 16비트 하프 워드: short 8비트 바이트: char 32비트 단정밀도 부동 소수점: float 64비트 배정밀도 부동 소수점: double C++에서는 불리언 및 wchar_t 타입도 지원됩니다.C++ 예외 처리Arm Compiler 6에서 C++ 예외 처리는 기본적으로 활성화되어 있습니다. 예외를 사용하지 않는 경우, -fno-exception 옵션을 사용하여 예외를 비활성화하는 것이 좋습니다. 또한, 일부 C++ 라이브러리는 예외 처리가 활성화된 상태로 컴파일되어 있으므로 주의가 필요합니다.C++ 초기화 및 소멸자C++ 객체 초기화 방식을 사용자 지정하려는 경우, _cpp_initialized_aeabi 및 aeabi_atexit 함수를 재정의할 수 있습니다. 힙을 사용하면서 자체 힙 관리 시스템을 구현하려는 경우, malloc과 free 함수를 리타겟팅하는 것이 좋습니다. 또한, C++ 라이브러리는 스레드 안전하지 않으므로 멀티스레딩 libc++를 사용할 경우 주의해야 합니다.Arm 아키텍처를 위한 코드 개발 고려 사항Arm 프로시저 호출 표준 (AAPCS)AAPCS 개요AAPCS는 Arm용 API 아키텍처 및 모든 컴파일러의 일부로, ARM Aarch 32 기기가 이를 준수해야 합니다. 이 표준은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다. 이를 이해하면 더 효율적인 코드를 작성할 수 있습니다.레지스터 사용 레지스터 r0-r3: 함수에 인수를 전달하는 데 사용됩니다. 레지스터 r0-r1: 반환되는 데이터의 크기에 따라 값을 반환하는 데 사용됩니다. 레지스터 r4-r11: 레지스터 변수이며 보존해야 합니다. 함수 호출 시 이 레지스터들은 호출된 함수가 원래 값을 복원할 수 있도록 저장해야 합니다. 스택 포인터 (SP, r13): 스택의 다음 빈 공간을 가리킵니다. 링크 레지스터 (LR, r14): 함수를 호출할 때 반환 주소를 가리킵니다. 프로그램 카운터 (PC, r15): 실행할 다음 명령을 가리킵니다.함수 호출 예제 레지스터 r0-r3과 r12는 함수 호출 시 손상될 수 있습니다. 함수 호출 전후에 필요한 레지스터를 저장 및 복원해야 합니다. 링크 레지스터는 함수 반환 주소를 가리키며, 호출자 함수가 다른 함수를 호출할 때는 값을 보존해야 합니다. 함수 반환 값이 단어 크기 이하인 경우 r0을 사용하여 반환하며, 64비트인 경우 r0과 r1의 조합을 사용합니다.매개변수 전달 최대 4개의 단어 크기 매개변수를 함수 레지스터에 전달할 수 있습니다. 추가 매개변수는 스택으로 전달됩니다. 하위 단어 크기 인수도 전체 레지스터를 사용합니다. 64비트 인수는 짝수 레지스터와 연속된 홀수 레지스터 쌍을 사용합니다. C++ 비정적 멤버 함수에서는 레지스터 r0이 항상 객체 포인터를 포함하므로 실제로 세 개의 인수만 전달할 수 있습니다.매개변수가 4개 이상일 때 매개변수가 4개 이상인 경우, 추가 매개변수는 스택에 전달됩니다. 함수가 반환될 때 스택 포인터를 복원해야 합니다. 블 (BL) 명령어는 다음 명령어의 주소를 링크 레지스터에 복사합니다.64비트 인수와 매개변수 전달 예제 정수 a는 레지스터 r0을 사용하고, 64비트 double b는 r2와 r3을 사용하여 전달합니다. 정수 c는 스택 메모리를 사용해야 합니다. 정수, double, 정수의 순서로 전달되는 경우, 레지스터와 스택을 최적화하여 사용할 수 있습니다.최적화 및 정렬 매개변수 전달 순서는 레지스터와 스택 사용 방식에 큰 영향을 미칩니다. 크기가 작은 매개변수를 먼저 배치하는 것이 좋습니다. 정적이 아닌 C++ 멤버 함수의 경우, r0에는 숨겨진 this 인수가 포함됩니다.위 내용은 Arm 아키텍처에 맞춰 코드를 효율적으로 작성하는 데 필요한 고려 사항을 요약한 것입니다. AAPCS 표준을 이해하고 준수하면 더 나은 성능과 유지보수성을 가진 코드를 작성할 수 있습니다.Arm Custom Instructions 요약개요Arm Custom Instructions는 Armv8-M 및 Armv8.1-M 아키텍처를 위한 사용자 지정 데이터 경로 확장의 일부로, 프로세서 설계자가 Arm 프로세서에 자체 기능을 추가할 수 있도록 합니다.명령어 클래스사용자 지정 명령어는 여러 범주로 나뉘며, 각 클래스는 사용자 지정 명령어에 지정할 수 있는 입력 및 출력 피연산자의 유형을 기반으로 정의됩니다.클래스 1 출력 대상 레지스터 피연산자와 입력 즉시값 피연산자를 포함. 변형: 비누산기, 누산기.클래스 2 출력 대상 레지스터와 소스 레지스터 피연산자를 추가. 변형: 비누산기, 누산기.조건 코드 전달조건 코드를 사용자 정의 명령어로 전달하기 위해 APSR_NZCV 레지스터를 사용하며, 이는 애플리케이션 프로세스 상태 레지스터를 의미합니다.레지스터 피연산자사용자 지정 명령어 클래스는 레지스터 피연산자를 사용할 수 있습니다. 각 클래스에 따라 레지스터 피연산자의 수와 유형이 다릅니다.클래스 1 출력 대상 레지스터와 입력 즉시값. 변형: 비누산기, 누산기.클래스 2 출력 대상 레지스터, 소스 레지스터, 입력 즉시값. 변형: 비누산기, 누산기.사용자 지정 명령어의 인코딩사용자 지정 명령어는 보조 프로세서 명령어와 동일한 인코딩 공간을 사용합니다. 특정 명령어를 Arm 사용자 지정 명령어로 전달하려면 자체 서명된 특정 코어 프로세서로 연결해야 합니다.누산기 변형각 클래스에는 몇 가지 변형이 있습니다. 결과만 계산하고 출력 레지스터를 사용하는 변형이 있으며, 등록된 값도 소비하는 누산기 변형도 있습니다.Armv8-M 메모리 모델개요Armv8-M 메인라인 아키텍처의 메모리 모델에 대해 알아보겠습니다. 이는 Armv8-M 주소 공간의 여러 파티션을 나열하고 메모리 유형을 구분하며, 주소 공간의 특정 파티션에 사용되는 이유를 설명합니다.주소 공간Armv8-M은 최대 4GB의 물리적 주소 공간을 포함하는 메모리 매핑 아키텍처입니다. 주소 공간은 물리적 메모리와 프로세서 제어 및 상태 레지스터 모두를 위한 공유 주소 공간입니다.메모리 영역메모리는 8개의 512MB 세그먼트 또는 파티션으로 분할됩니다. 각 영역은 특정 용도로 사용됩니다. 코드 섹션: 명령어 저장. SRAM: 고속 SRAM 메모리. 주변 장치 영역: 주변 장치 메모리. 시스템 영역: 프로세서 제어 및 상태 레지스터.메모리 속성각 메모리 영역은 다양한 메모리 속성을 가질 수 있습니다. 속성은 다음과 같습니다. 액세스 권한 실행 권한 공유 가능성 캐시 가능성메모리 유형메모리 영역에는 일반 메모리 또는 장치 메모리가 포함될 수 있습니다. 일반 메모리는 최상의 성능을 제공하며, 장치 메모리는 액세스에 부작용이 발생할 수 있는 영역에 사용됩니다.Arm 컴파일러개요Arm 아키텍처를 지원하는 다양한 컴파일러를 살펴보겠습니다. 주요 컴파일러로는 Arm Compiler 6과 Arm Compiler 5가 있습니다.Arm Compiler 6 최신 Arm 아키텍처 기능 및 확장을 지원. 베어메탈 소프트웨어 개발에 중점을 둠. 오픈소스 LLVM Clang을 기반으로 구축.Arm Compiler 5 레거시 툴 체인으로 Armv4에서 Armv7까지 지원. 유지 관리만 이루어지며 수명이 거의 끝남.기능 안전일부 임베디드 시스템의 경우 기능 안전 요구 사항이 있습니다. Arm은 기능 안전 요구 사항을 충족하기 위해 장기 유지 관리 릴리스(LTM)를 제공합니다.컴파일러 사용Arm Compiler는 Arm DS 또는 Keil-MDK와 함께 제공되며, 웹 사이트에서 독립 실행형 버전으로 다운로드할 수 있습니다.AAPCS (Arm Procedure Call Standard)개요Arm 아키텍처를 위한 프로시저 호출 표준(AAPCS)은 함수에 인수를 전달하는 방법과 스택의 레지스터를 함수 호출에 사용하는 방법을 지정합니다.레지스터 사용 r0-r3: 함수에 인수를 전달. r4-r11: 레지스터 변수로 사용되며 보존해야 함. r12: 임시 레지스터. r13 (SP): 스택 포인터. r14 (LR): 링크 레지스터. r15 (PC): 프로그램 카운터.스택 정렬AAPCS에 따르면, 스택은 외부 가시 경계에서 8바이트로 정렬되어야 합니다. 이는 함수 호출 시 스택이 8바이트로 정렬되어야 함을 의미합니다.함수 호출 예제호출자 함수가 레지스터 값을 수정하지 않을 것으로 예상되면 호출자는 함수를 호출하기 전에 레지스터를 저장하고, 함수가 반환된 후 원래 값을 복원해야 합니다.요약 Arm Custom Instructions: 사용자 지정 명령어를 통해 프로세서 기능을 확장할 수 있습니다. Armv8-M 메모리 모델: 다양한 메모리 영역과 속성을 이해하여 최적의 성능을 제공합니다. Arm 컴파일러: 최신 아키텍처 기능을 지원하며, 기능 안전 요구 사항을 충족할 수 있습니다. AAPCS: 효율적인 함수 호출과 인수 전달을 위한 표준을 이해하면 더 나은 코드를 작성할 수 있습니다.Armv8-M Mainline Debug학습 목표이 모듈의 끝에서 다음을 할 수 있습니다: Debug, Trace 및 Profiling 요구 사항 및 기능 설정 Invasive Debug와 Non-invasive Debug의 구분 Armv8-M Mainline Debug 및 Trace 구성 요소 설명: FPB, DWT, ITM, MTB, ETM 및 TPIU 프로세서가 중단된 다양한 Debug 이벤트 감지 Semihosting 호출과 표준 Breakpoints의 차이점 구별 Profiling 기능 설명: DWT 및 Armv8.1-M Performance Monitoring Unit (PMU)기본 Debug 요구 사항 Run Control 코드 단일 단계 실행 명령어에 Breakpoints 설정 데이터 접근에 Watchpoints 설정 State Control 프로세서 상태 읽기 및 쓰기 시스템 메모리 접근 주변기기 접근 Execution History 실행 추적 정보 Armv8-M Mainline Debug 구성 요소 DAP ETM Trigger TPIU SW/JTAG Debug Agent FPB DWT ITM MTB ROM Table PIL CTI Bus Matrix MPU SAU IPPBInvasive Debug vs. Non-invasive Debug Invasive Debug 프로세서 제어: 코어 중단, 코드 단일 단계 실행, 코드 실행 프로세서 레지스터 검사 및 변경: Debug 상태에서 메모리와 메모리 매핑 레지스터 검사 및 변경: 프로세서 실행 중이나 중단 중 Non-invasive Debug 프로세서의 동작 관찰: 프로세서 중단 없이 프로그램 실행에 비침입적일 수 있음 Non-invasive Debug는 MTB, ITM, ETM 및 PMU를 통해 제공됨 Debug 상태 - 중단 DebugDebug 상태가 프로세서에서 활성화되고 적격한 Debug 이벤트가 발생하면 프로세서는 Debug 상태로 들어갑니다. 이 상태에서는 프로세서가 멈추고, 명령어가 실행되지 않으며, 인터럽트가 서비스되지 않습니다. Debug 인터페이스를 통해 프로세서를 제어합니다.중단 Debug를 위한 Debug 이벤트 전통적인 시작/중단 Debug PMU Sticky 플래그가 PMU 카운터가 오버플로우했음을 나타냄 EXTERNAL EDBGRQ 입력이 다른 SoC 구성 요소에서 어서트됨 VCATCH 벡터 캐치가 트리거됨 DWTTRAP이 Watchpoints와 일치하는 주소로 데이터 접근 BKPT 명령어가 실행되거나 FPB에서 Breakpoints가 일치 디버거로부터의 HALTED 중단 요청셀프 호스팅 Debug프로세서를 구성하여 중단 대신 DebugMonitor 예외를 받도록 할 수 있습니다. 이는 실시간 요구사항이 있는 시스템 디버깅에 적합합니다. DebugMonitor는 PMU 오버플로우를 처리하는 데 사용될 수 있습니다.벡터 캐치 선택된 예외를 트랩하는 메커니즘 예외가 어서트되면 코어가 중단됨 디버거를 통해 선택 리셋, HardFault, UsageFault, BusFault, SecureFault와 같은 예외를 트랩할 수 있음FPB - Flash Patch 및 Breakpoints 유닛FPB는 명령어 페치에 Breakpoints를 설정할 수 있도록 지원합니다. 소프트웨어 Breakpoints는 BKPT 명령어로 구현되며, 하드웨어 Breakpoints는 FPB 비교기를 통해 구현됩니다.Breakpoints vs. Watchpoints Breakpoints: 명령어 디버깅에 사용 Watchpoints: 데이터 접근 디버깅에 사용DWT WatchpointsDWT는 데이터 주소와 명령어 주소 비교기를 제공합니다. DWT는 데이터 값과 데이터 주소가 일치할 때 중단할 수 있습니다. DWT 레지스터는 디버거에 의해 사용될 수 있습니다.SemihostingSemihosting은 라이브러리 코드가 Arm 타겟에서 실행되지만 저수준 I/O는 호스트에 의해 처리됩니다. BKPT 명령어가 호스트 접근을 시작합니다.Trace: 소개Trace는 구성 요소가 어떻게 실행되고 성능을 발휘하는지 보여주는 데이터를 캡처하는 과정입니다. 주로 프로그램 Trace(명령어 Trace)나 응용 프로그램 Trace(도구 Trace)가 있습니다.MTB - Micro Trace BufferMTB는 간단한 실행 추적 기능을 제공하며, 실행 중의 분기를 온칩 RAM에 저장합니다.ITM - Instrumentation Trace MacrocellITM은 소프트웨어와 하드웨어가 생성하는 Trace 패킷을 생성하고 출력합니다.DWT - Trace 캡처DWT는 주소 일치, 주기적 PC 샘플링, 데이터 값, 예외 입출 및 반환, 이벤트 카운터와 같은 이벤트에 대한 패킷을 생성합니다.ETM - Embedded Trace MacrocellETM은 명령어 Trace만 지원하는 비침입 Debug 구성 요소입니다. ETM 하드웨어는 프로세서의 활동을 모니터링합니다.TPIU - Trace Port Interface UnitTPIU는 ETM과 ITM에서 데이터를 형식화하고 직렬화합니다. TPIU는 비동기적으로 코어 클럭과 TRACECLKIN에서 파생된 TRACECLK로 데이터를 클럭킹합니다.Trace Port와 대역폭ETM은 거의 0에서 여러 바이트의 명령어까지 데이터 속도를 생성할 수 있습니다. TRACECLKIN이 코어 클럭 속도로 실행될 때 명령어 Trace에 대해 2-3개의 핀이 필요합니다.DWT - Performance ProfilingDWT는 주기(CYCCNT), 폴디드 명령어(FOLDCNT), 모든 로드 또는 저장 명령어를 실행하는 데 필요한 추가 주기(LSUCNT), 프로세서 수면 주기(SLEEPCNT), 다중 주기 명령어와 명령어 페치 지연을 실행하는 데 필요한 추가 주기(CPICNT), 예외 처리에 소비된 주기(EXCCNT)를 위한 카운터를 포함합니다.PMU - Performance Monitoring UnitPMU는 이벤트 통계 정보를 수집하고 성능 분석을 위해 시스템 Debug에 사용됩니다. 31개의 16비트 이벤트 카운터와 하나의 32비트 주기 카운터를 지원합니다. PMU 카운터와 DWT 프로파일링 카운터의 작동은 상호 배타적입니다.M-profile 부팅 및 초기화© 2022 Arm학습 목표이 모듈을 마치면 다음을 할 수 있습니다: 시작 및 초기화 코드를 개발합니다. 메모리 설명 파일을 작성합니다. C 라이브러리를 어떻게 활용할지 선택합니다. 기기에서 부팅할 수 있는 실행 파일 이미지를 생성합니다.임베디드 개발 프로세스개발 환경에서 독립 실행형 임베디드 애플리케이션으로 이동할 때 고려해야 할 사항: 애플리케이션 시작 타겟 메모리 맵 하드웨어 사용을 위한 C 라이브러리목차 기본 컴파일 도구 동작 시작 및 초기화 코드 작성 CMSIS-Core를 사용한 초기 시작 및 시스템 초기화 코드 시작 후 초기화 디바이스에 맞게 이미지 메모리 맵 조정 메모리 설명 파일 작성 (스캐터 파일/링커 스크립트) 스택 및 힙 배치 추가 메모리 맵 고려 사항 시스템에 맞게 C 라이브러리 동작 재설정 부팅 준비 이미지 빌드기본 컴파일 도구 동작Arm Compiler의 기본 시작 및 초기화 시퀀스 main() 함수는 라이브러리 초기화 코드를 링크하도록 Arm Linker (armlink)에 지시합니다. __main 함수는 C 라이브러리의 진입점입니다. __main은 __scatterload와 __rt_entry를 호출합니다. __scatterload는 실행 시간 영역을 초기화합니다. __rt_entry는 다양한 초기화 함수를 호출한 다음 사용자 레벨의 main()을 호출합니다. 기본 메모리 맵 - Arm Compiler기본적으로 Arm Compiler는 코드를 0x8000에서 로드하고 실행하도록 링크합니다. 힙은 데이터 영역 바로 위에 배치됩니다. 스택 기본 위치는 링크 시 정의되고 리셋 시 프로세서에 의해 구성됩니다.기본 C 라이브러리 - Arm Compiler Arm Compiler는 여러 준비된 T32 (이전 Thumb) C 라이브러리를 제공하며, ‘세미호스팅’ 지원을 포함합니다. c_w.l - 리틀 엔디안 C 라이브러리 h_w.b - 빅 엔디안 헬퍼 라이브러리 f_ws.l/.b - 소프트웨어 부동 소수점 라이브러리리셋 및 초기화실제 시스템에서는 애플리케이션의 진입점을 컴파일러 특정 라이브러리 함수(__main 또는 _start)로 설정하지 않으려 할 수 있습니다. M-profile 프로세서는 특권 모드로 시작합니다. 시스템 초기화는 특권 모드에서만 실행할 수 있습니다. SystemInit 함수는 __main 전에 호출되며, 벡터 테이블 오프셋 레지스터(VTOR), 부동 소수점 유닛(FPU), 마이크로컨트롤러 벡터 확장(MVE), 보안 속성 유닛(SAU)을 초기화합니다.CMSIS-Core: 시작 파일 startup_&lt;device&gt;.c 또는 startup_&lt;device&gt;.s 파일은 다음을 포함합니다: 벡터 테이블 M-profile 예외 벡터 디바이스 특정 인터럽트 벡터 기본 루틴을 구현하는 약한 함수들 리셋 핸들러 SystemInit을 호출한 후 __PROGRAM_START() 매크로를 호출합니다. 메모리 맵 설명 파일 작성CMSIS-Core는 Arm Compiler 스캐터 파일, GNU 링커 스크립트, IAR 링커 구성 파일 템플릿을 제공합니다. 각각의 파일은 기본/필수 메모리 영역/세그먼트를 설명합니다. RO/XO 코드 및 데이터 RW 및 ZI 데이터 메인 스택 런타임 메모리 관리C 라이브러리 런타임 메모리 모델을 재설정해야 합니다. 스택과 힙을 단일 메모리 영역(단일 영역 모델) 또는 별도의 영역(두 영역 모델)에 배치할지 결정해야 합니다. 기본적으로 단일 영역 모델이 사용됩니다. 두 영역 모델을 구현하려면 __use_two_region_memory를 가져와야 합니다.메모리 맵 추가 고려 사항M-profile 시스템에서 주변 장치는 메모리 매핑됩니다. CMSIS-Core 헤더는 장치의 주변 레지스터에 액세스하는 권장 방법입니다.C 라이브러리 재설정C 라이브러리의 디바이스 드라이버 수준 기능을 타겟 하드웨어에 맞게 구현으로 교체할 수 있습니다. 예: printf()는 디버거 콘솔이 아닌 LCD 화면으로 출력해야 합니다. 세미호스팅을 사용하는 C 라이브러리 함수를 시스템에 맞게 구현으로 교체합니다.디버깅 ROM 이미지 링커는 디버깅에 적합한 ELF/DWARF 이미지를 생성합니다. ELF 이미지를 바이너리 형식으로 변환하려면 fromelf 유틸리티를 사용합니다. 예: fromelf --bin -o &lt;output&gt; image.axf ELF 이미지에서 DWARF 디버그 정보를 로드하여 ROM 이미지를 디버깅할 수 있습니다.Cortex-M3 Startup &amp; Exception HandlingTarmac Trace Arm 전용 추적 형식 Fast Models / FVPs (Fixed Virtual Platforms)에서 수집 가능 RTL (Register Transfer Level) 시뮬레이션에서 수집 가능 실행된 명령어, 전송된 레지스터 값, 메모리 접근 및 발생한 예외를 보여줌 Arm Fast Models 문서에 문서화됨: Tarmac Trace DocumentationTarmac Trace 예제8004 clk IT (8004) 0000061c 6801 T thread : LDR r1,[r0,#0]8004 clk MR4 20000170 000000008004 clk R r1 00000000시작 예제 CMSIS 시작 코드 사용 C에서 인터럽트 핸들러 설정 CMSIS 함수를 사용하여 인터럽트를 활성화하고 트리거Hello, world!Enabled device-specific timer 0Hello from TIM0_IRQHandler()!리셋 단계리셋 핸들러Reset_Handler PROCEXPORT Reset_Handler [WEAK]IMPORT SystemInitIMPORT __mainLDR R0, =SystemInitBLX R0LDR R0, =__mainBX R0ENDP리셋 과정 리셋 예외 발생 스택 포인터 값 설정 프로세서가 T32 상태에 있음을 나타내는 CPSR 값 설정 리셋 핸들러의 첫 번째 명령어 실행 시작벡터 테이블리셋 핸들러 주소는 벡터 테이블에 지정됨__Vectors DCD __initial_sp ; Top of StackDCD Reset_Handler ; Reset Handler__main() 함수 스캐터 로딩 C 라이브러리 초기화 애플리케이션 코드 실행 시작main() 함수의 애플리케이션 코드int main(void){ printf(\"Hello, world!\\n\"); /* Initialize TIM0_IRQn */ NVIC_SetPriority(TIM0_IRQn, 1); NVIC_EnableIRQ(TIM0_IRQn); printf(\"Enabled device-specific timer 0\\n\"); /* Set TIM0_IRQn to pending */ NVIC_SetPendingIRQ(TIM0_IRQn); return 0;}예외 처리소프트웨어에서 예외 트리거/* Set “pending” bit for the interrupt to 1. *//* Processor takes exception and branches to exception handler. */NVIC_SetPendingIRQ(TIM0_IRQn);예외 처리 과정 프로세서는 필요한 레지스터를 스택에 자동으로 저장5484 clk E 00000cd0 00000012 CoreEvent_EXT_INT25485 clk IT (5485) 00000c7c a001 T handler : ADR r0,{pc}+8 ; 0xc84요약핸들러 모드 벡터 테이블 사용 예외 처리 과정에서 스택 업데이트 핸들러로 분기 스택 레지스터 업데이트 핸들러에서 복귀" }, { "title": "ARM 강의", "url": "/posts/ARM-%EA%B0%95%EC%9D%98(Armv8-M-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B3%B8-%EC%82%AC%ED%95%AD)/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2024-06-03 00:00:00 +0900", "snippet": "ARM 아키텍처의 발전개요ARM 아키텍처는 수년에 걸쳐 개발 및 발전해 왔으며, 모든 ARM 프로세서의 기반입니다. 이 요약에서는 아키텍처 버전 V4T부터 V8 및 V9까지의 주요 내용을 다룹니다.주요 내용초기 버전 (V1, V2, V3) 초기 버전: 아키텍처 버전 1, 2, 3이 있었으나, Thumb 명령어 세트가 도입되면서 ARM이 대중화되었습니다.아키텍처 버전 4T Thumb 명령어 세트 도입: 16비트 명령어 세트가 도입되어 ARM7TDMI와 같은 인기 프로세서가 개발되었습니다. 그 전에는 32비트 명령어만 사용할 수 있었습니다.아키텍처 버전 5 향상된 수학 명령어: Count Leading Zeros (CLZ)와 같은 향상된 수학 명령어가 추가되었습니다. DSP 명령어: DSP 연산을 효율적으로 수행할 수 있는 명령어가 추가되었습니다.아키텍처 버전 6 Thumb-2: 16비트와 32비트 명령어를 혼합하여 사용할 수 있는 Thumb-2 명령어가 도입되었습니다. TrustZone: 보안 확장 기능인 TrustZone이 도입되었습니다. 멀티코어 지원: 추가 커널 및 멀티코어 지원이 포함되었습니다.아키텍처 버전 7 가상화: 일부 A-profile 시스템에서 가상화 기능이 도입되었습니다. NEON SIMD 명령어 세트: 매우 강력한 NEON SIMD 명령어 세트가 도입되었습니다.아키텍처 버전 8 64비트 레지스터: 64비트 레지스터와 새로운 예외 모델 및 메모리 모델이 도입되었습니다. 호환성 모드: 이전 아키텍처 코드와의 호환성을 유지하며, 새로운 프로세서에서도 실행이 가능했습니다.아키텍처 버전 9 통합 및 정리: V8의 다양한 포인트 버전을 통합 및 정리한 버전입니다. 최신 버전: V8-M 프로파일과 비교할 때 TrustZone을 지원하는 것이 주요 특징입니다.Cortex-M 프로세서 예외 처리 메커니즘: Cortex-M 프로세서는 매우 우수한 예외 처리 메커니즘을 갖추고 있습니다. 파이프라인 길이: 프로세서 파이프라인의 길이는 아키텍처에서 지정하지 않으며, 예로 Cortex-M3와 Cortex-M7을 들 수 있습니다.이 요약을 통해 ARM 아키텍처의 발전 과정을 이해하고, 각 버전에서 도입된 주요 기능을 알 수 있습니다.Cortex-M 프로세서 개요 Cortex-M 제품군: Arm의 다양한 프로세서 중 한 부분으로, Linux 및 Windows와 같은 운영 체제를 지원하는 애플리케이션 프로파일, 고성능 임베디드 제어 애플리케이션을 목표로 하는 실시간 프로파일, 그리고 저전력, 비용 민감한 장치를 위한 마이크로컨트롤러 프로파일로 나뉩니다. 고성능 기능: 일부 Cortex-M 프로세서는 물리적 변조 방지 기능과 사이드 채널 완화 기능을 추가하여 보안에 민감한 애플리케이션에 적합합니다.주요 Cortex-M 프로세서 Cortex-M0과 Cortex-M0+: 가장 작은 최저 전력 대역에 속하며, Armv6-M 명령어 세트를 구현합니다. 단일 사이클 저지연 I/O 포트를 제공합니다. Cortex-M23: Cortex-M0+에서 개발된 것으로, Armv8-M 명령어 세트를 기반으로 합니다. TrustZone 보안 기능이 추가되었습니다. Cortex-M3 및 Cortex-M4: Armv7-M 명령어 세트를 기반으로 하며, 다양한 32비트 연산 코드를 지원합니다. Cortex-M4는 DSP 명령어 세트와 단정밀도 부동 소수점 연산을 추가로 지원합니다. Cortex-M33 및 Cortex-M35P: Armv8-M 명령어 세트를 기반으로 하며, 변조 방지 기능을 포함합니다. Cortex-M7: Cortex-M 제품군 중 가장 고성능으로, 6단계 파이프라인과 이중 이슈 처리 기능을 갖추고 있습니다. 단정밀도 및 배정밀도 부동 소수점 연산을 지원합니다.보안 기능 TrustZone: Cortex-M35P와 같은 일부 프로세서는 Armv8-M TrustZone 보안 기능을 제공합니다. 변조 방지: 보안에 민감한 애플리케이션을 위한 물리적 변조 방지 기능을 포함합니다.디버깅 및 개발 지원 디버그 인터페이스: 각 Cortex-M 프로세서에는 독립형 프로세서 시스템으로 디버깅할 수 있도록 디버그 액세스 포트(DAP)가 제공됩니다. CoreSight 지원: 칩 레벨에서 스트리밍 트레이스 출력 또는 전용 트레이스 핀을 제공하여, 프로세서 활동을 외부 디버그 도구에 지속적으로 보고할 수 있습니다.최신 버전 Armv8-M: 최신 M 프로파일 아키텍처 버전으로, 보안 확장과 M 프로파일 벡터 확장(MVE)을 포함합니다.이 요약은 Cortex-M 프로세서의 다양한 기능과 각 모델의 특징을 이해하는 데 도움이 됩니다.Armv8-M 프로세서 및 마이크로컨트롤러 프로파일 개요개요Armv8-M 프로세서는 마이크로컨트롤러 시장을 지원하도록 설계되었습니다. 실제로 Armv8-M의 M은 마이크로컨트롤러의 약자입니다. 이 문서에서는 Armv8-M 프로세서의 주요 특징과 다른 두 가지 주요 아키텍처 프로필인 A 프로파일과 R 프로파일을 간단히 살펴봅니다.주요 내용Arm 프로파일 A 프로파일: A는 Applications를 의미합니다. 메모리 용량이 크고 주파수가 높은 복잡한 시스템에 적합합니다. 이러한 시스템에는 Linux나 Android 등과 같은 운영 체제가 포함될 수 있습니다. R 프로파일: R은 실시간(Real-time)을 의미합니다. 실시간 시스템 전용으로, 자동차 시스템 등에서 사용됩니다. M 프로파일: M은 마이크로컨트롤러를 의미합니다. IoT 시스템에서 베어메탈 시스템에 이르기까지 다양한 임베디드 시스템에 사용됩니다. 실시간 요구 사항이 있는 시스템에도 적합합니다.M-프로파일의 특징 단순화된 아키텍처: 대부분의 명령어가 단일 사이클로 실행되며, RISC 아키텍처를 기반으로 합니다. RISC는 축소된 명령어 세트 컴퓨터(Reduced Instruction Set Computer)의 약자입니다. 전력 효율성: 전력 소비가 적어 배터리 수명이 중요한 마이크로컨트롤러 시스템에 적합합니다. 프로그래밍 용이성: C 또는 C++로 프로그래밍할 수 있으며, 특정 루틴에 대해 어셈블리 언어를 사용할 수도 있습니다. 단순한 메모리 보호 모델: 가상 주소를 물리적 주소로 변환할 수 있는 메모리 관리 장치(MMU)가 포함된 애플리케이션 프로세서와 달리, 더 간단한 메모리 보호 모델을 사용합니다.실행 모드 스레드 모드: 재설정 후 사용되며, 운영 체제에서 생성되는 프로세스와 스레드에 사용됩니다. 핸들러 모드: 예외를 처리하는 데 사용됩니다.예외 처리 벡터 테이블: 명령어가 아닌 주소로 구성됩니다. 이는 더 유연한 접근 방식을 제공합니다. 컨텍스트 저장: 예외 발생 시 자동으로 컨텍스트를 저장하여 안전하게 반환할 수 있습니다.데이터 유형 로드 및 저장 아키텍처: 32비트 로드 및 저장 아키텍처로, 메모리 액세스는 로드 및 저장 명령을 통해 이루어집니다. 지원되는 데이터 유형: 바이트(8비트), 하프 워드(16비트), 워드(32비트), 더블 워드(64비트)를 지원합니다.이 문서는 Armv8-M 프로세서의 다양한 기능과 각 프로파일의 특징을 이해하는 데 도움이 됩니다.ARMv8-M 코어 레지스터 소개R0-R7 레지스터 대부분의 명령에서 접근 가능 데이터 처리 및 메모리 액세스 명령에 사용R8-R12 레지스터 (하이 레지스터) 32비트 명령어에 주로 사용 일부 16비트 명령어에도 사용 가능스택 포인터와 링크 레지스터, 프로그램 카운터 R13 (스택 포인터): 스택에 접근하는 데 사용 메인 스택 포인터와 프로세스 스택 포인터의 두 가지 버전 존재 R14 (링크 레지스터): 함수 호출에서 리턴 주소를 저장 서브루틴 호출 시 사용 프로그램 카운터: 명령어를 단계별로 실행XPSR (프로그램 상태 레지스터) 응용 프로그램 상태 레지스터, 실행 프로그램 상태 레지스터, 인터럽트 프로그램 상태 레지스터로 구성 제어 레지스터에는 다양한 특수 비트 존재Armv8.1 추가 기능 포인터 인증 브랜치 (PACBTI)와 같은 확장 기능 추가 여러 활성화 및 비활성화 비트가 컨트롤 레지스터에 포함됨스택 포인터 사용 예제 풀 디센딩 스택 모델: 스택은 메모리에서 아래로 확장되고 스택 포인터는 마지막 위치를 가리킴 푸시 및 팝 연산을 통해 스택 포인터가 메모리의 위치를 가리킴링크 레지스터 사용 예제 함수 호출 시 링크 레지스터를 사용하여 리턴 주소를 저장 BL 명령어를 사용하여 함수로 분기 BX 명령어를 사용하여 링크 레지스터의 값으로 분기프로그램 카운터 명령어를 단계별로 실행하며 분기 명령어에서 암시적으로 사용됨 C 언어에서 함수 호출 시 적절한 점프 명령어를 생성프로그램 상태 레지스터 (XPSR) ALU 플래그: N (음수), Z (0), C (캐리), V (오버플로우) 인터럽트 프로그램 상태 레지스터: 현재 활성화된 인터럽트 또는 예외 번호 표시 실행 프로그램 상태 레지스터: T 비트 및 IT 필드 포함제어 레지스터 최대 8비트까지 확장 가능 NPriv 필드와 SPSEL 필드: 스레드 모드에서 실행 권한 및 스택 포인터 선택 부동 소수점 컨텍스트 활성 필드 (FPCA) 부동 소수점 확장 및 보안 확장과 관련된 비트스택 제한 레지스터 메인 스택 및 프로세스 스택에 대한 제한 설정 가능 스택 제한 값을 초과할 경우 UsageFault 발생 보안 확장을 사용할 경우 추가 레지스터 존재예외 처리 관련 레지스터 특수 용도의 레지스터: 인터럽트와 오류를 마스킹하는 방법 제공 BASEPRI 레지스터: 현재 스레드를 중단할 수 있는 인터럽트 결정이 문서는 ARMv8-M 코어 레지스터에 대한 개요를 제공하며, 각 레지스터의 기능과 사용 방법에 대해 설명합니다. ARM 아키텍처의 다양한 명령어와 예외 처리 메커니즘을 이해하는 데 도움이 됩니다.Armv8-M 명령어 세트 소개개요Armv8-M 아키텍처는 다양한 명령어 세트를 제공합니다. 이 문서에서는 주요 명령어 세트와 그 특성에 대해 설명합니다. 자세한 내용은 나중에 어셈블리 언어를 다룰 때 더 깊이 다루겠습니다.명령어 세트 개요 T32 명령어 세트: Thumb 명령어 세트로, Armv7-M 명령어 세트에서 파생되었습니다. 16비트 및 32비트 명령어: 두 가지 명령어를 혼합하여 사용 가능. 16비트 명령어는 코드 밀도를 높이고 메모리 사용량을 줄이기 위해 도입되었습니다.명령어 예시 ADD 명령어: 16비트 ADD와 32비트 ADD 명령어가 있으며, 컴파일러나 어셈블리 프로그램이 적절한 버전을 선택할 수 있습니다. LSLS 명령어: 논리적 전환 명령어로, 비트를 왼쪽으로 이동시키는 곱셈 연산도 포함됩니다.새로운 명령어 로드-획득 및 스토어-릴리즈 명령어: 동기화 및 세마포어 관리에 사용됩니다. 보안 확장 명령어: 보안 격리를 돕기 위한 SG 명령어와 NS명령어 등이 있습니다. TT 명령어: 특정 주소의 메모리 속성을 테스트하는 명령어입니다.다이어그램 요약 기본 아키텍처 명령어: 모든 기본 명령어를 포함. DSP 확장 명령어: 7개의 추가 명령어 포함. 부동 소수점 확장 명령어: 부동 소수점 연산을 위한 명령어 포함.메모리 액세스 명령어 STR 명령어: 레지스터의 값을 메모리 주소에 저장. LDR 명령어: 메모리 주소에서 레지스터로 데이터 로드. 로드-획득 및 스토어-릴리즈 명령어: 암묵적 장벽 연산 포함.프로그램 흐름 명령어 브랜치 명령어: 레이블로 직접 이동하거나 서브루틴 호출에 사용. BX 명령어: 레지스터 값으로 브랜치. BLX 명령어: 서브루틴 호출에 사용.결론Armv8-M 명령어 세트는 다양한 명령어를 통해 효율적이고 유연한 프로그래밍을 가능하게 합니다. 어셈블리 언어와 함께 사용하면 더 깊이 있는 프로그래밍이 가능합니다.프로그래밍 표준 및 CMSIS 개요Arm 아키텍처 프로시저 호출 표준 (AAPCS)개요AAPCS는 Arm 아키텍처에서 함수 호출 시 레지스터와 메모리의 사용 규칙을 정의하는 표준입니다. 이는 컴파일러와 어셈블러 프로그래머가 서로 호환되는 객체와 이미지를 만들기 위해 준수해야 하는 중요한 문서입니다.주요 내용 레지스터 사용: 함수 인수는 r0~r3 레지스터를 사용하며, 추가 인수는 스택에 저장됩니다. 보존 레지스터: r4~r11 레지스터는 함수 내에서 보존해야 하며, 사용 전에 스택에 푸시되어야 합니다. 8바이트 스택 정렬 규칙: 스택은 항상 8바이트로 정렬되어야 합니다. 위치 독립적 데이터: r9는 위치 독립적 데이터의 기본 포인터로 사용될 수 있습니다. 디버깅: r11은 디버깅용 프레임 포인터로 예약될 수 있습니다.예제호출자 함수가 foo 함수를 호출할 때, 인수는 r0에서 r3 레지스터로 전달됩니다. 호출자 함수는 r0에서 r3 레지스터를 보존할 필요는 없으나, r4에서 r11 레지스터는 보존해야 합니다. foo 함수가 반환될 때, 결과는 r0에 저장됩니다.공통 마이크로컨트롤러 소프트웨어 인터페이스 (CMSIS)개요CMSIS는 Cortex-M 마이크로컨트롤러의 표준 소프트웨어 인터페이스입니다. CMSIS는 다양한 구성 요소로 구성되어 있으며, 각 구성 요소는 특정 기능을 제공합니다.주요 구성 요소 CMSIS-DSP: DSP 기능을 위한 무료 라이브러리. CMSIS-NN: 신경망 기능을 위한 라이브러리. CMSIS-DAP: 소형 마이크로컨트롤러를 디버깅하기 위한 펌웨어. CMSIS-RTOS: 운영 체제와 주변 장치 액세스를 위한 코드. CMSIS-Driver: 주변 장치 액세스를 위한 드라이버. CMSIS-Core: 프로세서의 주변 장치에 표준 방식으로 액세스하는 데 유용한 명령 내장 및 기능 제공.CMSIS-Core 기능 명령어 내장 함수: C 프로그램에서 Arm 아키텍처의 특수 명령어를 사용하기 쉽게 함. 시작 코드: 리셋 핸들러 코드, 스택 포인터 초기화 코드, 벡터 테이블 및 표준 인터럽트 핸들러 포함. SIMD 명령어: 단일 명령어로 여러 작업을 수행할 수 있는 명령어. NVIC 및 SyStick 타이머 구성: 중첩 벡터 인터럽트 컨트롤러와 시스템 타이머 구성. 인터럽트 마스킹: 특정 인터럽트를 비활성화하는 기능 제공.사용 예시CMSIS-Core를 사용하면 Cortex-M 프로세서 또는 M-profile 구현을 표준화된 방법으로 프로그래밍할 수 있습니다. 이는 Arm Compiler, GNU 도구, IAR 컴파일러 등 다양한 툴체인에서 작동하는 내장 함수를 제공합니다.유용한 리소스 developer.arm.com: CMSIS와 관련된 다양한 참조 자료와 블로그 제공. GitHub: CMSIS 소스 코드와 설명서 제공. Keil MDK: CMSIS 지원 및 패키지가 사전 설치된 제품.결론CMSIS는 프로세서의 주변 장치에 표준화된 방식으로 액세스할 수 있도록 도와주며, 오픈 소스 프로젝트로서 개발자들이 기여할 수 있습니다. 이를 통해 Arm 마이크로컨트롤러 시스템의 개발을 용이하게 합니다.참고 자료 developer.arm.com GitHub - CMSIS Arm 아키텍처 참조 설명서Armv8-M Mainline 어셈블리 언어 프로그래밍개요이 모듈에서는 Armv8-M Mainline 장치에서 어셈블리 언어 프로그래밍이 유용한 이유와 사용 가능한 어셈블리 언어 명령어 유형을 살펴봅니다. 데이터 처리 명령, 로드/스토어 명령, 흐름 제어 명령, 기타 유용한 명령어 및 Armv8.1-M 사용자 지정 데이터 경로 확장(CDE)에 포함된 명령어를 다룹니다.어셈블리 언어 프로그래밍의 필요성 시스템 레지스터 접근: C 언어로는 시스템 레지스터에 직접 접근할 수 없으므로 어셈블리 명령어를 사용해야 합니다. 특정 명령 시퀀스 테스트: 매우 구체적인 명령 시퀀스의 동작을 테스트하거나, 컴파일러가 자동으로 수행할 수 없는 경우 직접 코드를 최적화할 때 유용합니다. 디버깅: 컴파일러의 출력을 디버깅할 때 어셈블리 명령어를 이해하면 유용합니다.T32 명령어 세트 이전 명칭: Thumb 명령어 세트 명령어 길이: 16비트와 32비트 명령어가 혼합되어 있습니다. 목적: 코드 크기를 최소화하고, 다양한 명령어 너비를 혼합하여 메모리 효율성을 높이는 데 도움.어셈블리 명령어 구문 명령어 형식: opcode는 명령어 이름 한정어, 조건 코드, 레지스터 피연산자 등을 포함할 수 있음 대상 레지스터 Rd, 두 번째 레지스터 피연산자 Rn, 선택적 피연산자 Rm UAL 구문: 통합 어셈블러 언어 구문으로, 모든 Arm 아키텍처와 프로세서에 적용.주요 어셈블리 명령어데이터 처리 명령어 MOV: 데이터를 한 레지스터에서 다른 레지스터로 이동. ADD: 두 레지스터의 값을 더하여 결과를 레지스터에 저장. SUB: 한 레지스터의 값에서 다른 레지스터의 값을 빼서 결과를 레지스터에 저장.로드/스토어 명령어 LDR: 메모리에서 데이터를 레지스터로 로드. STR: 레지스터의 데이터를 메모리에 저장.흐름 제어 명령어 B: 조건 없이 분기. BL: 서브루틴 호출 및 링크 레지스터에 반환 주소 저장. BX: 레지스터의 값으로 분기.기타 명령어 NOP: 아무 작업도 하지 않음. WFI: 인터럽트 대기.사용자 지정 명령어 CDE 명령어: Armv8.1-M 사용자 지정 데이터 경로 확장에 포함된 명령어.조건 코드 및 플래그 APSR: 애플리케이션 프로그램 상태 레지스터, 조건 플래그 포함. N: 네거티브 플래그 Z: 제로 플래그 C: 캐리 플래그 V: 오버플로 플래그 어셈블리 언어 프로그래밍의 예 루프 예제: 조건 플래그를 사용하여 루프의 종료를 제어. 카운터를 감소시키고, Z 플래그가 설정되면 루프를 종료. 참고 문서 Armv8-M 아키텍처 참조 매뉴얼: 어셈블리 명령어와 그 사용법에 대한 자세한 정보 제공. Arm Compiler 툴체인 문서: Arm 컴파일러에서 지원하는 어셈블러와 그 사용법 설명.Armv8-M Assembly Language Programming Overview데이터 처리 명령 (Data Processing Instructions)이 섹션에서는 Armv8-M Mainline 아키텍처의 일부로 사용할 수 있는 다양한 유형의 데이터 처리 명령을 살펴보겠습니다. 산술 연산 (Arithmetic Operations): ADD, SUB, ADCS, RSB 등의 명령이 있으며, 이들은 레지스터 간의 산술 연산을 수행합니다. 논리 연산 (Logical Operations): AND, ORR, BIC 등이 있으며, 비트 단위 논리 연산을 수행합니다. 조건 플래그 (Conditional Flags): 대부분의 데이터 처리 명령은 S 접미사를 사용하여 조건 플래그를 업데이트할 수 있습니다.데이터 처리 명령 예제 (Examples)ADD 명령 예제: 구문: ADD{S} {Rd}, Rn, Rm 예: ADDS r0, r1, r2 - r1과 r2의 합을 r0에 저장하고 플래그를 업데이트합니다.비교 명령 (Compare Instructions) CMP 명령: 두 레지스터 값을 비교하여 조건 플래그를 설정합니다. 구문: CMP Rn, Rm 예: CMP r1, r2 - r1과 r2를 비교하고 플래그를 설정합니다.논리 연산 (Logical Operations)논리 연산 명령 예제: AND: 비트 단위 AND 연산 ORR: 비트 단위 OR 연산 BIC: 비트 지우기 연산 구문: AND{S} {Rd}, Rn, Rm 예: ANDS r0, r1, r2 - r1과 r2의 AND 결과를 r0에 저장하고 플래그를 업데이트합니다.시프트 및 회전 명령 (Shift and Rotate Instructions)Armv8-M Mainline 아키텍처의 시프트 명령: ASR: Arithmetic Shift Right LSL: Logical Shift Left LSR: Logical Shift Right 구문: ASR {Rd}, Rn, #imm 예: ASR r0, r1, #2 - r1을 오른쪽으로 2비트 산술 이동하여 r0에 저장합니다.곱셈 및 나눗셈 명령 (Multiplication and Division Instructions)곱셈 명령: MUL: 32비트 곱셈 SMULL: 64비트 부호 있는 곱셈 구문: MUL {Rd}, Rn, Rm 예: MUL r0, r1, r2 - r1과 r2를 곱하여 r0에 저장합니다.비트 조작 명령 (Bit Manipulation Instructions)비트 조작 명령: UBFX: 부호 없는 비트 필드 추출 BFI: 비트 필드 삽입 구문: UBFX {Rd}, Rn, #lsb, #width 예: UBFX r0, r1, #8, #8 - r1의 8번 비트부터 8비트를 추출하여 r0에 저장합니다.C와 어셈블리 간의 변환 (Transformations between C and Assembly)C 코드에서 어셈블리 코드로 변환 예제: C 코드: dest1 = op1 + op2; dest2 = op3 - op4; 어셈블리 코드:상수 로드 명령 (Constant Load Instructions)상수 값을 레지스터에 로드하는 방법: MOV: 상수를 레지스터에 로드 구문: MOV {Rd}, #imm 예: MOV r0, #0x2543 - 0x2543 값을 r0에 로드합니다.나눗셈 명령 (Division Instructions)나눗셈 명령: SDIV: 부호 있는 나눗셈 UDIV: 부호 없는 나눗셈 구문: SDIV {Rd}, Rn, Rm 예: SDIV r0, r1, r2 - r1을 r2로 나누어 r0에 저장합니다.메모리 액세스 명령 (Memory Access Instructions)메모리에서 데이터 로드 및 저장이 섹션에서는 메모리에서 데이터를 로드하고 저장하는 데 사용할 수 있는 명령 유형을 살펴봅니다. 특히, Armv8-M 메인라인 아키텍처의 일부인 명령어 세트에서 메모리 액세스 크기와 데이터를 로드하거나 저장하는 주소가 계산되는 방식에 대해 다룹니다.명령어 유형 LDR (Load Register): 단어(word) 데이터를 메모리에서 로드합니다. STR (Store Register): 단어 데이터를 메모리에 저장합니다. LDRB (Load Register Byte): 바이트 데이터를 메모리에서 로드합니다. STRB (Store Register Byte): 바이트 데이터를 메모리에 저장합니다. LDRH (Load Register Halfword): 하프워드 데이터를 메모리에서 로드합니다. STRH (Store Register Halfword): 하프워드 데이터를 메모리에 저장합니다. LDRSB (Load Register Signed Byte): 부호 있는 바이트 데이터를 메모리에서 로드합니다. LDRSH (Load Register Signed Halfword): 부호 있는 하프워드 데이터를 메모리에서 로드합니다.메모리 로드 명령어는 메모리에서 데이터를 로드하면 대상 레지스터의 최하위 비트를 차지하고 나머지 공간은 0으로 채워집니다. 부호 확장을 수행하는 경우 가장 중요한 비트를 다른 모든 비트에 복사합니다.오프셋 주소 지정 모드 (Offset Addressing Modes)다양한 오프셋 주소 지정 모드를 지원하여 메모리 액세스 시 유연성을 제공합니다. 기본 레지스터 오프셋 (Register Offset): 기본 레지스터에 상수를 더하거나 뺀 값을 사용합니다. 예: LDR r0, [r1, #8] - r1 값에 8을 더한 주소에서 r0으로 로드합니다. 레지스터 시프트 오프셋 (Register Shifted Offset): 레지스터 값을 시프트하여 오프셋으로 사용합니다. 예: LDR r0, [r1, r2, LSL #2] - r2 값을 왼쪽으로 2비트 시프트하고 r1에 더한 주소에서 r0으로 로드합니다. 주소 지정 모드네 가지 주소 지정 모드를 지원합니다. 단순 주소 지정 모드 (Simple Addressing Mode): 기본 레지스터에서 단순히 로드하거나 저장합니다. 예: LDR r0, [r1] - r1 주소에서 r0으로 로드합니다. 오프셋 주소 지정 모드 (Offset Addressing Mode): 기본 레지스터에 오프셋을 더하여 주소를 계산합니다. 예: LDR r0, [r1, #12] - r1 값에 12를 더한 주소에서 r0으로 로드합니다. 사전 인덱스 주소 지정 모드 (Pre-indexed Addressing Mode): 오프셋을 더한 후 로드하거나 저장합니다. 예: LDR r0, [r1, #12]! - r1 값에 12를 더한 주소에서 r0으로 로드하고, r1을 갱신합니다. 사후 인덱스 주소 지정 모드 (Post-indexed Addressing Mode): 로드나 저장 후 오프셋을 더합니다. 예: LDR r0, [r1], #12 - r1 주소에서 r0으로 로드한 후 r1 값에 12를 더합니다. 다중 레지스터 로드 및 저장 (Multiple Register Load and Store) LDM (Load Multiple): 여러 레지스터를 한 번에 로드합니다. STM (Store Multiple): 여러 레지스터를 한 번에 저장합니다. 예: LDM r10!, {r0, r1, r4} - r10 주소에서 r0, r1, r4에 로드한 후 r10을 갱신합니다. 스택 액세스 (Stack Access) PUSH: 스택에 레지스터를 저장합니다. 예: STMFD sp!, {r4-r7, lr} - r4에서 r7 및 링크 레지스터를 스택에 푸시합니다. POP: 스택에서 레지스터를 로드합니다. 예: LDMFD sp!, {r4-r7, pc} - r4에서 r7 및 프로그램 카운터를 스택에서 팝합니다. 메모리 복사 작업메모리 복사 작업을 수행하는 어셈블리 명령 시퀀스: 소스에서 로드: LDRB r0, [r1], #1 - r1 주소에서 바이트를 로드하고, r1 값을 1 증가시킵니다. 목적지에 저장: STRB r0, [r2], #1 - r0 값을 r2 주소에 저장하고, r2 값을 1 증가시킵니다. 반복 루프: 문자열 복사 작업을 반복합니다. 예: loop: LDRB r0, [r1], #1 STRB r0, [r2], #1 CMP r0, #0 BNE loop Armv8-M Assembly Language Programming - Control Flow Instructions흐름 제어 명령어 (Control Flow Instructions)개요어셈블리 언어 프로그램이 실행될 때, 프로세서는 기본적으로 사용 가능한 다음 주소에서 다음 명령을 계속 실행합니다. 흐름 제어 명령어를 사용하면 이러한 동작을 변경하여 특정 명령을 건너뛰거나 코드의 다른 지점으로 이동할 수 있습니다. 이 섹션에서는 ARMv8-M 아키텍처의 다양한 흐름 제어 명령어를 살펴봅니다.분기 명령어 (Branch Instructions)분기 명령어는 프로그램 카운터(PC)를 변경하여 코드의 다른 부분으로 이동할 수 있게 합니다. 분기 명령어는 일반적으로 레이블과 함께 사용됩니다. B: 기본 분기 명령어로, 지정된 레이블로 분기합니다. 예: B label BL: 링크 명령이 있는 분기 명령어로, 서브루틴이나 함수를 호출할 때 사용됩니다. 현재 주소를 링크 레지스터(LR)에 저장한 후 지정된 레이블로 분기합니다. 예: BL func 조건부 분기 (Conditional Branch)조건부 분기 명령어는 특정 조건이 참일 때만 분기합니다. 조건은 상태 플래그(N, Z, C, V)에 따라 결정됩니다. BEQ: Z 플래그가 설정되어 있을 때 분기 (equal). 예: BEQ label BNE: Z 플래그가 설정되지 않았을 때 분기 (not equal). 예: BNE label BGT: N 플래그와 V 플래그가 같을 때 분기 (greater than). 예: BGT label BLT: N 플래그와 V 플래그가 다를 때 분기 (less than). 예: BLT label 비교 및 분기 명령어 (Compare and Branch Instructions)ARMv8-M 메인라인 아키텍처는 비교와 분기를 하나의 명령어로 결합한 명령어를 제공합니다. CBZ (Compare and Branch on Zero): 지정된 레지스터의 값이 0일 때 분기. 예: CBZ r0, label CBNZ (Compare and Branch on Non-Zero): 지정된 레지스터의 값이 0이 아닐 때 분기. 예: CBNZ r0, label 조건부 실행 블록 (Conditional Execution Blocks)if-then 블록을 사용하여 여러 명령어를 조건부로 실행할 수 있습니다. IT (If-Then) 명령어를 사용하여 최대 4개의 후속 명령어를 조건부로 실행할 수 있습니다. IT: if-then 블록의 시작을 정의합니다. 예: IT EQ ITE: if-then-else 블록의 시작을 정의합니다. 예: ITE EQ 예제다음은 if-then 블록을 사용하는 예제입니다.CMP r0, #0 // r0을 0과 비교IT EQ // if-then 블록 시작MOVEQ r1, #2 // r0이 0이면 r1에 2를 이동MOVNE r1, #4 // r0이 0이 아니면 r1에 4를 이동ARM 어셈블리 지침 요약어셈블리 구문의 이해어셈블리 지침 및 구문은 ARM 컴파일러와 GNU 어셈블러에서 다르게 사용됩니다. 이 섹션에서는 두 가지 구문의 차이점을 이해하고, 어떤 컴파일러가 사용되었는지 구분할 수 있는 방법을 학습합니다. 또한, Armv8-M 메인라인 특수 목적 레지스터의 값을 변경하는 간단한 읽기-수정-쓰기 시퀀스를 작성하는 방법을 배웁니다.어셈블러 비교레거시 armasm 어셈블러와 ARM 컴파일러 6의 armclang 통합 어셈블러를 비교합니다. 이 두 어셈블러는 통합 어셈블리 언어(UAL) 구문 규칙을 준수하지만, 디렉티브와 표현식을 작성하는 방식에서 차이가 있습니다. armasm 어셈블러는 이전 ARM 컴파일러 5의 일부였으며 ARMV8-M 아키텍처의 모든 기능을 지원하지는 않습니다. armclang 어셈블러는 ARM 컴파일러 6의 일부이며 ARMV8-M 아키텍처의 모든 기능을 지원합니다.명령어 및 디렉티브두 어셈블러는 동일한 명령 시퀀스를 사용하지만, 지침에서는 차이가 발생합니다. 섹션 정의: armasm에서는 area 지시문을 사용하고, armclang에서는 section 지시문을 사용합니다. 상수 정의: armasm에서는 EQU 지시문을 사용하고, armclang에서는 .equ 지시문을 사용합니다. 32비트 값 정의: armasm에서는 DCD 지시문을 사용하고, armclang에서는 .word 지시문을 사용합니다. 파일 종료: armasm에서는 END 지시문을 사용하고, armclang에서는 .end 지시문을 사용합니다.디지털 신호 처리(DSP) 명령어DSP 애플리케이션에서 포화 연산을 수행하는 방법을 설명합니다. 포화 연산은 값을 특정한 2의 거듭제곱으로 제한하는 연산입니다. ARMv8-M 아키텍처는 하드웨어에서 이 작업을 수행하기 위한 USAT 및 SSAT 명령을 제공합니다.바이트 리버설 명령다른 주변 장치를 다루기 위해 바이트 리버설 지침을 사용할 수 있습니다. rev 명령을 사용하여 레지스터의 바이트 순서를 뒤집을 수 있습니다.카운트 리딩 제로 명령어CLZ 또는 카운트 리딩 제로 명령어는 최상위 비트에서 시작하여 설정되지 않은 0의 수를 세고 해당 값을 레지스터에 반환합니다.특수 용도의 레지스터 프로그래밍특수 용도의 레지스터를 사용하여 Cortex-M 장치를 프로그래밍하는 방법을 설명합니다. MRS 명령어: 특수 목적 레지스터에서 범용 레지스터로 이동하는 명령어입니다. MSR 명령어: 범용 레지스터에서 특수 목적 레지스터로 이동하는 명령어입니다.전원 관리 명령어프로세서를 저전력 상태로 전환하거나 멀티코어 시스템의 다른 프로세서에 이벤트를 알리는 데 사용할 수 있는 몇 가지 전원 관리 명령이 있습니다. WFI 명령어: 프로세서를 저전력 상태로 전환합니다. WFE 명령어: 송신 이벤트에 대한 응답으로 깨어납니다.기타 유용한 명령어 NOP 명령어: 코드에서 자리 표시자로 자주 사용됩니다. 컴파일러에서 명령을 특정 경계에 정렬하는 데 사용할 수 있습니다.ARMv8-M 아키텍처의 추가 지침 보안 상태 지침: ARMv8-M 보안 확장 교육 모듈에서 다루는 지침입니다. 장벽 명령: 작업 발생 순서를 제어하고 잘못된 실행을 방지하는 데 사용됩니다. 관리자 호출 명령(SVC): 운영 체제에 작업을 수행하도록 요청하는 데 사용됩니다.ARM 사용자 지정 명령어 요약개요이 모듈의 마지막 부분에서는 Arm Custom Instructions 기능에 대해 알아봅니다. 이는 Armv8-M 및 Armv8.1-M 아키텍처를 위한 사용자 지정 데이터 경로 확장의 일부로, 프로세서 설계자가 Arm 프로세서에 자체 기능을 추가할 수 있도록 합니다.사용자 지정 명령어의 구문사용자 지정 명령어는 여러 명령어 클래스로 나뉘며, 각 클래스는 지정할 수 있는 입력 및 출력 피연산자의 유형에 따라 정의됩니다. 클래스 1: 출력 대상 레지스터와 입력 즉시값 피연산자. 클래스 2: 출력 대상 레지스터, 입력 즉시값 피연산자, 추가 소스 레지스터 피연산자. 클래스 3: 여러 소스 레지스터 피연산자.조건 코드 전달사용자 정의 명령어로 조건 코드를 전달하려면 APSR_NZCV라는 이름을 사용해야 합니다. 이는 애플리케이션 프로세스 상태 레지스터를 의미하며, Negative, Zero, Carry, Overflow 플래그를 포함합니다.SIMD 및 부동 소수점 레지스터사용 중인 프로세서에 따라 사용자 지정 명령어에 SIMD 및 부동 소수점 레지스터를 전달할 수도 있습니다. 예를 들어, Cortex-M33은 SIMD 레지스터 전달을 지원하지 않습니다.사용자 지정 명령어의 인코딩사용자 지정 명령어는 보조 프로세서 명령어와 동일한 인코딩 공간을 사용합니다. 특정 명령어를 Arm 사용자 지정 명령어로 전달하려면 코어 프로세서에 연결해야 합니다.사용자 지정 명령어 클래스의 변형각 명령어 클래스에는 몇 가지 변형이 있습니다. 일반 변형: 결과를 계산하고 출력 레지스터를 사용. 누산기 변형: 등록된 값을 소비하여 연산. 이중 변형: 결과를 두 개의 레지스터에 저장.명령어 클래스 1명령어 클래스 1은 다음과 같은 형태로 나타납니다: CX로 시작하여 사용자 지정 명령어임을 나타냅니다. 보조 프로세서 이름(P0 등). 대상 레지스터(범용 레지스터 또는 특수 이름). 즉시값(최대 13비트).비누산기 변형레지스터만 출력으로 사용하며, 실제 값은 코프로세서에 전달되지 않습니다.누산기 변형레지스터 또는 플래그와 즉시값을 코어 프로세서로 전달하여 레지스터를 업데이트합니다.명령어 클래스 2명령어 클래스 2는 다음과 같은 형태로 나타납니다: CX로 시작하여 사용자 지정 명령어임을 나타냅니다. 보조 프로세서 이름(P1 등). 두 개의 대상 레지스터. 소스 레지스터 및 즉시값(최대 9비트).비누산기 변형두 개의 대상 레지스터를 입력으로 사용하지 않고 즉시값과 opcode를 코어 프로세서로 전송하여 업데이트.누산기 변형두 개의 대상 레지스터 값을 받아 코어 프로세서로 확장하여 모든 값을 사용할 수 있게 합니다.참고 사항 누산기 변형이라는 용어는 보조 프로세서가 대상 레지스터 값을 사용하는 방식을 의미하며, 단순히 더하기 또는 빼기 연산을 수행하는 것은 아닙니다. 원하는 연산을 수행할 수 있습니다.Armv8-M 메모리 모델 요약개요안녕하세요, 여러분. 저는 Arm에서 일하는 애플리케이션 엔지니어 Yang Song입니다. 오늘은 Armv8-M 메인라인 아키텍처의 중요한 주제인 메모리 모델에 대해 알아보겠습니다.학습 목표이 모듈을 마치면 다음을 할 수 있습니다: Armv8-M 메인라인 주소 공간의 여러 파티션을 나열 Arm 아키텍처 메모리 유형 구분 주소 공간의 특정 파티션에 사용되는 이유 구분 다양한 메모리 속성과 해당 속성이 로드 및 저장에 미치는 영향 식별 Endianness가 Armv8-M 프로세서에 미치는 영향 특성화 다양한 Barrier 명령 인식 및 사용 이유 설명메모리 주소 공간Armv8-M은 최대 4GB의 물리적 주소 공간을 포함하는 메모리 매핑 아키텍처입니다. 주소 공간은 물리적 메모리와 프로세서 제어 및 상태 레지스터 모두를 위한 공유 주소 공간입니다. 메모리는 8개의 512MB 세그먼트 또는 파티션으로 분할됩니다: 코드 섹션 SRAM 주변기기 2개의 RAM 영역 2개의 장치 영역 시스템 영역시스템 영역에는 프로세서 제어 및 상태 레지스터가 포함됩니다.메모리 유형과 속성메모리 영역에는 일반 메모리 또는 장치 메모리가 포함될 수 있습니다. 메모리 유형은 프로세서가 해당 메모리에 액세스하는 방식을 결정합니다. 각 메모리 유형에는 추가 속성(액세스 권한, 실행 권한, 공유 가능성, 캐시 가능성)이 있습니다.일반 메모리 정상 메모리: 코드 및 대부분의 데이터 영역에 사용. 최상의 성능을 제공하며, CPU가 액세스를 재정렬하거나 병합할 수 있음. 추측적 액세스: 일반 메모리는 순서가 약한 메모리 모델을 구현하여 다른 일반 액세스 및 장치 액세스와 관련하여 액세스를 순서대로 완료할 필요가 없음.장치 메모리 장치 유형 메모리: 액세스에 부작용이 발생할 수 있는 영역에 사용. 예를 들어, 주변 장치의 제어 레지스터에 기록하면 인터럽트가 발생할 수 있음. 장치 메모리 변형: NGNRNE (가장 제한적), NGNRE, GRE (가장 제한이 적음).Endianness 리틀 엔디안: 기본 설정. 단어의 최하위 바이트가 가장 낮은 주소를 가리킴. 빅 엔디안: 구성 가능. 단어의 최상위 바이트가 가장 낮은 주소를 가리킴. BE-8 모델: Arm Cortex-M 프로파일 코어에서 지원.Barrier 명령어 DMB (Data Memory Barrier): DMB 이전의 모든 명시적 메모리 액세스가 DMB 이후의 명시적 메모리 액세스 전에 완료되도록 보장. DSB (Data Synchronization Barrier): DSB가 완료되기 전에 모든 명시적 메모리 트랜잭션이 완료되도록 보장. DSB는 매우 제한적이며 명령어 실행을 차단. ISB (Instruction Synchronization Barrier): 시스템 제어 레지스터의 변경 사항을 동기화하여 새로운 체계를 설정.메모리 보호 (Memory Protection)학습 목표이 모듈을 완료하면 다음을 할 수 있습니다: 메모리 보호 장치(MPU)의 필요성 설명 Armv8-M MPU가 이전 Armv7-M 및 Arm6-M MPU와 어떻게 다른지 이해 다양한 메모리 맵핑된 MPU 레지스터 설명 MPU 레지스터를 프로그래밍하여 메모리 영역 구성메모리 보호의 동기메모리 보호는 주소 공간 접근을 제어합니다. 코어가 다양한 보안 및 특권 상태에서 작동할 수 있기 때문에 필요하며, 민감한 데이터를 특정 상태로 제한하는 것이 중요합니다.메모리 보호와 보안 속성메모리 보호는 다음으로 구성됩니다: 선택적 메모리 보호 장치(MPU) 보호 메모리 시스템 아키텍처(PMSAv8)를 기반으로 함 선택적 보안 속성 장치(SAU) 보안 확장이 구현된 경우 사용 가능 MPU는 다음을 완전히 지원합니다: 보호 영역, 접근 권한 및 시스템에 메모리 속성 내보내기 MPU 불일치 및 권한 위반은 MemManage 핸들러를 호출기본 시스템 주소 맵기본적으로 주소 공간은 8개의 0.5GB 영역을 정의합니다. MPU가 구현되지 않은 경우 기본 시스템 주소 맵이 적용됩니다. MPU가 구현되었지만 비활성화된 경우 시스템이 PPB 주소 공간에 접근하는 경우 등메모리 보호 장치(MPU)MPU는 기본 메모리 관리를 제공합니다. 주소 영역에 속성을 적용할 수 있도록 함 모든 접근은 MPU 영역에 대해 검사됩니다.각 영역은 다음으로 구성됩니다: 기본 주소 한계 주소 속성(예: 유형, 크기, 접근 권한)MPU 레지스터 주소 이름 유형 설명 0xE000ED90 MPU_TYPE RO MPU 유형 레지스터 0xE000ED94 MPU_CTRL RW MPU 제어 레지스터 0xE000ED98 MPU_RNR RW MPU 영역 번호 레지스터 0xE000ED9C MPU_RBAR RW MPU 영역 기본 주소 레지스터 0xE000EDA0 MPU_RLAR RW MPU 영역 한계 주소 레지스터 0xE000EDC0 MPU_MAIR0 RW MPU 메모리 속성 간접 레지스터 0 0xE000EDC4 MPU_MAIR1 RW MPU 메모리 속성 간접 레지스터 1 MPU 제어 레지스터 (MPU_CTRL) 비트 위치 이름 설명 [2] PRIVDEFENA MPU가 활성화된 경우 기본 메모리 맵을 백그라운드 영역으로 사용하도록 허용 [1] HFNMIENA 하드폴트 및 NMI 핸들러가 MPU를 활성화된 상태로 메모리에 접근할 수 있도록 제어 [0] ENABLE MPU 활성화/비활성화 (1: 활성화, 0: 비활성화) MPU 영역 기본 주소 레지스터 (MPU_RBAR) XN: 실행 불가 여부 (0: 실행 가능, 1: 실행 불가) SH: 공유 가능성 (00: 공유 불가, 01: 예약됨, 10: 외부 공유 가능, 11: 내부 공유 가능) AP: 접근 권한 (00: 특권 코드만 읽기/쓰기, 01: 모든 특권 레벨에서 읽기/쓰기, 10: 특권 코드만 읽기, 11: 모든 특권 레벨에서 읽기)MPU 영역 한계 주소 레지스터 (MPU_RLAR) LIMIT: 선택된 MPU 메모리 영역의 상한 한계 주소 AttrIndx: MPU_MAIR0/1 필드에서 속성 세트를 연결 EN: 영역 활성화 여부 (0: 비활성화, 1: 활성화)MPU 메모리 속성 간접 레지스터 (MPU_MAIR0/1) Attr: 속성 (예: 0000: 디바이스 메모리, 00RW: 외부 쓰기-스루 일시적, 0100: 외부 비캐시)MPU 구성 MPU_TYPE 읽기: 사용 가능한 영역 수 확인 MPU_RBAR에 기본 주소, 공유 가능성 및 접근 권한 쓰기 MPU_RLAR에 한계 주소, 추가 메모리 속성 및 영역 활성화 비트 쓰기 MPU_MAIRn에 Attr 값에 해당하는 메모리 속성 인코딩 쓰기 MPU_CTRL 레지스터에 쓰기하여 Hardfault/NMI 동작 및 특권 접근 구성 후 MPU 활성화 MPU_RNR에 영역 번호 쓰기MemManage faults (Armv8-M Mainline 전용) 데이터 접근 위반 (DACCVIOL) 명령어 접근 위반 (IACCVIOL) 예외 엔트리 스택 메모리 작업 실패 (MSTKERR) 예외 반환 스택 메모리 작업 실패 (MUNSTKERR) 게으른 상태 보존 오류 플래그 (MLSPERR)Armv8-M 아키텍처의 예외 처리학습 목표이 모듈을 완료하면 다음을 수행할 수 있습니다: M-프로파일 예외 모델 설명 내장된 중첩 벡터 인터럽트 컨트롤러(NVIC) 및 임베디드 시스템에 최적화된 방식 예외 유형 벡터 테이블 리셋 동작 기본 예외 처리 메커니즘 리셋 동작 설명 예외 진입 및 예외 반환 시 발생하는 일 설명 예외 대기 시간과 예외 처리 속도를 높이기 위한 아키텍처 최적화 논의목차 소개 예외 모델 예외 진입 및 종료 동작 우선순위와 제어 인터럽트 민감도 벡터 테이블 및 인터럽트 핸들러 작성 내부 예외 및 RTOS 지원 오류 예외 참고 자료개요Arm 마이크로컨트롤러 프로파일 아키텍처 버전의 예외 아키텍처는 다른 Arm 아키텍처와 매우 다릅니다. 마이크로컨트롤러 응용 프로그램을 위해 설계되었습니다. 많은 인터럽트 소스를 지원 중첩 인터럽트의 효율적인 처리 유연한 인터럽트 아키텍처 (높은 구성 가능성) RTOS 지원 내장주요 기능 중첩 벡터 인터럽트 컨트롤러(NVIC) 마이크로 코드 아키텍처가 “더티 작업” 처리 인터럽트 진입/종료 및 인터럽트 중첩에 대한 소프트웨어 오버헤드 없음 모든 예외 처리를 위한 단일 모드 및 단일 스택 핸들러 모드 / 메인 스택 프로그래밍이 용이 어셈블리어로 핸들러 코드를 작성할 필요 없음 마이크로 코드 인터럽트 메커니즘 저지연을 위한 인터럽트 아키텍처 설계 NVIC에 내장된 인터럽트 우선순위 메커니즘 인터럽트 진입/종료는 하드웨어 제어로 “마이크로 코드화” 프로세서 컨텍스트를 자동으로 저장 및 복원 가장 높은 우선순위 대기 인터럽트의 늦은 결정 허용 프로세서 상태의 전체 복원/저장 없이 다른 대기 인터럽트 서비스 허용 (테일 체이닝) 인터럽트 서비스 루틴(ISR)은 전적으로 C 언어로 작성 가능 일부 다중 사이클 명령어는 개선된 인터럽트 대기 시간을 위해 인터럽트 가능예외 유형예외는 다양한 이벤트로 인해 발생할 수 있습니다: 내부 외부프로세서 모드 사용 예스레드 모드에서 예외가 발생하면 프로세서 모드가 변경됩니다. 핸들러 모드에서 예외가 발생하면 모드가 변경되지 않습니다.외부 인터럽트 NVIC에 의해 처리되는 외부 인터럽트 프로세서 코어와 긴밀하게 결합 하나의 비마스킹 인터럽트(NMI) 지원 외부 인터럽트의 수는 구현에 따라 다름 (최대 496개 인터럽트 지원)선점선점은 예외를 처리하기 위해 태스크가 일시 중단될 때 발생합니다. 동일한 우선순위의 여러 예외가 대기 중인 경우 고정된 순서로 처리됩니다. 활성화된 예외는 높은 우선순위 예외만 선점할 수 있습니다.예외 처리 모델프로세서는 “기본 실행 우선순위 수준”으로 실행을 시작합니다. 리셋 시 모든 인터럽트가 비활성화됩니다. 기본 실행 우선순위는 가장 낮은 프로그래밍 가능한 우선순위보다 낮으므로 활성화된 모든 인터럽트가 코어를 선점합니다.벡터 테이블벡터 테이블의 첫 번째 항목은 초기 메인 스택 포인터를 포함합니다. 나머지 항목은 예외 핸들러의 주소입니다. 벡터 테이블은 최대 496개의 외부 인터럽트를 가질 수 있습니다.예외 진입 동작예외를 받을 때 프로세서는 대부분의 명령어에서 현재 명령어 스트림을 완료합니다. 프로세서 상태는 현재 스택에 자동으로 저장됩니다. ISR 주소는 벡터 테이블에서 읽어옵니다. 링크 레지스터는 인터럽트 반환을 위해 수정됩니다. 예외 핸들러 루틴은 핸들러 모드에서 메인 스택을 사용하여 실행됩니다.예외 반환예외에서 반환할 때 프로세서는 특정 “매직” 값(0xFFFF_FFXX)으로 PC가 로드될 때 다음 명령어를 실행합니다. 대기 중인 인터럽트가 없는 경우 포어그라운드 상태가 복원됩니다. 다른 인터럽트가 대기 중인 경우 가장 높은 우선순위가 서비스될 수 있습니다.내부 예외 및 RTOS 지원SysTick 타이머 RTOS 또는 사용자 정의 프로그램 실행을 위한 시스템 하트비트 제공 주기적 인터럽트는 시스템 태스크 스케줄링을 구동Supervisor Call (SVC) 비특권 소프트웨어가 시스템 호출을 할 수 있도록 허용 RTOS 서비스 요청 처리Pended System Call (PendSV) RTOS 개발을 용이하게 함오류 예외일반 오류의 세 가지 클래스 BusFault: 메모리 액세스 오류 (프리페치 또는 데이터 액세스) MemManage: MPU 권한 불일치 UsageFault: 정의되지 않은 명령어, CP 액세스, 불법 상태 전환 등오류 처리단순 시스템은 HardFault 핸들러만 사용합니다. 별도의 오류 핸들러를 활성화하는 것은 필요한 경우에만 해야 합니다. 각 오류에는 연관된 상태 레지스터가 있습니다.Lockup 상태회복 불가능한 예외의 경우 Lockup 상태에 진입합니다. NMI 예외 또는 디버그 이벤트, 리셋 시 Lockup 상태에서 벗어날 수 있습니다.동기 및 비동기 예외동기 예외는 명령어 스트림과 고정된 관계가 있습니다. 비동기 예외는 명령어 스트림과 고정된 관계가 없습니다.참고 자료 Armv8-M 아키텍처 레퍼런스 매뉴얼 애플리케이션 노트: AN209 - Cortex-M3/M4/M7 오류 예외 사용 도서: The Definitive Guide to the Cortex-M3 and Cortex-M4 Processors (ISBN: 978-0124080829) - Yiu" }, { "title": "EB AUTOSAR", "url": "/posts/EB-AUTOSAR/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-06-02 00:00:00 +0900", "snippet": "EB AUTOSAR에 대해EB AUTOSAR는 ETAS와 Bosch가 제공하는 AUTOSAR(AUTomotive Open System ARchitecture) 솔루션입니다. AUTOSAR는 자동차 전자 시스템의 표준 소프트웨어 아키텍처를 정의하는 글로벌 개발 파트너십입니다. EB(ETAS and Bosch)는 AUTOSAR 표준을 구현하고, 자동차 제조업체와 공급업체가 효율적이고 재사용 가능한 소프트웨어를 개발할 수 있도록 다양한 툴과 소프트웨어 컴포넌트를 제공합니다.AUTOSAR의 주요 구성 요소 기본 소프트웨어 (Basic Software, BSW): 서비스 계층(Service Layer): 운영 체제, 메모리 서비스, 통신 서비스 등을 포함합니다. ECU 추상화 계층(ECU Abstraction Layer): 하드웨어와 독립적인 인터페이스를 제공합니다. 마이크로컨트롤러 추상화 계층(Microcontroller Abstraction Layer, MCAL): 하드웨어에 종속된 부분을 추상화하여 상위 계층이 하드웨어 독립적으로 동작할 수 있게 합니다. 런타임 환경 (Runtime Environment, RTE): 애플리케이션 소프트웨어와 기본 소프트웨어 간의 인터페이스를 관리합니다. 각 애플리케이션 소프트웨어 컴포넌트가 다른 컴포넌트나 BSW와 통신할 수 있도록 합니다. 애플리케이션 소프트웨어 (Application Software): 특정 기능을 수행하는 소프트웨어 컴포넌트로 구성됩니다. 각 컴포넌트는 RTE를 통해 통신하며, 다양한 기능을 수행하는 데 필요한 인터페이스를 제공합니다. EB AUTOSAR의 기능 및 장점 통합 개발 환경: EB는 AUTOSAR 개발을 지원하는 통합 개발 환경(IDE)을 제공합니다. 이를 통해 개발자는 AUTOSAR 규격에 맞는 소프트웨어를 쉽게 개발할 수 있습니다. EB tresos Studio는 AUTOSAR 소프트웨어 개발을 위한 강력한 툴로, 다양한 설정과 구성 작업을 자동화하고 효율적으로 관리할 수 있습니다. 컴포넌트 재사용: AUTOSAR 표준을 준수하여 개발된 소프트웨어 컴포넌트는 재사용이 가능하여, 새로운 프로젝트에서 개발 시간을 절감할 수 있습니다. 이는 소프트웨어의 품질을 높이고 비용을 절감하는 데 큰 도움이 됩니다. 하드웨어 독립성: MCAL과 같은 계층을 통해 하드웨어에 독립적인 소프트웨어 개발이 가능하며, 다양한 하드웨어 플랫폼에서 동일한 소프트웨어를 사용할 수 있습니다. 표준화된 인터페이스: AUTOSAR는 표준화된 인터페이스를 제공하여, 서로 다른 공급업체의 소프트웨어 컴포넌트가 원활하게 통합될 수 있도록 합니다. EB AUTOSAR의 구성 예시1. 기본 소프트웨어 (BSW) OS (Operating System): 실시간 운영체제 기능을 제공하여 태스크 스케줄링, 자원 관리, 인터럽트 관리 등을 수행. COM (Communication Services): CAN, LIN, FlexRay와 같은 통신 프로토콜을 지원. MEM (Memory Services): NVRAM 관리, 메모리 할당 등을 수행.2. 런타임 환경 (RTE) RTE Generator: 애플리케이션 소프트웨어와 BSW 간의 인터페이스 코드를 자동으로 생성. Inter-ECU Communication: ECU 간의 메시지 전송을 관리.3. 애플리케이션 소프트웨어 SWC (Software Components): 특정 기능을 수행하는 모듈들로, 예를 들어 엔진 제어, 브레이크 시스템 관리 등을 담당.AUTOSAR 소프트웨어 컴포넌트 예시 코드다음은 간단한 AUTOSAR SWC (Software Component) 예시 코드입니다.// RTE Header#include \"Rte_SWC.h\"// Runnable Entityvoid Runnable_SWC(void){ // 데이터 요소 읽기 int sensorValue; Rte_Read_InPort_SensorValue(&amp;sensorValue); // 데이터 처리 int processedValue = sensorValue * 2; // 데이터 요소 쓰기 Rte_Write_OutPort_ProcessedValue(processedValue);}" }, { "title": "OSEK", "url": "/posts/OSEK/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-29 00:00:00 +0900", "snippet": "OSEKOSEK OSOSEK OS는 실시간 운영체제(RTOS)로, 자동차 전자 시스템을 위한 표준 운영체제 인터페이스를 정의합니다. OSEK(Open Systems and their corresponding Interfaces for automotive Electronics)는 주로 자동차 산업에서 사용되며, 여러 전자 제어 장치(ECU) 간의 효율적이고 신뢰성 있는 소프트웨어 관리를 목표로 합니다.OSEK OS의 주요 특징 및 구성 요소 태스크 관리 (Task Management) 태스크(Task): OSEK OS에서는 태스크를 실시간으로 관리합니다. 태스크는 실행 상태, 대기 상태, 준비 상태 등 다양한 상태를 가질 수 있습니다. 우선순위(Priority): 각 태스크는 우선순위를 가지며, 우선순위에 따라 스케줄링됩니다. OSEK OS는 고정 우선순위 스케줄링을 사용합니다. 태스크 유형: 기본(Basic) 태스크와 확장(Extended) 태스크로 나눌 수 있습니다. 확장 태스크는 이벤트를 기다릴 수 있습니다. 스케줄링 (Scheduling) 비선점형 스케줄링(Non-preemptive Scheduling): 태스크가 실행 중일 때 다른 태스크가 선점할 수 없습니다. 선점형 스케줄링(Preemptive Scheduling): 높은 우선순위의 태스크가 실행 중인 태스크를 선점할 수 있습니다. 이벤트 관리 (Event Management) 확장 태스크는 이벤트를 대기할 수 있으며, 이벤트가 설정되면 태스크가 실행됩니다. 이벤트는 주로 태스크 간의 동기화에 사용됩니다. 자원 관리 (Resource Management) OSEK OS는 태스크 간의 자원 접근을 조정하기 위한 메커니즘을 제공합니다.자원(Resource): 상호 배제를 위해 사용되며, 자원을 사용할 때는 항상 먼저 자원을 요청하고, 사용 후에는 반환해야 합니다. 알람 및 타이머 (Alarm and Timer) 알람은 주기적 또는 일정 시간 후에 태스크를 활성화하거나 이벤트를 설정할 수 있습니다.타이머는 실시간 시스템에서 시간을 관리하는 데 사용됩니다. OSEK OS의 태스크 상태 RUNNING: 태스크가 실행 중인 상태. READY: 태스크가 실행 준비가 된 상태. WAITING: 태스크가 이벤트나 자원을 기다리는 상태. SUSPENDED: 태스크가 비활성화된 상태. 예제 코드 기본적인 태스크와 이벤트를 설정하는 예제#include \"osek.h\"// 태스크 선언TASK(Task1) { while (1) { // 태스크 실행 코드 TerminateTask(); }}TASK(Task2) { while (1) { // 태스크 실행 코드 TerminateTask(); }}// 알람 콜백 함수 선언ALARMCALLBACK(AlarmCallback) { // 알람 콜백 함수 실행 코드}// 메인 함수int main(void) { // OSEK 커널 초기화 StartOS(OSDEFAULTAPPMODE); return 0;}// OSEK OS 설정 파일 (OIL 파일)CPU my_cpu { OS my_os { STATUS = STANDARD; STARTUPHOOK = FALSE; ERRORHOOK = FALSE; SHUTDOWNHOOK = FALSE; PRETASKHOOK = FALSE; POSTTASKHOOK = FALSE; USEGETSERVICEID = FALSE; USEPARAMETERACCESS = FALSE; USERESSCHEDULER = FALSE; TASK Task1 { PRIORITY = 1; ACTIVATION = 1; SCHEDULE = FULL; AUTOSTART = TRUE; STACKSIZE = 512; }; TASK Task2 { PRIORITY = 2; ACTIVATION = 1; SCHEDULE = FULL; AUTOSTART = TRUE; STACKSIZE = 512; }; ALARM my_alarm { COUNTER = my_counter; ACTION = ACTIVATETASK { TASK = Task1; }; AUTOSTART = TRUE { ALARMTIME = 10; CYCLETIME = 20; APPMODE = OSDEFAULTAPPMODE; }; }; };};요약OSEK OS는 자동차 전자 시스템에서 실시간 태스크 관리, 자원 관리, 이벤트 관리 및 스케줄링을 위한 표준 인터페이스를 제공합니다. 이 표준은 시스템의 안정성과 효율성을 높이며, 다양한 하드웨어 플랫폼에서 사용할 수 있도록 설계되었습니다. OSEK OS는 고정 우선순위 스케줄링을 사용하며," }, { "title": "수열과 쿼리 15", "url": "/posts/%EC%88%98%EC%97%B4%EA%B3%BC-%EC%BF%BC%EB%A6%AC-15/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-20 00:00:00 +0900", "snippet": "수열과 쿼리 15문제길이가 N인 수열 A1, A2, …, AN이 주어진다. 이때, 다음 쿼리를 수행하는 프로그램을 작성하시오.1 i v : Ai를 v로 바꾼다. (1 ≤ i ≤ N, 1 ≤ v ≤ 109)2 : 수열에서 크기가 가장 작은 값의 인덱스를 출력한다. 그러한 값이 여러개인 경우에는 인덱스가 작은 것을 출력한다.수열의 인덱스는 1부터 시작한다.입력첫째 줄에 수열의 크기 N이 주어진다. (1 ≤ N ≤ 100,000)둘째 줄에는 A1, A2, …, AN이 주어진다. (1 ≤ Ai ≤ 109)셋째 줄에는 쿼리의 개수 M이 주어진다. (1 ≤ M ≤ 100,000)넷째 줄부터 M개의 줄에는 쿼리가 주어진다.출력2번 쿼리에 대해서 정답을 한 줄에 하나씩 순서대로 출력한다.#include &lt;stdio.h&gt;#define HEAP_MAX 200100#define ARR_MAX 10000001#define P printf#define INT_MAX 0x7fffffffint N, M;int arr[ARR_MAX];struct HEAP{ int idx; int value;};HEAP heap[HEAP_MAX];int heapidx[HEAP_MAX];int hn;int compare(HEAP a, HEAP b){ if (a.value &lt; b.value) return 1; else if (a.value == b.value &amp;&amp; a.idx &lt; b.idx) return 1; return 0;}#if 0HEAP pop(HEAP* heap, int&amp; hn, int* heapidx){ HEAP tmp, ret = heap[1]; heap[1] = heap[hn]; heap[hn].value = INT_MAX; heap[hn--].idx = INT_MAX; for (register int i = 1; i * 2 &lt;= hn;) { if (compare(heap[i], heap[i * 2]) &amp;&amp; compare(heap[i], heap[i * 2 + 1])) break; else if (heap[i * 2].value &lt; heap[i * 2 + 1].value) { tmp = heap[i * 2]; heap[i * 2] = heap[i]; heap[i] = tmp; heapidx[heap[i].idx] = i; heapidx[heap[i * 2].idx] = i * 2; i *= 2; } else { tmp = heap[i * 2 + 1]; heap[i * 2 + 1] = heap[i]; heap[i] = tmp; heapidx[heap[i].idx] = i; heapidx[heap[i * 2 + 1].idx] = i * 2 + 1; i = i * 2 + 1; } } return ret;}#endifvoid push(HEAP* heap, int&amp; hn, int idx, int value, int* heapidx){ HEAP tmp; heap[++hn].idx = idx; heap[hn].value = value; heapidx[idx] = hn; for (int i = hn; i &gt; 1; i /= 2) { if (compare(heap[i / 2], heap[i])) break; tmp = heap[i / 2]; heap[i / 2] = heap[i]; heap[i] = tmp; heapidx[heap[i].idx] = i; heapidx[heap[i / 2].idx] = i / 2; }}void update(HEAP* heap, int&amp; hn, int idx, int value, int* heapidx){ HEAP tmp; int update_heapidx = heapidx[idx]; heap[update_heapidx].value = value; /* 위로 이동 */ for (int i = update_heapidx; i &gt; 1; i /= 2) { if (compare(heap[i / 2], heap[i])) break; tmp = heap[i / 2]; heap[i / 2] = heap[i]; heap[i] = tmp; heapidx[heap[i].idx] = i; heapidx[heap[i / 2].idx] = i / 2; } /* 아래로 이동 */ for(int i = update_heapidx; i * 2 + 1 &lt;= hn;) { if (compare(heap[i], heap[i * 2]) &amp;&amp; compare(heap[i], heap[i * 2 + 1])) break; else if (compare(heap[i * 2], heap[i * 2 + 1])) { tmp = heap[i * 2]; heap[i * 2] = heap[i]; heap[i] = tmp; heapidx[heap[i].idx] = i; heapidx[heap[i * 2].idx] = i * 2; i *= 2; } else { tmp = heap[i * 2 + 1]; heap[i * 2 + 1] = heap[i]; heap[i] = tmp; heapidx[heap[i].idx] = i; heapidx[heap[i * 2 + 1].idx] = i * 2 + 1; i = i * 2 + 1; } } }// 최소힙int main(){ scanf(\"%d\", &amp;N); for (int i = 0; i &lt; HEAP_MAX /* heap size */; i++) heap[i].idx = heap[i].value = INT_MAX; for (int i = 1; i &lt;= N; i++) { int val; scanf(\"%d\", &amp;val); push(heap, hn, i, val, heapidx); } scanf(\"%d\", &amp;M); for (int i = 0; i &lt; M; i++) { int cmd; scanf(\"%d\", &amp;cmd); if (cmd == 1) { int idx, v; scanf(\"%d %d\", &amp;idx, &amp;v); update(heap, hn, idx, v, heapidx); } else { // 최소값의 인덱스 pop(값 출력) printf(\"%d\\n\", heap[1].idx); } } return 0;}" }, { "title": "회사에 있는 사람", "url": "/posts/%ED%9A%8C%EC%82%AC%EC%97%90-%EC%9E%88%EB%8A%94-%EC%82%AC%EB%9E%8C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-18 00:00:00 +0900", "snippet": "회사에 있는 사람문제상근이는 세계적인 소프트웨어 회사 기글에서 일한다. 이 회사의 가장 큰 특징은 자유로운 출퇴근 시간이다. 따라서, 직원들은 반드시 9시부터 6시까지 회사에 있지 않아도 된다.각 직원은 자기가 원할 때 출근할 수 있고, 아무때나 퇴근할 수 있다.상근이는 모든 사람의 출입카드 시스템의 로그를 가지고 있다. 이 로그는 어떤 사람이 회사에 들어왔는지, 나갔는지가 기록되어져 있다. 로그가 주어졌을 때, 현재 회사에 있는 모든 사람을 구하는 프로그램을 작성하시오.입력첫째 줄에 로그에 기록된 출입 기록의 수 n이 주어진다. (2 ≤ n ≤ 106) 다음 n개의 줄에는 출입 기록이 순서대로 주어지며, 각 사람의 이름이 주어지고 “enter”나 “leave”가 주어진다. “enter”인 경우는 출근, “leave”인 경우는 퇴근이다.회사에는 동명이인이 없으며, 대소문자가 다른 경우에는 다른 이름이다. 사람들의 이름은 알파벳 대소문자로 구성된 5글자 이하의 문자열이다.출력현재 회사에 있는 사람의 이름을 사전 순의 역순으로 한 줄에 한 명씩 출력한다.답안Hash Table + Merge Sort#include &lt;stdio.h&gt;typedef unsigned long long int ull;#define MAX_TABLE (200009)#define MAX_NUM (110000)int n;struct people{ char name[6]; int inout; // 들어오면 1, 나가면 out};struct HASH{ people* db; HASH* next;};people total[1100000];people remain[1100000];people mergetemp[1100000];HASH hashtable[MAX_TABLE];HASH pool[MAX_TABLE];int pcnt;void mystrcpy(char* dst, char* src){ while (*dst++ = *src++);}int mystrcmp(char* dst, char* src){ while (*dst &amp;&amp; *dst == *src) { dst++; src++; } return *dst - *src;}void merge(int start, int end){ register int i, j, k, mid = (start + end) &gt;&gt; 1; i = k = start; j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= end) { // 사전의 역순으로 정렬 if (mystrcmp(remain[i].name, remain[j].name) &gt; 0) { mergetemp[k++] = remain[i++]; } else { mergetemp[k++] = remain[j++]; } } while (i &lt;= mid) { mergetemp[k++] = remain[i++]; } while(j &lt;= end) { mergetemp[k++] = remain[j++]; } for (register int a = start; a &lt;= end; a++) { remain[a] = mergetemp[a]; }}void sort(int start, int end){ if (start &gt;= end) return; register int mid = (start + end) &gt;&gt; 1; sort(start, mid); sort(mid + 1, end); merge(start, end);}ull hash(const char* str){ ull hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;}int main(){ scanf(\"%d\", &amp;n); char order[7]; char name[7]; register int cnt = 0; for (register int i = 0; i &lt; n; i++) { scanf(\"%s %s\", name, order); ull hn = hash(name); if (!mystrcmp(order, (char*)\"enter\")) { /* 등록 */ mystrcpy(total[cnt].name, name); total[cnt].inout = 1; HASH* nd = &amp;pool[pcnt++]; nd-&gt;db = &amp;total[cnt++]; nd-&gt;next = hashtable[hn].next; hashtable[hn].next = nd; } else { /* 제거 */ HASH* nd = hashtable[hn].next; while (nd) { // 이름이 있고 enter하고 out 한적이 없으면 if (!mystrcmp(nd-&gt;db-&gt;name, name) &amp;&amp; nd-&gt;db-&gt;inout) { // flag 를 사용해서 제거 표시를 해둔다. // 실제 노드를 제거하는게 아니기 때문에 탐색시간은 그대로 nd-&gt;db-&gt;inout = 0; break; } nd = nd-&gt;next; } } } register int rem_cnt = 0; for (register int i = 0; i &lt; cnt; i++) { if (total[i].inout) remain[rem_cnt++] = total[i]; } sort(0, rem_cnt - 1); for (register int i = 0; i &lt; rem_cnt; i++) { printf(\"%s\\n\", remain[i].name); } return 0;}" }, { "title": "영단어 암기는 괴로워", "url": "/posts/%EC%98%81%EB%8B%A8%EC%96%B4-%EC%95%94%EA%B8%B0%EB%8A%94-%EA%B4%B4%EB%A1%9C%EC%9B%8C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-12 00:00:00 +0900", "snippet": "문제화은이는 이번 영어 시험에서 틀린 문제를 바탕으로 영어 단어 암기를 하려고 한다. 그 과정에서 효율적으로 영어 단어를 외우기 위해 영어 단어장을 만들려 하고 있다. 화은이가 만들고자 하는 단어장의 단어 순서는 다음과 같은 우선순위를 차례로 적용하여 만들어진다.자주 나오는 단어일수록 앞에 배치한다.해당 단어의 길이가 길수록 앞에 배치한다.알파벳 사전 순으로 앞에 있는 단어일수록 앞에 배치한다 M보다 짧은 길이의 단어의 경우 읽는 것만으로도 외울 수 있기 때문에 길이가 $M$이상인 단어들만 외운다고 한다. 화은이가 괴로운 영단어 암기를 효율적으로 할 수 있도록 단어장을 만들어 주자.입력첫째 줄에는 영어 지문에 나오는 단어의 개수 $N$과 외울 단어의 길이 기준이 되는 $M$이 공백으로 구분되어 주어진다.둘째 줄부터 N+1번째 줄까지 외울 단어를 입력받는다. 이때의 입력은 알파벳 소문자로만 주어지며 단어의 길이는 10을 넘지 않는다.단어장에 단어가 반드시 1개 이상 존재하는 입력만 주어진다.출력화은이의 단어장에 들어 있는 단어를 단어장의 앞에 위치한 단어부터 한 줄에 한 단어씩 순서대로 출력한다.#include &lt;stdio.h&gt;#include &lt;stdio.h&gt;typedef unsigned long long int ull;#define MAX_TABLE (200009)#define MAX_NUM (110000)int N, M;struct HASH{ int id; char word[12]; HASH* next;};HASH hashtable[MAX_TABLE];HASH pool[MAX_TABLE];int pcnt;struct HEAP{ int id; // 들어온 순서 int count; // 단어 등장 횟수 int len; // 단어 길이 char* word; // HASHTABLE 포인터};HEAP heap[MAX_NUM];int heapidx[MAX_NUM]; // id 가 heap 어느 위치에 있는지 저장int hn;int mystrlen(char *word){ int len = 0; while (*word++) len++; return len;}void mystrcpy(char* dst, char* src){ while (*dst++ = *src++);}int mystrcmp(char * dst, char* src){ while (*dst &amp;&amp; *dst == *src) { src++; dst++; } return *dst - *src;}ull hash(const char* str){ ull hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;}//1. 자주 나오는 단어일수록 앞에 배치한다.//2. 해당 단어의 길이가 길수록 앞에 배치한다.//3. 알파벳 사전 순으로 앞에 있는 단어일수록 앞에 배치한다int priority_check(HEAP a, HEAP b){ if (a.count &gt; b.count) return 1; else if (a.count == b.count &amp;&amp; a.len &gt; b.len) return 1; else if (a.count == b.count &amp;&amp; a.len == b.len &amp;&amp; mystrcmp(a.word, b.word) &lt; 0) return 1; return 0;}HEAP pop(HEAP* haep, int&amp; hn, int* heapidx){ HEAP ret = heap[1], tmp; heap[1] = heap[hn]; heap[hn].count = -1; heap[hn--].len = -1; for (int i = 1; i * 2 &lt;= hn; ) { if (priority_check(heap[i], heap[i * 2]) &amp;&amp; priority_check(heap[i], heap[i * 2 + 1])) break; else if (priority_check(heap[i * 2], heap[i * 2 + 1])) { tmp = heap[i * 2]; heap[i * 2] = heap[i]; heap[i] = tmp; heapidx[heap[i].id] = i; heapidx[heap[i * 2].id] = i * 2; i = i * 2; } else { tmp = heap[i * 2 + 1]; heap[i * 2 + 1] = heap[i]; heap[i] = tmp; heapidx[heap[i].id] = i; heapidx[heap[i * 2 + 1].id] = i * 2 + 1; i = i * 2 + 1; } } return ret;}void push(HEAP* heap, int&amp; hn, int* heapidx, HEAP x){ HEAP tmp; heap[++hn] = x; heapidx[x.id] = hn; for (int i = hn; i &gt; 1; i /= 2) { // 부모노드가 더 크면 break if (priority_check(heap[i / 2], heap[i])) break; tmp = heap[i / 2]; heap[i / 2] = heap[i]; heap[i] = tmp; //heapidx (id 가 heap 어느 위치에 있는지 저장) 업데이트 heapidx[heap[i].id] = i; heapidx[heap[i / 2].id] = i / 2; }}// 등록된 단어인지 체크int check_exist(char* word, ull h){ HASH* nd = hashtable[h].next; for (HASH* hp = nd; hp; hp = hp-&gt;next) { if (!mystrcmp(hp-&gt;word, word)) return hp-&gt;id; } return 0;}//id가 있는 경우는 update로 id를 넘겨줘서 heap에서 직접 count를 증가void update_heap(HEAP* heap, int&amp; hn, int id, int* heapIdx){ HEAP tmp; int uhn = heapidx[id]; heap[uhn].count++; // 필요한 경우 해당 heap idx 부터 swap 시작 for (int i = uhn; i &gt; 1; i /= 2) { if (priority_check(heap[i / 2], heap[i])) break; tmp = heap[i / 2]; heap[i / 2] = heap[i]; heap[i] = tmp; heapidx[heap[i].id] = i; heapidx[heap[i / 2].id] = i / 2; }}int main(){ scanf(\"%d %d\", &amp;N, &amp;M); char str[12]; int id = 1; for (int i = 0; i &lt; N; i++) { scanf(\"%s\", str); int strlen = mystrlen(str); if (strlen &lt; M) continue; ull lhn = hash(str); int checkid = check_exist(str, lhn); // id가 있으면 update if (checkid) update_heap(heap, hn, checkid, heapidx); else // 없다면 추가 { HASH* h = &amp;pool[pcnt++]; h-&gt;id = id; mystrcpy(h-&gt;word, str); h-&gt;next = hashtable[lhn].next; hashtable[lhn].next = h; HEAP lheap; lheap.count = 1; lheap.id = id++; lheap.len = strlen; lheap.word = h-&gt;word; push(heap, hn, heapidx, lheap); } } while (hn) { HEAP lheap = pop(heap, hn, heapidx); printf(\"%s\\n\", lheap.word); } return 0;}" }, { "title": "듣보잡", "url": "/posts/%EB%93%A3%EB%B3%B4%EC%9E%A1/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-10 00:00:00 +0900", "snippet": "듣보잡문제김진영이 듣도 못한 사람의 명단과, 보도 못한 사람의 명단이 주어질 때, 듣도 보도 못한 사람의 명단을 구하는 프로그램을 작성하시오.입력첫째 줄에 듣도 못한 사람의 수 N, 보도 못한 사람의 수 M이 주어진다. 이어서 둘째 줄부터 N개의 줄에 걸쳐 듣도 못한 사람의 이름과, N+2째 줄부터 보도 못한 사람의 이름이 순서대로 주어진다. 이름은 띄어쓰기 없이 알파벳 소문자로만 이루어지며, 그 길이는 20 이하이다. N, M은 500,000 이하의 자연수이다.듣도 못한 사람의 명단에는 중복되는 이름이 없으며, 보도 못한 사람의 명단도 마찬가지이다.출력듣보잡의 수와 그 명단을 사전순으로 출력한다.답안Hash Table + Merge Sort#include &lt;stdio.h&gt;#define MAX_TABLE (1000007)typedef unsigned long long int ull;struct NODE{ char name[21]; NODE* next;};int N, M;NODE pool[550000];NODE hashtable[MAX_TABLE];char* strlist[550000];char* tmpstrlist[550000];int pcnt, listcnt;void init(){ for(register int i = 0; i &lt; MAX_TABLE; i++) hashtable[i].next = 0; pcnt = listcnt = 0; }void mystrcpy(char* dst, char* src){ while(*dst++ = *src++);}int mystrcmp(char* dst,char* src){ while(*dst &amp;&amp; *dst == *src) { dst++; src++; } return *dst - *src;}ull hash(const char *str){\tull hash = 5381;\tint c;\twhile (c = *str++)\t{\t\thash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE;\t}\treturn hash % MAX_TABLE;}void merge(int start, int end){ int i, j, k, mid = (end + start) &gt;&gt; 1; i = k = start; j = mid + 1; while(i &lt;= mid &amp;&amp; j &lt;= end) { if(mystrcmp(strlist[i], strlist[j]) &lt; 0) { tmpstrlist[k++] = strlist[i++]; } else { tmpstrlist[k++] = strlist[j++]; } } while(i &lt;= mid) tmpstrlist[k++] = strlist[i++]; while(j &lt;= end) tmpstrlist[k++] = strlist[j++]; for(register int x = start; x &lt;= end; x++) { strlist[x] = tmpstrlist[x]; }}void sort(int start, int end){ if(start &gt;= end) return; int mid = (end + start) &gt;&gt; 1; sort(start, mid); sort(mid+1, end); merge(start, end);}int main(){ char str[21]; scanf(\"%d %d\", &amp;N, &amp;M); for(register int i = 0; i &lt; N; i++) { NODE *nd = &amp;pool[pcnt++]; scanf(\"%s\", str); ull hashval = hash(str); mystrcpy(nd-&gt;name, str); nd-&gt;next = hashtable[hashval].next; hashtable[hashval].next = nd; } for(register int i = 0; i &lt; M; i++) { scanf(\"%s\", str); ull hashval = hash(str); for(NODE *p = hashtable[hashval].next; p != NULL; p = p-&gt;next) { if(!mystrcmp(p-&gt;name, str)) { strlist[listcnt++] = p-&gt;name; } } } sort(0, listcnt - 1); printf(\"%d\\n\", listcnt); for(register int i = 0; i &lt; listcnt; i++) { printf(\"%s\\n\", strlist[i]); } return 0;}" }, { "title": "이분 그래프", "url": "/posts/%EC%9D%B4%EB%B6%84-%EA%B7%B8%EB%9E%98%ED%94%84/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-07 00:00:00 +0900", "snippet": "이분 그래프그래프의 정점의 집합을 둘로 분할하여, 각 집합에 속한 정점끼리는 서로 인접하지 않도록 분할할 수 있을 때, 그러한 그래프를 특별히 이분 그래프 (Bipartite Graph) 라 부른다.그래프가 입력으로 주어졌을 때, 이 그래프가 이분 그래프인지 아닌지 판별하는 프로그램을 작성하시오.결론 : 두 개의 영역으로 나눠지고 각 영역안의 노드들은 서로 연결되지 않아야한다.(다른 영역 노드끼리는 연결 가능)답안DFS 풀이#include &lt;stdio.h&gt;#define ARR_MAX 21000int K, V, E;struct NODE{\tint x;\tNODE* next;};NODE head[ARR_MAX];NODE pool[ARR_MAX * 100];int pcnt;int check[ARR_MAX];void init(){\tpcnt = 0;\tfor (int i = 1; i &lt;= V; i++)\t{\t\thead[i].next = 0;\t\tcheck[i] = 0;\t}}void add_node(int key, int value){\tNODE* nd = &amp;pool[pcnt++];\tnd-&gt;x = value;\tnd-&gt;next = head[key].next;\thead[key].next = nd;}int dfs(int key, int value){\t// value 값을 기준으로 이분이 가능한지 판단한다.\tcheck[key] = value;\tfor (NODE* p = head[key].next; p != NULL; p = p-&gt;next)\t{\t\t// 같은 집합일 때 (색칠 되어있을 때)\t\tif (check[p-&gt;x] == value)\t\t\treturn 0;\t\t//색칠 안되어있을 때\t\tif (check[p-&gt;x] == 0)\t\t{\t\t\t/* 두 개의 색 값을 각각 2, 3로 표현할 때*/\t\t\t/* 5 - 3 = 2 &lt;-&gt; 5 - 2 = 3 */\t\t\tif (!dfs(p-&gt;x, 3 - value)) \t\t\t\treturn 0;\t\t}\t}\treturn 1;}int main(){\tscanf(\"%d\", &amp;K);\tfor (int i = 0; i &lt; K; i++)\t{\t\tint flag = 0;\t\tscanf(\"%d %d\", &amp;V, &amp;E);\t\tinit();\t\tfor (int j = 0; j &lt; E; j++)\t\t{\t\t\tint a, b;\t\t\tscanf(\"%d %d\", &amp;a, &amp;b);\t\t\tadd_node(a, b);\t\t\tadd_node(b, a);\t\t}\t\tflag = 0;\t\tfor (int j = 1; j &lt;= V; j++)\t\t{\t\t\tif (!check[j])\t\t\t{\t\t\t\tflag = dfs(j, 2);\t\t\t\tif (!flag) \t\t\t\t\tbreak;\t\t\t}\t\t}\t\tif (!flag)\t\t\tprintf(\"NO\\n\");\t\telse\t\t\tprintf(\"YES\\n\");\t}\treturn 0;}BFS 풀이" }, { "title": "해시 테이블 문제", "url": "/posts/%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%AC%B8%EC%A0%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-06 00:00:00 +0900", "snippet": "해시 테이블나는야 포켓몬 마스터 이다솜(해시 테이블 * 링크드 리스트)입력첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음… 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!출력첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~답안#include &lt;stdio.h&gt;#define MAX_TABLE (10007)typedef unsigned long long int ull;int N, M;struct NODE{ int index; char name[21];//최대길이 20 NODE* next;};NODE hash_table[MAX_TABLE]; // 포켓몬 도감NODE pool[105000]; // 포켓몬이름 -&gt; 숫자int pcnt;NODE arr[105000]; // 숫자 -&gt; 포켓몬 이름 void init(){ for (int i = 0; i &lt; MAX_TABLE; i++) { hash_table[i].next = 0; }}unsigned long hash(const char* str){ unsigned long hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;}//먼저 hello 라는 문자열 배열의 주소값을* src 라는 포인터 변수에 저장한다.////증감연산자 ++이 변수 뒤에 붙어있으므로, 먼저 대입이 이뤄진 후 변수의 값이 증가한다.////c언어에서 대입연산자(= )는 값을 반환한다.즉, * dst++ = *src++ 은 true 를 반환하므로, while 내부에 있으면 while 문이 계속 돌아간다.////* src배열의 첫번째 값이* dst 에 대입되고(h가 복사되고)//src와 dst 의 값이 증감 연산자로 1씩 증가하고(증가하는건 문자열이 아니라, 문자열이 저장된 주소값이 증가한다)//첫번째 값의 바로 옆 주소에는 다음 문자열이 저장되어 있으니//h 다음의 문자열인 e 가 dst 로 복사된다.//null 문자는 false 이므로, 문자열의 마지막자리에 있는 null 문자(\\0)를 만날때까지 while 문이 반복된다.void mystrcpy(char* dst, const char* src){ while (*dst++ = *src++);}int mystrcmp(const char* dst, const char* src){ //dst의 값과 src의 값이 null이 아니고 같으면 반복 while (*dst &amp;&amp; *dst == *src) { ++dst; ++src; } // 완전히 동일하면 0 return return *dst - *src;}void add_node(int key, int value){ NODE* nd = &amp;pool[pcnt++]; nd-&gt;index = value; nd-&gt;next = hash_table[key].next; hash_table[key].next = nd;}int ctoi(char* str){ int i, ret = 0, len, mul = 1; for (i = 0; str[i]; i++); len = i; for (i = len - 1; i &gt;= 0; i--) { ret += mul * (str[i] - '0'); mul *= 10; } return ret;}int main(){ char str[21]; // N 포켓몬 이름, M 맞춰야할 문제 scanf(\"%d %d\", &amp;N, &amp;M); // hashing 수행 for (int i = 1; i &lt;= N; i++) { scanf(\"%s\", str); ull hn = hash(str); NODE* nd = &amp;pool[pcnt++]; nd-&gt;index = i; mystrcpy(nd-&gt;name, str); nd-&gt;next = hash_table[hn].next; hash_table[hn].next = nd; mystrcpy(arr[i].name, str); } for (int i = 0; i &lt; M; i++) { scanf(\"%s\", str); // 숫자로 들어오는경우 포켓몬 이름 if (str[0] &gt;= '0' &amp;&amp; str[0] &lt;= '9') { int index = ctoi(str); printf(\"%s\\n\", arr[index].name); } // 알파벳으로 들어오는 경우 포켓몬 번호 else { ull hn = hash(str); NODE* nd = hash_table[hn].next; while (nd) { if (!mystrcmp(nd-&gt;name, str)) { printf(\"%d\\n\", nd-&gt;index); break; } nd = nd-&gt;next; } } } return 0;} Maximum Word Frequency문제Term frequency–Inverse document frequency (tf-idf) is a numerical statistic which reflects the importance of words in a document collection. It is often used in information retrieval system. The number of times a word appears in the document (word frequency) is one of the major factors to acquire tf-idf.You are asked to write a program to find the most frequent word in a document.입력The first line contains an integer n (1≤ n ≤ 1000) which determines the number of words. The following n lines include the list of words, one word per line. A word contains only lower-case letters and it can contain up to 20 characters.출력Print out the word that has the highest frequency and its frequency, separated by a single space. If you get more than 2 results, choose only the one that comes later in the lexicographical order. =&gt; 가장 빈도수가 많은 단어와 횟수를 출력하고, 1등이 여러 단어일 땐 사전순으로 출력하라답안#include &lt;stdio.h&gt;typedef unsigned long ul;#define MAX_TABLE (1007)#define MAX_WORD (20 + 5)struct NODE{ int count; char word[MAX_WORD]; NODE* next;};NODE pool[MAX_TABLE];NODE hashtable[MAX_TABLE];int pcnt;int n;ul hash(const char* str){ ul hash = 5381; int c; while (c = *str++) { hash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE; } return hash % MAX_TABLE;}void mystrcpy(char* dst, char* src){ while (*dst++ = *src++);}int mystrcmp(char* dst, char* src){ while (*dst &amp;&amp; *dst == *src) { dst++; src++; } return *dst - *src;}void add_word(char* word){ ul hn = hash(word); NODE* nd = &amp;pool[pcnt++]; nd-&gt;count = 1; mystrcpy(nd-&gt;word, word); nd-&gt;next = hashtable[hn].next; hashtable[hn].next = nd;}int is_exist(char * word){ ul hn = hash(word); for (NODE* p = hashtable[hn].next; p != NULL; p = p-&gt;next) { if (mystrcmp(p-&gt;word, word) == 0) { if (p-&gt;count &gt; 0) p-&gt;count++; return 1; } } return 0;}int main(){ int max_count = 0; char ans_word[MAX_WORD]; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { // hash table 에 추가 or 단순 count 증가 char str[MAX_WORD]; scanf(\"%s\", str); ul hn = hash(str); if (is_exist(str) == 0) { add_word(str); } } for (int i = 0; i &lt; MAX_TABLE; i++) { for (NODE* p = hashtable[i].next; p; p = p-&gt;next) { if (max_count &lt;= p-&gt;count) { max_count = p-&gt;count; //p-&gt;word 가 사전적 순서로 더 뒤에있는 문자이면 복사 if (mystrcmp(ans_word, p-&gt;word) &lt; 0) { mystrcpy(ans_word, p-&gt;word); } } } } printf(\"%s %d\\n\", ans_word, max_count); return 0;}" }, { "title": "해시 테이블 문제 (2차원 배열 탐색)", "url": "/posts/%ED%95%B4%EC%8B%9C-%EC%9D%91%EC%9A%A9-%EB%AC%B8%EC%A0%9C(2%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4-%ED%83%90%EC%83%89)/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-06 00:00:00 +0900", "snippet": "해시 테이블 문제 (2차원 배열 탐색)전체 2차원 배열에서 부분 2차원 배열 조각 패턴이 얼마나 있는지 탐색하는 문제#include &lt;stdio.h&gt;unsigned int hashmap[15][15];int N = 15;int M = 4;bool flag = true;char MAP[15][15] ={\t{ 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, },\t{ 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, },\t{ 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, },\t{ 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, },\t{ 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, },\t{ 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, },\t{ 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, },\t{ 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, },\t{ 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, },\t{ 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, },\t{ 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, },\t{ 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, },\t{ 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, },\t{ 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, },\t{ 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, },};char piece1[4][4] ={\t{ 1, 0, 0, 1, },\t{ 0, 1, 0, 0, },\t{ 0, 0, 1, 0, },\t{ 0, 0, 0, 1, },};char piece2[4][4] ={\t{ 1, 1, 0, 1, },\t{ 0, 0, 1, 0, },\t{ 0, 1, 0, 0, },\t{ 1, 0, 0, 0, },};char piece3[4][4] ={\t{ 1, 0, 0, 0, },\t{ 0, 1, 0, 1, },\t{ 0, 0, 1, 0, },\t{ 0, 1, 0, 0, },};// 서로 다른 크기의 배열을 호환시키기 위해 #define으로 매크로함수를 선언한다.// //#define gethash(arr, r, c) (((ui)arr[r + 0][c + 0] &lt;&lt; 15) | (ui)(arr[r + 0][c + 1] &lt;&lt; 14) | (ui)(arr[r + 0][c + 2] &lt;&lt; 13) | (ui)(arr[r + 0][c + 3] &lt;&lt; 12) | \\//\t\t\t\t\t\t\t((ui)arr[r + 1][c + 0] &lt;&lt; 11) | (ui)(arr[r + 1][c + 1] &lt;&lt; 10) | (ui)(arr[r + 1][c + 2] &lt;&lt; 9) | (ui)(arr[r + 1][c + 3] &lt;&lt; 8) | \\//\t\t\t\t\t\t ((ui)arr[r + 2][c + 0] &lt;&lt; 7) | (ui)(arr[r + 2][c + 1] &lt;&lt; 6) | (ui)(arr[r + 2][c + 2] &lt;&lt; 5) | (ui)(arr[r + 2][c + 3] &lt;&lt; 4) | \\//\t\t\t\t\t\t ((ui)arr[r + 3][c + 0] &lt;&lt; 3) | (ui)(arr[r + 3][c + 1] &lt;&lt; 2) | (ui)(arr[r + 3][c + 2] &lt;&lt; 1) | (ui)(arr[r + 3][c + 3]))unsigned int gethash(char (*arr)[15], int y, int x){\tunsigned int answer = ((unsigned int)arr[y][x] &lt;&lt; 15) | ((unsigned int)arr[y][x + 1] &lt;&lt; 14) | ((unsigned int)arr[y][x + 2] &lt;&lt; 13) | ((unsigned int)arr[y][x + 3] &lt;&lt; 12) | \\\t\t\t\t\t\t\t((unsigned int)arr[y + 1][x] &lt;&lt; 11) | ((unsigned int)arr[y + 1][x + 1] &lt;&lt; 10) | ((unsigned int)arr[y + 1][x + 2] &lt;&lt; 9) | ((unsigned int)arr[y + 1][x + 3] &lt;&lt; 8) | \\\t\t\t\t\t\t\t((unsigned int)arr[y + 2][x] &lt;&lt; 7) | ((unsigned int)arr[y + 2][x + 1] &lt;&lt; 6) | ((unsigned int)arr[y + 2][x + 2] &lt;&lt; 5) | ((unsigned int)arr[y + 2][x + 3] &lt;&lt; 4) | \\\t\t\t\t\t\t\t((unsigned int)arr[y + 3][x] &lt;&lt; 3) | ((unsigned int)arr[y + 3][x + 1] &lt;&lt; 2) | ((unsigned int)arr[y + 3][x + 2] &lt;&lt; 1) | ((unsigned int)arr[y + 3][x + 3]);\treturn answer;}unsigned int gethash_piece(char(*arr)[4], int y, int x){\tunsigned int answer = ((unsigned int)arr[y][x] &lt;&lt; 15) | ((unsigned int)arr[y][x + 1] &lt;&lt; 14) | ((unsigned int)arr[y][x + 2] &lt;&lt; 13) | ((unsigned int)arr[y][x + 3] &lt;&lt; 12) | \\\t\t((unsigned int)arr[y + 1][x] &lt;&lt; 11) | ((unsigned int)arr[y + 1][x + 1] &lt;&lt; 10) | ((unsigned int)arr[y + 1][x + 2] &lt;&lt; 9) | ((unsigned int)arr[y + 1][x + 3] &lt;&lt; 8) | \\\t\t((unsigned int)arr[y + 2][x] &lt;&lt; 7) | ((unsigned int)arr[y + 2][x + 1] &lt;&lt; 6) | ((unsigned int)arr[y + 2][x + 2] &lt;&lt; 5) | ((unsigned int)arr[y + 2][x + 3] &lt;&lt; 4) | \\\t\t((unsigned int)arr[y + 3][x] &lt;&lt; 3) | ((unsigned int)arr[y + 3][x + 1] &lt;&lt; 2) | ((unsigned int)arr[y + 3][x + 2] &lt;&lt; 1) | ((unsigned int)arr[y + 3][x + 3]);\treturn answer;}int findPiece(char MAP[][15], char piece[][4]){\tint cnt = 0;\tint boundary = N - M;\tif (flag)\t{\t\t\t\tfor (int i = 0; i &lt;= boundary; i++)\t\t{\t\t\tfor (int j = 0; j &lt;= boundary; j++)\t\t\t{\t\t\t\thashmap[i][j] = gethash(MAP, i, j);\t\t\t}\t\t}\t\tflag = false;\t}\tint targethash = gethash_piece(piece, 0, 0);\tfor (int i = 0; i &lt;= boundary; i++)\t{\t\tfor (int j = 0; j &lt;= boundary; j++)\t\t{\t\t\tif (hashmap[i][j] == targethash)\t\t\t\tcnt++;\t\t}\t}\treturn cnt;}int main(void){\tfor (register int tc = 0; tc &lt; 1; tc++)\t{\t\tif (findPiece(MAP, piece1) != 5) \t\t\tprintf(\"wrong!\\n\");\t\telse\t\t\tprintf(\"true!\\n\");\t\tif (findPiece(MAP, piece2) != 3)\t\t\tprintf(\"wrong!\\n\");\t\telse\t\t\tprintf(\"true!\\n\");\t\tif (findPiece(MAP, piece3) != 3)\t\t\tprintf(\"wrong!\\n\");\t\telse\t\t\tprintf(\"true!\\n\");\t}\tprintf(\"pass\\n\");\treturn 0;} " }, { "title": "우선순위 큐 문제", "url": "/posts/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90-%EB%AC%B8%EC%A0%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-06 00:00:00 +0900", "snippet": "우선순위 큐 문제최소힙 문제답안#include &lt;stdio.h&gt;#define ARR_MAX 100001int heap[ARR_MAX];int hn;int N;int pop(int* heap, int&amp; hn){\tregister int tmp, ret;\t//1) pop의 return값 heap[1]을 기억해둔다.\tret = heap[1];\t//2) heap의 배열에서 가장 끝에 값, 즉 heap[hn]을 heap[1]로 변경한다.\theap[1] = heap[hn];\t//3) heap[hn]은 최악의 우선순위값(최소힙이므로 0x7fff0000 정도의 큰 값)으로 변경해둔다.\t//4) heap이 1개 줄었으므로 hn 을 1 감소 시킨다.\theap[hn--] = 0x7fff0000;\tfor (register int i = 1; i * 2 &lt;= hn;)\t{\t\t// 자식노드가 더 크면 pass // 종료조건 heap을 만족할 경우\t\tif (heap[i] &lt; heap[i * 2] &amp;&amp; heap[i] &lt; heap[i * 2 + 1])\t\t\tbreak;\t\t// 자식노드가 부모노드보다 크고, 오른쪽 자식노드가 더 크면 왼쪽 자식노드와 부모노드 교환\t\telse if (heap[i * 2] &lt; heap[i * 2 + 1])\t\t{\t\t\ttmp = heap[i * 2];\t\t\theap[i * 2] = heap[i];\t\t\theap[i] = tmp;\t\t\ti = i * 2;\t\t}\t\t// 자식노드가 부모노드보다 크고, 왼쪽 자식노드가 더 크면 오른쪽 자식노드와 부모노드 교환\t\telse\t\t{\t\t\ttmp = heap[i * 2 + 1];\t\t\theap[i * 2 + 1] = heap[i];\t\t\theap[i] = tmp;\t\t\ti = i * 2 + 1;\t\t}\t}\treturn ret;}//heap은 eap은 부모 자식 간에만 우선순위를 만족해주기만 하면 되기 때문에 다른 자식노드들끼리의 우선순위 순서는 틀릴 수 있다.void push(int* heap, int&amp; hn, int x){\tregister int tmp;\t//모든 i에 대해서 자식 node는 i * 2, i * 2 + 1이 되고,\t//부모 node는 i / 2로 하면 된다. // hn = 0이므로 hn을 먼저 1로 만들어주고 값을 넣는다.\theap[++hn] = x;\tfor (register int i = hn; i &gt; 1; i /= 2)\t{ // 종료조건 heap을 만족할 경우\t\t// 자식 노드가 더 크면 pass\t\tif (heap[i / 2] &lt;= heap[i]) \t\t\tbreak;\t\t// 아니면 조상 &lt;-&gt; 부모 &lt;-&gt; 자식 노드간에 교환을 반복해서 수행한다. (부모노드가 자식노드보다 작을때까지)\t\t// 부모 노드와 자식 노드와의 교환\t\ttmp = heap[i / 2];\t\theap[i / 2] = heap[i];\t\theap[i] = tmp;\t}}int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint x;\t\tscanf(\"%d\", &amp;x);\t\tif (x)\t\t{\t\t\tpush(heap, hn, x);\t\t}\t\telse\t\t{\t\t\tif (hn)\t\t\t{\t\t\t\tprintf(\"%d\\n\", pop(heap, hn));\t\t\t}\t\t\t// 큐가 비어있는 경우\t\t\telse\t\t\t{\t\t\t\tprintf(\"0\\n\");\t\t\t}\t\t}\t}\treturn 0;} 최대 힙 문제최대힙에서 크게 바뀌는 부분은 다음과 같다. 부모노드 자식노드 크기 비교 부등호 관계 heap 마지막 노드에 최대 힙이므로 최소값 저장#include &lt;stdio.h&gt;#define ARR_MAX 100001int N, hn;int heap[ARR_MAX];void push(int* heap, int&amp; hn, int x){\tint tmp; // hn = 0이므로 hn을 먼저 1로 만들어주고 값을 넣는다.\theap[++hn] = x;\t// bottom-up\tfor (int i = hn; i &gt; 1; i/=2)\t{ // 종료조건 heap을 만족할 경우\t\t// 부모노드가 자식노드보다 크면 break;\t\tif (heap[i] &lt;= heap[i / 2])\t\t\tbreak;\t\ttmp = heap[i / 2];\t\theap[i / 2] = heap[i];\t\theap[i] = tmp;\t}}int pop(int* heap, int&amp; hn){\tint tmp, ret = heap[1];\theap[1] = heap[hn]; // 자연수가 입력되므로 최소값으로 -1 저장\theap[hn--] = -1;\t// 자식노드를 훑어가며 저장\t// top-down\tfor (int i = 1; i * 2 &lt;= hn;)\t{ // 종료조건 heap을 만족할 경우\t\tif (heap[i] &gt; heap[i * 2] &amp;&amp; heap[i] &gt; heap[i * 2 + 1])\t\t\tbreak;\t\telse if (heap[i * 2] &gt; heap[i * 2 + 1])\t\t{\t\t\ttmp = heap[i * 2];\t\t\theap[i * 2] = heap[i];\t\t\theap[i] = tmp;\t\t\ti = i * 2;\t\t}\t\telse\t\t{\t\t\ttmp = heap[i * 2 + 1];\t\t\theap[i * 2 + 1] = heap[i];\t\t\theap[i] = tmp;\t\t\ti = i * 2 + 1;\t\t}\t}\treturn ret;}int main(void){\tscanf(\"%d\", &amp;N);\t\tfor (int i = 0; i &lt; N; i++)\t{\t\tint x;\t\tscanf(\"%d\", &amp;x);\t\tif (x)\t\t{\t\t\tpush(heap, hn, x);\t\t}\t\t// 결과 출력\t\telse\t\t{\t\t\tif (hn)\t\t\t{\t\t\t\tprintf(\"%d\\n\", pop(heap, hn));\t\t\t}\t\t\t// 힙이 비었을 경우 0 출력\t\t\telse\t\t\t{\t\t\t\tprintf(\"0\\n\");\t\t\t}\t\t}\t}\treturn 0;}절대값 힙 문제#include &lt;stdio.h&gt;#define ARR_MAX 100001int N, hn;int heap[ARR_MAX];int abs(int x){\tint ret = (x &gt; 0) ? x : -x;\treturn ret;}// 비교함수를 만들어 놓는게 좋다.// 1) 절댓값이 가장 작으면 우선순위가 높다.// 2) 같은 절댓값인 경우는 음수가 우선순위가 높다.int compare(int a, int b){\tif (abs(a) &lt; abs(b))\t\treturn 1;\tif (abs(a) == abs(b) &amp;&amp; (a &lt; b))\t\treturn 1;\treturn 0;}void push(int* arr, int&amp; hn, int x){\tarr[++hn] = x;\tfor (register int i = hn; i &gt; 1; i /= 2)\t{\t\t// 자식노드가 더 크면\t\tif (compare(arr[i / 2], arr[i]))\t\t\tbreak;\t\tint tmp = arr[i];\t\tarr[i] = arr[i / 2];\t\tarr[i / 2] = tmp;\t}}int pop(int* arr, int &amp;hn){\tint tmp, ret = arr[1];\tarr[1] = arr[hn];\tarr[hn--] = 0x7fff0000;\tfor (register int i = 1; i * 2 &lt;= hn;)\t{\t\t// 자식노드가 더 크면\t\tif (compare(arr[i], arr[i * 2]) &amp;&amp; compare(arr[i], arr[i * 2 + 1]))\t\t\tbreak;\t\t// 부모노드가 더크면 두 자식 노드 중 더 작은 자식 노드 값과 부모 노드 값 교환\t\telse if (compare(arr[i * 2], arr[i * 2 + 1]))\t\t{\t\t\ttmp = arr[i];\t\t\tarr[i] = arr[i * 2];\t\t\tarr[i * 2] = tmp;\t\t\ti *= 2;\t\t}\t\telse\t\t{\t\t\ttmp = arr[i];\t\t\tarr[i] = arr[i * 2 + 1];\t\t\tarr[i * 2 + 1] = tmp;\t\t\ti = i * 2 + 1;\t\t}\t\t\t}\treturn ret;}int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint x;\t\tscanf(\"%d\", &amp;x);\t\tif (x)\t\t{\t\t\tpush(heap, hn, x);\t\t}\t\t// 결과 출력\t\telse\t\t{\t\t\tif (hn)\t\t\t{\t\t\t\tprintf(\"%d\\n\", pop(heap, hn));\t\t\t}\t\t\t// 힙이 비었을 경우 0 출력\t\t\telse\t\t\t{\t\t\t\tprintf(\"0\\n\");\t\t\t}\t\t}\t}\treturn 0;}우선순위 큐 두개 활용 문제백준이는 동생에게 “가운데를 말해요” 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.입력첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.출력한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.#include &lt;stdio.h&gt;int N;int maxheap[110000];int minheap[110000];int minhn, maxhn;int max_pop(int* arr, int &amp;hn){\tint tmp, ret = arr[1];\tarr[1] = arr[hn];\tarr[hn--] = -10001;\tfor (register int i = 1; i * 2 &lt;= hn; )\t{\t\tif (arr[i] &gt; arr[i * 2] &amp;&amp; arr[i] &gt; arr[i * 2 + 1])\t\t\tbreak;\t\telse if (arr[i * 2] &gt; arr[i * 2 + 1])\t\t{\t\t\ttmp = arr[i * 2];\t\t\tarr[i * 2] = arr[i];\t\t\tarr[i] = tmp;\t\t\ti *= 2;\t\t}\t\telse\t\t{\t\t\ttmp = arr[i * 2 + 1];\t\t\tarr[i * 2 + 1] = arr[i];\t\t\tarr[i] = tmp;\t\t\ti = i * 2 + 1;\t\t}\t}\treturn ret;}int min_pop(int* arr, int&amp; hn){\tint tmp, ret = arr[1];\tarr[1] = arr[hn];\tarr[hn--] = 10001;\tfor (register int i = 1; i * 2 &lt;= hn; )\t{\t\tif (arr[i] &lt; arr[i * 2] &amp;&amp; arr[i] &lt; arr[i * 2 + 1])\t\t\tbreak;\t\telse if (arr[i * 2] &lt; arr[i * 2 + 1])\t\t{\t\t\ttmp = arr[i * 2];\t\t\tarr[i * 2] = arr[i];\t\t\tarr[i] = tmp;\t\t\ti *= 2;\t\t}\t\telse\t\t{\t\t\ttmp = arr[i * 2 + 1];\t\t\tarr[i * 2 + 1] = arr[i];\t\t\tarr[i] = tmp;\t\t\ti = i * 2 + 1;\t\t}\t}\treturn ret;}void max_push(int* arr, int&amp; hn, int x){\tregister int tmp;\tarr[++hn] = x;\tfor (register int i = hn; i &gt; 1; i /= 2)\t{\t\t// 부모노드가 자식노드 보다 크면\t\tif (arr[i] &lt; arr[i / 2])\t\t\tbreak;\t\ttmp = arr[i];\t\tarr[i] = arr[i / 2];\t\tarr[i / 2] = tmp;\t}}void min_push(int* arr, int&amp; hn, int x){\tregister int tmp;\tarr[++hn] = x;\tfor (register int i = hn; i &gt; 1; i /= 2)\t{\t\t// 자식노드가 부모노드 보다 크면\t\tif (arr[i] &gt; arr[i / 2])\t\t\tbreak;\t\ttmp = arr[i];\t\tarr[i] = arr[i / 2];\t\tarr[i / 2] = tmp;\t}}int main(){\tint x;\tscanf(\"%d\", &amp;N);\t// 첫값은 먼저 넣어주고 시작\tscanf(\"%d\", &amp;x);\tmin_push(minheap, minhn, x);\tprintf(\"%d\\n\", x);\tfor (register int i = 1; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;x);\t\t//작은 값의 절반을 최대 힙, 큰 값의 절반을 최소 힙으로 넣어야 한다\t\t// 최소힙에 넣을 순서\t\t// 짝수개의 경우 maxheap[1] 이 중간값이 되고 홀수개의 경우 minheap[1] 값이 중간 값이 된다.\t\tif (maxhn == minhn)\t\t{\t\t\tif (x &lt; maxheap[1]) // 들어온 값이 최대 힙보다 작은 경우,\t\t\t{\t\t\t\t// 최대힙 최상단 노드를 최소 힙에 넣고 \t\t\t\tmin_push(minheap, minhn, max_pop(maxheap, maxhn));\t\t\t\t// 최대힙에 값을 채운다.\t\t\t\tmax_push(maxheap, maxhn, x);\t\t\t}\t\t\telse\t\t\t{\t\t\t\t//아니면 그냥 최소힙에 넣기\t\t\t\tmin_push(minheap, minhn, x);\t\t\t}\t\t\t// 값을 하나 넣고 홀수개가 됐으므로 minheap[1] 이 중간값\t\t\tprintf(\"%d\\n\", minheap[1]);\t\t}\t\t// 최대힙에 넣을 순서\t\telse\t\t{\t\t\tif (x &gt; minheap[1]) // 들어온 값이 최소 힙보다 큰 경우,\t\t\t{\t\t\t\t// 최소힙 최상단 노드를 최대 힙에 넣고 \t\t\t\tmax_push(maxheap, maxhn, min_pop(minheap, minhn));\t\t\t\t// 최소힙에 값을 채운다.\t\t\t\tmin_push(minheap, minhn, x);\t\t\t}\t\t\telse\t\t\t{\t\t\t\t//아니면 그냥 최대힙에 넣기\t\t\t\tmax_push(maxheap, maxhn, x);\t\t\t}\t\t\t// 값을 하나 넣고 홀수개가 됐으므로 maxheap[1] 이 중간값\t\t\tprintf(\"%d\\n\", maxheap[1]);\t\t}\t}\treturn 0;}" }, { "title": "삼성 SW 역량 테스트 B형 Reference 코드", "url": "/posts/%EC%82%BC%EC%84%B1-SW-%EC%97%AD%EB%9F%89-%ED%85%8C%EC%8A%A4%ED%8A%B8-B%ED%98%95-Reference-%EC%BD%94%EB%93%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-02 00:00:00 +0900", "snippet": "삼성 SW 역량 테스트 B형 Reference 코드Hash 코드Hash의 hashing 함수unsigned long hash(const char *str){\tunsigned long hash = 5381;\tint c;\twhile (c = *str++)\t{\t\thash = (((hash &lt;&lt; 5) + hash) + c) % MAX_TABLE;\t}\treturn hash % MAX_TABLE;}Merge Sort정렬된 배열 merge하기#include &lt;stdio.h&gt;#define ARR_MAX 110int b[ARR_MAX];int marr[ARR_MAX];void merge(int* arr, int start, int end){\tint mid, i, j, k;\tmid = (start + end) &gt;&gt; 1;\ti = k = start;\tj = mid + 1;\twhile (i &lt;= mid &amp;&amp; j &lt;= end)\t{\t\tif (arr[i] &lt; arr[j])\t\t{\t\t\tmarr[k++] = arr[i++];\t\t}\t\telse\t\t{\t\t\tmarr[k++] = arr[j++];\t\t}\t}\twhile (i &lt;= mid)\t{\t\tmarr[k++] = arr[i++];\t}\t\t\twhile (j &lt;= end)\t{\t\tmarr[k++] = arr[j++];\t}\tfor (int i = start; i &lt;= end; i++)\t{\t\tarr[i] = marr[i];\t}}void sort(int* arr, int start, int end){\tif (start &gt;= end)\t\treturn;\tint mid = (start + end) &gt;&gt; 1;\tsort(arr, start, mid);\tsort(arr, mid + 1, end);\tmerge(arr, start, end);\t}int main(void){\tint arr[] = { -1, -12, 5, 4, 3, 7, 7, -2, -1, -3 };\tint length = sizeof(arr) / sizeof(int);\tsort(arr, 0, length - 1);\tfor (int i = 0; i &lt; length; i++)\t{\t\tprintf(\"%d \", marr[i]);\t}\treturn 0;}DP, Memoization다이나믹 프로그래밍은 조건을 만족해야 사용할 수 있다.최적 부분 구조 - 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제를 모아서 큰 문제를 해결중복 부분 문제 - 동일한 작은 문제를 반복적으로 해결한다. 피보나치, 일반적인 DP 풀이 방식(재귀)#include &lt;iostream&gt;using namespace std;int fibo(int x){\tif(x==1 || x==2){ \treturn 1; } return fibo(x-1)+fibo(x-2);}int main(){\tcout &lt;&lt; fibo(4) &lt;&lt; '\\n'; return 0;}​ 피보나치, Memoization 탑 다운 방식 (재귀 사용)// Memoization 탑다운 방식#include &lt;iostream&gt;using namespace std;// 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화long long d[100];// 피보나치 함수를 재귀함수로 구현(탑다운 다이나믹 프로그래밍)int fibo(int x) {\t// 종료조건(1혹은 2일때 1반환) if(x==1 || x==2){ \treturn 1; } // 이미 계산한적 있는 문제라면 그대로 반환 if(d[x] != 0) { \treturn d[x]; } // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환 return d[x] = fibo(x-1) + fibo(x-2);}int main() {\tint N; cin &gt;&gt; N; cout &lt;&lt; fibo(N);} 피보나치, Memoization 바텀업 방식 (반복문 사용)// 바텀업 방식#include &lt;iostream&gt;using namespace std;// 앞서 계산된 결과를 저장하기 위한 DP테이블 초기화long long d[100];int main(void){ // 첫번째, 두번째 피보나치 수열은 1 d[1] = 1; d[2] = 1; int n = 50; // 피보나치 함수 반복문으로 구현 (바텀업 다이나믹 프로그래밍) for(int i=3; i&lt;n+1; i++){ \td[i] = d[i-1]+d[i-2]; } cout &lt;&lt; d[n] &lt;&lt; '\\n'; return 0;}다이나믹 프로그래밍 VS 분할 정복공통점 : 모두 최적 부분 구조를 가질 때 사용 가능(큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있는 상황)차이점 : 부분 문제 정복.(다이나믹 프로그래밍 문제에서는 각 부분 문제들이 서로 영향을 미치며 부분 문제가 중복되고,분할 정복 문제에서는 동일한 부분 문제가 반복적으로 계산되지 않는다.)분할 정복의 대표 사례인 퀵 정렬에서는 한 번 기준 원소가 자리를 변경해서 자리를 잡으면, 그 기준 원소의 위치가 바뀌지 않는다.또한 분할 이후에 해당 피벗을 다시 처리하는 부분에서 다시 호출하지 않는다.동적 계획법은 이미 해결한 문제를 반복적으로 해결하여 비효율적인 문제에서 유용할 것이다.우선순위 큐(priority queue) B형에서 Merge Sort는 마지막에 이분 탐색을 위해 필요한 경우가 많다. 그리고 ‘무언가’를 push해주고, 그 중 가장 우선순위가 높은 ‘무언가’를 pop하면서, 순서를 유지하고 싶을 때는 우선순위 큐를 이용한다. 우선순위 큐는 즉 자동 정렬되는 큐라고 이해하면 편하다.#include &lt;stdio.h&gt;#define ARR_MAX 110int heap[ARR_MAX];int hn;int N;int pop(int* heap, int&amp; hn){\tregister int tmp, ret;\t//1) pop의 return값 heap[1]을 기억해둔다.\tret = heap[1];\t//2) heap의 배열에서 가장 끝에 값, 즉 heap[hn]을 heap[1]로 변경한다.\theap[1] = heap[hn];\t//3) heap[hn]은 최악의 우선순위값(최소힙이므로 0x7fff0000 정도의 큰 값)으로 변경해둔다.\t//4) heap이 1개 줄었으므로 hn 을 1 감소 시킨다.\theap[hn--] = 0x7fff0000;\tfor (register int i = 1; i * 2 &lt;= hn;)\t{\t\tif (heap[i] &lt; heap[i * 2] &amp;&amp; heap[i] &lt; heap[i * 2 + 1]) break;\t\telse if (heap[i * 2] &lt; heap[i * 2 + 1])\t\t{\t\t\ttmp = heap[i * 2];\t\t\theap[i * 2] = heap[i];\t\t\theap[i] = tmp;\t\t\ti = i * 2;\t\t}\t\telse\t\t{\t\t\ttmp = heap[i * 2 + 1];\t\t\theap[i * 2 + 1] = heap[i];\t\t\theap[i] = tmp;\t\t\ti = i * 2 + 1;\t\t}\t}\treturn ret;}void push(int* heap, int&amp; hn, int x){\tregister int tmp;\t//모든 i에 대해서 자식 node는 i * 2, i * 2 + 1이 되고,\t//부모 node는 i / 2로 하면 된다.\theap[++hn] = x;\tfor (register int i = hn; i &gt; 1; i /= 2)\t{\t\t// 자식 노드가 더 크면 pass\t\tif (heap[i / 2] &lt;= heap[i]) \t\t\tbreak;\t\t// 아니면 조상 &lt;-&gt; 부모 &lt;-&gt; 자식 노드간에 교환을 반복해서 수행한다. (부모노드가 자식노드보다 작을때까지)\t\t// 부모 노드와 자식 노드와의 교환\t\ttmp = heap[i / 2];\t\theap[i / 2] = heap[i];\t\theap[i] = tmp;\t}}int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint x = scanf(\"%d\", &amp;x);\t\tif (x)\t\t{\t\t\tpush(heap, hn, x);\t\t}\t\telse\t\t{\t\t\tif (hn)\t\t\t{\t\t\t\tprintf(\"%d\", pop(heap, hn));\t\t\t}\t\t\t// 큐가 비어있는 경우\t\t\telse\t\t\t{\t\t\t\tprintf(\"0\\n\");\t\t\t}\t\t}\t}\t//int heap_len = sizeof(heap) / sizeof(int);\t//for (int i = 1; i &lt; heap_len; i++)\t//{\t//\tprintf(\"%d \", heap[i]);\t//}\treturn 0;}" }, { "title": "바이러스", "url": "/posts/%EB%B0%94%EC%9D%B4%EB%9F%AC%EC%8A%A4/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-05-02 00:00:00 +0900", "snippet": "바이러스신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.입력첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하인 양의 정수이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.출력1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.답안노드 : 자료 구조 개념에서 자료를 저장하는 최소 단위#include &lt;stdio.h&gt;#define ARR_MAX 110int N, M, answer;int q[ARR_MAX * ARR_MAX];int isvisited[ARR_MAX];struct NODE{ int x; struct NODE* next;};NODE head[ARR_MAX];NODE pool[ARR_MAX * ARR_MAX];int bufcnt;int wp, rp;void init(){ // 연결 관계만 끊어줘도 초기화 가능, 값들은 자연스럽게 덮여씌워짐 for (int i = 0; i &lt; N; i++) { head[i].next = 0; isvisited[i] = 0; } bufcnt = 0; answer = 0;}void add_node(int idx, int data){ // 1) node를 하나 pool에서 가져오고, 값을 입력한다. NODE* nd = &amp;pool[bufcnt++]; nd-&gt;x = data; // 2) node의 next를 head가 가르키는 곳에 연결한다. nd-&gt;next = head[idx].next; // 3) head를 새로운 node에 연결한다. head[idx].next = nd;}void bfs(){ int out; wp = rp = 0; q[wp++] = 1; isvisited[1] = 1; while (wp &gt; rp) { //q.pop out = q[rp++]; for (NODE* p = head[out].next; p != NULL; p = p-&gt;next) { if (isvisited[p-&gt;x] == 0) { isvisited[p-&gt;x] = 1; answer++; //q.push q[wp++] = p-&gt;x; } } }}void output_print(int idx){ idx += 1; printf(\"head %d : \", idx); for (NODE* p = head[idx].next; p != NULL; p = p-&gt;next) { printf(\"%d \", p-&gt;x); } printf(\"\\n\");}int main(){ scanf(\"%d %d\", &amp;N, &amp;M); init(); for (int i = 0; i &lt; M; i++) { int a, b; scanf(\"%d %d\", &amp;a, &amp;b); add_node(a, b); add_node(b, a); } bfs(); //for (int i = 0; i &lt; N; i++) //{ // output_print(i); //} printf(\"%d\\n\", answer); return 0;}" }, { "title": "Python 코딩 테스트 문법 정리", "url": "/posts/Python-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%AC%B8%EB%B2%95%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2024-02-29 00:00:00 +0900", "snippet": "기초 문법기초 입출력# 데이터의 개수 입력n = int(input())# 각 데이터를 공백으로 구분하여 입력data = list(map(int, input().split()))data.sort(reverse = True)data.sort()print(data)# 공백을 기준으로 구분하여 적은수의 데이터 입력n, m, k = map(int, input().split())# 공백을 기준으로 많은 수의 데이터를 입력받아야 할때T = int(input()) #Test casefor i in range(T): a,b = map(int, sys.stdin.readline().split())## 해당 내용의 파생# 📌한 개의 정수를 입력받을 때import sysa = int(sys.stdin.readline())# 😨 그냥 a = sys.stdin.readline() 하면 안되나요?# 👉 sys.stdin.readline()은 한줄 단위로 입력받기 때문에, 개행문자가 같이 입력 받아집니다.# 만약 3을 입력했다면, 3\\n 이 저장되기 때문에, 개행문자를 제거해야 합니다.# 또한, 변수 타입이 문자열 형태(str)로 저장되기 때문에, 정수로 사용하기 위해서 형변환을 거쳐야 합니다.# 📌정해진 개수의 정수를 한줄에 입력받을 때import sysa,b,c = map(int,sys.stdin.readline().split())# map()은 반복 가능한 객체(리스트 등)에 대해 각각의 요소들을 지정된 함수로 처리해주는 함수입니다.# 위와 같이 사용한다면 a,b,c에 대해 각각 int형으로 형변환을 할 수 있습니다.# 📌 임의의 개수의 정수를 한줄에 입력받아 리스트에 저장할 때import sysdata = list(map(int,sys.stdin.readline().split()))# split()은 문자열을 나눠주는 함수입니다.# 괄호 안에 특정 값을 넣어주면 그 값을 기준으로 문자열을 나누고, 아무 값도 넣어주지 않으면 공백(스페이스, 탭, 엔터 등)을 기준으로 나눕니다.# list()는 자료형을 리스트형으로 변환해주는 함수입니다.# map()은 맵 객체를 만들기 때문에, 리스트형으로 바꿔주기 위해서 list()로 감싸주었습니다.# 📌 임의의 개수의 정수를 n줄 입력받아 2차원 리스트에 저장할 때import sysdata = []n = int(sys.stdin.readline())for i in range(n): data.append(list(map(int,sys.stdin.readline().split())))# 이렇게 한다면 각 요소의 길이가 동일한 2차원 리스트도 만들 수 있고,# 각각 길이가 다른 2차원 리스트도 입력 받을 수 있습니다.# 📌 문자열 n줄을 입력받아 리스트에 저장할 때import sysn = int(sys.stdin.readline())data = [sys.stdin.readline().strip() for i in range(n)]# strip()은 문자열 맨 앞과 맨 끝의 공백문자를 제거합니다.# 👉 입력# 3# 안녕안녕# 나는 지수야# 헬륨가스 마셨더니 이렇게됐지# 👉 출력# ['안녕안녕', '나는 지수야', '헬륨가스 마셨더니 이렇게됐지']# 입력을 최대한 빠르게 받아야하는 경우import sys# 문자열 입력받기sys.stdin.readline().rstrip()# 데이터 출력'''print()기본적으로 출력 이후에 줄 바꿈을 수행한다.f-string'''# 출력할 변수들a = 1b = 2print(a,b)# 출력할 변수들answer = 7print(\"정답은 \" + answer + \"입니다.\") # TypeError: can only concatenate str (not \"int\") to str# 올바른 예print(\"정답은 \" + str(answer) + \"입니다\")print(\"정답은\" , str(answer), \"입니다\")# Python 3.6 이상answer = 7print(f\"정답은 {answer}입니다.\")'''2차원 배열 입력받기'''# 1. 원소 하나씩 입력받기arr = [for _ in range(B)]for i in range(B):\tarr[i] = list(map(int, input().split()))# 2. arr에 한 list씩 append 하기arr=[]for i in range(B):\tarr.append(list(map(int, input().split())))# 코딩테스트에서 주로 사용하는 방식# 3. 선언과 동시에 입력받기arr = [list(map(int, input().split()))for _in range(B)]arr = [list(map(int, input().split())) for _ in range (B)]arr = [list(map(int, sys.stdin.readline().rstrip)) for _ in range (B)]수 자료형#소수부가 0일 때 0을 생략a = 5. # 5.0# 10억의 지수 표현 방식 (최단 경로문제에서 자주 사용)a = 1e9 # 100000000.0# 컴퓨터는 2진수 체계이기 때문에 실수 덧셈을 정확히 하지 못한다. 보통 5째 자리에서 반올림 하면된다.a = 0.1 + 0.2print(rount(a,4))x = 7y = 3# 나누기x / y# 나머지x % y# 몫x // y# 거듭 연산자x ** y # a의 b승리스트 자료형, 메서드a = [1,2,3,4,5,6,7,8,9]print(a)print(a[4])# 빈 리스트 선언 방법a = list()a = []# 크기가 N이고 모든 값이 0인 1차원 리스트 초기화n = 10a = [0] * n# [0,0,0,0,0,0,0,0,0,0]# 리스트 인덱싱과 슬라이싱a[-1] # 9a[-3] # 7a[1:4] # [2,3,4]# 리스트 컴프리헨션# 리스트를 초기화하는 방법 중 하나이다# 대괄호안에 조건문과 반복문을 넣는 방식으로 리스트를 초기화할 수 있다.# 2차원 리스트를 초기화할 때 매우 효과적으로 사용된다.# 리스트 컴프리헨션과 일반소스코드 비교# 0부터 19까지의 수 중에서 홀수만 포함하는 리스트array = [i for i in range(20) if i % 2 == 1]array = []for i in range(20) if i % 2 == 1:\t\tarray.append(i)# 1부터 9까지의 수의 제곱 값을 포함하는 리스트array = [i*i for i in range(1,10)]# N * M 크기의 2차원 리스트 초기화n = 3m = 4array = [[0] * m for _ in range(n) ] # [[0,0,0,0],[0,0,0,0], [0,0,0,0]]# 리스트 관련 기타 메서드# 리스트에 원소 삽입a.append(2)# 오름차순 정렬a.sort()# 내림차순 정렬a.sort(reverse = True)# 리스트 원소 뒤집기a.reverse() # a list 가 변하는 것 return 값은 none# 특정 인덱스에 데이터 추가a.insert(2,3) # 인덱스2에 3추가# 특정 값인 데이터 개수 세기a.count(3)# 특정 값 데이터 삭제 (인덱스가 낮은 것 하나)a.remove(1) # 시간복잡도를 고려해서 remove는 사용하지 않는 것을 추천a = [1,2,3,4,5,5,5]remove_set = {3,5} # 집합# remove_set에 포함되지 않은 값만을 저장result = [i for i in a if i not in remove_set] # [1,2,4]문자열 자료형data = 'Hellow World'data = \"Do you know \\\"Python\\\"?\"print(data) # Don't you know \"Python\"?a = \"Hello\"b = \"World\"a + \" \" + b # Hello Worlda * 3 # HelloHelloHello# 파이썬 문자열은 내부적으로 리스트와 같이 처리 (인덱싱,슬라이싱) 사용 가능a = \"ABCDEF\"print(a[2:4]) #CD튜플 자료형'''튜플은 한 번 선언된 값을 변경할 수 없다. (immutable 자료형)리스트는 대괄호[] 를 이용하지만 , 튜플은 소괄호 ()를 이용한다그래프 알고리즘을 구현할 때 자주사용다익스트라 최단 경로 알고리즘 (우선순위큐 사용)(비용,노드번호) 형태로 튜플을 묶어서 관리한다.'''a = (1, 2, 3, 4)a[1] = 3 # TypeError딕셔너리 자료형'''key와 value의 쌍을 데이터로 가지는 자료형튜플 자료형이 사전자료형의 키로 사용되는 경우 (Q 22 블록이동하기)사전 자료형에 특정한 원소가 있는 지 검사할 때는 '원소 in 사전'의 형태를 사용할 수 있다.리스트나 튜플에 대해서도 사용할 수 있는 문법'''data = dict()data['사과'] = 'Apple'data['바나나'] = 'Banana'data['코코넛'] = 'Coconut'# {'사과': 'Apple', '바나나': 'Banana', '코코넛': 'Coconut'}if '사과' in data: print(\"'사과'를 키로 가지는 데이터가 존재합니다.\")data = dict()data['사과'] = 'Apple'data['바나나'] = 'Banana'data['코코넛'] = 'Coconut'# 키 데이터만 담은 리스트key_list = data.keys()value_list = data.values()for key in key_list: print(data[key]) # Apple Banana Coconut집합 자료형(Set)'''중복을 허용하지 않는다순서가 없다특정한 데이터가 이미 등장한 적이 있는지 여부를 체크할 때 효과적이다.'''# 집합 자료형 초기화 방법 data = set([1,1,2,3,4,4,5])data = {1,2,3,4,5}# 집합 자료형 초기화 방법 a = set([1,2,3,4,5])b = {3,4,5,6,7}a | b # 합집합 {1,2,3,4,5,6,7}a &amp; b # 교집합 {3,4,5}a - b # 차집합 {1,2}data = set([1,2,3])print(data)# 새로운 원소 추가data.add(4)# 새로운 원소 여러 개 추가data.update([5,6])# 특정한 값을 갖는 원소 삭제data.remove(3)print(data)전역 변수a = 0def func():\tglobal a\ta += 1for i in range(10):\tfunc()print(a)람다 표현식(Lambda Express)'''특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다람다식은 파이썬의 정렬 라이브러리를 사용할 때, 정렬 기준(Key)을 설정할 때에도 자주 사용한다.'''def add(a, b):\treturn a + bprint(add(3,7))# 람다 표현식으로 구현한 add() 메서드print( (lambda a, b: a + b)(3,7) )주요 라이브러리 문법1. 문자열 뒤집기아래와 같이 [::-1] 문법을 사용할 수 있다.string = ‘Welcome SJKOding!’print(string[::-1])2. 중복 제거하기set자료형을 이용하자. 변환할 변수를 set()으로 묶으면 된다. set은 중복을 허용하지 않고 순서가 없다.temp = [1, 1, 2, 2, 3, 4, 4, 5]print(list(set(temp)))출력 결과: [1, 2, 3, 4, 5]3. 한 줄에 여러 정수(int) 혹은 실수(float) 입력받기 python의 input함수는 기본적으로 string형태의 데이터로 입력받게 된다 따라서 숫자를 입력받는다면 반드시 형 변환을 해주어야한다 백준 알고리즘 같은 사이트에서 한 줄에 여러 값을 입력받는 경우가 대다수이다. 이는 map()함수와 문자열의 split()함수를 이용하여 아래와 같이 입력받을 수 있다.map()함수는 iterable한 자료형(리스트, 튜플과 같은 여러 값이 연속되어있는 자료형) 의 원소들을 각각 지정한 함수에 넣어 반환하는 함수이다.temp_list = list(map(int, input().split()))print(temp_list)입력: 34 2 566 4 7 8 11출력: [34, 2, 566, 4, 7, 8, 11]4. 특정 값으로 2차원 맵 (BFS, DFS 등에서 주로 사용) 생성 numpy와 같은 라이브러리로 쉽게 만들 수 있지만 코딩테스트에서는 표준 라이브러리만 허용하기 때문에 numpy를 사용할 수 없다. 따라서 리스트 컴프리헨션으로 아래와 같이 2차원 맵을 생성할 수 있다.visited = [[False for _ in range(m)] for _ in range(n)] # n: 행 개수 m: 열 개수visited는 주로 사용되는 변수명이다. 방문여부를 체크할 때 쓰인다.5. 파이썬에서는 if 0 &lt; n &lt; 10: 과 같은 문법을 허용한다.일반적으로 java나 C언어 같은 경우 아래와 같이 분할해서 &amp;&amp;연산자로 엮어야한다.if(0 &lt; n &amp;&amp; n &lt; 10){ }if 0 &lt; n &lt; 10: 6. 두 변수의 값 바꾸기다른 언어에서는 ^연산자를 사용하거나(숫자 swap의 경우) temp변수를 사용하여 두 변수의 값을 바꾸지만 파이썬은 아래와 같이 쉽게 바꿀 수 있다.a, b = b, a7. 리스트의 원소들을 차례로 순회할 때, 인덱스까지 동시에 가져오기아래와 같이 enumerate() 함수를 사용하여 동시에 가져올 수 있다.temp = ['k', 'o', 'r', 'e', 'a']for idx, value in enumerate(temp):\tprint(idx, value)출력 결과:0 ‘k’1 ‘o’(생략)8. Queue를 이용할 시 temp.pop(0)대신 deque사용하기.queue의 자료형을 구현할 경우 가장 먼저 들어온 데이터를 빼낼 때 .pop(0)으로 빼올 수 있지만 값을 빼온 후 나머지의 원소들을 한 칸씩 땡겨야 하기 때문에 시간복잡도 O(N)이 소요된다. 이를 해결하기위해 표준라이브러리 collections의 deque를 아래와 같이 사용한다. 이는 시간복잡도 O(1)이 소요되어 코딩테스트의 필수 라이브러리이며 BFS구현시 반드시 사용된다.from collections import dequequeue = deque([1, 2, 3, 4, 5])print(queue.popleft())print(list(queue))출력결과:1[2, 3, 4, 5]popleft(), appendleft()를 모두 허용하며 물론 pop()과 append()도 당연히 사용 가능하다. 앞 뒤로 자유자재로 데이터를 처리할 수 있고 시간복잡도가 O(1)이므로 필수로 알아둬야하는 라이브러리이다.9. 길이가 같은 두 개 이상의 iterable 객체를 동시에 for문 돌리기이는 zip()함수로 아래와 같이 사용할 수 있다.temp1 = [1, 3, 5]temp2 = [2, 4, 6]for n1, n2 in zip(temp1, temp2):\tprint(n1, n2)출력 결과:1 23 45 610. 딕셔너리 정렬 (key기준, value 기준) 딕셔너리의 value값을 기준으로 정렬하고자 할때 sorted 함수의 key인자를 아래와같이 사용하면 된다.```pythondic = {‘apple’: 3, ‘banana’: 1, ‘pear’: 5}sorted(dic.item(), key = lambda x: x[1])- 딕셔너리의 key값을 기준으로 정렬하려면 그냥 sorted(dic)을 하면 된다. - 만약 value값을 기준으로 먼저 정렬하고 그 상태에서 key값으로 정렬하려면 아래와 같이 수행하면 된다.```pythondic = {'apple': 3, 'banana': 1, 'pear': 5}sorted(dic.item(), key = lambda x: (x[1], x[0]))11. for-else문, while-else문해당 문법은 반복문 내에서 break로써 빠져나오지 않고 조건을 만족하여 빠져나왔을 경우에만 수행할 수 있게 지원한다.아래와 같이 사용하면 된다. 별도의 flag변수가 필요하지 않아 편하다.for i in range(1, 10):\tif i == 11: \tbreak else:\tprint('for-break 안걸림!') j = 0while j &lt; 10:\tif j == 4: \tbreak \tj += 1else:\tprint('while-break 안걸림!')출력결과:for-break 안걸림!12. 정렬된 리스트에서 이진 탐색으로 탐색 및 값 삽입하기 (bisect)정렬된 리스트에서 값을 찾거나 삽입할 때 단순 순회탐색이 아닌 이진탐색을 자동으로 지원하는 라이브러리. 시간복잡도는 O(logN)이므로 매우 효율적이다.import bisectlst = [1, 3, 5, 6, 6, 8]# 숫자 4가 어디에 위치해야하는지 index가져오기# 이때 탐색할 숫자가 이미 존재할때, ## bisect_left는 그 숫자의 가장 왼쪽 index 반환# bisect_right는 그 숫자의 가장 오른쪽 index 반환print(bisect.bisect_left(lst, 4) # 2print(bisect.bisect_left(lst, 6) # 3print(bisect.bisect_right(lst, 6) # 513. 2차원 리스트에서 열 추출하기ndarray, DataFrame은 열 추출을 쉽게 할 수 있지만 리스트는 열 접근을 지원하지 않는다. 이는 zip연산을 통해 간단하게 구현할 수 있다.a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]b = list(zip(*a))[0]print(b)# (1, 4, 7)c = list(zip(*a))[1]print(c)# (2, 5, 8)14. 백준에서 표준 입력으로 시간 단축하기sys라이브러리의 readline표준입력을 사용하면 입력시간이 대폭 감소한다. 거의 필수적인 기능이다. 예를 들어 테스트케이스의 최대 길이가 1000인 경우(1000번 입력받아야함), 특정 조건이 나올때 까지 입력받는 경우, 맵이나 크기가 100이 넘거나 그래프의 노드수가 100개가 넘는 등 입력이 다수 진행될 경우에 사용할 수 있다.*주의사항 sys.stdin.readline은 줄바꿈 문자를 포함하여 입력받기때문에 strip()을 포함해줘야한다. 단, 정수형으로 캐스팅할 경우 자동으로 줄바꿈 문자를 생략해준다.import sysinput = sys.stdin.readline # built-in input() 함수를 표준입력으로 대체while True:\tnum = int(input()) # 정수로 캐스팅했으므로 strip()필요없음. \tif num == -1: break print(num)15. defaultdict() 유사 딕셔너리딕셔너리를 사용할 때 다음과 같은 로직을 자주 만난다.if 1 in dic:\tdic[1].append('temp') else:\tdic[1] = 'temp'key가 존재하지 않을 때 어떠한 연산을 하려고하면 에러가 발생하기 때문이다. 이때, defaultdict()를 사용하면 편하다.key가 존재하지 않다면 자동으로 키를 생성하여 연산을 수행해주기 때문이다.# 백준의 어떠한 문제 해답 중 일부from collections import defaultdictdic = defaultdict(list)N = int(input())for i in range(N): deadline, cup = map(int, input().split()) dic[deadline].append(cup)코딩테스트 관련 문법1. 내장 함수 print(), input()과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 내장 라이브러리2. itertools 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리, 순열과 조합 라이브러리를 제공 Samsung 등 일부 코테에서는 사용 불가```python 순열 from itertools import permutations a = [‘A’, ‘B’, ‘C’]res = list(permutations(a, 3))print(res)[(‘A’, ‘B’, ‘C’), (‘A’, ‘C’, ‘B’), (‘B’, ‘A’, ‘C’), (‘B’, ‘C’, ‘A’), (‘C’, ‘A’, ‘B’), (‘C’, ‘B’, ‘A’)]조합from itertools import combinationsa = [‘A’, ‘B’, ‘C’]res = list(combinations(a, 2))print(res)[(‘A’, ‘B’), (‘A’, ‘C’), (‘B’, ‘A’), (‘B’, ‘C’), (‘C’, ‘A’), (‘C’, ‘B’)]중복순열from itertools import producta = [‘A’, ‘B’, ‘C’]res = list(product(a, repeat = 2))print(res)[(‘A’, ‘A’), (‘A’, ‘B’), (‘A’, ‘C’), (‘B’, ‘A’), (‘B’, ‘B’), (‘B’, ‘C’), (‘C’, ‘A’), (‘C’, ‘B’), (‘C’, ‘C’)]중복조합from itertools import combinations_with_replacementa = [‘A’, ‘B’, ‘C’]res = list(combinations_with_replacement(a, 2))print(res)[(‘A’, ‘A’), (‘A’, ‘B’), (‘A’, ‘C’), (‘B’, ‘B’), (‘B’, ‘C’), (‘C’, ‘C’)]## 3. heapq- 힙(Heap) 기능을 제공하는 라이브러리. 우선순위 큐 기능을 구현하기 위해 사용한다.```python# 추가heapq.heappush()# 제거heapq.heappop()# 정렬import heapqdef heapsort(iterable): h = [] res = [] for value in iterable: heapq.heappush(h, value) # (h, -value) for i in range(len(h)): res.append(heapq.heappop(h)) # ( -heapq.heappop(h) ) return resres = heapsort([1,3,5,7,9,2,4,6])print(res) # [1, 2, 3, 4, 5, 6, 7, 9]#반대로 내림차순의 경우엔 푸시와 팝의 부호를 바꾸는 방법으로 진행4. bisect 이진탐색/이분탐색(Binary Search) 기능을 제공하는 라이브러리5. Collections 덱(deque), 카운터(Counter) 등의 유용한 자료구조를 포함하고 있는 라이브러리from collections import dequedata = deque([2, 3, 4])data.appendleft(1)data.append(5)print(data) # deque([1, 2, 3, 4, 5])from collections import Countercounter = Counter(['red', 'blue', 'red', 'green', 'blue'])print(counter['blue']) # 2print(dict(counter)) # {'red': 2, 'blue': 2, 'green': 1 }6. math 필수적인 수학적 기능을 제공하는 라이브러리 팩토리얼(math.factorial), 제곱근(math.sqrt), 최대공약수(GCD), 삼각함수(math.radian, math.degree, math.sin,math.cos, math.tan), 파이(math.pi)import mathprint(math.factorial(5)) # 120print(math.sqrt(16)) # 4.0print(math.gcd(15, 10)) # 5DFS 탐색 노드를 스택에 삽입하고 방문 처리를 합니다. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 인접 노드를 스택에 넣고 방문 처리를 합니다. 방문하지 않은 인접 노드가 없으면 최상단 노드를 꺼냅니다. 2번의 과정을 더이상 수행할 수 없을 때까지 반복합니다. def dfs(graph, v, visited): visited[v] = True for i in graph[v]: if not visited[i]: dfs(graph, i, visited) BFS 탐색 시작 노드를 큐에 삽입하고 방문 처리를 합니다. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리를 합니다. 2번의 과정을 더이상 수행할 수 없을 때까지 반복합니다.```pythonfrom collections import dequedef bfs(graph, start, visited): queue = deque([start]) visited[start] = True while queue: v = queue.popleft() for i in graph[v]: if not visitied[i]: queue.append(i) visitied[i] = True## DFS BFS 벡준 문제 예시```pythonfrom collections import dequedef dfs(li,V,visited): #현재 노드 방문 처리 visited[V] = 1 print(V, end = ' ') #현재 노드와 연결된 다른 노드를 재귀적으로 방문 for i in li[V]: if visited[i] == 0: dfs(li,i,visited)def bfs(li,V,visited): deq = deque([V]) visited[V] = 0 while deq: # 큐가 빌때 까지 #맨 처음 인자 빼고, 출력 V = deq.popleft() print(V, end = ' ') #방문하지 않은 인자 큐에 추가 for i in li[V]: if visited[i] == 1: deq.append(i) visited[i] = 0N, M, V = map(int, input().split())li = [[]for i in range(N+1)]for i in range(M): num_1, num_2 = map(int, input().split()) li[num_1].append(num_2) li[num_2].append(num_1)visited = [0] * (N + 1)#리스트 정렬for i in range(1,N+1): li[i].sort()dfs(li, V, visited)print()bfs(li, V, visited)BFS 문제 예제 (백준, 14502 연구소)#14502_연구소_bfs_gold5from collections import dequeimport copyimport sysinput = sys.stdin.readlinedy = [-1, 1, 0, 0]dx = [0, 0, -1, 1]def bfs(): queue = deque() #queue에 2의 위치 전부 append test_map = copy.deepcopy(lab_map) for i in range(n): for k in range(m): if test_map[i][k] == 2: queue.append((i,k)) while queue: y,x = queue.popleft() for i in range(4): dy = y+dy[i] dx = x+dx[i] if (0&lt;=dr&lt;n) and (0&lt;=dc&lt;m): if test_map[dy][dx] == 0: test_map[dy][dx] =2 queue.append((dr,dc)) global result count = 0 for i in range(n): for k in range(m): if test_map[i][k] == 0: count +=1 result = max(result, count)def make_wall(count): if count == 3: bfs() return for i in range(n): for k in range(m): if lab_map[i][k] == 0: lab_map[i][k] = 1 make_wall(count+1) lab_map[i][k] = 0n, m = map(int,input().split())lab_map = [list(map(int,input().split())) for _ in range(n)]result = 0make_wall(0)print(result)from collections import dequeimport copyimport sysinput = sys.stdin.readlinedy = [-1, 1, 0, 0]dx = [0, 0, -1, 1]def bfs(): queue = deque() #queue에 2의 위치 전부 append test_map = copy.deepcopy(lab_map) for i in range(n): for j in range(m): if test_map[i][j] == 2: queue.append((i,j)) while queue: y,x = queue.popleft() for i in range(4): ny = y+dy[i] nx = x+dx[i] if (0&lt;=ny&lt;n) and (0&lt;=nx&lt;m): if test_map[ny][nx] == 0: test_map[ny][nx] = 2 queue.append((ny,nx)) global result count = 0 for i in range(n): for j in range(m): if test_map[i][j] == 0: count +=1 result = max(result, count)def make_wall(count): if count == 3: bfs() return for i in range(n): for j in range(m): if lab_map[i][j] == 0: lab_map[i][j] = 1 make_wall(count+1) lab_map[i][j] = 0n, m = map(int,input().split())lab_map = [list(map(int,input().split())) for _ in range(n)]result = 0make_wall(0)print(result)출처https://sjkoding.tistory.com/18https://seongbindb.tistory.com/54" }, { "title": "UDS 진단통신", "url": "/posts/UDS-%EC%A7%84%EB%8B%A8%ED%86%B5%EC%8B%A0/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2023-10-29 00:00:00 +0900", "snippet": "UDS 진단통신 UDS(Unified Diagnostic Service) 프로토콜 차량 제조사들이 필요한 다양한 기능들을 정의 해둠 ISO14229 기반 OBD(On-board Diagnostics) 프로토콜 법적 의무 사항. 주로 차량 배기가스와 연관된 정보 XCP(Universal measurement and Calibration Protocol) 프로토콜주로 변수값 읽고,쓰는데 초점 Request - Response 방식 SID : Service ID(첫 번째 byte) Negative 응답의 경우 0x7F SID NRC(Negative Response Code), Positive 응답의 경우 SID + 0x40Addressing 방식 Physical Address 특정 ECU에게 명령 Functional Address -모든 ECU에게 동시에 명령 CAN 메세지에는 ID라는게 있다. 이 ID를 이용해서 구분한다.ReadDataByIdentifier (0x22) SW의 Data를 읽을때 사용한다. Data Identifier (DID) 를 통해서 어떤 Data를 읽을건지구분한다. DID 는 2byte 크기의 정수이다. 0~65535 까지 나타낼 수 있음. DID는 제어기마다 각각 구분된다WriteDataByIdentifier (0x2E) ReadDataByIdentifier 와 내용은 동일Ecu Reset (0x11) ECU를 Reset하는 기능 SID SF 조합Session Control (0x10) Session : Mode Mode를 변경하는 것 각 Mode에서 실행 가능한 Service, Function들을 사전에 정의 해둠 예시 Default Session Programming Session (소프트웨어 업데이트 시 사용) Extended Diagnostic Session Safety System Diagnostic Session (안전 동작과 관련) 위와 같이 표준에서 정의하고 있긴 하지만 결국 몇 가지 Mode를 둘 것이고, 각 Mode의 숫자는 무엇으로 할것인지 각 모드에서 어떤 동작을 할 것인지는 OEM(완성차 제조사) 의 결정을 따라야 한다.Sub Function Reset Type 설명 Hard-Reset KeyOffOnReset SoftReset EnableRapidPowerShutdown DisableRapidPowerShutdown Etc… TesterPresent (0x3E) 진단기가 현재 연결 되어있다는걸 알려주는 용도. 혹은, 현재 Session을 계속 유지하라고 알려주는 용도.타이밍 파라미터 (S3, P2 Timer) S3 client(진단기) : 2000ms S3 Server(제어기) : 5000ms (해당 시간 Timeout 발생 시 default session 으로 돌아간다. 이를 위해 S3 Client의 주기만큼 Test Present 진단을 보내 Timeout 시간 초기화를 수행한다.) P2 Server : 50ms 진단기가 제어기에게 진단을 날렸을 때 제어기가 응답하는 시간) P2* Server : 5000ms (Timeout 발생하여 Negative Response 발생했을 때 NRC 일 경우 P2* Server 시간만큼 기다림) P2 Client (진단기가 제어기에게 진단을 날렸을 때 응답을 안했을 때 Timeout 발생) P2* ClientSecurity Access(0x27) 특정 기능은 password를 아는 사람만 사용할 수 있게 하겠다. 는 용도 특정 서비스, 기능을 사용하려면 특정 Level의 Lock(자물쇠)를 풀어야 함 각 Level 의 숫자는 상하 관계가 아니라 완전 독립적임 SF 가 홀수면 Seed 요청 (2n-1), Request Seed SF 가 짝수면 Key 전송을 의미함(2n), Send Key Seed 값이 0이면 해당 level 의 lock 은 풀려있다는 걸 의미함Routine Control(0x31) 뭐라고 분류하기 애매한, 사전에 정의된 어떤 기능을 동작시키는 것 Routine Identifier : RID, 2byte 정수 Routine Start / Routine Stop / Request Routine Result SF = 1 : Start Routine SF = 2 : Stop Routine SF = 3 : Request Routine Result SID(0x31) SF RID … 구조를 가진다DTC : Diagnostic Trouble Code (고장 진단 코드) 고장이 발생 했을 때 어떤 고장인지를 구별해주는 Code Code를 나타내는 Format을 정의하는 다양한 국제 표준이 있음 널리 쓰이는 것 중 하나가 ISO 15031-6 에서 정의하는 FormatDTC Status Mask bit 0 testFailed bit 1 testFailedThisOperationCycle=&gt; operation cycle 내 에러가 발생했는지에 대한 비트 Operation cycle 끝나면 clear bit 2 pendingDTC=&gt; operation cycle 내 에러가 발생했는지에 대한 비트 Operation cycle 끝나도 clear 되지 않는다 bit 3 confirmedDTC=&gt; 제조사에서 정의, NVM 에 저장되는 DTC, UDS 진단을 통해 읽어올 수 있음 bit 4 testNotCompletedSinceLastClear=&gt; clear 서비스 이후 test가 complete 되지 않았을 때 set bit 5 testFailedSinceLastClear=&gt; clear 서비스 이후 test가 fail 이 발생하면 set bit 6 testNotCompletedThisOperationCycle=&gt; 이번 operation cycle에서 test가 한 번도 끝나지 않았을 때 set bit 7 warningIndicatorRequested=&gt; 제조사에서 정의, 어떤 특정한 고장이 setSnapshot Data 고장 발생할 당시의 여러가지 데이터들을 기록해둔 것 스냅샷 데이터에 포함되는 데이터항목들은 모두 DID를 갖는데이터들이다.제조사에서 정의하는 속성들 DTC 마다 Snap Shot Data 형태를 다르게 구성 가능 SnapShot Data를 언제 저장할 것인지 DTC마다 스냅샷 최대 몇개 찍을 수 있는지 스냅샷 저장된 갯수가 최대치에 도달한 경우 처리 규칙Record Number 저장된 SnapShot Data 들을 구분하기 위한 번호 Snapshot Identification DTC 코드 + 레코드넘버Extended Data DTC 마다 (고장마다) 각각 가짐 Extended Data에 포함되는 내용, 포멧, 크기 등은 제조사가 임의로정하는 것 그렇게해서 정해진 Extended Data는 Record Number라는 것으로구별됨 레코드 Number FF로 담아서 요청하면 해당 DTC에 매핑된 Extended Data 전부 다 리턴하는 것 Record Number는 1byte 데이터이며, 표준에서 범위 제한해놓은게 있다. 01 ~ 8F( 10진수로 1~143) : 제조사 임의 지정 FF : 모든 Record를 의미 미래를 위해 남겨두거나, 법적으로 꼭 봐야하는 데이터 같은거는 표준에서 번호 사전에 할당해버림Clear DiagnosticInformation(0x14) DTC와 관련된 여러가지 데이터들을 Clear 하는 명령. DTC Status Mask (DTC Status Byte) DTC Snapshot Data DTC Extended Data 그 외 여러가지 정보들 Clear되는 정보들은 위와 같은 정보들로 구성할 수 있다. 그렇지만 clear 명령을 날렸을때 정확히 어떤 데이터를 지울 건지는 제조사에서 임의로 정한다. Permanent DTC는 이 서비스로 지울수 없다." }, { "title": "싸움땅", "url": "/posts/%EC%88%A0%EB%9E%98%EC%9E%A1%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-14 00:00:00 +0900", "snippet": "싸움땅술래잡기 게임을 진행해보려고 합니다. 술래잡기 게임은 n * n 크기의 격자에서 진행되며 술래는 처음 정중앙에 서있습니다.술래잡기 게임에는 m명의 도망자가 있습니다. 도망자는 처음 지정된 곳에 서있습니다. 도망자는 중앙에서 시작하지는 않습니다. 도망자의 종류는 좌우로만 움직이는 유형과 상하로만 움직이는 유형 이렇게 2가지가 있습니다. 이때 좌우로 움직이는 사람은 항상 오른쪽을 보고 시작하며, 상하로 움직이는 사람은 항상 아래쪽을 보고 시작합니다.예로 3명의 도망자(m = 3)가 주어진 경우를 가정해보겠습니다.또, 이 술래잡기 게임에는 h개의 나무가 있습니다.예로 하나의 나무(h = 1)가 있는 경우를 가정해보겠습니다. 이처럼 나무가 도망자와 초기에 겹쳐져 주어지는 것 역시 가능합니다.술래잡기 게임에서는 m명의 도망자가 먼저 동시에 움직이고, 그 다음 술래가 움직이고, 도망자가 움직이고, 술래가 움직이고, … 이렇게 도망자가 1턴 그리고 이어서 술래가 1턴 진행하는 것을 총 k번 반복하게 됩니다. 이때 도망자가 움직일 때 현재 술래와의 거리가 3 이하인 도망자만 움직입니다. 도망자의 위치가 (x1, y1), 술래의 위치가 (x2, y2)라 했을 때 두 사람간의 거리는 x1 - x2 + y1 - y2 로 정의됩니다. 술래와의 거리가 3 이하인 도망자들은 1턴 동안 다음 규칙에 따라 움직이게 됩니다.현재 바라보고 있는 방향으로 1칸 움직인다 했을 때 격자를 벗어나지 않는 경우움직이려는 칸에 술래가 있는 경우라면 움직이지 않습니다.움직이려는 칸에 술래가 있지 않다면 해당 칸으로 이동합니다. 해당 칸에 나무가 있어도 괜찮습니다.현재 바라보고 있는 방향으로 1칸 움직인다 했을 때 격자를 벗어나는 경우먼저 방향을 반대로 틀어줍니다. 이후 바라보고 있는 방향으로 1칸 움직인다 했을 때 해당 위치에 술래가 없다면 1칸 앞으로 이동합니다.위의 규칙에 따라 &lt;Figure 3&gt;에서 도망자가 1턴 동안 움직인 이후의 모습은 다음과 같습니다.이후 술래가 1턴 움직이는 경우를 살펴보겠습니다.술래는 처음 위 방향으로 시작하여 달팽이 모양으로 움직입니다.만약 끝에 도달하게 되면 다시 거꾸로 중심으로 이동하고, 다시 중심에 오게 되면 처음처럼 위 방향으로 시작하여 시계뱡향으로 도는 것을 k턴에 걸쳐 반복하게 됩니다.술래는 1번의 턴 동안 정확히 한 칸 해당하는 방향으로 이동하게 됩니다. 이동 후의 위치가 만약 이동방향이 틀어지는 지점이라면, 방향을 바로 틀어줍니다. 만약 이동을 통해 양끝에 해당하는 위치인 (1행, 1열) 혹은 정중앙에 도달하게 된다면 이 경우 역시 방향을 바로 틀어줘야 함에 유의합니다. &lt;Figure 4&gt;에서 술래가 한 칸 이동하게 되면, 술래는 바로 방향을 틀게 됩니다.이동 직후 술래는 턴을 넘기기 전에 시야 내에 있는 도망자를 잡게 됩니다. 술래의 시야는 현재 바라보고 있는 방향을 기준으로 현재 칸을 포함하여 총 3칸입니다. 격자 크기에 상관없이 술래의 시야는 항상 3칸임에 유의합니다.하지만 만약 나무가 놓여 있는 칸이라면, 해당 칸에 있는 도망자는 나무에 가려져 보이지 않게 됩니다. 따라서 &lt;Figure 8&gt;의 경우에서는 (2행, 5열)에 있는 도망자만 잡히게 됩니다. 잡힌 도망자는 사라지게 되고, 술래는 현재 턴을 t번째 턴이라고 했을 때 t x 현재 턴에서 잡힌 도망자의 수만큼의 점수를 얻게 됩니다. 따라서 &lt;Figure 8&gt;의 상황에서 술래는 1 x 1인 1점을 얻게 되고 (2행, 5열)에 있던 도망자는 사라지게 됩니다.그 다음에는 다시 도망자의 턴이 진행되고, 이어서 술래의 턴이 진행되는 것을 총 k번에 걸쳐 반복하게 됩니다.만약 k = 2였다면, 이제 2번째 턴이 진행되어야 합니다.2번째 턴에서 먼저 도망자가 움직이게 됩니다.이후 술래는 한 칸 앞으로 움직이게 됩니다. 이때 역시 이동방향이 틀어지는 지점이므로, 이동후 바로 방향을 틀게 됩니다. 이 경우 남은 두 도망자가 모두 잡히게 되어 2(번째 턴) x 2(명의 도망자)에 해당하는 4점을 추가적으로 얻게 됩니다.k번에 걸쳐 술래잡기를 진행하는 동안 술래가 총 얻게된 점수를 출력하는 프로그램을 작성해보세요.풀이 방법달팽이 회전만 잘 처리해주면 되는 문제달팽이 회전에서 고려해야될점은 이동하는 단위거리가 2번씩 반복되다가 마지막에는 3번이라는 점#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;struct info{ int y; int x; int dir;};info catcher;// runner 의 x, y, 방향 좌표를 저장vector&lt;int&gt; runnermap[100][100];bool tree_arr[100][100] = { 0 };// 상우하좌 술래가 움직이는 방식int dy[4] = {-1,0,1,0};int dx[4] = {0,1,0,-1};int answer = 0;int n, m, h, k;// len은 회전반경을 의미, cnt 는 잡은 마릿수bool turnback = false;int len, cnt;//목표 lenint curlen= 1;int calc_dist(int y1, int x1, int y2, int x2){ return abs(y1 - y2) + abs(x1 - x2);}void move_runner(){ vector&lt;int&gt; tmpRunnerMap[100][100]; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { for(int k = 0; k &lt; runnermap[i][j].size(); k++) { int dir = runnermap[i][j][k]; int dist = calc_dist(i, j, catcher.y, catcher.x); // 거리가 3보다 멀면 도망자는 움직이지 않는다. if(dist &gt; 3) { tmpRunnerMap[i][j].push_back(runnermap[i][j][k]); continue; } int ny = i + dy[dir]; int nx = j + dx[dir]; // 격자 밖일 경우 방향을 반대로 틀어준다. if( nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n) { // if( dir &lt; 2) dir += 2; // else dir -= 2; dir = (dir + 2) % 4; // 다시 한칸 이동 ny = i + dy[dir]; nx = j + dx[dir]; } // 이동한 위치에 술래가 있을 경우 이동 X if ( nx == catcher.x &amp;&amp; ny == catcher.y) { ny = ny - dy[dir]; nx = nx - dx[dir]; } tmpRunnerMap[ny][nx].push_back(dir); } } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { runnermap[i][j].clear(); runnermap[i][j] = tmpRunnerMap[i][j]; } } }void move_catcher(){ int y = catcher.y; int x = catcher.x; int dir = catcher.dir; int ny = y + dy[dir]; int nx = x + dx[dir]; // curlen 은 나선형 움직임 중 현재 최대 직선거리 // len은 현재 최대 직선 거리 중 몇만큼 직진했다는 것을 나타냄 len++; if(curlen == len) { len = 0; cnt++; if(!turnback) { dir = (dir + 1) % 4; } else { dir = (dir + 3) % 4; } if(cnt == 2) { cnt = 0; if(!turnback) curlen++; else curlen--; } } // 0, 0 좌표, n / 2 n / 2 중심 좌표에 도달했을 때 if(ny == 0 &amp;&amp; nx == 0) { turnback = true; curlen = n - 1; dir = 2; cnt = -1; len = 0; } else if(ny == (n / 2) &amp;&amp; nx == (n /2)) { turnback = false; curlen=1; dir = 0; cnt = 0; len = 0; } catcher = {ny, nx, dir};}int catch_runner(){ int y = catcher.y; int x = catcher.x; int dir = catcher.dir; int cnt = 0; for(int i = 0; i &lt; 3; i++) { int ny = y + (dy[dir] * i); int nx = x + (dx[dir] * i); if(tree_arr[ny][nx] == 1) continue; if( nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n) continue; // 잡힌 도망자들 제거 및 개수 카운팅 if(runnermap[ny][nx].size() &gt; 0) { cnt += runnermap[ny][nx].size(); runnermap[ny][nx].clear(); } } return cnt;}void simulate(){ // i는 턴을 의미한다. for(int i = 1; i &lt;= k; i++) { move_runner(); move_catcher(); answer += i * catch_runner(); }}int main() { // 여기에 코드를 작성해주세요. curlen = 1; len = 0; cnt = 0; scanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;h, &amp;k); // 술래 위치 방향 초기화 catcher = {(n / 2), (n / 2), 0}; for(int i = 0; i &lt; m; i++) { int y, x, d; scanf(\"%d %d %d\", &amp;y, &amp;x, &amp;d); // 좌우 if(d == 1) d = 1; else d = 2; runnermap[y-1][x-1].push_back(d); } // 나무 위치 업데이트 for(int i = 0; i &lt; h; i++) { int y, x; scanf(\"%d %d\", &amp;y, &amp;x); tree_arr[y - 1][x - 1] = 1; } simulate(); printf(\"%d\\n\", answer); return 0;}정답코드#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;tuple&gt;#include &lt;cstdlib&gt;#define MAX_N 100#define DIR_NUM 4using namespace std;// 변수 선언int n, m, h, k;// 각 칸에 있는 도망자 정보를 관리합니다.// 도망자의 방향만 저장하면 충분합니다.vector&lt;int&gt; hiders[MAX_N][MAX_N];vector&lt;int&gt; next_hiders[MAX_N][MAX_N];bool tree[MAX_N][MAX_N];// 정방향 기준으로// 현재 위치에서 술래가 움직여야 할 방향을 관리합니다.int seeker_next_dir[MAX_N][MAX_N];// 역방향 기준으로// 현재 위치에서 술래가 움직여야 할 방향을 관리합니다.int seeker_rev_dir[MAX_N][MAX_N];// 술래의 현재 위치를 나타냅니다.pair&lt;int, int&gt; seeker_pos;// 술래가 움직이는 방향이 정방향이면 true / 아니라면 false입니다.bool forward_facing = true;int ans;// 정중앙으로부터 끝까지 움직이는 경로를 계산해줍니다.void InitializeSeekerPath() { // 상우하좌 순서대로 넣어줍니다. int dx[DIR_NUM] = {-1, 0, 1, 0}; int dy[DIR_NUM] = {0 , 1, 0, -1}; // 시작 위치와 방향, // 해당 방향으로 이동할 횟수를 설정합니다. int curr_x = n / 2, curr_y = n / 2; int move_dir = 0, move_num = 1; while(curr_x || curr_y) { // move_num 만큼 이동합니다. for(int i = 0; i &lt; move_num; i++) { seeker_next_dir[curr_x][curr_y] = move_dir; curr_x += dx[move_dir]; curr_y += dy[move_dir]; seeker_rev_dir[curr_x][curr_y] = (move_dir &lt; 2) ? (move_dir + 2) : (move_dir - 2); // 이동하는 도중 (0, 0)으로 오게 되면, // 움직이는 것을 종료합니다. if(!curr_x &amp;&amp; !curr_y) break; } // 방향을 바꿉니다. move_dir = (move_dir + 1) % 4; // 만약 현재 방향이 위 혹은 아래가 된 경우에는 // 특정 방향으로 움직여야 할 횟수를 1 증가시킵니다. if(move_dir == 0 || move_dir == 2) move_num++; }}// 격자 내에 있는지를 판단합니다.bool InRange(int x, int y) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}void HiderMove(int x, int y, int move_dir) { // 좌우하상 순서대로 넣어줍니다. int dx[DIR_NUM] = {0 , 0, 1, -1}; int dy[DIR_NUM] = {-1, 1, 0, 0}; int nx = x + dx[move_dir], ny = y + dy[move_dir]; // Step 1. // 만약 격자를 벗어난다면 // 우선 방향을 틀어줍니다. if(!InRange(nx, ny)) { // 0 &lt;-&gt; 1 , 2 &lt;-&gt; 3이 되어야 합니다. move_dir = (move_dir &lt; 2) ? (1 - move_dir) : (5 - move_dir); nx = x + dx[move_dir]; ny = y + dy[move_dir]; } // Step 2. // 그 다음 위치에 술래가 없다면 움직여줍니다. if(make_pair(nx, ny) != seeker_pos) next_hiders[nx][ny].push_back(move_dir); // 술래가 있다면 더 움직이지 않습니다. else next_hiders[x][y].push_back(move_dir);}int DistFromSeeker(int x, int y) { // 현재 술래의 위치를 불러옵니다. int seeker_x, seeker_y; tie(seeker_x, seeker_y) = seeker_pos; return abs(seeker_x - x) + abs(seeker_y - y);}void HiderMoveAll() { // Step 1. next hider를 초기화해줍니다. for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) next_hiders[i][j].clear(); // Step 2. hider를 전부 움직여줍니다. for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { // 술래와의 거리가 3 이내인 도망자들에 대해서만 // 움직여줍니다. if(DistFromSeeker(i, j) &lt;= 3) { for(int k = 0; k &lt; (int) hiders[i][j].size(); k++) HiderMove(i, j, hiders[i][j][k]); } // 그렇지 않다면 현재 위치 그대로 넣어줍니다. else { for(int k = 0; k &lt; (int) hiders[i][j].size(); k++) next_hiders[i][j].push_back(hiders[i][j][k]); } } // Step 3. next hider값을 옮겨줍니다. for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) hiders[i][j] = next_hiders[i][j];}// 현재 술래가 바라보는 방향을 가져옵니다.int GetSeekerDir() { // 현재 술래의 위치를 불러옵니다. int x, y; tie(x, y) = seeker_pos; // 어느 방향으로 움직여야 하는지에 대한 정보를 가져옵니다. int move_dir; if(forward_facing) move_dir = seeker_next_dir[x][y]; else move_dir = seeker_rev_dir[x][y]; return move_dir;}void CheckFacing() { // Case 1. 정방향으로 끝에 다다른 경우라면, 방향을 바꿔줍니다. if(seeker_pos == make_pair(0, 0) &amp;&amp; forward_facing) forward_facing = false; // Case 2. 역방향으로 끝에 다다른 경우여도, 방향을 바꿔줍니다. if(seeker_pos == make_pair(n / 2, n / 2) &amp;&amp; !forward_facing) forward_facing = true;}void SeekerMove() { int x, y; tie(x, y) = seeker_pos; // 상우하좌 순서대로 넣어줍니다. int dx[DIR_NUM] = {-1, 0, 1, 0}; int dy[DIR_NUM] = {0 , 1, 0, -1}; int move_dir = GetSeekerDir(); // 술래를 한 칸 움직여줍니다. seeker_pos = make_pair(x + dx[move_dir], y + dy[move_dir]); // 끝에 도달했다면 방향을 바꿔줘야 합니다. CheckFacing();}void GetScore(int t) { // 상우하좌 순서대로 넣어줍니다. int dx[DIR_NUM] = {-1, 0, 1, 0}; int dy[DIR_NUM] = {0 , 1, 0, -1}; // 현재 술래의 위치를 불러옵니다. int x, y; tie(x, y) = seeker_pos; // 술래의 방향을 불러옵니다. int move_dir = GetSeekerDir(); // 3칸을 바라봅니다. for(int dist = 0; dist &lt; 3; dist++) { int nx = x + dist * dx[move_dir], ny = y + dist * dy[move_dir]; // 격자를 벗어나지 않으며 나무가 없는 위치라면 // 도망자들을 전부 잡게 됩니다. if(InRange(nx, ny) &amp;&amp; !tree[nx][ny]) { // 해당 위치의 도망자 수 만큼 점수를 얻게 됩니다. ans += t * (int) hiders[nx][ny].size(); // 도망자들이 사라지게 됩니다. hiders[nx][ny].clear(); } }}void Simulate(int t) { // 도망자가 움직입니다. HiderMoveAll(); // 술래가 움직입니다. SeekerMove(); // 점수를 얻습니다. GetScore(t);}int main() { // 입력: cin &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; k; // 술래 정보를 입력받습니다. while(m--) { int x, y, d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; hiders[x - 1][y - 1].push_back(d); } // 나무 정보를 입력받습니다. while(h--) { int x, y; cin &gt;&gt; x &gt;&gt; y; tree[x - 1][y - 1] = true; } // 술래의 처음 위치를 설정합니다. seeker_pos = make_pair(n / 2, n / 2); // 술래잡기 시작 전에 // 구현상의 편의를 위해 // 술래 경로 정보를 미리 계산합니다. InitializeSeekerPath(); // k번에 걸쳐 술래잡기를 진행합니다. for(int t = 1; t &lt;= k; t++) Simulate(t); cout &lt;&lt; ans; return 0;}" }, { "title": "싸움땅", "url": "/posts/%EC%8B%B8%EC%9B%80%EB%95%85/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-13 00:00:00 +0900", "snippet": "싸움땅인기 게임인 싸움땅은 다음과 같은 방식으로 진행됩니다. 게임은 n * n 크기의 격자에서 진행되며, 각각의 격자에는 무기들이 있을 수 있습니다. 초기에는 무기들이 없는 빈 격자에 플레이어들이 위치하며 각 플레이어는 초기 능력치를 가집니다. 각 플레이어의 초기 능력치는 모두 다릅니다. 게임은 다음과 같은 방식으로 진행됩니다.아래 그림에서 빨간색 배경의 숫자는 총의 경우 공격력을, 플레이어의 경우 초기 능력치를 의미하며, 노란색 배경의 숫자는 플레이어의 번호를 의미합니다.하나의 라운드는 다음의 과정에 걸쳐 진행됩니다.1-1. 첫 번째 플레이어부터 순차적으로 본인이 향하고 있는 방향대로 한 칸만큼 이동합니다. 만약 해당 방향으로 나갈 때 격자를 벗어나는 경우에는 정반대 방향으로 방향을 바꾸어서 1만큼 이동합니다.2-1. 만약 이동한 방향에 플레이어가 없다면 해당 칸에 총이 있는지 확인합니다. 총이 있는 경우, 해당 플레이어는 총을 획득합니다. 플레이어가 이미 총을 가지고 있는 경우에는 놓여있는 총들과 플레이어가 가지고 있는 총 가운데 공격력이 더 쎈 총을 획득하고, 나머지 총들은 해당 격자에 둡니다.2-2-1. 만약 이동한 방향에 플레이어가 있는 경우에는 두 플레이어가 싸우게 됩니다. 해당 플레이어의 초기 능력치와 가지고 있는 총의 공격력의 합을 비교하여 더 큰 플레이어가 이기게 됩니다. 만일 이 수치가 같은 경우에는 플레이어의 초기 능력치가 높은 플레이어가 승리하게 됩니다. 이긴 플레이어는 각 플레이어의 초기 능력치와 가지고 있는 총의 공격력의 합의 차이만큼을 포인트로 획득하게 됩니다.2-2-2. 진 플레이어는 본인이 가지고 있는 총을 해당 격자에 내려놓고, 해당 플레이어가 원래 가지고 있던 방향대로 한 칸 이동합니다. 만약 이동하려는 칸에 다른 플레이어가 있거나 격자 범위 밖인 경우에는 오른쪽으로 90도씩 회전하여 빈 칸이 보이는 순간 이동합니다. 만약 해당 칸에 총이 있다면, 해당 플레이어는 가장 공격력이 높은 총을 획득하고 나머지 총들은 해당 격자에 내려 놓습니다.2-2-3. 이긴 플레이어는 승리한 칸에 떨어져 있는 총들과 원래 들고 있던 총 중 가장 공격력이 높은 총을 획득하고, 나머지 총들은 해당 격자에 내려 놓습니다.위 과정을 1번부터 n번 플레이어까지 순차적으로 한 번씩 진행하면 1 라운드가 끝나게 되고, 그 결과는 다음과 같습니다.1번 라운드에 걸쳐 전체 플레이어가 획득한 포인트는 1번 사람부터 n번 사람까지 순서대로 [1, 0, 0, 0]입니다.위의 과정을 한번더 반복하여 나온 2번 라운드 결과는 다음과 같으며, 2번 라운드 이후 획득한 포인트 역시 1번 라운드와 동일하게 [1, 0, 0, 0]이 됩니다.k 라운드 동안 게임을 진행하면서 각 플레이어들이 획득한 포인트를 출력하는 프로그램을 작성해보세요. 공격자의 공격위에서 선정된 공격자는 자신을 제외한 가장 강한 포탑을 공격합니다.가장 강한 포탑은 위에서 정한 가장 약한 포탑 선정 기준의 반대이며, 다음과 같습니다.공격력이 가장 높은 포탑이 가장 강한 포탑입니다.만약 공격력이 가장 높은 포탑이 2개 이상이라면, 공격한지 가장 오래된 포탑이 가장 강한 포탑입니다. (모든 포탑은 시점 0에 모두 공격한 경험이 있다고 가정하겠습니다.)만약 그러한 포탑이 2개 이상이라면, 각 포탑 위치의 행과 열의 합이 가장 작은 포탑이 가장 강한 포탑입니다.만약 그러한 포탑이 2개 이상이라면, 각 포탑 위치의 열 값이 가장 작은 포탑이 가장 강한 포탑입니다.위의 예시에서 공격 대상자를 선정해보겠습니다. 공격 대상인 가장 강한 포탑은 공격력이 가장 큰 26의 공격력을 가진 (3,4) 위치의 포탑이 됩니다.공격을 할 때에는 레이저 공격을 먼저 시도하고, 만약 그게 안 된다면 포탄 공격을 합니다. 각 공격의 규칙은 다음과 같습니다.(1) 레이저 공격레이저는 다음의 규칙으로 움직입니다.상하좌우의 4개의 방향으로 움직일 수 있습니다.부서진 포탑이 있는 위치는 지날 수 없습니다.가장자리에서 막힌 방향으로 진행하고자 한다면, 반대편으로 나옵니다. (예를 들어, 위의 예시에서 (2,3)에서 오른쪽으로 두번 이동한다면, (2,3) -&gt; (2,4) -&gt; (2,1) 순으로 이동합니다.)레이저 공격은 공격자의 위치에서 공격 대상 포탑까지의 최단 경로로 공격합니다. 만약 그러한 경로가 존재하지 않는다면 (2) 포탄 공격을 진행합니다. 만약 경로의 길이가 똑같은 최단 경로가 2개 이상이라면, 우/하/좌/상의 우선순위대로 먼저 움직인 경로가 선택됩니다.최단 경로가 정해졌으면, 공격 대상에는 공격자의 공격력 만큼의 피해를 입히며, 피해를 입은 포탑은 해당 수치만큼 공격력이 줄어듭니다. 또한 공격 대상을 제외한 레이저 경로에 있는 포탑도 공격을 받게 되는데, 이 포탑은 공격자 공격력의 절반 만큼의 공격을 받습니다. (절반이라 함은 공격력을 2로 나눈 몫을 의미합니다.)(2) 포탄 공격공격 대상에 포탄을 던집니다. 공격 대상은 공격자 공격력 만큼의 피해를 받습니다. 추가적으로 주위 8개의 방향에 있는 포탑도 피해를 입는데, 공격자 공격력의 절반 만큼의 피해를 받습니다. (절반이라 함은 공격력을 2로 나눈 몫을 의미합니다.) 공격자는 해당 공격에 영향을 받지 않습니다. 만약 가장자리에 포탄이 떨어졌다면, 위에서의 레이저 이동처럼 포탄의 추가 피해가 반대편 격자에 미치게 됩니다.위의 예시에서 공격자가 공격 대상을 레이저로 공격하기 위한 최단 경로는 아래 그림과 같습니다. 최단 경로가 2개 이상 있지만, 오른쪽으로 먼저 움직이는 것이 우선 순위가 높기 때문에, 다음의 경로가 선택된 것입니다. 최단 경로가 정해졌기 때문에, 공격 대상에는 9만큼의 피해를 입히고, 경로에 있는 포탑에는 4(=9/2) 만큼의 피해를 입힙니다. 포탑 부서짐공격을 받아 공격력이 0 이하가 된 포탑은 부서집니다. 포탑 정비공격이 끝났으면, 부서지지 않은 포탑 중 공격과 무관했던 포탑은 공격력이 1씩 올라갑니다. 공격과 무관하다는 뜻은 공격자도 아니고, 공격에 피해를 입은 포탑도 아니라는 뜻입니다. 위의 예시에서 공격과 무관했던 다음 4개의 포탑은 정비를 받아 공격력이 1씩 증가합니다. 이렇게 첫 번째 턴이 종료됩니다.다음 두 번째 턴이 시작되면, 다시 공격자 선정이 시작됩니다.첫 번째 규칙에 따라 가장 공격력이 작은 9 만큼의 공격력을 가진 (1,2), (2,1), (2,4), (3,1) 위치의 포탑이 공격자 후보가 됩니다. 두 번째 규칙에 의해 가장 최근에 공격한 포탑인 (1,2) 포탑이 가장 약한 포탑이므로 공격자로 선정됩니다. 마찬가지로 핸디캡으로 8 만큼의 공격력을 얻습니다.다음으로 공격 대상을 선택하면, 공격력이 가장 높은 (3,4)가 선택됩니다. 공격자의 위치에서 공격 대상의 위치까지 이동하는 경로가 없기 때문에, 레이저 공격은 불가능하여 포탄 공격을 수행하게 됩니다. 포탄은 공격 대상인 (3,4) 위치에 떨어지며, 공격 대상은 17만큼의 피해를 받고, 주변 8개의 방향에 있는 포탑은 8만큼의 피해를 받습니다.마지막으로 공격과 무관했던 포탑은 정비를 받아 1 만큼의 공격력을 얻지만, 위의 예시에서는 부서지지 않은 포탑 중 공격과 무관했던 포탑이 없으므로, 최종 모습은 다음과 같습니다.전체 과정이 종료된 후 남아있는 포탑 중 가장 강한 포탑의 공격력을 출력하는 프로그램을 작성해보세요.풀이 방법BFS로 최단거리에 있는 승객을 찾는다.BFS로 승객을 목적지까지 이동시킨다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct Player{\tint x;\tint y;\tint stat;\tint gun;\tint dir;\tint point;};int N, M, K, R = 0;// 상우하좌int dy[4] = {-1,0,1,0};int dx[4] = {0,1,0,-1};vector &lt;int&gt; gun[21][21];Player player[31];int ploc[21][21];// 내림차순 정렬bool compare(int a, int b){ return a &gt; b;}void get_gun(int y, int x, int idx){ if(player[idx].gun &lt; gun[y][x][0]) { // 총 변경 int temp = player[idx].gun; player[idx].gun = gun[y][x][0]; gun[y][x][0] = temp; // 공격력이 가장쎈 총이 가장 처음에 오도록 정렬 sort(gun[y][x].begin(), gun[y][x].end(), compare); }}void fight(int y, int x, int p, int idx){ int win, lose, score = 0;\tint scoreA = player[idx].stat + player[idx].gun;\tint scoreB = player[p].stat + player[p].gun; if(scoreA == scoreB) { if(player[idx].stat &gt; player[p].stat) { win = idx; lose = p; } else { win = p; lose = idx; } } else if(scoreA &gt; scoreB) { win = idx; lose = p; score = scoreA - scoreB; } else { win = p; lose = idx; score = scoreB - scoreA; } //진 플레이어는 본인이 가지고 있는 총을 해당 격자에 내려놓고, 해당 플레이어가 원래 가지고 있던 방향대로 한 칸 이동합니다 gun[y][x].push_back(player[lose].gun); // 공격력이 가장쎈 총이 가장 처음에 오도록 정렬 sort(gun[y][x].begin(), gun[y][x].end(), compare); player[lose].gun = 0; int n_dir; // 진 플레이어의 이동 for(int k = 0; k &lt; 4; k++) { n_dir = (player[lose].dir + k) % 4; int ny = y + dy[n_dir]; int nx = x + dx[n_dir]; // 격자 밖일 경우 넘어가서 계속해서 오른쪽으로 90도 회전한다 // if (ny &lt;= 0 || ny &gt; N || nx &lt;= 0 || nx &gt; N || ploc[ny][nx]) {\t\t// \tcontinue;\t\t// } if(ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N || ploc[ny][nx] ) { continue; } player[lose].y = ny; player[lose].x = nx; player[lose].dir = n_dir; ploc[ny][nx] = lose; get_gun(ny, nx, lose); break; } // 패배자의 이동 이후 승리자의 위치 업데이트 및 총 변경 ploc[y][x] = win; player[win].y = y; player[win].x = x; get_gun(y, x, win); // 스코어 업데이트 player[win].point += score;}void simulate(){ while(++R &lt;= K) { for(int i = 1; i &lt;= M; i++) { int ny = player[i].y + dy[player[i].dir]; int nx = player[i].x + dx[player[i].dir]; if (ny &lt; 1 || ny &gt; N || nx &lt; 1 || nx &gt; N) { player[i].dir = (player[i].dir + 2) % 4; ny = player[i].y + dy[player[i].dir]; nx = player[i].x + dx[player[i].dir]; } //이동한 방향에 플레이어가 없는 경우(총 주움) if(ploc[ny][nx] == 0) { // 기존 사람 위치는 초기화 ploc[player[i].y][player[i].x] = 0; ploc[ny][nx] = i; player[i].y = ny; player[i].x = nx; get_gun(ny, nx, i); } //이동한 방향에 플레이어가 있는 경우(싸움) else { ploc[player[i].y][player[i].x] = 0; fight(ny, nx, ploc[ny][nx], i); } } }}int main() { int g, y, x, d, s; scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K); for(int i = 1; i &lt;= N; i++) { for(int j = 1; j &lt;= N; j++) { scanf(\"%d\", &amp;g); gun[i][j].push_back(g); } } for(int i = 1; i &lt;= M; i++) { scanf(\"%d %d %d %d\", &amp;y, &amp;x, &amp;d, &amp;s); player[i].y = y; player[i].x = x; player[i].dir = d; player[i].stat = s; player[i].gun = 0; player[i].point = 0; ploc[y][x] = i; } simulate(); for(int i = 1; i &lt;= M; i++) { printf(\"%d \", player[i].point); } printf(\"\\n\"); return 0;}정답코드#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;tuple&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#define MAX_N 20#define MAX_M 30#define DIR_NUM 4#define Player tuple&lt;int, int, int, int, int, int&gt;#define EMPTY make_tuple(-1, -1, -1, -1, -1, -1)using namespace std;// 변수 선언int n, m, k;// 각 칸마다 놓여있는 총 목록을 관리합니다.vector&lt;int&gt; gun[MAX_N][MAX_N];// 각 칸마다 플레이어 정보를 관리합니다.// 순서대로 (num, x, y, d, s, a) 정보를 관리합니다.// (x, y)위치에서 방향 d를 보고 있으며// 초기 능력치가 s인 num번 플레이어가// 공격력이 a인 총을 들고 있음을 뜻합니다.// 총이 없으면 a는 0입니다.Player players[MAX_M];// 입력으로 주어지는// 방향 순서대로 // dx, dy를 정의합니다.// ↑, →, ↓, ←int dx[DIR_NUM] = {-1, 0, 1, 0};int dy[DIR_NUM] = { 0, 1, 0, -1};// 플레이어들의 포인트 정보를 기록합니다.int points[MAX_M];// (x, y)가 격자를 벗어나는지 확인합니다.bool InRange(int x, int y) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}// 현재 (x, y)위치에서 방향 d를 보고 있을 때// 그 다음 위치와 방향을 찾아줍니다.tuple&lt;int, int, int&gt; GetNext(int x, int y, int d) { int nx = x + dx[d], ny = y + dy[d]; // 격자를 벗어나면 // 방향을 뒤집어 // 반대 방향으로 한 칸 이동합니다. if(!InRange(nx, ny)) { // 반대 방향 : 0 &lt;-&gt; 2 / 1 &lt;-&gt; 3 d = (d &lt; 2) ? (d + 2) : (d - 2); nx = x + dx[d], ny = y + dy[d]; } return make_tuple(nx, ny, d);}// 해당 칸에 있는 Player를 찾아줍니다.// 없다면 EMPTY를 반환합니다.Player FindPlayer(pair&lt;int, int&gt; pos) { for(int i = 0; i &lt; m; i++) { int x, y; tie(ignore, x, y, ignore, ignore, ignore) = players[i]; if(pos == make_pair(x, y)) return players[i]; } return EMPTY;}// Player p의 정보를 갱신해줍니다.void Update(Player p) { int num; tie(num, ignore, ignore, ignore, ignore, ignore) = p; // Player의 위치를 찾아 // 값을 갱신해줍니다. for(int i = 0; i &lt; m; i++) { int num_i; tie(num_i, ignore, ignore, ignore, ignore, ignore) = players[i]; if(num_i == num) { players[i] = p; break; } }}// 플레이어 p를 pos 위치로 이동시켜줍니다.void Move(Player p, pair&lt;int, int&gt; pos) { int num, x, y, d, s, a; tie(num, x, y, d, s, a) = p; int nx, ny; tie(nx, ny) = pos; // 가장 좋은 총으로 갱신해줍니다. gun[nx][ny].push_back(a); sort(gun[nx][ny].begin(), gun[nx][ny].end(), greater&lt;int&gt;()); a = gun[nx][ny][0]; gun[nx][ny].erase(gun[nx][ny].begin()); p = make_tuple(num, nx, ny, d, s, a); Update(p);}// 진 사람의 움직임을 진행합니다.// 결투에서 패배한 위치는 pos입니다.void LoserMove(Player p) { int num, x, y, d, s, a; tie(num, x, y, d, s, a) = p; // 먼저 현재 위치에 총을 내려놓게 됩니다. gun[x][y].push_back(a); // 빈 공간을 찾아 이동하게 됩니다. // 현재 방향에서 시작하여 // 90'씩 시계방향으로 // 회전하다가 // 비어있는 최초의 곳으로 이동합니다. for(int i = 0; i &lt; 4; i++) { int ndir = (d + i) % 4; int nx = x + dx[ndir], ny = y + dy[ndir]; if(InRange(nx, ny) &amp;&amp; FindPlayer(make_pair(nx, ny)) == EMPTY) { p = make_tuple(num, x, y, ndir, s, 0); Move(p, make_pair(nx, ny)); break; } }}// p2과 p2가 pos에서 만나 결투를 진행합니다.void Duel(Player p1, Player p2, pair&lt;int, int&gt; pos) { int num1, d1, s1, a1; tie(num1, ignore, ignore, d1, s1, a1) = p1; int num2, d2, s2, a2; tie(num2, ignore, ignore, d2, s2, a2) = p2; // (초기 능력치 + 총의 공격력, 초기 능력치) 순으로 우선순위를 매겨 비교합니다. // p1이 이긴 경우 if(make_pair(s1 + a1, s1) &gt; make_pair(s2 + a2, s2)) { // p1은 포인트를 얻게 됩니다. points[num1] += (s1 + a1) - (s2 + a2); // p2는 진 사람의 움직임을 진행합니다. LoserMove(p2); // 이후 p1은 이긴 사람의 움직임을 진행합니다. Move(p1, pos); } // p2가 이긴 경우 else { // p2는 포인트를 얻게 됩니다. points[num2] += (s2 + a2) - (s1 + a1); // p1은 진 사람의 움직임을 진행합니다. LoserMove(p1); // 이후 p2는 이긴 사람의 움직임을 진행합니다. Move(p2, pos); }}// 1라운드를 진행합니다.void Simulate() { // 첫 번째 플레이어부터 순서대로 진행합니다. for(int i = 0; i &lt; m; i++) { int num, x, y, d, s, a; tie(num, x, y, d, s, a) = players[i]; // Step 1-1. 현재 플레이어가 움직일 그 다음 위치와 방향을 구합니다. int nx, ny, ndir; tie(nx, ny, ndir) = GetNext(x, y, d); // 해당 위치에 있는 전 플레이어 정보를 얻어옵니다. Player next_player = FindPlayer(make_pair(nx, ny)); // 현재 플레이어의 위치와 방향을 보정해줍니다. Player curr_player = make_tuple(num, nx, ny, ndir, s, a); Update(curr_player); // Step 2. 해당 위치로 이동해봅니다. // Step 2-1. 해당 위치에 플레이어가 없다면 그대로 움직입니다. if(next_player == EMPTY) Move(curr_player, make_pair(nx, ny)); // Step 2-2. 해당 위치에 플레이어가 있다면 결투를 진행합니다. else Duel(curr_player, next_player, make_pair(nx, ny)); }}int main() { // 입력: cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { int num; cin &gt;&gt; num; // 총이 놓여 있는 칸입니다. if(num != 0) gun[i][j].push_back(num); } // 플레이어 정보를 입력받습니다. for(int i = 0; i &lt; m; i++) { int x, y, d, s; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d &gt;&gt; s; players[i] = make_tuple(i, x - 1, y - 1, d, s, 0); } // k번에 걸쳐 시뮬레이션을 진행합니다. while(k--) Simulate(); // 각 플레이어가 획득한 포인트를 출력합니다. for(int i = 0; i &lt; m; i++) cout &lt;&lt; points[i] &lt;&lt; \" \"; return 0;}" }, { "title": "포탑부수기", "url": "/posts/%ED%8F%AC%ED%83%91%EB%B6%80%EC%88%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-12 00:00:00 +0900", "snippet": "포탑부수기N×M 격자가 있고, 모든 위치에는 포탑이 존재합니다. (즉, 포탑의 개수는 NM개)각 포탑에는 공격력이 존재하며, 상황에 따라 공격력이 줄어들거나 늘어날 수 있습니다. 또한, 공격력이 0 이하가 된다면, 해당 포탑은 부서지며 더 이상의 공격을 할 수 없습니다. 최초에 공격력이 0인 포탑 즉, 부서진 포탑이 존재할 수 있습니다.아래와 같은 4×4 크기의 격자를 생각해보겠습니다. (1,1), (2,2), (3,2) 를 포함한 총 7개의 칸은 이미 부서진 포탑을 의미합니다.하나의 턴은 다음의 4가지 액션을 순서대로 수행하며, 총 K번 반복됩니다.만약 부서지지 않은 포탑이 1개가 된다면 그 즉시 중지됩니다. 공격자 선정부서지지 않은 포탑 중 가장 약한 포탑이 공격자로 선정됩니다. 공격자로 선정되면 가장 약한 포탑이므로, 핸디캡이 적용되어 N+M만큼의 공격력이 증가됩니다.가장 약한 포탑은 다음의 기준으로 선정됩니다.공격력이 가장 낮은 포탑이 가장 약한 포탑입니다.만약 공격력이 가장 낮은 포탑이 2개 이상이라면, 가장 최근에 공격한 포탑이 가장 약한 포탑입니다. (모든 포탑은 시점 0에 모두 공격한 경험이 있다고 가정하겠습니다.)만약 그러한 포탑이 2개 이상이라면, 각 포탑 위치의 행과 열의 합이 가장 큰 포탑이 가장 약한 포탑입니다.만약 그러한 포탑이 2개 이상이라면, 각 포탑 위치의 열 값이 가장 큰 포탑이 가장 약한 포탑입니다.위의 예시에서 공격자를 선정해보면, 가장 낮은 공격력은 1이기 때문에, 아래 그림과 같이 (1,2) 위치에 있는 포탑이 공격자로 선정되며, 공격력이 8(=4(N)+4(M))만큼 증가하여 9가 됩니다. 공격자의 공격위에서 선정된 공격자는 자신을 제외한 가장 강한 포탑을 공격합니다.가장 강한 포탑은 위에서 정한 가장 약한 포탑 선정 기준의 반대이며, 다음과 같습니다.공격력이 가장 높은 포탑이 가장 강한 포탑입니다.만약 공격력이 가장 높은 포탑이 2개 이상이라면, 공격한지 가장 오래된 포탑이 가장 강한 포탑입니다. (모든 포탑은 시점 0에 모두 공격한 경험이 있다고 가정하겠습니다.)만약 그러한 포탑이 2개 이상이라면, 각 포탑 위치의 행과 열의 합이 가장 작은 포탑이 가장 강한 포탑입니다.만약 그러한 포탑이 2개 이상이라면, 각 포탑 위치의 열 값이 가장 작은 포탑이 가장 강한 포탑입니다.위의 예시에서 공격 대상자를 선정해보겠습니다. 공격 대상인 가장 강한 포탑은 공격력이 가장 큰 26의 공격력을 가진 (3,4) 위치의 포탑이 됩니다.공격을 할 때에는 레이저 공격을 먼저 시도하고, 만약 그게 안 된다면 포탄 공격을 합니다. 각 공격의 규칙은 다음과 같습니다.(1) 레이저 공격레이저는 다음의 규칙으로 움직입니다.상하좌우의 4개의 방향으로 움직일 수 있습니다.부서진 포탑이 있는 위치는 지날 수 없습니다.가장자리에서 막힌 방향으로 진행하고자 한다면, 반대편으로 나옵니다. (예를 들어, 위의 예시에서 (2,3)에서 오른쪽으로 두번 이동한다면, (2,3) -&gt; (2,4) -&gt; (2,1) 순으로 이동합니다.)레이저 공격은 공격자의 위치에서 공격 대상 포탑까지의 최단 경로로 공격합니다. 만약 그러한 경로가 존재하지 않는다면 (2) 포탄 공격을 진행합니다. 만약 경로의 길이가 똑같은 최단 경로가 2개 이상이라면, 우/하/좌/상의 우선순위대로 먼저 움직인 경로가 선택됩니다.최단 경로가 정해졌으면, 공격 대상에는 공격자의 공격력 만큼의 피해를 입히며, 피해를 입은 포탑은 해당 수치만큼 공격력이 줄어듭니다. 또한 공격 대상을 제외한 레이저 경로에 있는 포탑도 공격을 받게 되는데, 이 포탑은 공격자 공격력의 절반 만큼의 공격을 받습니다. (절반이라 함은 공격력을 2로 나눈 몫을 의미합니다.)(2) 포탄 공격공격 대상에 포탄을 던집니다. 공격 대상은 공격자 공격력 만큼의 피해를 받습니다. 추가적으로 주위 8개의 방향에 있는 포탑도 피해를 입는데, 공격자 공격력의 절반 만큼의 피해를 받습니다. (절반이라 함은 공격력을 2로 나눈 몫을 의미합니다.) 공격자는 해당 공격에 영향을 받지 않습니다. 만약 가장자리에 포탄이 떨어졌다면, 위에서의 레이저 이동처럼 포탄의 추가 피해가 반대편 격자에 미치게 됩니다.위의 예시에서 공격자가 공격 대상을 레이저로 공격하기 위한 최단 경로는 아래 그림과 같습니다. 최단 경로가 2개 이상 있지만, 오른쪽으로 먼저 움직이는 것이 우선 순위가 높기 때문에, 다음의 경로가 선택된 것입니다. 최단 경로가 정해졌기 때문에, 공격 대상에는 9만큼의 피해를 입히고, 경로에 있는 포탑에는 4(=9/2) 만큼의 피해를 입힙니다. 포탑 부서짐공격을 받아 공격력이 0 이하가 된 포탑은 부서집니다. 포탑 정비공격이 끝났으면, 부서지지 않은 포탑 중 공격과 무관했던 포탑은 공격력이 1씩 올라갑니다. 공격과 무관하다는 뜻은 공격자도 아니고, 공격에 피해를 입은 포탑도 아니라는 뜻입니다. 위의 예시에서 공격과 무관했던 다음 4개의 포탑은 정비를 받아 공격력이 1씩 증가합니다. 이렇게 첫 번째 턴이 종료됩니다.다음 두 번째 턴이 시작되면, 다시 공격자 선정이 시작됩니다.첫 번째 규칙에 따라 가장 공격력이 작은 9 만큼의 공격력을 가진 (1,2), (2,1), (2,4), (3,1) 위치의 포탑이 공격자 후보가 됩니다. 두 번째 규칙에 의해 가장 최근에 공격한 포탑인 (1,2) 포탑이 가장 약한 포탑이므로 공격자로 선정됩니다. 마찬가지로 핸디캡으로 8 만큼의 공격력을 얻습니다.다음으로 공격 대상을 선택하면, 공격력이 가장 높은 (3,4)가 선택됩니다. 공격자의 위치에서 공격 대상의 위치까지 이동하는 경로가 없기 때문에, 레이저 공격은 불가능하여 포탄 공격을 수행하게 됩니다. 포탄은 공격 대상인 (3,4) 위치에 떨어지며, 공격 대상은 17만큼의 피해를 받고, 주변 8개의 방향에 있는 포탑은 8만큼의 피해를 받습니다.마지막으로 공격과 무관했던 포탑은 정비를 받아 1 만큼의 공격력을 얻지만, 위의 예시에서는 부서지지 않은 포탑 중 공격과 무관했던 포탑이 없으므로, 최종 모습은 다음과 같습니다.전체 과정이 종료된 후 남아있는 포탑 중 가장 강한 포탑의 공격력을 출력하는 프로그램을 작성해보세요.풀이 방법BFS로 최단거리에 있는 승객을 찾는다.BFS로 승객을 목적지까지 이동시킨다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LEN_2D_MAX 21using namespace std;int N, M, K;int min_y, min_x, str_y, str_x;int dy[4] = { 0, 1, 0, -1 };int dx[4] = { 1, 0, -1, 0 };//우/하/좌/상int ddy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };int ddx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };struct turret { int y; int x; int atk; int last;};turret arr[11][11];int atk_route[11][11];// 1. 공격자 선정void sel_attacker(){ turret weak = { 8754321, 8764321, 8764321, 8765421 }; for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= M; j++) { if (arr[i][j].atk &lt;= 0) continue; if (weak.atk &gt; arr[i][j].atk) { weak = arr[i][j]; } else if (weak.atk == arr[i][j].atk) { if (weak.last &lt; arr[i][j].atk) { weak = arr[i][j]; } else if (weak.last == arr[i][j].last) { if (weak.y + weak.x &lt; i + j) { weak = arr[i][j]; } else if (weak.y + weak.x == i + j) { if (weak.x &lt; j) { weak = arr[i][j]; } } } } } } min_y = weak.y; min_x = weak.x; return;}// 2. 공격자의 공격void atk_cmd(){ turret strong = { 0, 0, 0, 0}; for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= M; j++) { if (arr[i][j].atk &lt;= 0) continue; if (strong.atk &lt; arr[i][j].atk) { strong = arr[i][j]; } else if (strong.atk == arr[i][j].atk) { if (strong.last &gt; arr[i][j].last) { strong = arr[i][j]; } else if (strong.last == arr[i][j].last) { if (strong.y + strong.x &gt; i + j) { strong = arr[i][j]; } else if (strong.y + strong.x == i + j) { if (strong.x &gt; j) { strong = arr[i][j]; } } } } } } str_y = strong.y; str_x = strong.x; return;}bool razer(int y, int x){ int isivisited[11][11] = { 0 }; int py[11][11] = { 0 }; int px[11][11] = { 0 }; queue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; q; bool flag = false; q.push(make_pair(make_pair(y, x), 0)); isivisited[y][x] = 1; while (!q.empty()) { int cy = q.front().first.first; int cx = q.front().first.second; int turn = q.front().second; q.pop(); // 공격 목표에 도달했을 때 if (cy == str_y &amp;&amp; cx== str_x) { flag = true; break; } for (int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if (ny &lt; 1) ny = N; else if (ny &gt; N) ny = 1; if (nx &lt; 1) nx = M; else if (nx &gt; M) nx = 1; if (isivisited[ny][nx] == 1 || arr[y][x].atk &lt;= 0) continue; isivisited[ny][nx] = 1; q.push(make_pair(make_pair(ny, nx), turn + 1)); // 레이저 경로 저장 py[ny][nx] = cy; px[ny][nx] = cx; } } if (flag == true) { arr[str_y][str_x].atk -= arr[min_y][min_x].atk; atk_route[str_y][str_x] = 1; int cy = py[str_y][str_x]; int cx = px[str_y][str_x]; atk_route[cy][cx] = 1; while (!(cy == min_y &amp;&amp; cx == min_x)) { arr[cy][cx].atk -= (arr[min_y][min_x].atk / 2); int ny = py[cy][cx]; int nx = px[cy][cx]; cy = ny; cx = nx; atk_route[cy][cx] = 1; } } return flag;}void bomb(int y, int x){ arr[y][x].atk -= arr[min_y][min_x].atk; atk_route[y][x] = 1; for (int dir = 0; dir &lt; 8; dir++) { int ny = y + ddy[dir]; int nx = x + ddx[dir]; if (ny &lt; 1) ny = N; else if (ny &gt; N) ny = 1; if (nx &lt; 1) nx = M; else if (nx &gt; M) nx = 1; // 공격력이 0이거나 공격자이거나 if (arr[ny][nx].atk &lt;= 0 || (ny == min_y &amp;&amp; nx == min_x)) continue; arr[ny][nx].atk -= (arr[min_y][min_x].atk / 2); atk_route[ny][nx] = 1; } return;}// 4. 포탑 정비void fix_turret(){ for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= M; j++) { if (min_y == i &amp;&amp; min_x == j) continue; if (str_y == i &amp;&amp; str_x == j) continue; if (atk_route[i][j] == 1) continue; if (arr[i][j].atk &lt;= 0) continue; arr[i][j].atk++; } } return;}void clear_var(){ min_y = 0; min_x = 0; str_y = 0; str_x = 0; memset(atk_route, 0x0, sizeof(atk_route));}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K); int atk_in; for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= M; j++) { scanf(\"%d\", &amp;atk_in); arr[i][j] = { i, j, atk_in, 0 }; } } int turn = 1; while (K &gt;= turn) { clear_var(); sel_attacker(); atk_cmd(); // 공격자로 선정되면 가장 약한 포탑이므로, 핸디캡이 적용되어 N+M만큼의 공격력이 증가됩니다. arr[min_y][min_x].atk += (N + M); // 공격당한 시간(턴) arr[min_y][min_x].last = turn; bool razer_atk = razer(min_y, min_x); if (razer_atk == false) { bomb(str_y, str_x); } // 종료조건 체크 (포탑공격력이 모두 0일 때) int cnt = 0; for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= M; j++) { if (arr[i][j].atk &gt; 0) { cnt++; } } } if (cnt == 1) { break; } fix_turret(); turn++; } for (int i = 1; i &lt;= N; i++) { for (int j = 1; j &lt;= M; j++) { printf(\"%d \", arr[i][j].atk); } printf(\"\\n\"); } printf(\"%d %d\\n\", str_y, str_x); printf(\"%d\\n\", arr[str_y][str_x].atk); return 0;}정답코드#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;tuple&gt;using namespace std;#define MAX_N 10const int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};const int dx2[9] = {0, 0, 0, -1, -1, -1, 1, 1, 1}, dy2[9] = {0, -1, 1, 0, -1, 1, 0, -1, 1};int n, m, k;int turn;// 현재 포탑들이 가진 힘과 언제 각성했는지 기록해줍니다.int board[MAX_N][MAX_N];int rec[MAX_N][MAX_N];// 빛의 공격을 할 때 방문 여부와 경로 방향을 기록해줍니다.bool vis[MAX_N][MAX_N];int back_x[MAX_N][MAX_N], back_y[MAX_N][MAX_N];// 공격과 무관했는지 여부를 저장합니다.bool is_active[MAX_N][MAX_N];// 구조체 turret을 정의해 관리합니다.struct Turret{ int x, y, r, p;};// 살아있는 포탑들을 관리합니다.vector&lt;Turret&gt; live_turret;// turret의 약함, 강함 우선순위에 맞게 정렬함수를 만들어줍니다.bool cmp(Turret a, Turret b) { if(a.p != b.p) return a.p &lt; b.p; if(a.r != b.r) return a.r &gt; b.r; if(a.x + a.y != b.x + b.y) return a.x + a.y &gt; b.x + b.y; return a.y &gt; b.y;}// 턴을 진행하기 전 필요한 전처리를 정리해줍니다.void Init() { turn++; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) { vis[i][j] = false; is_active[i][j] = false; }}// 각성을 진행합니다.// 각성을 하면 가장 약한 포탑이 n + m만큼 강해집니다.void Awake() { // 우선순위에 맞게 현재 살아있는 포탑들을 정렬해줍니다. sort(live_turret.begin(), live_turret.end(), cmp); // 가장 약한 포탑을 찾아 n + m만큼 더해주고, // is_active와 live_turret 배열도 갱신해줍니다. Turret weak_turret = live_turret[0]; int x = weak_turret.x; int y = weak_turret.y; board[x][y] += n + m; rec[x][y] = turn; weak_turret.p = board[x][y]; weak_turret.r = rec[x][y]; is_active[x][y] = true; live_turret[0] = weak_turret;}// 레이저 공격을 진행합니다.bool LaserAttack() { // 기존에 정렬된 가장 앞선 포탑이 // 각성한 포탑입니다. Turret weak_turret = live_turret[0]; int sx = weak_turret.x; int sy = weak_turret.y; int pow = weak_turret.p; // 기존에 정렬된 가장 뒤 포탑이 // 각성한 포탑을 제외한 포탑 중 가장 강한 포탑입니다. Turret strong_turret = live_turret[(int) live_turret.size() - 1]; int ex = strong_turret.x; int ey = strong_turret.y; // bfs를 통해 최단경로를 관리해줍니다. queue&lt;pair&lt;int, int&gt; &gt; q; vis[sx][sy] = true; q.push(make_pair(sx, sy)); // 가장 강한 포탑에게 도달 가능한지 여부를 can_attack에 관리해줍니다. bool can_attack = false; while(!q.empty()) { int x, y; tie(x, y) = q.front(); q.pop(); // 가장 강한 포탑에게 도달할 수 있다면 // 바로 멈춥니다. if(x == ex &amp;&amp; y == ey) { can_attack = true; break; } // 각각 우, 하, 좌, 상 순서대로 방문하며 방문 가능한 포탑들을 찾고 // queue에 저장해줍니다. for(int dir = 0; dir &lt; 4; dir++) { int nx = (x + dx[dir] + n) % n; int ny = (y + dy[dir] + m) % m; // 이미 방문한 포탑이라면 넘어갑니다. if(vis[nx][ny]) continue; // 벽이라면 넘어갑니다. if(board[nx][ny] == 0) continue; vis[nx][ny] = true; back_x[nx][ny] = x; back_y[nx][ny] = y; q.push(make_pair(nx, ny)); } } // 만약 도달 가능하다면 공격을 진행합니다. if(can_attack) { // 우선 가장 강한 포탑에게는 pow만큼의 공격을 진행합니다. board[ex][ey] -= pow; if(board[ex][ey] &lt; 0) board[ex][ey] = 0; is_active[ex][ey] = true; // 기존의 경로를 역추적하며 // 경로 상에 있는 모든 포탑에게 pow / 2만큼의 공격을 진행합니다. int cx = back_x[ex][ey]; int cy = back_y[ex][ey]; while(!(cx == sx &amp;&amp; cy == sy)) { board[cx][cy] -= pow / 2; if(board[cx][cy] &lt; 0) board[cx][cy] = 0; is_active[cx][cy] = true; int next_cx = back_x[cx][cy]; int next_cy = back_y[cx][cy]; cx = next_cx; cy = next_cy; } } // 공격을 성공했는지 여부를 반환합니다. return can_attack;}// 레이저 공격을 하지 못했다면 폭탄 공격을 진행합니다.void BombAttack() { // 기존에 정렬된 가장 앞선 포탑이 // 각성한 포탑입니다. Turret weak_turret = live_turret[0]; int sx = weak_turret.x; int sy = weak_turret.y; int pow = weak_turret.p; // 기존에 정렬된 가장 뒤 포탑이 // 각성한 포탑을 제외한 포탑 중 가장 강한 포탑입니다. Turret strong_turret = live_turret[(int) live_turret.size() - 1]; int ex = strong_turret.x; int ey = strong_turret.y; // 가장 강한 포탑의 3 * 3 범위를 모두 탐색하며 // 각각에 맞는 공격을 진행합니다. for(int dir = 0; dir &lt; 9; dir++) { int nx = (ex + dx2[dir] + n) % n; int ny = (ey + dy2[dir] + m) % m; // 각성한 포탑 자기 자신일 경우 넘어갑니다. if(nx == sx &amp;&amp; ny == sy) continue; // 가장 강한 포탑일 경우 pow만큼의 공격을 진행합니다. if(nx == ex &amp;&amp; ny == ey) { board[nx][ny] -= pow; if(board[nx][ny] &lt; 0) board[nx][ny] = 0; is_active[nx][ny] = true; } // 그 외의 경우 pow / 2만큼의 공격을 진행합니다. else { board[nx][ny] -= pow / 2; if(board[nx][ny] &lt; 0) board[nx][ny] = 0; is_active[nx][ny] = true; } }}// 공격에 관여하지 않은 모든 살아있는 포탑의 힘을 1 증가시킵니다.void Reserve() { for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { if(is_active[i][j]) continue; if(board[i][j] == 0) continue; board[i][j]++; } }}int main() { // 입력: cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; board[i][j]; // k턴 동안 진행됩니다. while(k--) { // 턴을 진행하기 전 살아있는 포탑을 정리합니다. live_turret.clear(); for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) if(board[i][j]) { Turret new_turret; new_turret.x = i; new_turret.y = j; new_turret.r = rec[i][j]; new_turret.p = board[i][j]; live_turret.push_back(new_turret); } // 살아있는 포탑이 1개 이하라면 바로 종료합니다. if(live_turret.size() &lt;= 1) break; // 턴을 진행하기 전 필요한 전처리를 정리해줍니다. Init(); // 각성을 진행합니다. Awake(); // 레이저 공격을 진행합니다. bool is_suc = LaserAttack(); // 레이저 공격을 하지 못했다면 포탄 공격을 진행합니다. if(!is_suc) BombAttack(); // 공격에 관여하지 않은 모든 살아있는 포탑의 힘을 1 증가시킵니다. Reserve(); } // 살아있는 포탑의 힘 중 가장 큰 값을 출력합니다. int ans = 0; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) ans = max(ans, board[i][j]); cout &lt;&lt; ans; return 0;}" }, { "title": "스타트 택시", "url": "/posts/%EC%8A%A4%ED%83%80%ED%8A%B8-%ED%83%9D%EC%8B%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-11 00:00:00 +0900", "snippet": "스타트 택시스타트링크가 “스타트 택시”라는 이름의 택시 사업을 시작했다. 스타트 택시는 특이하게도 손님을 도착지로 데려다줄 때마다 연료가 충전되고, 연료가 바닥나면 그 날의 업무가 끝난다.택시 기사 최백준은 오늘 M명의 승객을 태우는 것이 목표이다. 백준이 활동할 영역은 N×N 크기의 격자로 나타낼 수 있고, 각 칸은 비어 있거나 벽이 놓여 있다. 택시가 빈칸에 있을 때, 상하좌우로 인접한 빈칸 중 하나로 이동할 수 있다. 알고리즘 경력이 많은 백준은 특정 위치로 이동할 때 항상 최단경로로만 이동한다.M명의 승객은 빈칸 중 하나에 서 있으며, 다른 빈칸 중 하나로 이동하려고 한다. 여러 승객이 같이 탑승하는 경우는 없다. 따라서 백준은 한 승객을 태워 목적지로 이동시키는 일을 M번 반복해야 한다. 각 승객은 스스로 움직이지 않으며, 출발지에서만 택시에 탈 수 있고, 목적지에서만 택시에서 내릴 수 있다.백준이 태울 승객을 고를 때는 현재 위치에서 최단거리가 가장 짧은 승객을 고른다. 그런 승객이 여러 명이면 그중 행 번호가 가장 작은 승객을, 그런 승객도 여러 명이면 그중 열 번호가 가장 작은 승객을 고른다. 택시와 승객이 같은 위치에 서 있으면 그 승객까지의 최단거리는 0이다. 연료는 한 칸 이동할 때마다 1만큼 소모된다. 한 승객을 목적지로 성공적으로 이동시키면, 그 승객을 태워 이동하면서 소모한 연료 양의 두 배가 충전된다. 이동하는 도중에 연료가 바닥나면 이동에 실패하고, 그 날의 업무가 끝난다. 승객을 목적지로 이동시킨 동시에 연료가 바닥나는 경우는 실패한 것으로 간주하지 않는다.모든 승객을 성공적으로 데려다줄 수 있는지 알아내고, 데려다줄 수 있을 경우 최종적으로 남는 연료의 양을 출력하는 프로그램을 작성하시오.풀이 방법BFS로 최단거리에 있는 승객을 찾는다.BFS로 승객을 목적지까지 이동시킨다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define LEN_2D_MAX 21using namespace std;int N, M, F;int arr[LEN_2D_MAX][LEN_2D_MAX] = { 0, };bool isvisited[LEN_2D_MAX][LEN_2D_MAX] = { false, };int dist[LEN_2D_MAX][LEN_2D_MAX] = { 0, };int dy[4] = { 0,1,0,-1 };int dx[4] = { 1,0,-1,0 };struct pos{\tint y;\tint x;};vector&lt;pos&gt; people;vector&lt;pos&gt; dst;pos taxi;void bfs(int y, int x){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tq.push(make_pair(y, x));\tisvisited[y][x] = true;\tdist[y][x] = 0;\twhile (!q.empty())\t{\t\tint cy = q.front().first;\t\tint cx = q.front().second;\t\tq.pop();\t\tfor (int dir = 0; dir &lt; 4; dir++)\t\t{\t\t\tint ny = cy + dy[dir];\t\t\tint nx = cx + dx[dir];\t\t\tif (ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N)\t\t\t{\t\t\t\tif (!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == 0)\t\t\t\t{\t\t\t\t\tq.push(make_pair(ny, nx));\t\t\t\t\tisvisited[ny][nx] = true;\t\t\t\t\tdist[ny][nx] = dist[cy][cx] + 1;\t\t\t\t}\t\t\t}\t\t}\t}}void simulate(){\tfor (int pn = 0; pn &lt; M; pn++)\t{\t\t// 최소 이동거리 측정\t\tmemset(isvisited, false, sizeof(isvisited));\t\tmemset(dist, 0, sizeof(dist));\t\tbfs(taxi.y, taxi.x);\t\tint min_dist = 87654321;\t\tint ny = 0, nx = 0, idx = -1;\t\tfor (int i = 0; i &lt; people.size(); i++)\t\t{\t\t\tint cy = people[i].y;\t\t\tint cx = people[i].x;\t\t\tif (dist[cy][cx] &lt; min_dist)\t\t\t{\t\t\t\tny = cy;\t\t\t\tnx = cx;\t\t\t\tidx = i;\t\t\t\tmin_dist = dist[cy][cx];\t\t\t}\t\t\telse if (dist[cy][cx] == min_dist)\t\t\t{\t\t\t\tif (ny &gt; cy)\t\t\t\t{\t\t\t\t\tny = cy;\t\t\t\t\tnx = cx;\t\t\t\t\tidx = i;\t\t\t\t}\t\t\t\telse if (ny == cy &amp;&amp; nx &gt; cx)\t\t\t\t{\t\t\t\t\tny = cy;\t\t\t\t\tnx = cx;\t\t\t\t\tidx = i;\t\t\t\t}\t\t\t}\t\t}\t\t// 택시에 태운 사람 제거, 택시 위치 업데이트\t\tpeople.erase(people.begin() + idx);\t\ttaxi.y = ny;\t\ttaxi.x = nx;\t\t// 기름 업데이트\t\tF -= dist[ny][nx];\t\tif (F &lt; 0) {\t\t\tF = -1;\t\t\tbreak;\t\t}\t\t// 목적지까지 거리 구하기\t\tmemset(isvisited, false, sizeof(isvisited));\t\tmemset(dist, 0, sizeof(dist));\t\tbfs(taxi.y, taxi.x);\t\t// 손님과 매칭되는 목적지\t\tint cy = dst[idx].y;\t\tint cx = dst[idx].x;\t\t// 목적지에 도착한 경우 택시 위치 업데이트\t\ttaxi.y = cy;\t\ttaxi.x = cx;\t\tdst.erase(dst.begin() + idx);\t\t// 기름 업데이트\t\tF -= dist[cy][cx];\t\tif (F &lt; 0) {\t\t\tF = -1;\t\t\tbreak;\t\t}\t\tF += (dist[cy][cx] * 2);\t}\treturn;}int main(int argc, char** argv){\tscanf(\"%d %d %d\", &amp;N, &amp;M, &amp;F);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\tscanf(\"%d %d\", &amp;taxi.y, &amp;taxi.x);\tfor (int i = 0; i &lt; M; i++)\t{\t\tint a, b, c, d;\t\tscanf(\"%d %d %d %d\", &amp;a, &amp;b, &amp;c, &amp;d);\t\ta--;\t\tb--;\t\tc--;\t\td--;\t\tpeople.push_back({ a, b });\t\tdst.push_back({ c, d });\t}\tsimulate();\tif (F &lt;= 0)\t\tprintf(\"-1\\n\");\telse\t\tprintf(\"%d\\n\", F);\treturn 0;}" }, { "title": "마법사 상어와 파이어볼", "url": "/posts/%EB%A7%88%EB%B2%95%EC%82%AC-%EC%83%81%EC%96%B4%EC%99%80-%ED%8C%8C%EC%9D%B4%EC%96%B4%EB%B3%BC/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-10 00:00:00 +0900", "snippet": "마법사 상어와 파이어볼모든 파이어볼이 자신의 방향 di로 속력 si칸 만큼 이동한다.이동하는 중에는 같은 칸에 여러 개의 파이어볼이 있을 수도 있다.이동이 모두 끝난 뒤, 2개 이상의 파이어볼이 있는 칸에서는 다음과 같은 일이 일어난다.같은 칸에 있는 파이어볼은 모두 하나로 합쳐진다.파이어볼은 4개의 파이어볼로 나누어진다.나누어진 파이어볼의 질량, 속력, 방향은 다음과 같다.질량은 ⌊(합쳐진 파이어볼 질량의 합)/5⌋이다.속력은 ⌊(합쳐진 파이어볼 속력의 합)/(합쳐진 파이어볼의 개수)⌋이다.합쳐지는 파이어볼의 방향이 모두 홀수이거나 모두 짝수이면, 방향은 0, 2, 4, 6이 되고, 그렇지 않으면 1, 3, 5, 7이 된다.질량이 0인 파이어볼은 소멸되어 없어진다.마법사 상어가 이동을 K번 명령한 후, 남아있는 파이어볼 질량의 합을 구해보자.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define LEN_2D_MAX 50\tusing namespace std;int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };int N, M, K, answer = 0;struct fireball_info{\tint y;\tint x;\tint m;\tint s;\tint d;};vector&lt;fireball_info&gt; fb;vector&lt;int&gt; arr[LEN_2D_MAX][LEN_2D_MAX];void fmove(){\tvector&lt;int&gt; temp_arr[LEN_2D_MAX][LEN_2D_MAX];\tfor (int i = 0; i &lt; fb.size(); i++)\t{\t\tint dir = fb[i].d;\t\t// 속력이 배열의 크기를 넘어갈 경우를 생각한다.\t\tint speed = fb[i].s % N;\t\t// 이동방향에 따라 좌표값이 음수가 될 수 있다, 이를 방지하기 위해 N을 더해준다.\t\tint ny = (fb[i].y + (dy[dir] * speed) + N) % N;\t\tint nx = (fb[i].x + (dx[dir] * speed) + N) % N;\t\ttemp_arr[ny][nx].push_back(i);\t\t// 해당 파이어볼의 이동 구현\t\tfb[i].y = ny;\t\tfb[i].x = nx;\t}\t// 원본에 내용 적용\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tarr[i][j] = temp_arr[i][j];\t\t}\t}\treturn;}// 합쳐지는 파이어 볼의 질량을 계산하는 곳void fsum(){\tvector&lt;fireball_info&gt; temp_fb;\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\t//해당 위치에 파이어볼이 없을때\t\t\tif (arr[i][j].size() == 0)\t\t\t\tcontinue;\t\t\t// 해당위치에 파이어볼이 하나만 있을때 충돌 x\t\t\t// 그 위치에 파이어볼을 넣어주면된다\t\t\tif (arr[i][j].size() == 1)\t\t\t{\t\t\t\tint idx = arr[i][j][0];\t\t\t\ttemp_fb.push_back(fb[idx]);\t\t\t\tcontinue;\t\t\t}\t\t\tint msum = 0, ssum = 0;\t\t\tbool is_odd = true, is_even = true;\t\t\t// 파이어볼이 중첩되는 경우\t\t\tfor (int k = 0; k &lt; arr[i][j].size(); k++)\t\t\t{\t\t\t\tint idx = arr[i][j][k];\t\t\t\tmsum += fb[idx].m;\t\t\t\tssum += fb[idx].s;\t\t\t\tif ((fb[idx].d &amp; 1) == 0)\t\t\t\t{\t\t\t\t\tis_odd = false;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tis_even = false;\t\t\t\t}\t\t\t}\t\t\t// 질량이 0인 파이어볼 소멸\t\t\tif (msum / 5 == 0)\t\t\t\tcontinue;\t\t\tint temp_m = msum / 5;\t\t\tint temp_s = ssum / arr[i][j].size();\t\t\t// 합쳐진 파이업볼은 4개의 파이어볼로 4방향으로 퍼져나간다.\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t{\t\t\t\t// 모두 홀수이거나 모두 짝수일 때\t\t\t\tif (is_odd || is_even)\t\t\t\t{\t\t\t\t\ttemp_fb.push_back({ i, j, temp_m, temp_s, k * 2 });\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\ttemp_fb.push_back({ i, j, temp_m, temp_s, ((k * 2) + 1) });\t\t\t\t}\t\t\t}\t\t}\t}\t// 벡터의 경우 대입연산이 가능\t// 대입연산 수행시 대입 받는 좌변 벡터는 우변 벡터의 크기만큼 자동으로 늘어나고 우변의 모든 요소가 좌변으로 대입된다.\t// 원래 좌변에 들어가있는 값은 파괴되고 우변 벡터와 똑같은 값, 크기를 가지게 된다.\tfb = temp_fb;\treturn;}void simulate(){\twhile (K--)\t{\t\tfmove();\t\tfsum();\t}\tfor (int i = 0; i &lt; fb.size(); i++)\t{\t\tanswer += fb[i].m;\t}\treturn;}int main(int argc, char** argv){\tscanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);\tfor (int i = 0; i &lt; M; i++)\t{\t\tint y, x, m, s, d;\t\tscanf(\"%d %d %d %d %d\", &amp;y, &amp;x, &amp;m, &amp;s, &amp;d);\t\ty--;\t\tx--;\t\tfb.push_back({ y, x, m, s, d });\t\t// 2차원 좌표에서 파이어볼 의 index를 저장한다\t\tarr[y][x].push_back(i);\t}\tsimulate();\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "상어 초등학교", "url": "/posts/%EC%83%81%EC%96%B4-%EC%B4%88%EB%93%B1%ED%95%99%EA%B5%90/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-09 00:00:00 +0900", "snippet": "상어 초등학교1, 비어있는 칸 중에서 좋아하는 학생이 인접한 칸에 가장 많은 칸으로 자리를 정한다. 1을 만족하는 칸이 여러 개이면, 인접한 칸 중에서 비어있는 칸이 가장 많은 칸으로 자리를 정한다. 2를 만족하는 칸도 여러 개인 경우에는 행의 번호가 가장 작은 칸으로, 그러한 칸도 여러 개이면 열의 번호가 가장 작은 칸으로 자리를 정한다.학생 입력 순서대로 빈 공간 중 가장 선호도가 높은 자리에 배치하고, 모든 배치가 끝나면 선호도 점수를 계산한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define LEN_1D_MAX 401#define LEN_2D_MAX 21using namespace std;int N, answer = 0;struct student{\tint me;\tint y;\tint x;\tint friend[4];};int arr[LEN_2D_MAX][LEN_2D_MAX] = { 0, };student stud[LEN_1D_MAX] = { 0, };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };// 해당 위치에 학생을 위치시켰을 때 점수를 계산하는 함수int getpoint(int y, int x, int i){\tint point = 0;\tfor(int dir = 0; dir &lt; 4; dir++)\t{\t\tint ny = y + dy[dir];\t\tint nx = x + dx[dir];\t\tif(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 nx &lt; n)\t\t{\t\t\t// 1을 만족하는 칸이 여러 개이면, 인접한 칸 중에서 비어있는 칸이 가장 많은 칸으로 자리를 정한다.\t\t\tif(board[ny][nx] == 0)\t\t\t{\t\t\t\tpoint++;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tfor(int i = 0; i &lt; 4; i++)\t\t\t\t{\t\t\t\t\t// 우선순위를 위해 10점 부과\t\t\t\t\tif(board[ny][nx] == stud.friend[i])\t\t\t\t\t{\t\t\t\t\t\tpoint += 10;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}\treturn point;}// 해당 위치에 학생을 위치시키는 함수 void setstudent(int y, int x, int i){\tst[i].y = y;\tst[i].x = x;\tboard[y][x] = st[i].me;}// 최종적인 만족도를 계산하는 함수int calc_point(int idx){\tint point = 0;\tfor(int i = 0; i &lt; N; i++)\t{\t\tfor(int j = 0; j &lt; N; j++)\t\t{\t\t\tint temp_point = 1;\t\t\tint cnt = 0;\t\t\tint cy = stud[idx].y;\t\t\tint cx = stud[idx].x;\t\t\tfor(int dir = 0; dir &lt; 4; dir++)\t\t\t{\t\t\t\tint ny = cy + dy[dir];\t\t\t\tint nx = cx + dx[dir];\t\t\t\tfor(int k = 0; k &lt; 4; k++)\t\t\t\t{\t\t\t\t\tif(arr[ny][nx] == stud[idx].friend[k])\t\t\t\t\t{\t\t\t\t\t\tcnt++;\t\t\t\t\t\ttemp_point *= 10;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tif(cnt == 0)\t\t{\t\t\ttemp_point = 0;\t\t}\t\tpoint += temp_point;\t}\treturn point;}int main(int argc, char** argv){\tscanf(\"%d %d\", &amp;N);\tfor(int i = 0; i &lt; N * N; i++)\t{\t\t\t\tscanf(\"%d %d %d %d %d\", &amp;stud[i].me, &amp;stud[i].freind[0], &amp;stud[i].freind[1], &amp;stud[i].freind[2], &amp;stud[i].freind[3]);\t}\tfor(int i = 0; i &lt; N * N; i++)\t{\t\tint cy = -1, cx = -1, point = -1;\t\tbool flag = false;\t\tfor(int y = 0; y &lt; N; y++)\t\t{\t\t\tfor(int x = 0; x &lt; N; x++)\t\t\t{\t\t\t\tif(board[y][x] == 0)\t\t\t\t{\t\t\t\t\tint curr_point = getpoint(y, x, i);\t\t\t\t\tif(curr_point &gt; point)\t\t\t\t\t{\t\t\t\t\t\tcy = y;\t\t\t\t\t\tcx = x;\t\t\t\t\t\tpoint = curr_point;\t\t\t\t\t\tflag = true;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t\tsetstudent(cy, cx, i);\t}\tfor(int i = 0; i &lt; N * N; i++)\t{\t\tanswer += calc_point(i);\t}\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "마법사 상어와 블리자드", "url": "/posts/%EB%A7%88%EB%B2%95%EC%82%AC-%EC%83%81%EC%96%B4%EC%99%80-%EB%B8%94%EB%A6%AC%EC%9E%90%EB%93%9C/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-10-09 00:00:00 +0900", "snippet": "마법사 상어와 블리자드 구슬이 블리자드 마법에 맞아 파괴되는 내용 구현 연속하는 구슬이 있을 때 폭발하는 내용 구현 구슬이 변하는 것 구현(A 구슬의 개수, B 구슬의 번호)핵심은 2차원 배열 내에서 나선형으로 진행하기 때문에 2차원 =&gt; 1차원 배열로 해당 내용을 구현하고 그 내용을 다시 1차원 =&gt; 2차원 배열로 복원시켜 해당 동작을 구현하는 것#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define LEN_1D_MAX 2500#define LEN_2D_MAX 49using namespace std;int N, M, answer = 0;int line_size = 0;int line[LEN_1D_MAX] = { 0, };int arr[LEN_2D_MAX][LEN_2D_MAX] = { 0, };int dy[4] = { -1, 1, 0, 0 };int dx[4] = { 0, 0, -1, 1 };void destroy_by_rule(int d, int s){\tint cy = N / 2;\tint cx = N / 2;\tfor (int i = 1; i &lt;= s; i++)\t{\t\tint ny = cy + (dy[d] * i);\t\tint nx = cx + (dx[d] * i);\t\tarr[ny][nx] = 0;\t}}void convert_to_line(){\tint cy = N / 2;\tint cx = N / 2;\t\tint ddy[4] = { 0, 1, 0, -1 };\tint ddx[4] = { -1, 0, 1, 0 };\tint dir = 0, loop_cnt = 2;\tline_size = 0;\tfor (int move_r = 1; move_r &lt; N; move_r++)\t{\t\t// 마지막의 경우에만 loop cnt 가 3번으로 늘어난다\t\tif (move_r == N - 1)\t\t{\t\t\tloop_cnt = 3;\t\t}\t\tfor (int i = 0; i &lt; loop_cnt; i++)\t\t{\t\t\tfor (int j = 0; j &lt; move_r; j++)\t\t\t{\t\t\t\tcy += ddy[dir];\t\t\t\tcx += ddx[dir];\t\t\t\tif (arr[cy][cx] != 0)\t\t\t\t{\t\t\t\t\tline[line_size++] = arr[cy][cx];\t\t\t\t}\t\t\t}\t\t\tdir = (dir + 1) % 4;\t\t}\t\t\t}\treturn;}int explosion(){\tint point = 0;\tint cnt = 1;\tfor (int i = 1; i &lt; line_size; i++)\t{\t\tif (line[i - 1] == line[i])\t\t{\t\t\t++cnt;\t\t}\t\telse\t\t{\t\t\tif (cnt &gt;= 4)\t\t\t{\t\t\t\tfor (int j = 1; j &lt;= cnt; j++)\t\t\t\t{\t\t\t\t\tpoint += line[i - j];\t\t\t\t\tline[i - j] = 0;\t\t\t\t}\t\t\t}\t\t\tcnt = 1;\t\t}\t}\t// 마지막까지 동일한 숫자가 반복되고 4가 넘는 경우에 대한 예외처리를 해준다\tif (cnt &gt;= 4)\t{\t\tfor (int j = 1; j &lt;= cnt; j++)\t\t{\t\t\tpoint += line[line_size - j];\t\t\tline[line_size - j] = 0;\t\t}\t}\tanswer += point;\treturn point;}void remove_zero(){\tint back_size = 0;\tint backup[2500] = { 0, };\tfor (int i = 0; i &lt; line_size; i++)\t{\t\tif (line[i] != 0)\t\t{\t\t\tbackup[back_size++] = line[i];\t\t}\t}\tfor (int i = 0; i &lt; back_size; i++)\t{\t\tline[i] = backup[i];\t}\tline_size = back_size;\treturn;}void change_by_rule(){\tint back_size = 0;\tint backup[2500] = { 0, };\tint cnt = 1;\tfor (int i = 1; i &lt; line_size; i++)\t{\t\tif (line[i - 1] == line[i])\t\t{\t\t\t++cnt;\t\t}\t\telse\t\t{\t\t\tif (back_size &lt; N * N - 2)\t\t\t{\t\t\t\t// 구슬의 개수와 최초 그 구슬의 번호를 번갈아가며 출력\t\t\t\tbackup[back_size++] = cnt;\t\t\t\tbackup[back_size++] = line[i - 1];\t\t\t}\t\t\tcnt = 1;\t\t}\t}\tif (line_size &gt; 0 &amp;&amp; back_size &lt; N * N - 2)\t{\t\tbackup[back_size++] = cnt;\t\tbackup[back_size++] = line[line_size - 1];\t}\tfor (int i = 0; i &lt; back_size; i++)\t{\t\tline[i] = backup[i];\t}\tline_size = back_size;\treturn;}void convert_to_mat(){\tint cy = N / 2;\tint cx = N / 2;\tint ddy[4] = { 0, 1, 0, -1 };\tint ddx[4] = { -1, 0, 1, 0 };\tint dir = 0, loop_cnt = 2;\tint cur = 0;\tfor (int move_r = 1; move_r &lt; N; move_r++)\t{\t\t// 마지막의 경우에만 loop cnt 가 3번으로 늘어난다\t\tif (move_r == N - 1)\t\t{\t\t\tloop_cnt = 3;\t\t}\t\tfor (int i = 0; i &lt; loop_cnt; i++)\t\t{\t\t\tfor (int j = 0; j &lt; move_r; j++)\t\t\t{\t\t\t\tcy += ddy[dir];\t\t\t\tcx += ddx[dir];\t\t\t\tif (cur &lt; line_size)\t\t\t\t{\t\t\t\t\tarr[cy][cx] = line[cur++];\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tarr[cy][cx] = 0;\t\t\t\t}\t\t\t}\t\t\tdir = (dir + 1) % 4;\t\t}\t\t\t}\treturn;}int main(int argc, char** argv){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\tanswer = 0;\tfor (int i = 0; i &lt; M; i++)\t{\t\tint d, s;\t\tscanf(\"%d %d\", &amp;d, &amp;s);\t\tdestroy_by_rule(d - 1, s);\t\tconvert_to_line();\t\t// 구슬이 한번 파괴되고 나면 배열이 재정비되고 그 이후에도 또다시 파괴시켜야할 구슬이 있을 수 있기 때문에 파괴될 구슬이 없을 때까지 반복해서 수행한다.\t\twhile (explosion() != 0)\t\t{\t\t\tremove_zero();\t\t}\t\tremove_zero();\t\tchange_by_rule();\t\tconvert_to_mat();\t}\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "토스트 계란틀", "url": "/posts/%EC%BD%94%EB%93%9C%ED%8A%B8%EB%A6%AC-%EB%B9%B5/", "categories": "CodingTest, BFS", "tags": "CodingTest, BFS", "date": "2023-10-08 00:00:00 +0900", "snippet": "토스트 계란틀문제최근 코드트리 빵이 전국적으로 인기를 얻어 편의점에서 해당 빵을 구하기 힘들어졌습니다. 빵을 구하고자 하는 m명의 사람이 있는데, 1번 사람은 정확히 1분에, 2번 사람은 정확히 2분에, …, m번 사람은 정확히 m 분에 각자의 베이스캠프에서 출발하여 편의점으로 이동하기 시작합니다. 사람들은 출발 시간이 되기 전까지 격자 밖에 나와있으며, 사람들이 목표로 하는 편의점은 모두 다릅니다. 이 모든 일은 n*n 크기의 격자 위에서 진행됩니다.코드트리 빵을 구하고 싶은 사람들은 다음과 같은 방법으로 움직입니다. 이 3가지 행동은 총 1분 동안 진행되며, 정확히 1, 2, 3 순서로 진행되어야 함에 유의합니다.격자에 있는 사람들 모두가 본인이 가고 싶은 편의점 방향을 향해서 1 칸 움직입니다. 최단거리로 움직이며 최단 거리로 움직이는 방법이 여러가지라면 ↑, ←, →, ↓ 의 우선 순위로 움직이게 됩니다. 여기서 최단거리라 함은 상하좌우 인접한 칸 중 이동가능한 칸으로만 이동하여 도달하기까지 거쳐야 하는 칸의 수가 최소가 되는 거리를 뜻합니다.만약 편의점에 도착한다면 해당 편의점에서 멈추게 되고, 이때부터 다른 사람들은 해당 편의점이 있는 칸을 지나갈 수 없게 됩니다. 격자에 있는 사람들이 모두 이동한 뒤에 해당 칸을 지나갈 수 없어짐에 유의합니다.현재 시간이 t분이고 t ≤ m를 만족한다면, t번 사람은 자신이 가고 싶은 편의점과 가장 가까이 있는 베이스 캠프에 들어갑니다. 여기서 가장 가까이에 있다는 뜻 역시 1에서와 같이 최단거리에 해당하는 곳을 의미합니다. 가장 가까운 베이스캠프가 여러 가지인 경우에는 그 중 행이 작은 베이스캠프, 행이 같다면 열이 작은 베이스 캠프로 들어갑니다. t번 사람이 베이스 캠프로 이동하는 데에는 시간이 전혀 소요되지 않습니다.이때부터 다른 사람들은 해당 베이스 캠프가 있는 칸을 지나갈 수 없게 됩니다. t번 사람이 편의점을 향해 움직이기 시작했더라도 해당 베이스 캠프는 앞으로 절대 지나갈 수 없음에 유의합니다. 마찬가지로 격자에 있는 사람들이 모두 이동한 뒤에 해당 칸을 지나갈 수 없어짐에 유의합니다.풀이 팁 베이스 캠프 이동은 시간의 소요되지 않는다.=&gt; BFS로 최단거리를 찾고 해당 베이스 캠프로 사람을 이동시킨다 베이스 캠프에서 출발하는 사람의 경우 현재 한칸씩 이동하는 로직을 설계할 것4방면으로 움직일 수 있고 어느 방향으로 움직여야 최단거리로 이동하는 루트에 속하는지를 알기 위해 편의점에서 현재 사람의 위치까지의 BFS를 구하고 각포인트의 최단 시간을 탐색한다.=&gt; 최단 거리로 이동할 수 압ㄲ에 없게 만들고 그 우선순위에 맞춰 움직인다. 편의점에 도착한 경우, 베이스캠프에 사람이 도착한 경우 BLOCK 그 즉시 그 배열 포인트를 BLOCK 상태로 만든다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;tuple&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 15#define MAX_M 30#define MAX_NUM 87654321using namespace std;int n, m, answer = 0, curr_t = 0, debug_cnt = 0;int arr[MAX_N][MAX_N] = { 0 ,};// 상좌우하 순의 우선순위int dy[4] = {-1, 0, 0, 1};int dx[4] = {0, -1, 1, 0};pair&lt;int, int&gt; conv_pos[MAX_M]; pair&lt;int, int&gt; people[MAX_M];int step[MAX_N][MAX_N]; bool isvisited[MAX_N][MAX_N]; void init(){ for(int i = 0; i &lt; m; i++) { people[i] = make_pair(-1, -1); } return ;}void init_arr(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { isvisited[i][j] = false; step[i][j] = 0; } } }bool range_check(int y, int x){ return y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; n;}bool cango(int y, int x){ return range_check(y, x) &amp;&amp; !isvisited[y][x] &amp;&amp; arr[y][x] != 2;}void bfs(pair&lt;int, int&gt; curr_pos){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(curr_pos); isvisited[curr_pos.first][curr_pos.second] = true; step[curr_pos.first][curr_pos.second] = 0; while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(cango(ny, nx)) { q.push(make_pair(ny, nx)); step[ny][nx] = step[cy][cx] + 1; isvisited[ny][nx] = 1; } } } return;}void simulate(){ for(int i = 0; i &lt; m; i++) { int curr_y, curr_x; // 해당 인원이 편의점에 도착했거나 아직 시작지점에 있을 때 if(people[i] == make_pair(-1, -1) || people[i] == conv_pos[i]) continue; if(people[i] == conv_pos[i]) { debug_cnt++; printf(\"%d\\n\", debug_cnt); } // 1 단계 : 편의점 방향으로 사람을 한 칸 이동시킨다. init_arr(); bfs(conv_pos[i]); tie(curr_y, curr_x) = people[i]; int min_dist = MAX_NUM; int min_y = -1, min_x = -1; for(int dir = 0; dir &lt; 4; dir++) { int ny = curr_y + dy[dir]; int nx = curr_x + dx[dir]; if(range_check(ny, nx) &amp;&amp; step[ny][nx] &lt; min_dist &amp;&amp; isvisited[ny][nx]) { min_dist = step[ny][nx]; min_y = ny; min_x = nx; } } people[i] = make_pair(min_y, min_x); } // 2 단계 : 해당 인원이 편의점에 도착했을 때 해당 포인트를 이제 이동불가한 포인트로 바꿔준다. for(int i = 0; i &lt; m; i++) { if(people[i] == conv_pos[i]) { int ny, nx; tie(ny, nx) = people[i]; arr[ny][nx] = 2; } } // 3단계. 현재 시간 curr_t에 대해 curr_t ≤ m를 만족한다면 t번 사람이 베이스 캠프로 이동합니다. // t &lt;= m 을 만족하지 못하는 경우 if(curr_t &gt; m) return; init_arr(); bfs(conv_pos[curr_t - 1]); int min_dist = MAX_NUM; int min_y = -1, min_x = -1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { // &gt; 으로 min_dist를 탐색할 경우 가장 가까운 베이스캠프가 여러 가지인 경우에는 그 중 행이 작은 베이스캠프, 행이 같다면 열이 작은 베이스 캠프로 들어가는 조건 충족 if(isvisited[i][j] &amp;&amp; arr[i][j] == 1 &amp;&amp; min_dist &gt; step[i][j]) { min_dist = step[i][j]; min_y = i; min_x = j; } } } // 해당 베이스 캠프로 이동이 끝나면 그 지역은 이동불가 표시 people[curr_t - 1] = make_pair(min_y, min_x); arr[min_y][min_x] = 2;}bool end_call(){ for(int i = 0; i &lt; m; i++) { if(people[i] != conv_pos[i]) return false; } return true;}int main() { scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; m; i++) { int x, y; scanf(\"%d %d\", &amp;y, &amp;x); conv_pos[i] = make_pair(y - 1, x - 1); } init(); while(true) { curr_t++; simulate(); if(end_call()) break; } printf(\"%d\\n\", curr_t); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;queue&gt;#include &lt;climits&gt;#define MAX_N 15#define MAX_M 30#define DIR_NUM 4#define EMPTY make_pair(-1, -1)using namespace std;// 변수 선언int n, m;// 0이면 빈 칸, 1이면 베이스 캠프, 2라면 아무도 갈 수 없는 곳을 뜻합니다.int grid[MAX_N][MAX_N];// 편의점 목록을 관리합니다.pair&lt;int, int&gt; cvs_list[MAX_M];// 현재 사람들의 위치를 관리합니다.pair&lt;int, int&gt; people[MAX_M];// 현재 시간을 기록합니다.int curr_t;// dx, dy값을 // 문제에서의 우선순위인 상좌우하 순으로 적어줍니다.int dx[DIR_NUM] = {-1, 0, 0, 1};int dy[DIR_NUM] = { 0, -1, 1, 0};// bfs에 사용되는 변수들입니다.int step[MAX_N][MAX_N]; // 최단거리 결과 기록bool visited[MAX_N][MAX_N]; // 방문 여부 표시// (x, y)가 격자 내에 있는 좌표인지를 판단합니다.bool InRange(int x, int y) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}// (x, y)로 이동이 가능한지 판단합니다.bool CanGo(int x, int y) { return InRange(x, y) &amp;&amp; // 범위를 벗어나지 않으면서 !visited[x][y] &amp;&amp; // 방문했던 적이 없으면서 grid[x][y] != 2; // 이동 가능한 곳이어야 합니다.}// start_pos를 시작으로 하는 BFS를 진행합니다.// 시작점으로부터의 최단거리 결과는 step배열에 기록됩니다.void BFS(pair&lt;int, int&gt; start_pos) { // visited, step 값을 전부 초기화합니다. for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { visited[i][j] = false; step[i][j] = 0; } // 초기 위치를 넣어줍니다. queue&lt;pair&lt;int, int&gt; &gt; q; int sx = start_pos.first, sy = start_pos.second; q.push(start_pos); visited[sx][sy] = true; step[sx][sy] = 0; // BFS를 진행합니다. while(!q.empty()) { // 가장 앞에 원소를 골라줍니다. pair&lt;int, int&gt; curr_pos = q.front(); q.pop(); // 인접한 칸을 보며 아직 방문하지 않은 칸을 큐에 넣어줍니다. int x = curr_pos.first, y = curr_pos.second; for(int i = 0; i &lt; DIR_NUM; i++) { int nx = x + dx[i], ny = y + dy[i]; // 갈 수 있는 경우에만 진행합니다. if(CanGo(nx, ny)) { visited[nx][ny] = true; step[nx][ny] = step[x][y] + 1; q.push(make_pair(nx, ny)); } } }}// 시뮬레이션을 진행합니다.void Simulate() { // Step 1. 격자에 있는 사람들에 한하여 편의점 방향을 향해 1칸 움직입니다. for(int i = 0; i &lt; m; i++) { // 아직 격자 밖에 있는 사람이거나 이미 편의점에 도착한 사람이라면 패스합니다. if(people[i] == EMPTY || people[i] == cvs_list[i]) continue; // 원래는 현재 위치에서 편의점 위치까지의 최단거리를 구해줘야 합니다. // 다만 최단거리가 되기 위한 그 다음 위치를 구하기 위해서는 // 거꾸로 편의점 위치를 시작으로 현재 위치까지 오는 최단거리를 구해주는 것이 필요합니다. // 따라서 편의점 위치를 시작으로 하는 BFS를 진행합니다. BFS(cvs_list[i]); int px, py; tie(px, py) = people[i]; // 현재 위치에서 상좌우하 중 최단거리 값이 가장 작은 곳을 고르면 // 그 곳으로 이동하는 것이 최단거리 대로 이동하는 것이 됩니다. // 그러한 위치 중 상좌우하 우선순위대로 가장 적절한 곳을 골라줍니다. int min_dist = INT_MAX; int min_x = -1, min_y = -1; for(int j = 0; j &lt; DIR_NUM; j++) { int nx = px + dx[j], ny = py + dy[j]; if(InRange(nx, ny) &amp;&amp; visited[nx][ny] &amp;&amp; min_dist &gt; step[nx][ny]) { min_dist = step[nx][ny]; min_x = nx; min_y = ny; } } // 우선순위가 가장 높은 위치로 한 칸 움직여줍니다. people[i] = make_pair(min_x, min_y); } // Step 2. 편의점에 도착한 사람에 한하여 // 앞으로 이동 불가능하다는 표시로 // grid값을 2로 바꿔줍니다. for(int i = 0; i &lt; m; i++) { if(people[i] == cvs_list[i]) { int px, py; tie(px, py) = people[i]; grid[px][py] = 2; } } // Step 3. 현재 시간 curr_t에 대해 curr_t ≤ m를 만족한다면 // t번 사람이 베이스 캠프로 이동합니다. // curr_t가 m보다 크다면 패스합니다. if(curr_t &gt; m) return; // Step 3-1. 편의점으로부터 가장 가까운 베이스 캠프를 고르기 위해 // 편의점을 시작으로 하는 BFS를 진행합니다. BFS(cvs_list[curr_t - 1]); // Step 3-2. 편의점에서 가장 가까운 베이스 캠프를 선택합니다. // i, j가 증가하는 순으로 돌리기 때문에 // 가장 가까운 베이스 캠프가 여러 가지여도 // 알아서 (행, 열) 우선순위대로 골라집니다. int min_dist = INT_MAX; int min_x = -1, min_y = -1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { // 방문 가능한 베이스 캠프 중 // 거리가 가장 가까운 위치를 찾아줍니다. if(visited[i][j] &amp;&amp; grid[i][j] == 1 &amp;&amp; min_dist &gt; step[i][j]) { min_dist = step[i][j]; min_x = i; min_y = j; } } } // 우선순위가 가장 높은 베이스 캠프로 이동합니다. people[curr_t - 1] = make_pair(min_x, min_y); // 해당 베이스 캠프는 앞으로 이동이 불가능한 칸임을 표시합니다. grid[min_x][min_y] = 2;}// 전부 편의점에 도착헀는지를 확인합니다.bool End() { // 단 한 사람이라도 // 편의점에 도착하지 못했다면 // 아직 끝나지 않은 것입니다. for(int i = 0; i &lt; m; i++) { if(people[i] != cvs_list[i]) return false; } // 전부 편의점에 도착했다면 끝입니다. return true;}int main() { // 입력: cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; grid[i][j]; for(int i = 0; i &lt; m; i++) { int x, y; cin &gt;&gt; x &gt;&gt; y; cvs_list[i] = make_pair(x - 1, y - 1); } // 초기 사람들은 격자 밖에 있으므로 // 위치를 EMPTY 상태로 놓습니다. for(int i = 0; i &lt; m; i++) people[i] = EMPTY; // 1분에 한번씩 시뮬레이션을 진행합니다. while(true) { curr_t++; Simulate(); // 전부 이동이 끝났다면 종료합니다. if(End()) break; } cout &lt;&lt; curr_t; return 0;}" }, { "title": "메이즈 러너", "url": "/posts/%EB%A9%94%EC%9D%B4%EC%A6%88-%EB%9F%AC%EB%84%88/", "categories": "CodingTest, BFS", "tags": "CodingTest, BFS", "date": "2023-10-08 00:00:00 +0900", "snippet": "메이즈 러너문제M명의 참가자가 미로 탈출하기 게임에 참가하였습니다.미로의 구성은 다음과 같습니다.미로는 N×N 크기의 격자입니다. 각 위치는 (r,c)의 형태로 표현되며, 아래로 갈수록 r이 증가, 오른쪽으로 갈수록 c가 증가합니다. 좌상단은 (1,1)입니다.미로의 각 칸은 다음 3가지 중 하나의 상태를 갖습니다.빈 칸참가자가 이동 가능한 칸입니다.벽참가자가 이동할 수 없는 칸입니다.1이상 9이하의 내구도를 갖고 있습니다.회전할 때, 내구도가 1씩 깎입니다.내구도가 0이 되면, 빈 칸으로 변경됩니다.출구참가자가 해당 칸에 도달하면, 즉시 탈출합니다.1초마다 모든 참가자는 한 칸씩 움직입니다. 움직이는 조건은 다음과 같습니다.두 위치 (x1,y1), (x2,y2)의 최단거리는 ∣x1−x2∣+∣y1−y2∣로 정의됩니다.모든 참가자는 동시에 움직입니다.상하좌우로 움직일 수 있으며, 벽이 없는 곳으로 이동할 수 있습니다.움직인 칸은 현재 머물러 있던 칸보다 출구까지의 최단 거리가 가까워야 합니다.움직일 수 있는 칸이 2개 이상이라면, 상하로 움직이는 것을 우선시합니다.참가가가 움직일 수 없는 상황이라면, 움직이지 않습니다.한 칸에 2명 이상의 모험가가 있을 수 있습니다.모든 참가자가 이동을 끝냈으면, 다음 조건에 의해 미로가 회전합니다.한 명 이상의 참가자와 출구를 포함한 가장 작은 정사각형을 잡습니다.가장 작은 크기를 갖는 정사각형이 2개 이상이라면, 좌상단 r 좌표가 작은 것이 우선되고, 그래도 같으면 c 좌표가 작은 것이 우선됩니다.선택된 정사각형은 시계방향으로 90도 회전하며, 회전된 벽은 내구도가 1씩 깎입니다.K초 동안 위의 과정을 계속 반복됩니다. 만약 K초 전에 모든 참가자가 탈출에 성공한다면, 게임이 끝납니다. 게임이 끝났을 때, 모든 참가자들의 이동 거리 합과 출구 좌표를 출력하는 프로그램을 작성해보세요.풀이 팁해설 정답 코드#include &lt;iostream&gt;using namespace std;#define MAX_N 10int n, m, k;// 모든 벽들의 상태를 기록해줍니다.int board[MAX_N + 1][MAX_N + 1];// 회전의 구현을 편하게 하기 위해 2차원 배열을 하나 더 정의해줍니다.int next_board[MAX_N + 1][MAX_N + 1];// 참가자의 위치 정보를 기록해줍니다.pair&lt;int, int&gt; traveler[MAX_N + 1];// 출구의 위치 정보를 기록해줍니다.pair&lt;int, int&gt; exits;// 정답(모든 참가자들의 이동 거리 합)을 기록해줍니다.int ans;// 회전해야 하는 최소 정사각형을 찾아 기록해줍니다.int sx, sy, square_size;// 모든 참가자를 이동시킵니다.void MoveAllTraveler() { // m명의 모든 참가자들에 대해 이동을 진행합니다. for(int i = 1; i &lt;= m; i++) { // 이미 출구에 있는 경우 스킵합니다. if(traveler[i].first == exits.first &amp;&amp; traveler[i].second == exits.second) continue; // 행이 다른 경우 행을 이동시켜봅니다. if(traveler[i].first != exits.first) { int nx = traveler[i].first; int ny = traveler[i].second; if(exits.first &gt; nx) nx++; else nx--; // 벽이 없다면 행을 이동시킬 수 있습니다. // 이 경우 행을 이동시키고 바로 다음 참가자로 넘어갑니다. if(!board[nx][ny]) { traveler[i].first = nx; traveler[i].second = ny; ans++; continue; } } // 열이 다른 경우 열을 이동시켜봅니다. if(traveler[i].second != exits.second) { int nx = traveler[i].first; int ny = traveler[i].second; if(exits.second &gt; ny) ny++; else ny--; // 벽이 없다면 행을 이동시킬 수 있습니다. // 이 경우 열을 이동시킵니다. if(!board[nx][ny]) { traveler[i].first = nx; traveler[i].second = ny; ans++; continue; } } }}// 한 명 이상의 참가자와 출구를 포함한 가장 작은 정사각형을 찾습니다.void FindMinimumSquare() { // 가장 작은 정사각형부터 모든 정사각형을 만들어봅니다. for(int sz = 2; sz &lt;= n; sz++) { // 가장 좌상단 r 좌표가 작은 것부터 하나씩 만들어봅니다. for(int x1 = 1; x1 &lt;= n - sz + 1; x1++) { // 가장 좌상단 c 좌표가 작은 것부터 하나씩 만들어봅니다. for(int y1 = 1; y1 &lt;= n - sz + 1; y1++) { int x2 = x1 + sz - 1; int y2 = y1 + sz - 1; // 만약 출구가 해당 정사각형 안에 없다면 스킵합니다. if(!(x1 &lt;= exits.first &amp;&amp; exits.first &lt;= x2 &amp;&amp; y1 &lt;= exits.second &amp;&amp; exits.second &lt;= y2)) { continue; } // 한 명 이상의 참가자가 해당 정사각형 안에 있는지 판단합니다. bool is_traveler_in = false; for(int l = 1; l &lt;= m; l++) { if(x1 &lt;= traveler[l].first &amp;&amp; traveler[l].first &lt;= x2 &amp;&amp; y1 &lt;= traveler[l].second &amp;&amp; traveler[l].second &lt;= y2) { // 출구에 있는 참가자는 제외합니다. if(!(traveler[l].first == exits.first &amp;&amp; traveler[l].second == exits.second)) { is_traveler_in = true; } } } // 만약 한 명 이상의 참가자가 해당 정사각형 안에 있다면 // sx, sy, sqaure_size 정보를 갱신하고 종료합니다. if(is_traveler_in) { sx = x1; sy = y1; square_size = sz; return; } } } }}// 정사각형 내부의 벽을 회전시킵니다.void RotateSquare() { // 우선 정사각형 안에 있는 벽들을 1 감소시킵니다. for(int x = sx; x &lt; sx + square_size; x++) for(int y = sy; y &lt; sy + square_size; y++) { if(board[x][y]) board[x][y]--; } // 정사각형을 시계방향으로 90' 회전합니다. for(int x = sx; x &lt; sx + square_size; x++) for(int y = sy; y &lt; sy + square_size; y++) { // Step 1. (sx, sy)를 (0, 0)으로 옮겨주는 변환을 진행합니다. int ox = x - sx, oy = y - sy; // Step 2. 변환된 상태에서는 회전 이후의 좌표가 (x, y) -&gt; (y, square_n - x - 1)가 됩니다. int rx = oy, ry = square_size - ox - 1; // Step 3. 다시 (sx, sy)를 더해줍니다. next_board[rx + sx][ry + sy] = board[x][y]; } // next_board 값을 현재 board에 옮겨줍니다. for(int x = sx; x &lt; sx + square_size; x++) for(int y = sy; y &lt; sy + square_size; y++) { board[x][y] = next_board[x][y]; }}// 모든 참가자들 및 출구를 회전시킵니다.void RotateTravelerAndExit() { // m명의 참가자들을 모두 확인합니다. for(int i = 1; i &lt;= m; i++) { int x = traveler[i].first; int y = traveler[i].second; // 해당 참가자가 정사각형 안에 포함되어 있을 때에만 회전시킵니다. if(sx &lt;= x &amp;&amp; x &lt; sx + square_size &amp;&amp; sy &lt;= y &amp;&amp; y &lt; sy + square_size) { // Step 1. (sx, sy)를 (0, 0)으로 옮겨주는 변환을 진행합니다. int ox = x - sx, oy = y - sy; // Step 2. 변환된 상태에서는 회전 이후의 좌표가 (x, y) -&gt; (y, square_n - x - 1)가 됩니다. int rx = oy, ry = square_size - ox - 1; // Step 3. 다시 (sx, sy)를 더해줍니다. traveler[i] = make_pair(rx + sx, ry + sy); } } // 출구에도 회전을 진행합니다. int x = exits.first; int y = exits.second; if(sx &lt;= x &amp;&amp; x &lt; sx + square_size &amp;&amp; sy &lt;= y &amp;&amp; y &lt; sy + square_size) { // Step 1. (sx, sy)를 (0, 0)으로 옮겨주는 변환을 진행합니다. int ox = x - sx, oy = y - sy; // Step 2. 변환된 상태에서는 회전 이후의 좌표가 (x, y) -&gt; (y, square_n - x - 1)가 됩니다. int rx = oy, ry = square_size - ox - 1; // Step 3. 다시 (sx, sy)를 더해줍니다. exits = make_pair(rx + sx, ry + sy); }}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= n; j++) cin &gt;&gt; board[i][j]; for(int i = 1; i &lt;= m; i++) { cin &gt;&gt; traveler[i].first; cin &gt;&gt; traveler[i].second; } cin &gt;&gt; exits.first; cin &gt;&gt; exits.second; while(k--) { // 모든 참가자를 이동시킵니다. MoveAllTraveler(); // 모든 사람이 출구로 탈출했는지 판단합니다. bool is_all_escaped = true; for(int i = 1; i &lt;= m; i++) { if(!(traveler[i].first == exits.first &amp;&amp; traveler[i].second == exits.second)) { is_all_escaped = false; } } // 만약 모든 사람이 출구로 탈출했으면 바로 종료합니다. if(is_all_escaped) break; // 한 명 이상의 참가자와 출구를 포함한 가장 작은 정사각형을 찾습니다. FindMinimumSquare(); // 정사각형 내부의 벽을 회전시킵니다. RotateSquare(); // 모든 참가자들 및 출구를 회전시킵니다. RotateTravelerAndExit(); } cout &lt;&lt; ans &lt;&lt; \"\\n\"; cout &lt;&lt; exits.first &lt;&lt; \" \" &lt;&lt; exits.second;}" }, { "title": "토스트 계란틀", "url": "/posts/%ED%86%A0%EC%8A%A4%ED%8A%B8-%EA%B3%84%EB%9E%80%ED%8B%80/", "categories": "CodingTest, BFS", "tags": "CodingTest, BFS", "date": "2023-10-07 00:00:00 +0900", "snippet": "토스트 계란틀문제n * n개의 격자에 1 * 1 크기의 계란틀이 주어집니다.각각의 계란틀에 담긴 계란의 양이 주어지며 계란틀은 정사각형 형태입니다. 계란틀을 이루는 4개의 선은 분리가 가능합니다.계란틀이 있는 n * n 격자가 주어질 때 다음과 같은 규칙을 따릅니다.계란의 양이 너무 차이나지 않게 하기 위해 하나의 선을 맞대고 있는 두 계란틀의 계란의 양의 차이가 L 이상 R 이하라면 계란틀의 해당 선을 분리합니다.모든 계란틀에 대해 검사를 실시하고 위의 규칙에 해당하는 모든 계란틀의 선을 분리합니다.선의 분리를 통해 합쳐진 계란틀의 계란은 하나로 합치고 이후에 다시 분리합니다.합쳤다 다시 분리한 이후의 각 계란틀별 계란의 양은 (합쳐진 계란의 총 합)/(합쳐진 계란틀의 총 개수)가 됩니다. 편의상 소숫점은 버립니다.예를 들어 아래 그림과 같이 계란틀의 계란의 양이 주어지고, 계란 이동의 범위가 15 이상 24 이하로 주어진다면,아래 그림과 같이 계란틀의 선을 분리하게 됩니다.계란이 모두 합쳐지고 난 뒤 계란의 양은 아래 그림과 같이 바뀌게 됩니다.위의 과정이 한 번의 계란의 이동이며, 계란의 이동이 더 이상 필요 없을 때까지 해당 과정을 반복합니다.n * n 격자의 계란틀에 있는 계란의 양이 주어질 때, 계란의 이동이 몇 번 일어나는지를 구하는 프로그램을 작성하세요.풀이 팁BFS를 여러번 수행하여 탐색할경우 방문 체크 배열 등 초기화 해줘야할 것들에 대해 잘 고려하고 코드들 작성해야한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int n, L, R, flag_cnt = 1, answer = 0;int arr[51][51] = { 0, };int temp_arr[51][51] = { 0, };bool isvisited[51][51] = { false, };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};void bfs(int y, int x){ queue&lt;pair &lt;int, int&gt; &gt; q; queue&lt;pair &lt;int, int&gt; &gt; q_backup; int total_sum = 0; int cnt = 0; q.push(make_pair(y, x)); q_backup.push(make_pair(y, x)); cnt++; total_sum += arr[y][x]; isvisited[y][x] = true; while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 &amp;&amp;nx &lt; n &amp;&amp; isvisited[ny][nx] == false) { int diff = abs(arr[ny][nx] - arr[cy][cx]); if(diff &gt;= L &amp;&amp; diff &lt;= R) { q.push(make_pair(ny, nx)); q_backup.push(make_pair(ny, nx)); total_sum += arr[ny][nx]; cnt++; flag_cnt++; isvisited[ny][nx] = true; } } } } while(!q_backup.empty()) { int cy = q_backup.front().first; int cx = q_backup.front().second; int amount = total_sum / cnt; temp_arr[cy][cx] = amount; // printf(\"temp_arr[%d][%d] = %d, %d\\n\", cy, cx,amount, q_backup.size()); q_backup.pop(); } return;}void copy_temp_arr(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { temp_arr[i][j] = arr[i][j]; } } return;}void copy_arr(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { arr[i][j] = temp_arr[i][j]; } } return;}void init_arr(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { isvisited[i][j] = false; } } return;}void debug(){ for(int i = 0 ; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { printf(\"%d \", arr[i][j]); } printf(\"\\n\"); } printf(\"----------------------\\n\");}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d %d\", &amp;n, &amp;L, &amp;R); for(int i = 0 ; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } copy_temp_arr(); while(flag_cnt != 0) { flag_cnt = 0; for(int i = 0 ; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(isvisited[i][j] == false) bfs(i, j); } } copy_arr(); if(flag_cnt &gt; 0) answer++; // debug(); // 방문 배열은 초기화 시켜줘야한다. init_arr(); } printf(\"%d\\n\", answer); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;tuple&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 50#define DIR_NUM 4using namespace std;int n, L, R;int egg[MAX_N][MAX_N];queue&lt;pair&lt;int, int&gt; &gt; bfs_q;vector&lt;pair&lt;int, int&gt; &gt; egg_group;bool visited[MAX_N][MAX_N];bool InRange(int x, int y) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}bool CanGo(int x, int y, int curr_egg) { if(!InRange(x, y)) return false; int egg_diff = abs(egg[x][y] - curr_egg); return !visited[x][y] &amp;&amp; L &lt;= egg_diff &amp;&amp; egg_diff &lt;= R;}// visited 배열을 초기화 해줍니다.void InitializeVisited() { for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) visited[i][j] = false;}void BFS() { int dx[DIR_NUM] = {0, 1, 0, -1}; int dy[DIR_NUM] = {1, 0, -1, 0}; // BFS 탐색을 수행합니다. while(!bfs_q.empty()) { pair&lt;int, int&gt; curr_pos = bfs_q.front(); int curr_x, curr_y; tie(curr_x, curr_y) = curr_pos; bfs_q.pop(); for(int i = 0; i &lt; DIR_NUM; i++) { int new_x = curr_x + dx[i]; int new_y = curr_y + dy[i]; // L, R 사이인 경우에만 합쳐질 수 있습니다. if(CanGo(new_x, new_y, egg[curr_x][curr_y])) { bfs_q.push(make_pair(new_x, new_y)); egg_group.push_back(make_pair(new_x, new_y)); visited[new_x][new_y] = true; } } }}// 계란들을 합칩니다.void MergeEggs() {\tint sum_of_eggs = 0;\tfor(int k = 0; k &lt; (int) egg_group.size(); k++) {\t\tint x, y;\t\ttie(x, y) = egg_group[k];\t\tsum_of_eggs += egg[x][y];\t}\tfor(int k = 0; k &lt; (int) egg_group.size(); k++) {\t\tint x, y;\t\ttie(x, y) = egg_group[k];\t\tegg[x][y] = sum_of_eggs / (int) egg_group.size();\t}\t}// 조건에 맞게 계란의 양을 바꿔줍니다.bool MoveEggs() { // BFS 탐색을 위한 초기화 작업을 수행합니다. InitializeVisited(); bool is_changed = false; // 아직 방문하지 못한 칸에 대해 // BFS 탐색을 통해 합쳐질 계란들을 찾아냅니다. for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(!visited[i][j]){ // 합쳐질 계란 목록을 담을 곳을 초기화합니다. egg_group.clear(); bfs_q.push(make_pair(i, j)); egg_group.push_back(make_pair(i, j)); visited[i][j] = true; BFS(); // 계란의 이동이 한번이라도 일어났는지를 확인합니다. if((int) egg_group.size() &gt; 1) is_changed = true; \t\t\t\t// (i, j)와 관련이 있는 계란들을 합칩니다. MergeEggs(); } } } return is_changed;}int main() { cin &gt;&gt; n &gt;&gt; L &gt;&gt; R; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; egg[i][j]; int move_cnt = 0; // 이동이 더 이상 필요 없을 때까지 // 계란의 이동을 반복합니다. while(true) { bool is_changed = MoveEggs(); if(!is_changed) break; move_cnt++; } cout &lt;&lt; move_cnt; return 0;}" }, { "title": "병원 거리 최소화하기", "url": "/posts/%EB%B3%91%EC%9B%90-%EA%B1%B0%EB%A6%AC-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-10-07 00:00:00 +0900", "snippet": "병원 거리 최소화하기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define MAX_NUM 87654321using namespace std;int n, m, answer = MAX_NUM;int arr[51][51] = { 0 ,};bool pick[13] = { false, };vector&lt;pair&lt;int, int&gt; &gt; h_cord, p_cord, comb_cord;int calc_dist(){ int temp_min_sum = 0; for(int i = 0; i &lt; p_cord.size(); i++) { int temp_dist = 0, temp_min = MAX_NUM; for(int j = 0; j &lt; comb_cord.size(); j++) { temp_dist = abs(p_cord[i].first - comb_cord[j].first) + abs(p_cord[i].second - comb_cord[j].second); temp_min = min(temp_min, temp_dist); } temp_min_sum += temp_min; } return temp_min_sum;}void comb(int cnt, int idx){ if(cnt == m) { int dist = calc_dist(); answer = min(dist, answer); return; } for(int i = idx + 1; i &lt; h_cord.size(); i++) { if(pick[i] == true) continue; pick[i] = true; comb_cord.push_back(h_cord[i]); comb(cnt + 1, i); pick[i] = false; comb_cord.pop_back(); } return;}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); if(arr[i][j] == 1) p_cord.push_back(make_pair(i, j)); else if(arr[i][j] == 2) h_cord.push_back(make_pair(i, j)); } } comb(0, 0); printf(\"%d\\n\", answer); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#define MAX_HOSPITAL 13using namespace std;int n, m;int min_distance = INT_MAX;vector&lt;pair&lt;int, int&gt; &gt; people;vector&lt;pair&lt;int, int&gt; &gt; hospitals;bool visited[MAX_HOSPITAL];// 사람과 병원 사이의 거리를 구하여 반환해줍니다.int GetDistance(pair&lt;int, int&gt; person, pair&lt;int, int&gt; hospital) { return abs(person.first - hospital.first) + abs(person.second - hospital.second);}// m 개의 병원이 선택됐을 때 각 사람의 병원 거리에 대한 합을 반환해줍니다.int GetCurrMinDistance() { int curr_min_distance = 0; // 각 사람에 대하여 가장 가까운 병원의 거리를 구합니다. for(int i = 0; i &lt; (int) people.size(); i++) { int single_min = INT_MAX; for(int j = 0; j &lt; (int) hospitals.size(); j++) { if(visited[j]) single_min = min(single_min, GetDistance(people[i], hospitals[j])); } curr_min_distance += single_min; } return curr_min_distance;}void SearchMinDistance(int cnt, int last_idx) { // m개의 병원이 선택됐을 경우 병원 거리의 총합을 구해줍니다. if(cnt == m) { min_distance = min(min_distance, GetCurrMinDistance()); return; } // 뽑을 수 있는 병원의 후보들을 탐색합니다. for(int i = last_idx + 1; i &lt; (int) hospitals.size(); i++) { visited[i] = true; SearchMinDistance(cnt + 1, i); visited[i] = false; }}int main() { cin &gt;&gt; n &gt;&gt; m; int buffer; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) { cin &gt;&gt; buffer; if(buffer == 1) people.push_back(make_pair(i, j)); else if(buffer == 2) hospitals.push_back(make_pair(i, j)); } SearchMinDistance(0, -1); cout &lt;&lt; min_distance; return 0;}" }, { "title": "정수 사각형 최솟값의 최대", "url": "/posts/%EC%A0%95%EC%88%98-%EC%82%AC%EA%B0%81%ED%98%95-%EC%B5%9C%EC%86%9F%EA%B0%92%EC%9D%98-%EC%B5%9C%EB%8C%80/", "categories": "CodingTest., DP", "tags": "CodingTest, DP", "date": "2023-09-06 00:00:00 +0900", "snippet": "정수 사각형 최솟값의 최대N×N 행렬이 주어졌을 때, (1,1)에서 시작하여 오른쪽 혹은 밑으로만 이동하여 (N,N)으로 간다고 했을 때 거쳐간 위치에 적혀있는 숫자들 중 최솟값을 최대로 하는 프로그램을 작성해보세요.첫째 줄에는 N이 주어집니다.두 번째 줄 부터 N개의 줄에 각각 각 행에 해당하는 N개의 정수 값이 공백을 사이에 두고 주어집니다.1≤N≤1001≤ 행렬에 주어지는 숫자 ≤1,000,000#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_NUM 7654321int N;int arr[101][101] = { 0, };int dp[101][101] = { 0, };int main() { scanf(\"%d\", &amp;N); for(int i = 1; i &lt;= N; i++) { for(int j = 1 ; j &lt;= N; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt;= N; i++) { for(int j = 0 ; j &lt;= N; j++) { dp[i][j] = MAX_NUM; } } dp[1][1] = arr[1][1]; for(int i = 1; i &lt;= N; i++) { for(int j = 1 ; j &lt;= N; j++) { if(i == 1 &amp;&amp; j == 1) continue; dp[i][j] = max(min(arr[i][j], dp[i-1][j]), min(arr[i][j], dp[i][j-1])); } } printf(\"%d\\n\", dp[N][N]); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX_NUM 1000using namespace std;int n;int num[MAX_NUM][MAX_NUM];int dp[MAX_NUM][MAX_NUM];void Initialize() { // 시작점의 경우 dp[0][0] = num[0][0]으로 초기값을 설정해줍니다 dp[0][0] = num[0][0]; // 최좌측 열의 초기값을 설정해줍니다. for(int i = 1; i &lt; n; i++) dp[i][0] = min(dp[i-1][0], num[i][0]); // 최상단 행의 초기값을 설정해줍니다. for(int j = 1; j &lt; n; j++) dp[0][j] = min(dp[0][j-1], num[0][j]);}int main() { cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; num[i][j]; // 초기값 설정 Initialize(); // 탐색하는 위치의 위에 값과 좌측 값 중에 큰 값과 // 해당 위치의 숫자 중에 최솟값을 구해줍니다. for(int i = 1; i &lt; n; i++) for(int j = 1; j &lt; n; j++) dp[i][j] = min(max(dp[i-1][j], dp[i][j-1]), num[i][j]); cout &lt;&lt; dp[n-1][n-1]; return 0;}" }, { "title": "정수 사각형 최소 합", "url": "/posts/%EC%A0%95%EC%88%98-%EC%82%AC%EA%B0%81%ED%98%95-%EC%B5%9C%EC%86%8C-%ED%95%A9/", "categories": "CodingTest., DP", "tags": "CodingTest, DP", "date": "2023-09-05 00:00:00 +0900", "snippet": "정수 사각형 최소 합N×N 행렬이 주어졌을 때, (1,N)에서 시작하여 왼쪽 혹은 밑으로만 이동하여 (N,1)로 간다고 했을 때 거쳐간 위치에 적혀있는 숫자의 합을 최소로 하는 프로그램을 작성해보세요.첫째 줄에는 N이 주어집니다.두 번째 줄 부터 N개의 줄에 각각 각 행에 해당하는 N개의 정수 값이 공백을 사이에 두고 주어집니다.1≤N≤1001≤ 행렬에 주어지는 숫자 ≤1,000,000#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_NUM 987654321int N;int arr[102][102] = { 0, };int dp[102][102] = { 0, };int main() { scanf(\"%d\", &amp;N); for(int i = 1; i &lt;= N; i++) { for(int j = 1 ; j &lt;= N; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt;= N + 1; i++) { for(int j = 0; j &lt;= N + 1; j++) { dp[i][j] = MAX_NUM; } } dp[1][N] = arr[1][N]; for(int i = 1; i &lt;= N; i++) { for(int j = N ; j &gt; 0; j--) { if(i == 1 &amp;&amp; j == N) continue; dp[i][j] = min(dp[i - 1][j] + arr[i][j], dp[i][j + 1] + arr[i][j]); } } // for(int i = 1; i &lt;= N; i++) // { // for(int j = 1 ; j &lt;= N; j++) // { // printf(\"%d \", dp[i][j]); // } // printf(\"\\n\"); // } printf(\"%d\\n\", dp[N][1]); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX_N 1000using namespace std;// 변수 선언int n;int num[MAX_N][MAX_N];int dp[MAX_N][MAX_N];void Initialize() { // 시작점의 경우 dp[0][n - 1] = num[0][n - 1]으로 초기값을 설정해줍니다 dp[0][n - 1] = num[0][n - 1]; // 최우측 열의 초기값을 설정해줍니다. for(int i = 1; i &lt; n; i++) dp[i][n - 1] = dp[i - 1][n - 1] + num[i][n - 1]; // 최상단 행의 초기값을 설정해줍니다. for(int j = n - 2; j &gt;= 0; j--) dp[0][j] = dp[0][j + 1] + num[0][j];}int main() { // 입력: cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; num[i][j]; // 초기값 설정 Initialize(); // 탐색하는 위치의 위에 값과 우측 값 중에 작은 값에 // 해당 위치의 숫자를 더해줍니다. for(int i = 1; i &lt; n; i++) for(int j = n - 2; j &gt;= 0; j--) dp[i][j] = min(dp[i - 1][j], dp[i][j + 1]) + num[i][j]; cout &lt;&lt; dp[n - 1][0]; return 0;}" }, { "title": "정수 사각형 최대 합", "url": "/posts/%EC%A0%95%EC%88%98-%EC%82%AC%EA%B0%81%ED%98%95-%EC%B5%9C%EB%8C%80-%ED%95%A9/", "categories": "CodingTest., DP", "tags": "CodingTest, DP", "date": "2023-09-03 00:00:00 +0900", "snippet": "정수 사각형 최대 합N×N 행렬이 주어졌을 때, (1,1)에서 시작하여 오른쪽 혹은 밑으로만 이동하여 (N,N)으로 간다고 했을 때 거쳐간 위치에 적혀있는 숫자의 합을 최대로 하는 프로그램을 작성해보세요.첫째 줄에는 N이 주어집니다.두 번째 줄 부터 N개의 줄에 각각 각 행에 해당하는 N개의 정수 값이 공백을 사이에 두고 주어집니다.1≤N≤1001≤ 행렬에 주어지는 숫자 ≤1,000,000#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N;int arr[101][101] = { 0, };int dp[101][101] = { 0, };int main() { scanf(\"%d\", &amp;N); for(int i = 1; i &lt;= N; i++) { for(int j = 1 ; j &lt;= N; j++) { scanf(\"%d\", &amp;arr[i][j]); } } dp[0][0] = arr[0][0]; for(int i = 1; i &lt;= N; i++) { for(int j = 1 ; j &lt;= N; j++) { dp[i][j] = max(dp[i - 1][j] + arr[i][j], dp[i][j - 1] + arr[i][j]); } } printf(\"%d\\n\", dp[N][N]); return 0;}해설 정답 코드" }, { "title": "비를 피하기", "url": "/posts/%EB%B9%84%EB%A5%BC-%ED%94%BC%ED%95%98%EA%B8%B0/", "categories": "CodingTest., BFS", "tags": "CodingTest, BFS", "date": "2023-08-30 00:00:00 +0900", "snippet": "비를 피하기숫자 0, 1, 2, 3로만 이루어진 n * n 격자에서 사람이 h명 겹치지 않게 서 있고, 비를 피할 수 있는 공간의 위치 m개가 주어졌을 때 각 사람마다 비를 피할 수 있는 가장 가까운 공간까지의 거리를 구하는 프로그램을 작성해보세요. 숫자 0은 해당 칸이 이동할 수 있는 곳임을, 숫자 1은 벽이 있어 해당 칸이 이동할 수 없는 곳임을 의미합니다. 숫자 2는 해당 칸에 사람이 서있음을 의미하고, 숫자 3는 해당 공간이 비를 피할 수 있는 공간임을 의미합니다. 사람은 상하좌우 인접한 곳으로만 움직 일 수 있으며 한 칸 움직이는 데 정확히 1초가 소요됩니다. 벽이 아닌 곳은 전부 이동이 가능합니다.첫 번째 줄에 격자의 크기를 나타내는 n과 사람의 수를 나타내는 h 그리고 비를 피할 수 있는 공간의 수를 나타내는 m이 각각 공백을 사이에 두고 주어집니다.두 번째 줄 부터는 n개의 줄에 걸쳐 각 행에 해당하는 n개의 숫자가 순서대로 공백을 사이에 두고 주어집니다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int arr[100][100] = { 0, };int answer[100][100] = { 0, };int isvisited[100][100] = { 0 ,};int dist[100][100] = { 0 ,};int n, h, m;int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};int flag = 0;void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; n) { if(isvisited[ny][nx] == 0 &amp;&amp; arr[ny][nx] != 1) { dist[ny][nx] = dist[cy][cx] + 1; isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); if(arr[ny][nx] == 3) { answer[y][x] = dist[ny][nx]; flag = 1; return; } } } } } return;}void print_answer(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { printf(\"%d \", answer[i][j]); } printf(\"\\n\"); } return;}int main() { scanf(\"%d %d %d\", &amp;n, &amp;h, &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d \", &amp;arr[i][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(arr[i][j] == 2) { isvisited[i][j] = 1; bfs(i, j); if(flag == 0) answer[i][j] = -1; flag = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { isvisited[i][j] = 0; dist[i][j] = 0; } } // memset(isvisited, 0x0, sizeof(int) * n * n); } } } print_answer(); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#define MAX_N 100#define DIR_NUM 4using namespace std;// 전역 변수 선언:int n, h, m;int a[MAX_N][MAX_N];vector&lt;pair&lt;int, int&gt; &gt; people_pos;vector&lt;pair&lt;int, int&gt; &gt; s_pos;// bfs에 필요한 변수들 입니다.queue&lt;pair&lt;int, int&gt; &gt; q;bool visited[MAX_N][MAX_N];int step[MAX_N][MAX_N]; // step[i][j] : 시작점으로부터 // (i, j) 지점에 도달하기 위한 // 최단거리를 기록합니다.bool InRange(int x, int y) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}// 격자를 벗어나지 않으면서, 벽도 없고, 아직 방문한 적이 없는 곳이라면// 지금 이동하는 것이 최단거리임을 보장할 수 있으므로 가야만 합니다. bool CanGo(int x, int y) { return InRange(x, y) &amp;&amp; a[x][y] != 1 &amp;&amp; !visited[x][y];}// queue에 새로운 위치를 추가하고// 방문 여부를 표시해줍니다.// 시작점으로 부터의 최단거리 값도 갱신해줍니다.void Push(int nx, int ny, int new_step) { q.push(make_pair(nx, ny)); visited[nx][ny] = true; step[nx][ny] = new_step;}// bfs를 통해 최소 이동 횟수를 구합니다.void BFS() { // queue에 남은 것이 없을때까지 반복합니다. while(!q.empty()) { // queue에서 가장 먼저 들어온 원소를 뺍니다. pair&lt;int, int&gt; curr_pos = q.front(); int x = curr_pos.first, y = curr_pos.second; q.pop(); int dx[DIR_NUM] = {-1, 1, 0, 0}; int dy[DIR_NUM] = {0, 0, -1, 1}; // queue에서 뺀 원소의 위치를 기준으로 4방향을 확인해봅니다. for(int dir = 0; dir &lt; DIR_NUM; dir++) { int nx = x + dx[dir], ny = y + dy[dir]; // 아직 방문한 적이 없으면서 갈 수 있는 곳이라면 // 새로 queue에 넣어줍니다. if(CanGo(nx, ny)) // 최단 거리는 이전 최단거리에 1이 증가하게 됩니다. Push(nx, ny, step[x][y] + 1); } }}int main() { // 입력: cin &gt;&gt; n &gt;&gt; h &gt;&gt; m;\t\tfor(int i = 0; i &lt; n; i++)\t\tfor(int j = 0; j &lt; n; j++) {\t\t\tcin &gt;&gt; a[i][j];\t\t\tif(a[i][j] == 2)\t\t\t\tpeople_pos.push_back(make_pair(i, j));\t\t\tif(a[i][j] == 3)\t\t\t\ts_pos.push_back(make_pair(i, j));\t\t}\t\t// 비를 피할 수 있는 공간들을 전부 시작점으로 하는\t// bfs를 진행합니다.\t// 이는 각 사람마다 가장 가까운 쉘터까지의 거리를 \t// 단 한번의 bfs로 구할 수 있도록 합니다.\tfor(int i = 0; i &lt; (int) s_pos.size(); i++)\t\tPush(s_pos[i].first, s_pos[i].second, 0);\t BFS();\tfor(int i = 0; i &lt; n; i++) {\t\tfor(int j = 0; j &lt; n; j++) {\t\t\tif(a[i][j] != 2)\t\t\t\tcout &lt;&lt; 0 &lt;&lt; \" \";\t\t\telse {\t\t\t\tif(!visited[i][j])\t\t\t\t\tcout &lt;&lt; -1 &lt;&lt; \" \";\t\t\t\telse\t\t\t\t\tcout &lt;&lt; step[i][j] &lt;&lt; \" \";\t\t\t}\t\t}\t\tcout &lt;&lt; endl;\t} return 0;}" }, { "title": "상한 귤", "url": "/posts/%EC%83%81%ED%95%9C-%EA%B7%A4/", "categories": "CodingTest., BFS", "tags": "CodingTest, BFS", "date": "2023-08-28 00:00:00 +0900", "snippet": "상한 귤숫자 0, 1, 2로만 이루어진 n * n 격자에서 0초에 k개의 상한 귤로부터 시작하여 1초에 한 번씩 모든 상한 귤로부터 인접한 곳에 있는 귤이 동시에 전부 상하게 될때, 각 귤마다 최초로 상하게 되는 시간을 구하는 프로그램을 작성해보세요. 숫자 0은 해당 칸에 아무것도 놓여있지 않음을, 숫자 1은 해당 칸에 귤이 놓여있음을, 숫자 2는 해당 칸에 상한 귤이 처음부터 놓여 있음을 의미합니다.BFS 진행시 visited 값을 true로 바꿔주는 것은 꼭 queue에 append를 할 때 같이 일어나야 합니다. (queue에서 pop할 때 visited를 true로 바꿔주면 안됩니다, push를 할 때 방문처리를 해줘야합니다.)특정 위치 (x, y)가 pop되기 전까지 계속 visited[x][y] 값이 false이기 때문에 동일한 위치 (x, y)가 여러 번 queue에 들어가게 됩니다. 따라서 시간도 오래걸리고 메모리도 중복된 원소때문에 많이 잡아먹게 되는 것입니다#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int arr[100][100] = { 0, };int time_arr[100][100] = { 0, };int isvisited[100][100] = { 0 ,};int n, k;int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};queue&lt;pair&lt;int, int&gt; &gt; q;int time_cnt = 0;void init(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(arr[i][j] == 0) time_arr[i][j] = -1; else if(arr[i][j] == 2) time_arr[i][j] = 0; } } return;}void bfs(){ //1초에 상한귤은 모두 한칸씩 퍼트린다. //따라서 현재 상한귤 갯수와 내용을 파악하고 다 퍼트린 다음 시간을 업데이트 해야한다. int cnt = k; int temp_cnt = 0; while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); cnt--; for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(arr[ny][nx] == 1) { arr[ny][nx] = 2; time_arr[ny][nx] = time_cnt + 1; } } for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; n) { if(isvisited[ny][nx] == 0 &amp;&amp; arr[ny][nx] == 2) { q.push(make_pair(ny, nx)); isvisited[ny][nx] = 1; temp_cnt++; } } } if(cnt == 0) { // update_time(); cnt = temp_cnt; time_cnt++; temp_cnt = 0; } } return;}void fin_mand(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(arr[i][j] == 1 &amp;&amp; isvisited[i][j] == 0) time_arr[i][j] = -2; } } return ;}void print_answer(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { printf(\"%d \", time_arr[i][j]); } printf(\"\\n\"); } return;}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d\", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); if(arr[i][j] == 2) { q.push(make_pair(i, j)); isvisited[i][j] = 1; } } } init(); bfs(); fin_mand(); print_answer(); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#define MAX_N 100#define DIR_NUM 4using namespace std;// 전역 변수 선언:int n, k;int a[MAX_N][MAX_N];vector&lt;pair&lt;int, int&gt; &gt; s_pos;// bfs에 필요한 변수들 입니다.queue&lt;pair&lt;int, int&gt; &gt; q;bool visited[MAX_N][MAX_N];int step[MAX_N][MAX_N]; // step[i][j] : // (i, j) 지점에 있는 귤이 // 최초로 상하게 되는 시간을 기록합니다.bool InRange(int x, int y) { return 0 &lt;= x &amp;&amp; x &lt; n &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n;}// 격자를 벗어나지 않으면서, 해당 위치에 귤이 놓여있고, 아직 방문한 적이 없는 곳이라면// 지금 이동하는 것이 최초로 해당 귤을 상하게 하는 것이므로 가야만 합니다. bool CanGo(int x, int y) { return InRange(x, y) &amp;&amp; a[x][y] &amp;&amp; !visited[x][y];}// queue에 새로운 위치를 추가하고// 방문 여부를 표시해줍니다.// 상하게 되는 시간 값도 갱신해줍니다.void Push(int nx, int ny, int new_step) { q.push(make_pair(nx, ny)); visited[nx][ny] = true; step[nx][ny] = new_step;}// bfs를 통해 각 칸마다 최초로 상하게 되는 시간을 구합니다.void BFS() { // queue에 남은 것이 없을때까지 반복합니다. while(!q.empty()) { // queue에서 가장 먼저 들어온 원소를 뺍니다. pair&lt;int, int&gt; curr_pos = q.front(); int x = curr_pos.first, y = curr_pos.second; q.pop(); int dx[DIR_NUM] = {-1, 1, 0, 0}; int dy[DIR_NUM] = {0, 0, -1, 1}; // queue에서 뺀 원소의 위치를 기준으로 4방향을 확인해봅니다. for(int dir = 0; dir &lt; DIR_NUM; dir++) { int nx = x + dx[dir], ny = y + dy[dir]; // 아직 방문한 적이 없으면서 갈 수 있는 곳이라면 // 새로 queue에 넣어줍니다. if(CanGo(nx, ny)) // 시간은 이전 시간에 1이 더해지게 됩니다. Push(nx, ny, step[x][y] + 1); } }}int main() { // 입력: cin &gt;&gt; n &gt;&gt; k;\t\tfor(int i = 0; i &lt; n; i++)\t\tfor(int j = 0; j &lt; n; j++) {\t\t\tcin &gt;&gt; a[i][j];\t\t\tif(a[i][j] == 2)\t\t\t\ts_pos.push_back(make_pair(i, j));\t\t}\t // 처음 상해있던 귤들을 // 전부 queue에 넣어놓고 시작합니다. // 이는 각 칸에 있는 신선한 귤에 대해 // 가장 가까이에 있던 상한 귤로부터 // 최초로 상하게 되는 시간을 // 단 한번의 BFS로 가능하게끔 합니다.\tfor(int i = 0; i &lt; (int) s_pos.size(); i++)\t\tPush(s_pos[i].first, s_pos[i].second, 0);\t BFS();\tfor(int i = 0; i &lt; n; i++) {\t\tfor(int j = 0; j &lt; n; j++) {\t\t\tif(a[i][j] == 0)\t\t\t\tcout &lt;&lt; -1 &lt;&lt; \" \";\t\t\telse {\t\t\t\tif(!visited[i][j])\t\t\t\t\tcout &lt;&lt; -2 &lt;&lt; \" \";\t\t\t\telse\t\t\t\t\tcout &lt;&lt; step[i][j] &lt;&lt; \" \";\t\t\t}\t\t}\t\tcout &lt;&lt; endl;\t} return 0;}" }, { "title": "xor 결과 최대 만들기", "url": "/posts/N%EA%B0%9C-%EC%A4%91%EC%97%90-M%EA%B0%9C-%EA%B3%A0%EB%A5%B4%EA%B8%B0(Simple)-xor-%EA%B2%B0%EA%B3%BC-%EC%B5%9C%EB%8C%80-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-08-27 00:00:00 +0900", "snippet": "xor 결과 최대 만들기n개의 음이 아닌 정수가 입력으로 주어졌을 때, 그 중 m개의 숫자를 뽑아 모두 xor한 결과의 최댓값을 출력하는 코드를 작성해보세요.조합 문제 : 순서를 따지지 않고 중복을 허용하지 않는 경우#include &lt;cstdio&gt;#include &lt;iostream&gt;int arr[21] = { 0, };int pick[21] = { 0, };int isvisited[21] = { 0, };int n, m;int max_xor = 0;void dfs(int cnt, int curr_num) { if(cnt == m) { int temp_xor = pick[0]; // printf(\"%d \", pick[0]); for(int i = 1; i &lt; m; i++) { temp_xor= temp_xor ^ pick[i]; // printf(\"%d \", pick[i]); } // printf(\"\\n\"); if(max_xor &lt; temp_xor) max_xor = temp_xor; return; } for(int i = curr_num; i &lt; n; i++) { pick[cnt] = arr[i]; dfs(cnt + 1, i + 1); } return;}int main() { scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;arr[i]); } dfs(0, 0); printf(\"%d\\n\", max_xor); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX_NUM 20using namespace std;// 전역 변수 선언:int n, m;int A[MAX_NUM];bool visited[MAX_NUM];int ans;int Calc() { // xor 연산의 항등원인 0을 초기값으로 설정합니다. int val = 0; for(int i = 0; i &lt; n; i++) if(visited[i]) val ^= A[i]; return val;}void FindMaxXor(int curr_idx, int cnt) { if(cnt == m) { // 선택된 모든 조합에 대해 xor 연산을 적용해봅니다. ans = max(ans, Calc()); return; } if(curr_idx == n) return; // curr_idx index 에 있는 숫자를 선택하지 않은 경우 FindMaxXor(curr_idx + 1, cnt); // curr_idx index 에 있는 숫자를 선택한 경우 visited[curr_idx] = true; FindMaxXor(curr_idx + 1, cnt + 1); visited[curr_idx] = false;}int main() { // 입력: cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) cin &gt;&gt; A[i]; FindMaxXor(0, 0); // 출력: cout &lt;&lt; ans; return 0;}" }, { "title": "N개 중에 M개 고르기(Simple) n개 중에 m개 뽑기", "url": "/posts/N%EA%B0%9C-%EC%A4%91%EC%97%90-M%EA%B0%9C-%EA%B3%A0%EB%A5%B4%EA%B8%B0(Simple)-n%EA%B0%9C-%EC%A4%91%EC%97%90-m%EA%B0%9C-%EB%BD%91%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-08-27 00:00:00 +0900", "snippet": "N개 중에 M개 고르기(Simple) n개 중에 m개 뽑기1이상 N이하의 숫자 중 M개의 숫자를 골라 만들 수 있는 모든 조합을 구해주는 프로그램을 작성해보세요.예를 들어 N이 4, M이 3인 경우 다음과 같이 4개의 조합이 가능합니다.1 2 31 2 41 3 42 3 4#include &lt;cstdio&gt;#include &lt;iostream&gt;int N, M;int isvisited[11] = { 0, };int arr[11] = { 0, };void dfs(int cnt){ if(cnt == M) { int temp_cnt = 1; while(temp_cnt &lt; cnt) { if(arr[temp_cnt - 1] &gt; arr[temp_cnt]) return; temp_cnt++; } for(int i = 0; i &lt; M; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return; } for(int i = 1; i &lt;= N; i++) { if(isvisited[i] == 0) { arr[cnt] = i; isvisited[i] = 1; dfs(cnt + 1); isvisited[i] = 0; } } return ;}int main() { scanf(\"%d %d\", &amp;N, &amp;M); dfs(0); return 0;}개선 답안#include &lt;cstdio&gt;#include &lt;iostream&gt;int N, M;int arr[11] = { 0, };void dfs(int cnt, int curr_num){ if(cnt == M) { for(int i = 0; i &lt; M; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return; } for(int i = curr_num; i &lt;= N; i++) { arr[cnt] = i; dfs(cnt + 1, i + 1); } return ;}int main() { scanf(\"%d %d\", &amp;N, &amp;M); dfs(0, 1); return 0;}해설 정답 코드#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, m;vector&lt;int&gt; combination;// 방문한 원소들을 출력해줍니다.void PrintCombination() { for(int i = 0; i &lt; combination.size(); i++) cout &lt;&lt; combination[i] &lt;&lt; \" \"; cout &lt;&lt; endl;}// 지금까지 뽑은 갯수와 뽑을지 말지를 결정할 숫자를 인자로 받습니다. void FindCombination(int curr_num, int cnt) { // n개의 숫자를 모두 탐색했으면 더 이상 탐색하지 않습니다. if(curr_num == n+1) { // 탐색하는 과정에서 m개의 숫자를 뽑은 경우 답을 출력해줍니다. if(cnt == m) PrintCombination(); return; } // curr_num에 해당하는 숫자를 사용했을 때의 경우를 탐색합니다. combination.push_back(curr_num); FindCombination(curr_num + 1, cnt + 1); combination.pop_back(); // curr_num에 해당하는 숫자를 사용하지 않았을 때의 경우를 탐색합니다. FindCombination(curr_num + 1, cnt);}int main() { cin &gt;&gt; n &gt;&gt; m; FindCombination(1, 0); return 0;}" }, { "title": "CAN 통신의 이해", "url": "/posts/CAN-%ED%86%B5%EC%8B%A0%EC%9D%98-%EC%9D%B4%ED%95%B4/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2023-08-14 00:00:00 +0900", "snippet": "CAN 통신CAN 통신은 버스형 토폴로지가운데 공통으로 버스를 두는 “버스형 토폴로지”모든 메세지는 브로드캐스트 방식으로 송신CAN 커넥터D-Sub 9 pin connectorCAN-LOW 2번 Pin, CAN-HIGH 7번 Pin120옴 종단저항반사파에 대한 신호 왜곡 방지를 위해 버스 양 끝단에 종단 저항을 연결한다CAN 에서는 CAN High, CAN Low 간의 전압 차를 이용하여 데이터를 표현한다. CAN High – CAN Low 값이 0.9 ~ 5 v = 0을 표현 CAN High – CAN Low 값이 -0. 1 ~ 0.5 v= 1을 표현CAN에서 데이터 0을 Dominant, 데이터 1을 Recessive 라고 표현한다.CAN 에서 Dominant가 Recessive보다 우선순위가 높다전압 차를 이용한 방법의 장점 Noise에 강하다(Noise는 일반적으로 CAN HIGH, LOW에 서로 비슷하게 영향을 주기 때문에 전압 차를 사용하는 CAN은 Noise에 상대적으로 강하다)CAN Controller and transceiver 각각의 제어기 안에는 일종의 작은 컴퓨터인 MCU 가 있다. MCU 내부에는 각종 peripheral들이 있고, 그 중에 CAN 통신과 관련된 역할을 하는 CAN Controller 라는 periphera이 있다. CAN Controller가 송신하는 데이터는 CAN TX 핀을 통해서 캔 트랜시버에게 전달된다. CAN Tranceiver는 캔 컨트롤러로부터 정보를 받아서 CAN High, CAN Low 핀으로 실제 ‘전압‘ 을 출력하는 역할을 한다. 반대로 다른 제어기가 메세지를 전송하면 CAN High, CAN Low의 전압값을 읽어서 비트로 해석하여 캔 컨트롤러에게 전달해준다. (CAN RX 핀) 캔 컨트롤러 : 메세지에 담기는 값과 관련 (Data Link Layer라고 함) 트랜시버 : 실제로 전선에 출력되는 전압과 관련 (Physical Layer라고 함)Baudrate CAN 통신 속도를 Baud Rate이라고 한다. 단위는 bps이다. 해당 네트워크에 참여하는 모든 제어기들은 모드 통일된 Baud Rate을 사용해야한다. Baud Rate을 얼마로 할 건지는 OEM(완성차회사)에서 지정하여 CAN DB에 나타낸다. 캔 프로토콜은 크게 Low—Speed CAN, High Speed CAN, CAN FD 3가지 종류로 나뉘며 각 프로토콜 별로 최대속도의 차이가 있다. 물리적인 버스(전선)의 최대길이에 따라 최대속도에 한계가 있다. Sampling Pointt: 하나의 비트 값이 0인지 1인지 판단하는 지점을 의미. 단위는 % 이다. Sampling Point 단위는 % 이다. 이것도 OEM에서 몇 %로 해야하는지 정해준다. 하나의 bit는 Sync, Tseg1,Tseg2 라는 것으로 나뉘고 이것들은 모두 여러 개의 time qunta로 구성됨 Time qunta는 Tseg1, Tseg2 의 길이를 세는 단위 Tseg1, Tseg2의 값을 적절하게 정함으로써 샘플링 포인트 값을 조절할 수 있음. Tseg1, Tseg2 얼마로 할지도 제조사에서 정해주기도 함SJW(Synchronization Jump Width) 란?Tseg1, Tseg2 의 제한 범위에 대한 내용Message ID 메시지 수신받은 제어기들은 이 메세지가 무슨 메세지인지 누가 보낸건지 확인 필요 그것을 구분하기 위해 사용하는게 메세지의 ID ID별로 메세지의 이름을 붙이고, 그 메세지를 누가 보낼건지를 OEM에서 사전에 정의해둔다.-이런 정보가 담겨진 자료를 CAN Db, Can DataBase, Communiation Matrix , K-Matrix 등으로 부른다. ID의 값이 작을수록 우선순위가 높다. 버스에 메세지가 점유하고 있는 시간을 Bus Load(버스로드)라고 하고 단위는 %이다. 일반적으로 OEM에서 최대 Bus Load를 정해준다.CAN통신에서 메세지의 형태를 id의 길이에 따라서 메세지를 2가지 포멧으로 구분하는데 아래와 같다. Standard Format : 11bit Extended Format : 29bitCAN ERROR 처리Bit Error 내가 보낸 bit를 바로 읽어 봤을 때 bit가 다르면 에러로 감지하는 것 1 을 보냈는데 0, 0을 보냈는데 1인 경우 에러로 감지 예외) arbitration 과정에서는 내가 1을 보냈지만 0이 나올 수 있다. 이거는 에러가 아님 Stuff Error 6개 연속 같은 bit가 버스에 나오는 것 에러(Physically, 수신인도 이 에러 확인한다) CRC ( Cyclic Redundancy Code) Error CRC 값 이상할 때 Acknowlege 에러 참고, 리시버는 ack 보낼 때 bit error체크도 한다. Sender가 1로 보냈는데 0으로 수신 안되면 에러로 판단. Structure Error 데이터 양식이 어긋났을 때Low Speed CAN 낮은 Baud Rate 선 하나가 끊어져도 통신이 가능한 장점 캔 저항이 제어기마다 달려있음 현재는 거의 사용되지 않는다CAN-FD(CAN with Fast Data Rate) High Speed CAN의 낮은 BaudRate과 작은 크기의 Data 영역 보완한 것이 핵심 Data 영역 속도 최대 8Mbps Data /영역 크기 최대 64byte 가능 Arbitration 영역/Data 영역 간 BaudRate이 서로 다름 BaudRate 뿐만 아니라 Sampling Point도 별개임 Data 영역에 담을 수 있는 길이가 더 길다 (최대 64 byte. High Speed CAN은 8 byte) HighSpeed CAN과 같은 네트워크에서 함께 사용 가능CAN FD 지원가능한 Tranceiver 사용해야함 ex)TJA1043 종단 저항 크기 다를 수 있다" }, { "title": "리눅스 실무 입문 정리", "url": "/posts/%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%8B%A4%EB%AC%B4-%EC%9E%85%EB%AC%B8-%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-07-17 00:00:00 +0900", "snippet": "마법사 상어와 비바라기Linux Shell리눅스 커널을 조작 및 제어하기 위해 사용하는 인터페이스Shell?쉘(shell)이란 운영체제에서 제공하는 명령을 실행하는 프로그램이다. 인터프리터(통역사) 역할을 하는 것으로 시스템으로 지원하는 명령어들의 집합을 묶어서 프로그램화한 것을 말한다.Linux Shell Types sh (Bourne shell) : By Unix Shell, Super shell =&gt; 가장 기본이 되는 쉘 bash (Bourne-agin shell) : Super shell in Linux =&gt; 가장 많이 사용 csh (C shell) : C like syntax tcsh (Enhanced-C shell): c ksh (korn shell) : by David Korn, Powerful Script Language zch (Z shell) : Unix/GNU shell script, Powerful Script LanguageLinux File System Directories /bin : 기본 명령어 /boot : for booting /dev : device file, cd-rom /etc : config, passwd, rc.d /home : user home dir /lib : shared library /media : ssd /opt : application software package /proc : process info /root : root home dir /sbin : 관리자용, ifconfig /srv : system data /tmp : temporary dir /usr : source or programs /usr/local /var : logs, ftp, spool, mailLinux Ports 20 FTP (data) 21 FTP (Control) 22 SSH / rsync / rcp 23 Telnet 25 SMTP (Simple Mail Transfer) 465 SMTPS 43 whois 53 DNS 20 FTP (data) 21 FTP (Control) 22 SSH / rsync / rcp 23 Telnet 25 SMTP (Simple Mail Transfer) 465 SMTPS 43 whois 53 DNS" }, { "title": "마법사 상어와 비바라기", "url": "/posts/%EB%A7%88%EB%B2%95%EC%82%AC-%EC%83%81%EC%96%B4%EC%99%80-%EB%B9%84%EB%B0%94%EB%9D%BC%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-04-06 00:00:00 +0900", "snippet": "마법사 상어와 비바라기구름 생성 함수에서 실수가 발생하여 오래걸렸던 문제si 값만큼 di 방향으로 움직이는 함수를 for 구문으로 구현하던 중 ny, nx값이 += 로 누적되어야 하지만 = 으로 값을 특정 값으로 초기화 하는 실수를 범했다.이런 실수는 하지 않도록 하자…#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int A[55][55] = { {0,}, };bool cloud[55][55] = { {0,}, };int dy[8] = { 0, -1, -1, -1, 0, 1, 1, 1 };int dx[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };vector&lt;int&gt; dir;vector&lt;int&gt; dist;vector&lt;pair&lt;int, int&gt; &gt; cloud_num;int answer = 0;void input_func(){\tint d, s;\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;A[i][j]);// i, j는 i행 c열에 있는 바구니, A[i][j] 는 바구니 안 물의 양, 순환구조\t\t}\t}\tfor (int i = 0; i &lt; M; i++)\t{\t\tscanf(\"%d %d\", &amp;d, &amp;s);\t\tdir.push_back(d);\t\tdist.push_back(s);\t}}void init_cloud(){\t// cloud 좌표 및 갯수 체크용 vector\tcloud_num.push_back(make_pair(N - 2, 0));\tcloud_num.push_back(make_pair(N - 2, 1));\tcloud_num.push_back(make_pair(N - 1, 0));\tcloud_num.push_back(make_pair(N - 1, 1));\tfor (int i = 0; i &lt; cloud_num.size(); i++)\t{\t\tint x, y;\t\ty = cloud_num[i].first;\t\tx = cloud_num[i].second;\t\tcloud[y][x] = true;\t}}int cycle_func(int x){\tif (x &lt; 0)\t\treturn N - 1;\tif (x &gt;= N)\t\treturn 0;\treturn x;}void move_cloud(int idx){\tint direc = dir[idx] - 1;\tint movcnt = dist[idx];\t\tfor (int i = 0; i &lt; cloud_num.size(); i++)\t{\t\tint ny = cloud_num[i].first, nx = cloud_num[i].second;\t\t\t\tfor (int j = 0; j &lt; movcnt; j++)\t\t{\t\t\tny += dy[direc];\t\t\tnx += dx[direc];\t\t\tny = cycle_func(ny);\t\t\tnx = cycle_func(nx);\t\t}\t\tcloud_num[i].first = ny;\t\tcloud_num[i].second = nx;\t\t\t}\tmemset(cloud, false, sizeof(cloud));\tfor (int i = 0; i &lt; cloud_num.size(); i++)\t{\t\tint x, y;\t\ty = cloud_num[i].first;\t\tx = cloud_num[i].second;\t\tcloud[y][x] = true;\t\tA[y][x]++;\t}}void water_copy_bug(){\tfor (int i = 0; i &lt; cloud_num.size(); i++)\t{\t\tint cnt = 0;\t\tint y = cloud_num[i].first;\t\tint x = cloud_num[i].second;\t\tfor (int j = 1; j &lt; 8; j += 2)\t\t{\t\t\tint ny = y + dy[j];\t\t\tint nx = x + dx[j];\t\t\tif (nx &lt; 0 || nx &gt;= N || ny &lt; 0 || ny &gt;= N)\t\t\t\tcontinue;\t\t\tif (A[ny][nx] &gt;= 1)\t\t\t\tcnt++;\t\t}\t\tA[y][x] += cnt;\t}}void make_cloud(){\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tif (cloud[i][j] == true)\t\t\t\tcontinue;\t\t\tif (A[i][j] &gt;= 2)\t\t\t{\t\t\t\tcloud_num.push_back(make_pair(i, j));\t\t\t\tA[i][j] -= 2;\t\t\t}\t\t}\t}\tmemset(cloud, false, sizeof(cloud));//구름이 사라진 칸이 아닌 것을 체크하기 위해 사용\tfor (int i = 0; i &lt; cloud_num.size(); i++)\t{\t\tint x, y;\t\ty = cloud_num[i].first;\t\tx = cloud_num[i].second;\t\tcloud[y][x] = true;\t}}void find_water_size(){\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tanswer += A[i][j];\t\t}\t}}/*1. 모든 구름이 di 방향으로 si칸 이동한다.2. 각 구름에서 비가 내려 구름이 있는 칸의 바구니에 저장된 물의 양이 1 증가한다.3. 구름이 모두 사라진다.4. 2에서 물이 증가한 칸 (r, c)에 물복사버그 마법을 시전한다. 물복사버그 마법을 사용하면,대각선 방향으로 거리가 1인 칸에 물이 있는 바구니의 수만큼 (r, c)에 있는 바구니의 물이 양이 증가한다.이때는 이동과 다르게 경계를 넘어가는 칸은 대각선 방향으로 거리가 1인 칸이 아니다.예를 들어, (N, 2)에서 인접한 대각선 칸은 (N-1, 1), (N-1, 3)이고, (N, N)에서 인접한 대각선 칸은 (N-1, N-1)뿐이다.5. 바구니에 저장된 물의 양이 2 이상인 모든 칸에 구름이 생기고, 물의 양이 2 줄어든다. 이때 구름이 생기는 칸은 3에서 구름이 사라진 칸이 아니어야 한다.*/int main(int argc, char** argv){\tinput_func();\tinit_cloud();\tfor (int i = 0; i &lt; M; i++)\t{\t\tmove_cloud(i); // 1번, 2번\t\twater_copy_bug(); // 4번\t\tcloud_num.clear(); // 3번\t\tmake_cloud(); // 5번\t}\tfind_water_size();\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "마법사 상어와 토네이도", "url": "/posts/%EB%A7%88%EB%B2%95%EC%82%AC-%EC%83%81%EC%96%B4%EC%99%80-%ED%86%A0%EB%84%A4%EC%9D%B4%EB%8F%84/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2023-04-05 00:00:00 +0900", "snippet": "마법사 상어와 토네이도문제를 총 2가지로 나눠보면, 토네이도의 이동 경로 설정 비율 별로 모래를 흩날리게 하기이 두가지이고 먼저 1번의 경우 패턴을 보면 방향전환을 총 2번한 후 이동 거리가 1씩 증가하는 것을 알 수있다.이러한 나선형 이동 구조를 바탕으로 어떤 크기든 최종적으로 종착점은 0,0이다.(종료 조건)2번의 경우 기존 dx, dy 이동 배열 뿐만 아니라 방향 별로 모래가 흩날리게 되는 비율을 설정하는 배열 t_dx, t_dy를 추가로 설정하고 문제에 사용한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;float s_rat[9] = { 0.01, 0.01, 0.07, 0.07, 0.1, 0.1, 0.02, 0.02, 0.05 };//서남동북 순int dy[4] = { 0, 1, 0, -1 };int dx[4] = { -1, 0, 1, 0 };int t_dy[4][10] = {\t\t\t\t{-1, 1, -1, 1, -1, 1, -2, 2, 0, 0}, // 서\t\t\t\t{-1, -1, 0, 0, 1, 1, 0, 0, 2, 1}, // 남\t\t\t\t{1, -1, 1, -1, 1, -1, 2, -2, 0, 0}, // 동\t\t\t\t{1, 1, 0, 0, -1, -1, 0, 0, -2, -1} // 북\t\t\t\t};int t_dx[4][10] = {\t\t\t\t{1, 1, 0, 0, -1, -1, 0, 0, -2, -1}, // 서\t\t\t\t{-1, 1, -1, 1, -1, 1,-2, 2, 0, 0}, // 남\t\t\t\t{-1, -1, 0, 0, 1, 1, 0, 0, 2, 1}, // 동\t\t\t\t{1, -1, 1, -1, 1, -1, 2, -2, 0, 0} // 북\t\t\t\t};int N, answer = 0;int arr[500][500] = { { 0,}, };/*토네이도는 한 번에 한 칸 이동한다토네이도 회전을 보면 이동방향을 두번 틀 때마다 이동 거리가 1씩 증가한다.결과적으로 크기가 몇이든 0,0 점이 종착점이 된다.*/void input_func(){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}}void sand_checker(){\tint cx = N / 2;\tint cy = N / 2;\t\t\tint dir = 0; // 0 : 서, 1 : 남, 2 : 동, 3 : 북\tint dist = 1; // 이동 간격\tint cnt = 0; // 두 번 체크 변수\tint sandtemp = 0;\t//탈출조건 허리케인이 종착지 0, 0에 도달 했을 때\twhile(true)\t{\t\t\tcnt++;\t\tfor (int i = 0; i &lt; dist; i++)\t\t{\t\t\tint nx = cx + dx[dir];\t\t\tint ny = cy + dy[dir];\t\t\tint sandtemp = arr[ny][nx];\t\t\tfor (int j = 0; j &lt; 9; j++)\t\t\t{\t\t\t\t\t\t\t\tint t_nx = nx + t_dx[dir][j];\t\t\t\tint t_ny = ny + t_dy[dir][j];\t\t\t\tint tpointsand = arr[ny][nx] * s_rat[j];\t\t\t\tsandtemp -= tpointsand;\t\t\t\tif (t_nx &lt; 0 || t_ny &lt; 0 || t_nx &gt;= N || t_ny &gt;= N)\t\t\t\t\tanswer += tpointsand;\t\t\t\telse\t\t\t\t\tarr[t_ny][t_nx] += tpointsand;\t\t\t}\t\t\t\t\t\tint t_nx = nx + t_dx[dir][9];\t\t\tint t_ny = ny + t_dy[dir][9];\t\t\tif (t_nx &lt; 0 || t_ny &lt; 0 || t_nx &gt;= N || t_ny &gt;= N)\t\t\t\tanswer += sandtemp;\t\t\telse\t\t\t\tarr[t_ny][t_nx] += sandtemp;\t\t\t\t\t\tarr[ny][nx] = 0; // 해당 지역 모래는 모두 사라진다.\t\t\t\t\t\tif (nx == 0 &amp;&amp; ny == 0)\t\t\t\treturn;\t\t\tcx = nx;\t\t\tcy = ny;\t\t\t\t\t\t\t\t}\t\tif (cnt == 2)\t\t{\t\t\tcnt = 0;\t\t\tdist++;\t\t}\t\tdir = (dir + 1) % 4; // 반시계 방향으로 90도 방향회전\t\t\t}\treturn;}int main(int argc, char** argv){\tinput_func();\tsand_checker();\tprintf(\"%d\\n\", answer);\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}" }, { "title": "안전 지대", "url": "/posts/%EC%95%88%EC%A0%84-%EC%A7%80%EB%8C%80/", "categories": "CodingTest", "tags": "CodingTest, BFS, DFS", "date": "2023-04-02 00:00:00 +0900", "snippet": "안전 지대문제 :N×M 크기의 격자로 구성된 마을이 있습니다. 격자마다 한 집을 의미하며, 각 집의 높이는 1이상 100이하의 숫자로 이루어져 있습니다.이런 상황에서 만약 비가 K(K≥1)만큼 온다고 한다면, 마을에 있는 집들 중 높이가 K 이하인 집들은 전부 물에 잠기게 되기 때문에, 대책을 세우기 위해 미리 각 K에 따라 안전 영역의 개수가 어떻게 달라지는지를 보려고 합니다. 여기서 안전 영역이란 잠기지 않은 집들로 이루어져 있으며, 잠기지 않은 집들끼리 서로 인접해 있는 경우 동일한 안전 영역에 있는 것으로 봅니다.위의 예에서 K=1인 경우에는 안전한 영역은 1개 입니다.첫 번째 줄에는 N과 M이 공백을 사이에 두고 주어지고,두 번째 줄부터는 N개의 줄에 걸쳐 각 행에 위치한 M개의 마을의 높이 정보가 공백을 사이에 두고 주어집니다.1≤N,M≤501≤ 각 집의 높이 ≤100해결 방안 :2차원 배열을 탐색하며 Flood Fill Algorithm 을 묻는 문제 BFS 로 해결 방법#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int vhi[100][100] = { 0 };int arr[100][100] = { 0 };bool isvisited[100][100] = { false };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};int N, M, K, ans, ans_idx;void findMax(){ for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { if(K &lt; vhi[i][j]) { K = vhi[i][j]; } } } }void floodFill(int height){ for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { if(height &lt; vhi[i][j]) arr[i][j] = 1; else arr[i][j] = 0; } }}void init(){ for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { isvisited[i][j] = false; } }}void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; isvisited[y][x] = true; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; nx &gt;=0 &amp;&amp; nx &lt; M) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == false) { q.push(make_pair(ny, nx)); isvisited[ny][nx] = true; } } } }}int main() { scanf(\"%d %d\", &amp;N, &amp;M); // 여기에 코드를 작성해주세요. for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { scanf(\"%d\", &amp;vhi[i][j]); } } findMax(); for(int tc = 1; tc &lt;= K; tc++) { int temp_max = 0, temp_maxidx = 0; floodFill(tc); init(); for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { if(arr[i][j] == 1 &amp;&amp; isvisited[i][j] == false) { bfs(i, j); temp_max++; temp_maxidx = tc; } } } if(temp_max &gt; ans) { ans = temp_max; ans_idx = temp_maxidx; } } // 모두 높이가 1인 배열이 주어질 경우 예외 처리 if(ans == 0) ans_idx = 1; printf(\"%d %d\\n\", ans_idx, ans); return 0;} DFS 로 문제 해결#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX_N 50#define MAX_M 50#define MAX_HEIGHT 100#define DIR_NUM 4using namespace std;int n, m;int grid[MAX_N][MAX_M];bool visited[MAX_N][MAX_M];int zone_num;// visited 배열을 초기화해줍니다.void InitializeVisited() { for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) visited[i][j] = false;}// 탐색하는 위치가 격자 범위 내에 있는지 여부를 반환합니다.bool InRange(int x, int y) { return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m;}// 탐색하는 위치로 움직일 수 있는지 여부를 반환합니다.bool CanGo(int x, int y, int k) { if(!InRange(x, y)) return false; if(visited[x][y] || grid[x][y] &lt;= k) return false; return true;}void DFS(int x, int y, int k) { //0: 오른쪽, 1: 아래쪽, 2: 왼쪽, 3: 위쪽 int dx[DIR_NUM] = {0, 1, 0, -1}; int dy[DIR_NUM] = {1, 0, -1, 0}; // 네 방향에 각각에 대하여 DFS 탐색을 합니다. for(int dir = 0; dir &lt; DIR_NUM; dir++) { int new_x = x + dx[dir]; int new_y = y + dy[dir]; if(CanGo(new_x, new_y, k)){ visited[new_x][new_y] = true; DFS(new_x, new_y, k); } }}void GetZoneNum(int k) { // 새로운 탐색을 시작한다는 의미로 zone_num를 0으로 갱신하고 // visited 배열을 초기화해줍니다. zone_num = 0; InitializeVisited(); // 격자의 각 위치에 대하여 탐색을 시작할 수 있는 경우 // 해당 위치로부터 시작한 DFS 탐색을 수행합니다. for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) { if(CanGo(i, j, k)) { // 해당 위치를 탐색할 수 있는 경우 visited 배열을 갱신하고 // 안전 영역을 하나 추가해줍니다. visited[i][j] = true; zone_num++; DFS(i, j, k); } }}int main() { // 가능한 안전 영역의 최솟값이 0이므로 다음과 같이 초기화 해줄 수 있습니다. int max_zone_num = -1; int answer_k = 0; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; m; j++) cin &gt;&gt; grid[i][j]; // 각 가능한 비의 높이에 대하여 안전 영역의 수를 탐색합니다. for(int k = 1; k &lt;= MAX_HEIGHT; k++){ GetZoneNum(k); // 기존의 최대 영역의 수보다 클 경우 이를 갱신하고 인덱스를 저장합니다. if(zone_num &gt; max_zone_num) { max_zone_num = zone_num; answer_k = k; } } cout &lt;&lt; answer_k &lt;&lt; \" \" &lt;&lt; max_zone_num; return 0;}" }, { "title": "뿌요뿌요", "url": "/posts/%EB%BF%8C%EC%9A%94%EB%BF%8C%EC%9A%94/", "categories": "CodingTest", "tags": "CodingTest, BFS, DFS", "date": "2023-04-02 00:00:00 +0900", "snippet": "뿌요뿌요2차원 배열을 탐색하며 Flood Fill Algorithm 을 묻는 문제 BFS 로 해결 방법#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, max_num = 0, max_block = 0, block_cnt = 0;int arr[100][100] = { 0 };bool isvisited[100][100] = { false };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};void findMax(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(max_num &lt; arr[i][j]) { max_num = arr[i][j]; } } } }void init(){ for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { isvisited[i][j] = false; } }}int bfs(int y, int x, int block_num){ queue&lt;pair&lt;int,int&gt; &gt; q; q.push(make_pair(y, x)); isvisited[y][x] = true; int temp_blockcnt = 1; while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;=0 &amp;&amp; nx &lt; n) { if(arr[ny][nx] == block_num &amp;&amp; isvisited[ny][nx] == false) { q.push(make_pair(ny, nx)); isvisited[ny][nx] = true; temp_blockcnt++; } } } } return temp_blockcnt;}int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } findMax(); for(int tc = 1; tc &lt;= max_num; tc++) { int temp_max = 0, temp_maxidx = 0; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(arr[i][j] == tc &amp;&amp; isvisited[i][j] == false) { temp_max = bfs(i, j, tc); if(temp_max &gt;= 4) { block_cnt++; if(temp_max &gt; max_block) { max_block = temp_max; } } } } } } printf(\"%d %d\\n\", block_cnt, max_block); return 0;} DFS 로 문제 해결#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX_NUM 100#define DIR_NUM 4using namespace std;int n;int grid[MAX_NUM][MAX_NUM];bool visited[MAX_NUM][MAX_NUM];int max_block;int bomb_cnt;int curr_block_num;// 탐색하는 위치가 격자 범위 내에 있는지 여부를 반환합니다.bool InRange(int x, int y) { return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n;}// 탐색하는 위치로 움직일 수 있는지 여부를 반환합니다.bool CanGo(int x, int y, int color) { if(!InRange(x, y)) return false; if(visited[x][y] || grid[x][y] != color) return false; return true;}void DFS(int x, int y) { //0: 오른쪽, 1: 아래쪽, 2: 왼쪽, 3: 위쪽 int dx[DIR_NUM] = {0, 1, 0, -1}; int dy[DIR_NUM] = {1, 0, -1, 0}; // 네 방향에 각각에 대하여 DFS 탐색을 합니다. for(int dir = 0; dir &lt; DIR_NUM; dir++) { int new_x = x + dx[dir]; int new_y = y + dy[dir]; if(CanGo(new_x, new_y, grid[x][y])){ visited[new_x][new_y] = true; // 블럭이 하나 추가됩니다. curr_block_num++; DFS(new_x, new_y); } }}int main() { cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) for(int j = 0; j &lt; n; j++) cin &gt;&gt; grid[i][j]; // 격자의 각 위치에서 탐색을 시작할 수 있는 경우 // 한 블럭에 대한 DFS 탐색을 수행합니다. for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(!visited[i][j] &amp;&amp; grid[i][j]) { // 해당 블럭을 방문할 수 있는 경우 visited 배열을 갱신하고 // 새로운 블럭을 탐색한다는 의미로 curr_block_num을 1으로 갱신합니다. visited[i][j] = true; curr_block_num = 1; DFS(i, j); // 한 블럭 묶음에 대한 탐색이 끝난 경우 답을 갱신합니다. if(curr_block_num &gt;= 4) bomb_cnt++; max_block = max(max_block, curr_block_num); } } } cout &lt;&lt; bomb_cnt &lt;&lt; \" \" &lt;&lt; max_block; return 0;}" }, { "title": "마을 구분하기", "url": "/posts/%EB%A7%88%EC%9D%84-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS, DFS", "date": "2023-04-01 00:00:00 +0900", "snippet": "마을 구분하기2차원 배열을 탐색하며 Flood Fill Algorithm 을 묻는 문제 BFS 로 해결 방법#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, village = 0;int arr [100][100] = { 0 };bool isvisited[100][100] = { 0 };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};vector&lt;int&gt; people;void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; isvisited[y][x] = true; q.push(make_pair(y, x)); int people_cnt = 0; while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); people_cnt++; for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;=0 &amp;&amp; nx &lt; n) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == false) { isvisited[ny][nx] = true; q.push(make_pair(ny, nx)); } } } } people.push_back(people_cnt); return;}int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(arr[i][j] == 1 &amp;&amp; isvisited[i][j] == false) { bfs(i, j); village++; } } } sort(people.begin(), people.end()); printf(\"%d\\n\", village); for(int i = 0; i &lt; people.size(); i++) { printf(\"%d\\n\", people[i]); } // 여기에 코드를 작성해주세요. return 0;} DFS 로 문제 해결#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, village = 0, people_cnt = 0;int arr [100][100] = { 0 };bool isvisited[100][100] = { 0 };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};vector&lt;int&gt; people;void dfs(int y, int x){ isvisited[y][x] = true; for(int dir = 0; dir &lt; 4; dir++) { int ny = y + dy[dir]; int nx = x + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;=0 &amp;&amp; nx &lt; n) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == false) { isvisited[ny][nx] = true; dfs(ny, nx); people_cnt++; } } } return;}int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { if(arr[i][j] == 1 &amp;&amp; isvisited[i][j] == false) { // 방문체크 배열과 사람 수가 한 세트로 간다고 이해하면 쉽다. people_cnt = 1; dfs(i, j); people.push_back(people_cnt); village++; } } } sort(people.begin(), people.end()); printf(\"%d\\n\", village); for(int i = 0; i &lt; people.size(); i++) { printf(\"%d\\n\", people[i]); } // 여기에 코드를 작성해주세요. return 0;}" }, { "title": "두 방향 탈출 가능 여부 판별하기", "url": "/posts/%EB%91%90-%EB%B0%A9%ED%96%A5-%ED%83%88%EC%B6%9C-%EA%B0%80%EB%8A%A5-%EC%97%AC%EB%B6%80-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2023-04-01 00:00:00 +0900", "snippet": "두 방향 탈출 가능 여부 판별하기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n, m, answer = 0;int arr [100][100] = { 0 };bool isvisited[100][100] = { 0 };int dy[2] = {0, 1};int dx[2] = {1, 0};void dfs(int y, int x){ for(int dir = 0; dir &lt; 2; dir++) { int ny = y + dy[dir]; int nx = x + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;=0 &amp;&amp; nx &lt; m) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == false) { isvisited[ny][nx] = true; dfs(ny, nx); } } } return;}int main() { scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { scanf(\"%d\", &amp;arr[i][j]); } } dfs(0, 0); if(isvisited[n-1][m-1] == true) answer = 1; else answer = 0; printf(\"%d\\n\", answer); // 여기에 코드를 작성해주세요. return 0;}" }, { "title": "1차원 윷놀이", "url": "/posts/%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%88%98%EC%97%B4-%EC%A4%91-%EC%B5%9C%EC%86%9F%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-31 00:00:00 +0900", "snippet": "1차원 윷놀이말의 시작 위치와 말이 n번까지 움직이지 않아도 최댓값이 나올 수 있으므로 재귀 종료조건이 아닐 때도 최댓값을 갱신해야하는 것을 주의한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n, m, k, answer = 0;vector&lt;int&gt; arr;int horse[5] = { 0 };int findmax(){ int temp_max = 0; for(int i = 1; i &lt;= k; i++) { if(horse[i] &gt;= m) temp_max++; } return temp_max;}void perm(int cnt){ // 말을 n번까지 움직이지 않아도 최대값이 나올 수 있으므로 항상 최댓값을 갱신한다. if(findmax() &gt; answer) answer = findmax(); if(cnt == n) { return; } for(int i = 1; i &lt;= k; i++) { if(horse[i] &gt;= m) continue; horse[i] += arr[cnt]; perm(cnt + 1); horse[i] -= arr[cnt]; }}int main() { // 여기에 코드를 작성해주세요. // m 숫자 배열, k 말의 개수, n 번의 턴 scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for(int i = 0; i &lt; n; i++) { int temp; scanf(\"%d\", &amp;temp); arr.push_back(temp); } // 말은 첫번째 칸에서 시작한다. for(int i = 1; i &lt;= k; i++) { horse[i] = 1; } perm(0); printf(\"%d\\n\", answer); return 0;}" }, { "title": "1차원 윷놀이", "url": "/posts/1%EC%B0%A8%EC%9B%90-%EC%9C%B7%EB%86%80%EC%9D%B4/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-29 00:00:00 +0900", "snippet": "1차원 윷놀이말의 시작 위치와 말이 n번까지 움직이지 않아도 최댓값이 나올 수 있으므로 재귀 종료조건이 아닐 때도 최댓값을 갱신해야하는 것을 주의한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n, m, k, answer = 0;vector&lt;int&gt; arr;int horse[5] = { 0 };int findmax(){ int temp_max = 0; for(int i = 1; i &lt;= k; i++) { if(horse[i] &gt;= m) temp_max++; } return temp_max;}void perm(int cnt){ // 말을 n번까지 움직이지 않아도 최대값이 나올 수 있으므로 항상 최댓값을 갱신한다. if(findmax() &gt; answer) answer = findmax(); if(cnt == n) { return; } for(int i = 1; i &lt;= k; i++) { if(horse[i] &gt;= m) continue; horse[i] += arr[cnt]; perm(cnt + 1); horse[i] -= arr[cnt]; }}int main() { // 여기에 코드를 작성해주세요. // m 숫자 배열, k 말의 개수, n 번의 턴 scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for(int i = 0; i &lt; n; i++) { int temp; scanf(\"%d\", &amp;temp); arr.push_back(temp); } // 말은 첫번째 칸에서 시작한다. for(int i = 1; i &lt;= k; i++) { horse[i] = 1; } perm(0); printf(\"%d\\n\", answer); return 0;}" }, { "title": "특정 조건에 맞게 k개 중에 1개를 n번 뽑기", "url": "/posts/%ED%8A%B9%EC%A0%95-%EC%A1%B0%EA%B1%B4%EC%97%90-%EB%A7%9E%EA%B2%8C-k%EA%B0%9C-%EC%A4%91%EC%97%90-1%EA%B0%9C%EB%A5%BC-n%EB%B2%88-%EB%BD%91%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-28 00:00:00 +0900", "snippet": "특정 조건에 맞게 k개 중에 1개를 n번 뽑기중복 순열을 출력하면서 중복되는 숫자가 연속으로 3개가 나오는 순열은 출력에서 제외하는 문제이다.기존 처럼 순열을 출력하고, 출력하기 전 제외해야하는 경우를 체크하는 코드를 추가한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int N, K;vector&lt;int&gt; arr;void perm(int cnt){ if(cnt == N) { if(cnt &gt;= 3) { for(int i = 0; i &lt; N - 2; i++) { if(arr[i] == arr[i + 1] &amp;&amp; arr[i + 1] == arr[i + 2]) return; } } for(int i = 0; i &lt; N; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return ; } for(int i = 1; i &lt;= K; i++) { arr.push_back(i); perm(cnt + 1); arr.pop_back(); }}int main() { scanf(\"%d %d\", &amp;K, &amp;N); perm(0); // 여기에 코드를 작성해주세요. return 0;}" }, { "title": "아름다운 수", "url": "/posts/%EC%95%84%EB%A6%84%EB%8B%A4%EC%9A%B4-%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-28 00:00:00 +0900", "snippet": "아름다운 수백 트래킹 방법을 사용하여 1~4 사이 숫자의 조합으로 아름다운 수(해당 숫자만큼 연달아 같은 숫자가 나오는 숫자)를 찾는다.먼저 백 트래킹을 사용하여 1~4 사이 숫자로 조합가능한 중복순열을 구하고 각 자리수 별 숫자를 vector 값에 저장한다. 그리고 해당 숫자가 아름다운 수인지 판정하는 로직을 통해 결과 판정 후 맞다면 정답 카운트를 +1 씩 증가시킨다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, answer;vector&lt;int&gt; numarr;bool check_bnum(){ for(int i = 0; i &lt; n; i += numarr[i]) { // array out of bound 경우 제거 if(i + numarr[i] - 1 &gt;= n) return false; for(int j = i; j &lt; i + numarr[i]; j++) { if(numarr[i] != numarr[j]) return false; } } return true;}void count_bnum(int cnt){ if(cnt == n) { if(check_bnum()) answer++; return; } for(int i = 1; i &lt;= 4; i++) { numarr.push_back(i); count_bnum(cnt+1); numarr.pop_back(); }}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d\", &amp;n); count_bnum(0); printf(\"%d\\n\", answer); return 0;}" }, { "title": "k개 중에 1개를 n번 뽑기", "url": "/posts/k%EA%B0%9C-%EC%A4%91%EC%97%90-1%EA%B0%9C%EB%A5%BC-n%EB%B2%88-%EB%BD%91%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-27 00:00:00 +0900", "snippet": "k개 중에 1개를 n번 뽑기백 트래킹의 대표적인 문제로 중복 순열을 구하는 문제이다.vector container와 배열로 문제를 해결하는 두가지 솔루션을 출력해보면,배열로 문제를 해결한 경우#include &lt;cstdio&gt;#include &lt;iostream&gt;int K, N;int arr[8] = { 0 };void perm(int cnt){ if(cnt == N) { for(int i = 0; i &lt; N; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return ; } for(int i = 1; i &lt;= K; i++) { arr[cnt] = i; cnt++; perm(cnt); cnt--; }}int main() { scanf(\"%d %d\", &amp;K, &amp;N); perm(0); return 0;}vector container로 문제를 해결한 경우#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int k, n;vector&lt;int&gt; selected_nums;// 선택된 원소들을 출력해줍니다.void PrintPermutation() { for(int i = 0; i &lt; (int) selected_nums.size(); i++) cout &lt;&lt; selected_nums[i] &lt;&lt; \" \"; cout &lt;&lt; endl;}void FindPermutations(int cnt) { // n개를 모두 뽑은 경우 답을 출력해줍니다. if(cnt == n) { PrintPermutation(); return; } // 1부터 k까지의 각 숫자가 뽑혔을 때의 경우를 탐색합니다. for(int i = 1; i &lt;= k; i++) { selected_nums.push_back(i); FindPermutations(cnt + 1); selected_nums.pop_back(); }}int main() { cin &gt;&gt; k &gt;&gt; n; FindPermutations(0); return 0;}" }, { "title": "숫자의 순차적 이동", "url": "/posts/%EC%88%AB%EC%9E%90%EC%9D%98-%EC%88%9C%EC%B0%A8%EC%A0%81-%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-26 00:00:00 +0900", "snippet": "숫자의 순차적 이동배열 내 원소를 swap 하는 문제이다. 한 번 교환이 일어나고 나면 그 숫자에 대해 연속해서 swap이 일어나지 않도록 break를 걸어 바로 2중 for문을 탈출하고 그 다음 숫자에 대해 swap이 진행될 수 있도록 해야 한다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int arr[21][21] = { 0 };int temparr[21][21] = { 0 };// 상하좌우int dx[8] = {-1, 0, 1, 1, 1, 0, -1, -1};int dy[8] = {-1, -1, -1, 0, 1, 1, 1, 0};void swap(int y, int x){ int max_num = 0, max_y = 0, max_x = 0; for(int dir = 0; dir &lt; 8; dir++) { int ny = y + dy[dir]; int nx = x + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= n) { if(arr[ny][nx] &gt; max_num) { max_num = arr[ny][nx]; max_y = ny; max_x = nx; } } } // swap int temp = arr[y][x]; arr[y][x] = arr[max_y][max_x]; arr[max_y][max_x] = temp;}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } while(m--) { for(int srch_num = 1; srch_num &lt;= n * n; srch_num++) { for(int i = 1; i &lt;= n; i++) { int end_flag = 0; for(int j = 1; j &lt;= n; j++) { // swap이 일어난 후 바로 다시 초기로 돌아가 srch_num을 1 증가시키고 탐색하도록 한다. if(arr[i][j] == srch_num) { swap(i, j); end_flag = 1; break; } } if(end_flag) { break; } } } } // 정답 출력 for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { printf(\"%d \", arr[i][j]); } printf(\"\\n\"); } return 0;}" }, { "title": "벽 짚고 미로 탈출하기", "url": "/posts/%EB%B2%BD-%EC%A7%9A%EA%B3%A0-%EB%AF%B8%EB%A1%9C-%ED%83%88%EC%B6%9C%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-26 00:00:00 +0900", "snippet": "벽 짚고 미로 탈출하기벽을 타고 이동하는 움직임과 90도 회전 후 이동을 구현하여 미로를 탈출 가능 여부와 걸리는 시간에 대해 묻는 문제이다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int n, r, c, elapsed_time, unreachable_flag = 0, ny, nx;int curr_x, curr_y, curr_dir; // 현재 위치와 방향을 의미합니다.int y = 1, x = 1;char arr[101][101] = { \"\" };int isvisited[101][101][4] = { 0 }; // 우하좌상(시계방향)int dy[4] = {0, 1, 0, -1};int dx[4] = {1, 0, -1, 0};bool inRange(int y, int x) { return y &gt;= 1 &amp;&amp; y &lt;= n &amp;&amp; x &gt;= 1 &amp;&amp; x &lt;= n;}// 우측에 벽이 있는 경우bool wallExist(int y, int x) { return inRange(y, x) &amp;&amp; arr[y][x] == '#';}void simulate() { //이미 방문한 적이 있다면 탈출 풀가 if(isvisited[curr_y][curr_x][curr_dir]) { printf(\"-1\\n\"); // 출력 후 프로그램 종료 exit(0); } // 해당 노드 방문 체크 isvisited[curr_y][curr_x][curr_dir] = 1; int nx = curr_x + dx[curr_dir]; int ny = curr_y + dy[curr_dir]; // 바라보고 있는 방향에 벽이 있는 경우 반시계 회전 if(wallExist(ny, nx)) curr_dir = (curr_dir - 1 + 4) % 4; // 탈출하는 경우 simulate 상에서는 시간만 증가(while문에서 탈출) else if(!inRange(ny, nx)) { curr_x = nx; curr_y = ny; elapsed_time++; } // 탈출하지 못하는 경우 else { // 시계 방향으로 돌면서 경우의 수 탐색 int ry = ny + dy[(curr_dir + 1) % 4]; int rx = nx + dx[(curr_dir + 1) % 4]; // 그대로 이동해도 바로 오른쪽에 짚을 벽이 있는 경우 해당 방향으로 한 칸 이동. if(wallExist(ry, rx)) { curr_x = nx; curr_y = ny; elapsed_time++; } // 그렇지 않다면 2칸 이동후 방향을 시계방향으로 90' 방향 변경. else { curr_x = rx; curr_y = ry; curr_dir = (curr_dir + 1) % 4; elapsed_time += 2; } }}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d\", &amp;n); scanf(\"%d %d\", &amp;r, &amp;c); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { cin &gt;&gt; arr[i][j]; } } curr_y = r; curr_x = c; curr_dir = 0; do { simulate(); }while(inRange(curr_y, curr_x)); printf(\"%d\\n\", elapsed_time); return 0;}" }, { "title": "숫자가 가장 큰 인접한 곳으로 동시에 이동", "url": "/posts/%EC%88%AB%EC%9E%90%EA%B0%80-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%9D%B8%EC%A0%91%ED%95%9C-%EA%B3%B3%EC%9C%BC%EB%A1%9C-%EB%8F%99%EC%8B%9C%EC%97%90-%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-25 00:00:00 +0900", "snippet": "숫자가 가장 큰 인접한 곳으로 동시에 이동동시에 여러 움직임을 구현하고 확인하는 문제로, 매 초 결과 상황을 업데이트하여 해결하는 문제이다.구슬 위치 상황을 업데이트 하는 2차원 배열을 두개를 만들고 각각 현재 상황과 1초 뒤 상황을 업데이트 하여 결과를 적용하고 1초 뒤 상황은 다시 초기화하는 방식으로 매초 구슬움직임 변화를 구현한다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m, t, answer;int arr[21][21] = { 0 };int cnt[21][21] = { 0 };int next_cnt[21][21] = { 0 };// 상하좌우int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void init_ball(){ for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { next_cnt[i][j] = 0; } }}void move(){ for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(cnt[i][j] == 1) { int max_num = 0, max_y = 0, max_x = 0; // 최대 값 탐색 및 좌표 업데이트 (상 =&gt; 하 =&gt; 좌 =&gt; 우 순) for(int dir = 0; dir &lt; 4; dir++) { int ny = i + dy[dir]; int nx = j + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= n) { if(arr[ny][nx] &gt; max_num) { max_num = arr[ny][nx]; max_y = ny; max_x = nx; } } } next_cnt[max_y][max_x]++; } } } // 이동 종료 후 결과 복사 for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { cnt[i][j] = next_cnt[i][j]; } }}void remove_ball(){ for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(cnt[i][j] &gt;= 2) cnt[i][j] = 0; } }}void simulate(){ init_ball(); move(); remove_ball();}int main() { // 여기에 코드를 작성해주세요. //m : 구슬의 개수 t 시간 scanf(\"%d %d %d\", &amp;n, &amp;m ,&amp;t); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } while(m--) { int y, x; scanf(\"%d %d\", &amp;y, &amp;x); cnt[y][x] = 1; } while(t--) { simulate(); } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(cnt[i][j] == 1) answer++; } } printf(\"%d\\n\", answer); return 0;}" }, { "title": "떨어지는 1자 블록", "url": "/posts/%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-1%EC%9E%90-%EB%B8%94%EB%A1%9D/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-24 00:00:00 +0900", "snippet": "떨어지는 1자 블록기본적인 BFS 문제, 이동 경로를 출력한다.떨어지는 블럭의 최종적인 위치를 계산하고 그 블럭을 채워 넣는다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m, k;int arr[101][101] = { 0 };int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } int down_step = 0; // 떨어질 블럭의 y 좌표(down_step)를 계산한다. for(int i = 0; i &lt;= n - 1; i++) { int down_flag = 1; for(int j = k; j &lt;= k + m -1; j++) { if(arr[i][j] != arr[i+1][j]) { down_flag = 0; } } if(down_flag == 1) { down_step++; } else { break; } } // 떨어질 블럭을 구현한다. for(int j = k; j &lt;= k + m - 1; j++) { arr[down_step][j] = 1; } for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { printf(\"%d \", arr[i][j]); } printf(\"\\n\"); } return 0;}" }, { "title": "숫자가 더 큰 인접한 곳으로 이동", "url": "/posts/%EC%88%AB%EC%9E%90%EA%B0%80-%EB%8D%94-%ED%81%B0-%EC%9D%B8%EC%A0%91%ED%95%9C-%EA%B3%B3%EC%9C%BC%EB%A1%9C-%EC%9D%B4%EB%8F%99/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-23 00:00:00 +0900", "snippet": "숫자가 더 큰 인접한 곳으로 이동기본적인 BFS 문제, 이동 경로를 출력한다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, r, c, answer;int arr[101][101] = { 0 };int isvisited[101][101] = { 0 };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; answer = arr[cy][cx]; printf(\"%d \", answer); q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= n) { if(arr[ny][nx] &gt; answer &amp;&amp; isvisited[ny][nx] == 0) { isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); break; } } } }}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d %d\", &amp;n, &amp;r, &amp;c); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } bfs(r, c); printf(\"\\n\"); return 0;}" }, { "title": "최대 감소 부분 수열", "url": "/posts/%EC%B5%9C%EB%8C%80-%EA%B0%90%EC%86%8C-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-03-20 00:00:00 +0900", "snippet": "최대 감소 부분 수열최대 감소 수열에 대해 묻는 문제로 최대 증가 수열을 구하는 문제를 뒤집어 생각한다.먼저 수열의 마지막 dp값을 1로 놓고 시작한다.그리고 뒤에서 부터 dp 값을 업데이트 시켜 나간다. 이 때 앞의 값이 뒤에 값보다 커야하는 감소 부분 수열의 성질 빼고는 풀이 방식은 최대 증가수열과 같다.#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int N;int arr[1001] = { 0 };int dp[10001] = { 0 };int main(){ // 여기에 코드를 작성해주세요. scanf(\"%d\", &amp;N); for(int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;arr[i]); } dp[N - 1] = 1; for(int i = N - 2; i &gt;= 0; i--) { int max_num = 0; for(int j = i + 1; j &lt; N; j++) { if(arr[i] &gt; arr[j] &amp;&amp; dp[j] &gt; max_num) { max_num = dp[j]; } } dp[i] = max_num + 1; } int answer = 0; for(int i = 0; i &lt; N; i++) { if(answer &lt; dp[i]) answer = dp[i]; } printf(\"%d\\n\", answer); return 0;}" }, { "title": "최대 감소 부분 수열", "url": "/posts/%EB%8F%99%EC%A0%84-%EA%B1%B0%EC%8A%AC%EB%9F%AC%EC%A3%BC%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-03-20 00:00:00 +0900", "snippet": "최대 감소 부분 수열최대 감소 수열에 대해 묻는 문제로 최대 증가 수열을 구하는 문제를 뒤집어 생각한다.먼저 수열의 마지막 dp값을 1로 놓고 시작한다.그리고 뒤에서 부터 dp 값을 업데이트 시켜 나간다. 이 때 앞의 값이 뒤에 값보다 커야하는 감소 부분 수열의 성질 빼고는 풀이 방식은 최대 증가수열과 같다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int coin[1001] = { 0 };int dp[10001] = { 0 };void init(){ for(int i = 1; i &lt;= M; i++) { dp[i] = 7654321; }}int main(){ scanf(\"%d %d\", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) { scanf(\"%d\", &amp;coin[i]); } // 최대값으로 초기화 init(); for(int i = 1; i &lt;= M; i++) { for(int j = 0; j &lt; N; j++) { // 현재 금액이 coin[j] 보다 작은 경우 coin[j] 를 써서 금액 i를 만들 수 없으므로 예외 처리 if(i - coin[j] &gt;= 0) { dp[i] = min(dp[i], dp[i - coin[j]] + 1); } } } if(dp[M] != 7654321) printf(\"%d\\n\", dp[M]); else printf(\"-1\\n\"); // 여기에 코드를 작성해주세요. return 0;}" }, { "title": "최소 경로로 탈출 하기", "url": "/posts/%EC%B5%9C%EC%86%8C-%EA%B2%BD%EB%A1%9C%EB%A1%9C-%ED%83%88%EC%B6%9C-%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-19 00:00:00 +0900", "snippet": "최소 경로로 탈출 하기최단거리 미로탐색을 수행하는 기본적인 BFS문제x, y 좌표이외에도 해당 지점의 최단 소요 거리를 출력한다.방문을 체크하는 bfs로 문제를 해결하는 경우, 방문한 지점은 다시 방문하지 않기 때문에 자연적으로 각 포인트의 최단거리를 출력할 수 있다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int arr[101][101] = { 0 };int isvisited[101][101] = { 0 };int dist[101][101] = { 1 };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= m) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == 0) { isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); dist[ny][nx] = dist[cy][cx] + 1; } } } } return ;}int main() { scanf(\"%d %d\", &amp;n ,&amp;m); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;arr[i][j]); } } isvisited[1][1] = 1; bfs(1, 1); if(dist[n][m] != 0) printf(\"%d\\n\", dist[n][m]); else printf(\"-1\\n\"); return 0;}" }, { "title": "최소 경로로 탈출 하기", "url": "/posts/%EC%B5%9C%EB%8C%80-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-19 00:00:00 +0900", "snippet": "최소 경로로 탈출 하기최단거리 미로탐색을 수행하는 기본적인 BFS문제x, y 좌표이외에도 해당 지점의 최단 소요 거리를 출력한다.방문을 체크하는 bfs로 문제를 해결하는 경우, 방문한 지점은 다시 방문하지 않기 때문에 자연적으로 각 포인트의 최단거리를 출력할 수 있다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int arr[101][101] = { 0 };int isvisited[101][101] = { 0 };int dist[101][101] = { 1 };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= m) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == 0) { isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); dist[ny][nx] = dist[cy][cx] + 1; } } } } return ;}int main() { scanf(\"%d %d\", &amp;n ,&amp;m); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;arr[i][j]); } } isvisited[1][1] = 1; bfs(1, 1); if(dist[n][m] != 0) printf(\"%d\\n\", dist[n][m]); else printf(\"-1\\n\"); return 0;}" }, { "title": "최소 경로로 탈출 하기", "url": "/posts/%EB%82%98%EC%9D%B4%ED%8A%B8/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-19 00:00:00 +0900", "snippet": "최소 경로로 탈출 하기최단거리 미로탐색을 수행하는 기본적인 BFS문제x, y 좌표이외에도 해당 지점의 최단 소요 거리를 출력한다.방문을 체크하는 bfs로 문제를 해결하는 경우, 방문한 지점은 다시 방문하지 않기 때문에 자연적으로 각 포인트의 최단거리를 출력할 수 있다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int arr[101][101] = { 0 };int isvisited[101][101] = { 0 };int dist[101][101] = { 1 };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= m) { if(arr[ny][nx] == 1 &amp;&amp; isvisited[ny][nx] == 0) { isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); dist[ny][nx] = dist[cy][cx] + 1; } } } } return ;}int main() { scanf(\"%d %d\", &amp;n ,&amp;m); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= m; j++) { scanf(\"%d\", &amp;arr[i][j]); } } isvisited[1][1] = 1; bfs(1, 1); if(dist[n][m] != 0) printf(\"%d\\n\", dist[n][m]); else printf(\"-1\\n\"); return 0;}" }, { "title": "네 방향 탈출 가능 여부 판별하기", "url": "/posts/%EB%84%A4-%EB%B0%A9%ED%96%A5-%ED%83%88%EC%B6%9C-%EA%B0%80%EB%8A%A5-%EC%97%AC%EB%B6%80-%ED%8C%90%EB%B3%84%ED%95%98%EA%B8%B0-copy/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-18 00:00:00 +0900", "snippet": "네 방향 탈출 가능 여부 판별하기미로탐색을 수행하는 기본적인 BFS문제#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int arr[100][100] = { 0 };int isvisited[100][100] = { 0 };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int y, int x){ queue&lt;pair&lt;int, int&gt; &gt; q; q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; m) { if(isvisited[ny][nx] == 0 &amp;&amp; arr[ny][nx] == 1) { isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); } } } } return;}int main() { scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { scanf(\"%d\", &amp;arr[i][j]); } } bfs(0, 0); printf(\"%d\\n\", isvisited[n-1][m-1]); // 여기에 코드를 작성해주세요. return 0;}" }, { "title": "갈 수 있는 곳들", "url": "/posts/%EA%B0%88-%EC%88%98-%EC%9E%88%EB%8A%94-%EA%B3%B3%EB%93%A4/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2023-03-18 00:00:00 +0900", "snippet": "갈 수 있는 곳들시작점이 여러개인 문제로, bfs로 큐 자료구조를 사용하여 현재 방문한 위치를 담아, 시작점으로부터 도달 가능한 위치를 구해준다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;int n, k,pos_route;int arr[101][101] = { 0 };int isvisited[101][101] = { 0 };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};queue&lt;pair&lt;int, int&gt; &gt; q;void bfs(int y, int x){ q.push(make_pair(y, x)); while(!q.empty()) { int cy = q.front().first; int cx = q.front().second; q.pop(); for(int dir = 0; dir &lt; 4; dir++) { int ny = cy + dy[dir]; int nx = cx + dx[dir]; if(ny &gt;= 1 &amp;&amp; ny &lt;= n &amp;&amp; nx &gt;= 1 &amp;&amp; nx &lt;= n) { if(arr[ny][nx] == 0 &amp;&amp; isvisited[ny][nx] == 0) { isvisited[ny][nx] = 1; q.push(make_pair(ny, nx)); } } } } return ;}int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d\", &amp;n, &amp;k); for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; k; i++) { int y, x; scanf(\"%d %d\", &amp;y, &amp;x); bfs(y, x); // 시작 노드 방문 체크 isvisited[y][x] = 1; } // 시작지점으로부터 방문이 가능한 서로 다른 칸의 수를 출력합니다. for(int i = 1; i &lt;= n; i++) { for(int j = 1; j &lt;= n; j++) { if(isvisited[i][j] == 1) pos_route++; } } printf(\"%d\\n\", pos_route); return 0;}" }, { "title": "격자 안에서 터지고 떨어지는 경우 십자 모양 폭발", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%ED%84%B0%EC%A7%80%EA%B3%A0-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EA%B2%BD%EC%9A%B0-%EC%8B%AD%EC%9E%90-%EB%AA%A8%EC%96%91-%ED%8F%AD%EB%B0%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-17 00:00:00 +0900", "snippet": "격자 안에서 터지고 떨어지는 경우 십자 모양 폭발십자 모양의 폭발과 중력으로 인한 변화를 구현하는 문제로 임시 배열 2개를 선언하여 각각 폭발이 일어 난후 배열의 상황, 중력 작용으로 인해 변한 배열의 상황을 담고 최종 결과를 출력한다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, r, c;int arr[201][201] = { 0 };int temp_arr[201][201] = { 0 };int ans_arr[201][201] = { 0 };int dy[4] = {-1, 1, 0, 0};int dx[4] = {0, 0, -1, 1};int main() { scanf(\"%d\", &amp;n); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } scanf(\"%d %d\", &amp;r, &amp;c); r--; c--; int bomb_range = arr[r][c] - 1; for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { temp_arr[i][j] = arr[i][j]; } } // 폭탄 터진 상황 구현 temp_arr[r][c] = 0; for(int i = 1; i &lt;= bomb_range; i++) { for(int dir = 0; dir &lt; 4; dir++) { int ny = r + dy[dir] * i; int nx = c + dx[dir] * i; if(ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; n) temp_arr[ny][nx] = 0; } } // 중력으로 인한 결과 구현 for(int c = 0; c &lt; n; c++) { int data_idx = 0; for(int i = n - 1; i &gt;= 0; i--) { if(temp_arr[i][c] == 0) { continue; } ans_arr[n - data_idx - 1][c] = temp_arr[i][c]; data_idx++; } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { printf(\"%d \", ans_arr[i][j]); } printf(\"\\n\"); } // 여기에 코드를 작성해주세요. return 0;}" }, { "title": "격자 안에서 터지고 떨어지는 경우 1차원 젠가", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%ED%84%B0%EC%A7%80%EA%B3%A0-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EA%B2%BD%EC%9A%B0-1%EC%B0%A8%EC%9B%90-%EC%A0%A0%EA%B0%80/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-16 00:00:00 +0900", "snippet": "격자 안에서 터지고 떨어지는 경우 1차원 젠가격자 안에서 터지고 떨어지는 경우=&gt; 임시 배열을 만들어 중력으로 인해 떨어지는 작업의 결과물을 구현하고 현재 배열로 복사한 후 임시 배열은 초기화하는 과정을 반복한다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n;int arr[101] = { 0 };int temp_arr[101] = { 0 };int main() { scanf(\"%d\", &amp;n); for(int i = 1; i &lt;= n; i++) { scanf(\"%d\", &amp;arr[i]); } for(int tc = 0; tc &lt; 2; tc++) { for(int i = 1; i &lt;= n; i++) { temp_arr[i] = 0; } int start, end, temp_idx = 0; scanf(\"%d %d\", &amp;start, &amp;end); for(int j = 0; j &lt; start; j++) { temp_arr[temp_idx] = arr[j]; temp_idx++; } for(int j = end + 1; j &lt;= n; j++) { temp_arr[temp_idx] = arr[j]; temp_idx++; } for(int i = 1; i &lt;= n; i++) { arr[i] = temp_arr[i]; } } int block_cnt = 0; for(int i = 1; i &lt;= n; i++) { if(arr[i] == 0) break; block_cnt++; } printf(\"%d\\n\", block_cnt); for(int i = 1; i &lt;= n; i++) { if(arr[i] == 0) break; printf(\"%d\\n\", arr[i]); } return 0;}" }, { "title": "격자 안에서 밀고 당기기 삼각형 컨베이어 벨트", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EB%B0%80%EA%B3%A0-%EB%8B%B9%EA%B8%B0%EA%B8%B0-%EC%82%BC%EA%B0%81%ED%98%95-%EC%BB%A8%EB%B2%A0%EC%9D%B4%EC%96%B4-%EB%B2%A8%ED%8A%B8/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-14 00:00:00 +0900", "snippet": "격자 안에서 밀고 당기기 삼각형 컨베이어 벨트배열을 밀고 당기는 문제시계 방향으로 한 칸씩 회전하는 삼각형 모양의 컨베이어 벨트가 있습니다. 각 변에 n개씩 총 3 * n 개의 숫자가 적혀 있고, 1초에 한 칸씩 움직입니다.삼각형 형태의 컨베이어 벨트로 임시변수를 총 2개 사용하여 문제를 해결한다.#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, t;int main() { // 여기에 코드를 작성해주세요. scanf(\"%d %d\", &amp;n , &amp;t); vector&lt;int&gt; a(n, 0); vector&lt;int&gt; b(n, 0); vector&lt;int&gt; c(n, 0); for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;a[i]); } for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;b[i]); } for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;c[i]); } while(t--) { // temp와 temp2 변수를 번갈아가며 사용하고 업데이트 한다 int temp = c[n-1], temp2 = a[n-1]; for(int i = n - 1; i &gt; 0; i--) a[i] = a[i-1]; a[0] = temp; temp = b[n-1]; for(int i = n - 1; i &gt; 0; i--) b[i] = b[i-1]; b[0] = temp2; temp2 = c[n-1]; for(int i = n - 1; i &gt; 0; i--) c[i] = c[i-1]; c[0] = temp; } for(int i = 0; i &lt; n; i++) { printf(\"%d \", a[i]); } printf(\"\\n\"); for(int i = 0; i &lt; n; i++) { printf(\"%d \", b[i]); } printf(\"\\n\"); for(int i = 0; i &lt; n; i++) { printf(\"%d \", c[i]); } printf(\"\\n\"); return 0;}해설 정답 코드#include &lt;iostream&gt;#define MAX_N 200using namespace std;// 전역 변수 선언:int n, t;int l[MAX_N + 1];int r[MAX_N + 1];int d[MAX_N + 1];int main() { // 입력: cin &gt;&gt; n &gt;&gt; t; for(int i = 0; i &lt; n; i++) cin &gt;&gt; l[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; r[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; d[i]; while(t--) { // Step 1 // 왼쪽에서 가장 오른쪽에 있는 숫자를 따로 temp값에 저장해놓습니다. int temp = l[n - 1]; // Step 2 // 왼쪽에 있는 숫자들을 완성합니다. // 벨트를 기준으로 오른쪽에서부터 채워넣어야 하며, // 맨 왼쪽 숫자는 아래에서 가져와야함에 유의합니다. for(int i = n - 1; i &gt;= 1; i--)\t\t\tl[i] = l[i - 1];\t\tl[0] = d[n - 1]; // Step 3 // 오른쪽에 있는 숫자들을 완성합니다. // 벨트를 기준으로 마찬가지로 오른쪽에서부터 채워넣어야 하며, // 맨 왼쪽 숫자는 이전 단계에서 미리 저장해놨던 temp값을 가져와야함에 유의합니다. int temp2 = r[n - 1]; for(int i = n - 1; i &gt;= 1; i--)\t\t\tr[i] = r[i - 1];\t\tr[0] = temp; // Step 4 // 아래에 있는 숫자들을 완성합니다. // 마찬가지로 벨트를 기준으로 오른쪽에서부터 채워넣어야 하며, // 맨 왼쪽 숫자는 이전 단계에서 미리 저장해놨던 temp값을 가져와야함에 유의합니다. for(int i = n - 1; i &gt;= 1; i--)\t\t\td[i] = d[i - 1];\t\td[0] = temp2; } // 출력: for(int i = 0; i &lt; n; i++)\t\tcout &lt;&lt; l[i] &lt;&lt; \" \";\tcout &lt;&lt; endl; for(int i = 0; i &lt; n; i++)\t\tcout &lt;&lt; r[i] &lt;&lt; \" \";\tcout &lt;&lt; endl;\tfor(int i = 0; i &lt; n; i++)\t\tcout &lt;&lt; d[i] &lt;&lt; \" \"; return 0;}" }, { "title": "격자 안에서 밀고 당기기 컨베이어 벨트", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EB%B0%80%EA%B3%A0-%EB%8B%B9%EA%B8%B0%EA%B8%B0-%EC%BB%A8%EB%B2%A0%EC%9D%B4%EC%96%B4-%EB%B2%A8%ED%8A%B8/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-13 00:00:00 +0900", "snippet": "격자 안에서 밀고 당기기 컨베이어 벨트배열을 밀고 당기는 기초적인 문제vector 자료형을 배열처럼 사용해서 먼저 앞에 채워 넣을 값(circular term으로 결정)을 채워넣고 그 다음 circular term 이후의 값들을 차례대로 배열 쉬프트를 수행한 후 값을 매칭시켜 넣는다. circular term이 0일 경우 input 그대로 output 을 출력하도록 예외처리 수행#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, t;int main() { // 여기에 코드를 작성해주세요. int num = 0; vector&lt;int&gt; v; scanf(\"%d %d\", &amp;n , &amp;t); vector&lt;int&gt; answer(2*n, 0); for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num); v.push_back(num); } for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;num); v.push_back(num); } int circular_term = t % (2 * n); if(circular_term == 0) { for(int idx = 0; idx &lt; 2 * n; idx++) { answer[idx] = v[idx]; } } else { for(int idx = 0; idx &lt; circular_term; idx++) { answer[idx] = v[2* n - circular_term + idx]; } for(int idx = circular_term; idx &lt; 2 * n; idx++) { answer[idx] = v[idx - circular_term]; } } for(int i = 0; i &lt; n; i++) { printf(\"%d \", answer[i]); } printf(\"\\n\"); for(int i = n; i &lt; 2 * n; i++) { printf(\"%d \", answer[i]); } printf(\"\\n\"); return 0;}위 아래 배열 모두 한 칸씩 밀어서 총 t번 그 과정을 수행하여 정답을 도출한 코드#include &lt;iostream&gt;#define MAX_N 200using namespace std;// 전역 변수 선언:int n, t;int u[MAX_N + 1];int d[MAX_N + 1];int main() { // 입력: cin &gt;&gt; n &gt;&gt; t; for(int i = 0; i &lt; n; i++) cin &gt;&gt; u[i]; for(int i = 0; i &lt; n; i++) cin &gt;&gt; d[i]; while(t--) { // Step 1 // 위에서 가장 오른쪽에 있는 숫자를 따로 temp값에 저장해놓습니다. int temp = u[n - 1]; // Step 2 // 위에 있는 숫자들을 완성합니다. // 오른쪽에서부터 채워넣어야 하며, // 맨 왼쪽 숫자는 아래에서 가져와야함에 유의합니다. for(int i = n - 1; i &gt;= 1; i--)\t\t\tu[i] = u[i - 1];\t\tu[0] = d[n - 1]; // Step 3 // 아래에 있는 숫자들을 완성합니다. // 마찬가지로 오른쪽에서부터 채워넣어야 하며, // 맨 왼쪽 숫자는 위에서 미리 저장해놨던 temp값을 가져와야함에 유의합니다. for(int i = n - 1; i &gt;= 1; i--)\t\t\td[i] = d[i - 1];\t\td[0] = temp; } // 출력: for(int i = 0; i &lt; n; i++)\t\tcout &lt;&lt; u[i] &lt;&lt; \" \";\tcout &lt;&lt; endl; \tfor(int i = 0; i &lt; n; i++)\t\tcout &lt;&lt; d[i] &lt;&lt; \" \"; return 0;}" }, { "title": "격자 안에서 완전탐색 트로미노", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-12 00:00:00 +0900", "snippet": "격자 안에서 완전탐색 트로미노n * m크기의 이차원 영역의 각 위치에 자연수가 하나씩 적혀있습니다. 이 때 아래의 그림에 주어진 2가지 종류의 블럭 중 한 개를 블럭이 격자를 벗어나지 않도록 적당히 올려놓아 블럭이 놓인 칸 안에 적힌 숫자의 합이 최대가 될 때의 결과를 출력하는 프로그램을 작성해보세요. 단, 주어진 블럭은 자유롭게 회전하거나 뒤집을 수 있습니다테트리스 처럼 특정 블럭을 회전시켜가며 최대 합을 구하는 문제이다.배열의 회전 등을 경험해 볼 수 있는 좋은 문제.#include &lt;cstdio&gt;using namespace std;int n, m;int arr[200][200] = { 0 };int dy[4] = {-1, 0, 1, 0};int dx[4] = {0, 1, 0, -1};int main(){ int max_cnt = 0; scanf(\"%d %d\", &amp;n , &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; m; j++) { int flag = 1; int temp_cnt = 0; for(int idx = 0; idx &lt; 4; idx++) { flag = 1; temp_cnt = arr[i][j]; int y = i + dy[idx]; int x = j + dx[idx]; // 테트리스 블럭이 범위 내에 들어가는지 확인한다(flag) if(y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; m) { temp_cnt += arr[y][x]; } else { flag = 0; } y = i + dy[(idx + 1) % 4]; x = j + dx[(idx + 1) % 4]; if(y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; m) { temp_cnt += arr[y][x]; } else { flag = 0; } if(max_cnt &lt; temp_cnt &amp;&amp; flag == 1) { max_cnt = temp_cnt; } } for(int idx = 0; idx &lt; 4; idx++) { flag = 1; temp_cnt = arr[i][j]; int y = i + dy[idx]; int x = j + dx[idx]; if(y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; m) { temp_cnt += arr[y][x]; } else { flag = 0; } y = i + dy[(idx + 2) % 4]; x = j + dx[(idx + 2) % 4]; if(y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; m) { temp_cnt += arr[y][x]; } else { flag = 0; } if(max_cnt &lt; temp_cnt &amp;&amp; flag == 1) { max_cnt = temp_cnt; } } } } printf(\"%d\", max_cnt); return 0;}" }, { "title": "격자 안에서 완전탐색 금 채굴하기", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%EA%B8%88-%EC%B1%84%EA%B5%B4%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-12 00:00:00 +0900", "snippet": "격자 안에서 완전탐색 금 채굴하기n * m크기의 이차원 영역의 각 위치에 자연수가 하나씩 적혀있습니다. 이 때 아래의 그림에 주어진 2가지 종류의 블럭 중 한 개를 블럭이 격자를 벗어나지 않도록 적당히 올려놓아 블럭이 놓인 칸 안에 적힌 숫자의 합이 최대가 될 때의 결과를 출력하는 프로그램을 작성해보세요. 단, 주어진 블럭은 자유롭게 회전하거나 뒤집을 수 있습니다마름모 모양의 탐색 알고리즘 =&gt; 절댓값으로 거리를 계산하고 거리 내 영역을 탐색하면 마름모 모양으로 탐색할 수 있다.(Out of Bound error 회피를 위해 조건문 추가해야함) abs(y-i) + abs(x-j) &lt;= k#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n, m;int arr[20][20] = { 0 };int calcArea(int k){ return k * k + (k+1) * (k+1);}int main(){ int max_cnt = 0; scanf(\"%d %d\", &amp;n , &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { for(int k = 0; k &lt; n; k++) { int gold_cnt = 0, gold_value = 0, profit = 0; for(int y = i - k; y &lt;= i + k; y++) { for(int x = j - k; x &lt;= j + k; x++) { if(y &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; x &gt;= 0 &amp;&amp; x &lt; n) { if(abs(y-i) + abs(x-j) &lt;= k &amp;&amp; arr[y][x] == 1) { gold_cnt++; gold_value += m; } } } } profit = gold_value - calcArea(k); if(profit &gt;= 0 &amp;&amp; max_cnt &lt; gold_cnt) { max_cnt = gold_cnt; } } } } printf(\"%d\\n\", max_cnt); return 0;}" }, { "title": "격자 안에서 완전탐색 최고의 33위치", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%EC%B5%9C%EA%B3%A0%EC%9D%98-33%EC%9C%84%EC%B9%98/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-11 00:00:00 +0900", "snippet": "격자 안에서 완전탐색 최고의 33위치N * N 크기의 격자 정보가 주어집니다. 이때 해당 위치에 동전이 있다면 1, 없다면 0이 주어집니다. N * N 격자를 벗어나지 않도록 3 * 3 크기의 격자를 적절하게 잘 잡아서 해당 범위 안에 들어있는 동전의 개수를 최대로 하는 프로그램을 작성해보세요.단순 완전 탐색, 브루트포스 문제이다.#include &lt;cstdio&gt;using namespace std;int N;int arr[20][20] = { 0 };int main() { // 여기에 코드를 작성해주세요. int max_cnt = 0; scanf(\"%d\", &amp;N); for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; N; j++) { scanf(\"%d\", &amp;arr[i][j]); } } for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; N; j++) { int temp_cnt = 0; for(int y = i; y &lt; i + 3; y++) { for(int x = j; x &lt; j + 3; x++) { if(arr[y][x] == 1) temp_cnt++; } } if(max_cnt &lt; temp_cnt) max_cnt = temp_cnt; } } printf(\"%d\\n\", max_cnt); return 0;}" }, { "title": "격자 안에서 완전탐색 행복한 수열의 개수", "url": "/posts/%EA%B2%A9%EC%9E%90-%EC%95%88%EC%97%90%EC%84%9C-%EC%99%84%EC%A0%84%ED%83%90%EC%83%89-%ED%96%89%EB%B3%B5%ED%95%9C-%EC%88%98%EC%97%B4%EC%9D%98-%EA%B0%9C%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-11 00:00:00 +0900", "snippet": "격자 안에서 완전탐색 행복한 수열의 개수횡방향, 종방향 탐색을 수행하는 문제,n, m 이 둘다 1일 때는 두 방향 모두 하나씩 수열이 존재하므로 2를 출력하는 예외케이스에 대한 처리가 필요하다.#include &lt;cstdio&gt;using namespace std;int n, m;int arr[100][100] = { 0 };int main(){ int answer = 0; scanf(\"%d %d\", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) { for(int j = 0; j &lt; n; j++) { scanf(\"%d\", &amp;arr[i][j]); } } if(n == 1 &amp;&amp; m == 1) { printf(\"2\\n\"); return 0; } for(int i = 0; i &lt; n; i++) { int cnt = 0; for(int x = 0; x &lt; n - 1; x++) { if(arr[i][x] == arr[i][x + 1]) cnt++; else cnt = 0; if (cnt &gt;= m - 1) { answer++; cnt = 0; break; } } } for(int j = 0; j &lt; n; j++) { int cnt = 0; for(int y = 0; y &lt; n - 1; y++) { if(arr[y][j] == arr[y + 1][j]) cnt++; else cnt = 0; if (cnt &gt;= m - 1) { answer++; cnt = 0; break; } } } printf(\"%d\\n\", answer);}" }, { "title": "숫자 변환하기", "url": "/posts/%EC%88%AB%EC%9E%90-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-03-09 00:00:00 +0900", "snippet": "숫자 변환하기특정 연산으로 얻을 X -&gt; Y 로 가기까지의 최소 연산 수를 구하는 문제이다.dp 배열을 최댓값으로 초기화 하고 dp[x] =&gt; dp[y] 까지 반복문을 통해서 연산을 수행하고최솟값을 업데이트 시켜나간다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;int solution(int x, int y, int n) { int answer = 0; int dp[1000001] = { 1000001 }; for(int i = 1; i &lt;= 1000001; i++) dp[i] = 7654321; dp[x] = 0; for(int i = x; i &lt; y; i++) { if(i + n &lt;= y) dp[i + n] = min(dp[i] + 1, dp[i + n]); if(i * 2 &lt;= y) dp[i * 2] = min(dp[i] + 1, dp[i * 2]); if(i * 3 &lt;= y) dp[i * 3] = min(dp[i] + 1, dp[i * 3]); } if(dp[y] == 7654321) answer = -1; else answer = dp[y]; return answer;}" }, { "title": "귤 고르기", "url": "/posts/%EA%B7%A4-%EA%B3%A0%EB%A5%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Stack", "date": "2023-03-05 00:00:00 +0900", "snippet": "귤 고르기경화는 과수원에서 귤을 수확했습니다. 경화는 수확한 귤 중 ‘k’개를 골라 상자 하나에 담아 판매하려고 합니다. 그런데 수확한 귤의 크기가 일정하지 않아 보기에 좋지 않다고 생각한 경화는 귤을 크기별로 분류했을 때 서로 다른 종류의 수를 최소화하고 싶습니다.예를 들어, 경화가 수확한 귤 8개의 크기가 [1, 3, 2, 5, 4, 5, 2, 3] 이라고 합시다. 경화가 귤 6개를 판매하고 싶다면, 크기가 1, 4인 귤을 제외한 여섯 개의 귤을 상자에 담으면, 귤의 크기의 종류가 2, 3, 5로 총 3가지가 되며 이때가 서로 다른 종류가 최소일 때입니다.경화가 한 상자에 담으려는 귤의 개수 k와 귤의 크기를 담은 배열 tangerine이 매개변수로 주어집니다. 경화가 귤 k개를 고를 때 크기가 서로 다른 종류의 수의 최솟값을 return 하도록 solution 함수를 작성해주세요.=&gt; c++ STL map 자료형을 사용하여 문제를 해결한다.key : 귤의 크기value : 크기 별 귤의 개수#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;int solution(int k, vector&lt;int&gt; tangerine) { int answer = 1; map&lt;int, int&gt; m;// key, value vector&lt;int&gt; v; for(int i = 0; i &lt; tangerine.size(); i++) { m[tangerine[i]]++;// value 값++ } for(auto i = m.begin(); i != m.end(); i++) { v.push_back(i-&gt;second); } sort(v.begin(), v.end(), greater&lt;int&gt;()); for(int i = 0; i &lt; v.size(); i++) { // 어떠한 경우에도 크기 종류는 최소 1가지 이상이므로 answer는 1부터 시작한다. // 대신 판매하려는 귤의 개수보다 크기 별 귤의 개수가 클 때 answer를 +1 시킨다. if(k - v[i] &gt; 0) { k -= v[i]; answer++; } else break; } return answer;}" }, { "title": "C++_STL_정리", "url": "/posts/C++_STL_%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-03-05 00:00:00 +0900", "snippet": "C++_STL_정리Set container 연관 컨테이너(associative container) 중 하나 노드 기반 컨테이너 이며 균형 이진트리로 구현 red-black tree 형태로 구현 Key라 불리는 원소들의 집합으로 이루어진 컨테이너 (원소 = key) key값은 중복이 허용하지 않는다 =&gt; 해당 컨테이너를 사용하는 주요 이유 원소가 insert 멤버 함수에 의해 삽입이 되면, 원소는 자동으로 정렬 default 정렬기준은 less(오름차순) set의 경우 헤더파일을 include 해서 사용한다. Set 생성자set s; 기본 선언 방법.set s(compare); or set&lt;int, compare&gt; s; compare 함수를 통해 정렬 기준 설정ex) set&lt;int, greater&gt; s; // 내림 차순 정렬set s2(s1); s1 을 복사한 s2Set 멤버 함수s.begin(); 맨 첫번째 원소를 가리키는 반복자를 리턴(참조)합니다. iter = s.begin(); 으로 사용합니다.s.end(); 맨 마지막 원소(의 다음)를 가리키는 원소의 끝부분을 알 때 사용합니다. 반복자를 리턴(참조)합니다. iter = s.end();s.rbegin(), s.rend(); begin(), end() 와 반대로 작동하는 멤버함수들입니다. 역으로 출력하고 싶을때 사용합니다. 이런 식으로 사용합니다.s.clear(); 모든 원소를 제거합니다.s.count(k); 원소 k 의 갯수를 반환합니다 set에서는 무조건 0,1 개 겠죠 ? -&gt; multiset은 키값이 중복이 가능하기때문에 거기서 쓰입니다.s.empty(); set s가 비어있는지 확인합니다.s.insert(k); 원소 k를 삽입합니다. 삽입시에 자동으로 정렬된 위치에 삽입됩니다. 삽입이 성공 실패에 대한 여부는 리턴값 (pair&lt;iterator, bool&gt;) 으로 나오게됩니다. pair&lt;iterator, bool&gt;에서 pair.first는 삽입한 원소를 가리키는 반복자 이고, pair.second는 성공(true), 실패(false)를 나타냅니다.s.insert(iter, k); iter가 가리키는 위치 부터 k를 삽입할 위치를 탐색하여 삽입합니다. s.erase(iter); iter가 가리키는 원소를 제거합니다. 제거 한다음 제거 한 원소 다음 원소를 가리키는 반복자를 리턴합니다.s.erase(start, end); [start, end) 범위의 원소를 모두 제거합니다.s.find(k); 원소 k를 가리키는 반복자를 반환합니다. 원소 k가 없다면 s.end() 와 같은 반복자를 반환합니다. s2.swap(s1); s1과 s2를 바꿔줍니다.s.upper_bound(k); 원소 k가 끝나는 구간의 반복자 입니다.s.lower_bound(k); 원소 k가 시작하는 구간의 반복자 입니다.s.equal_range(k); 원소 k가 시작하는 구간과 끝나는 구간의 반복자 pair 객체를 반환합니다. upper_bound(k), lower_bound(k) 가 합쳐진 멤버함수s.value_comp(), s.key_comp(); 정렬 기준 조건자를 반환합니다. set 컨테이너에서는 두개의 함수 반환형이 같습니다.s.size(); 사이즈(원소의 갯수)를 반환합니다.s.max_size(); 최대 사이즈(남은 메모리 크기)를 반환합니다.#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;using namespace std;int main(){\t// set\tset&lt;string&gt; s;\t// insert(element)\ts.insert(\"abc\");\ts.insert(\"def\");\ts.insert(\"ghi\");\ts.insert(\"jkl\");\t// erase(element)\ts.erase(\"jkl\");\t// empty(), size()\tif(!s.empty()) cout &lt;&lt; \"s size: \" &lt;&lt; s.size() &lt;&lt; '\\n';\t// find(element)\tcout &lt;&lt; *s.find(\"abc\") &lt;&lt; '\\n';\tcout &lt;&lt; *s.find(\"def\") &lt;&lt; '\\n';\t// count(element)\tcout &lt;&lt; \"abc count: \" &lt;&lt; s.count(\"abc\") &lt;&lt; '\\n';\t// begin(), end()\tcout &lt;&lt; \"traverse\" &lt;&lt; '\\n';\tfor(auto it = s.begin(); it != s.end(); it++){\t\tcout &lt;&lt; \"value: \" &lt;&lt; *it &lt;&lt; '\\n';\t}\treturn 0;}Map container Associative - 연관 컨테이너 (associative container) 중 하나 노드 기반으로 이루어져있고 균형 이진 트리 구조(레드 블랙 트리 형태로 구현됨) Map - map은 key와 value로 이루어져있으며 이는 pair 객체 형태로 저장 Unique Key - key는 고유한 값이므로 중복이 불가능 Ordered - map도 set과 마찬가지로 삽입이 되면서 자동으로 정렬(default는 less/오름차순 입니다.) Allocator-aware - map container는 저장공간의 필요에 따라서 allocator 객체를 사용 헤더파일에 포함 using namespace std; 를 사용하면 편리 기본 생성 방법 : map&lt; [Data type1], [Data type2] &gt; [변수이름];=&gt; ex) map&lt;int, int&gt; m1;=&gt; map&lt;string, int&gt; m2; map 에 삽입을 하기 위한 insert는 pair 객체를 인자로 받아야합니다. (key 값과 value는 쌍을 이루기 때문)map 생성자map&lt;int, int&gt; m; 기본 선언 방법map m(pred); pred를 통해 정렬기준(오름,내림)을 세웁니다.map m2(m1); m1을 복사한 m2 를 생성합니다.m.begin()첫 번째 원소의 iterator (반복자)를 반환한다 (즉 map의 원소를 반복자를 이용해서 접근할 수 있다.)m.end()마지막 원소 다음의 반복자를 반환m.clear()저장하고 있는 모든 원소를 삭제한다.m.insert()원소를 추가한다.m.find()key와 관련된 원소의 반복자를 반환한다. (단 찾지 못한 경우 end() 반복자를 반환한다)m.size()원소의 개수를 반환한다.m.erase()해당 원소를 삭제한다.#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; mapset;int main(void) {\tmapset.insert({ \"Alice\", 100 });\tmapset.insert({ \"Bob\", 200 });\tif (mapset.find(\"Alice\") != mapset.end()) \t{\t\tcout &lt;&lt; \"find\" &lt;&lt; endl;\t}\telse {\t\tcout &lt;&lt; \"not find\" &lt;&lt; endl;\t}\t//인덱스기반\tfor (auto iter = mapset.begin() ; iter != mapset.end(); iter++)\t{\t\tcout &lt;&lt; iter-&gt;first &lt;&lt; \" \" &lt;&lt; iter-&gt;second &lt;&lt; endl;\t}\tcout &lt;&lt; endl;\t//범위기반\tfor (auto iter : mapset) {\t\tcout &lt;&lt; iter.first &lt;&lt; \" \" &lt;&lt; iter.second &lt;&lt; endl;\t}\treturn 0;}map 자료형 원소 순회 방법//접근방법 `for(auto i = m.begin(); i != m.end(); i++){ v.push_back(i-&gt;second);}//접근방법 2map&lt;int, int&gt;::iterator iter;for(iter = m.begin(); iter != m.end(); iter++){ cout &lt;&lt; \"[\" &lt;&lt; iter-&gt;first &lt;&lt; \", \" &lt;&lt; iter-&gt;second &lt;&lt; \"]\" &lt;&lt; \" \" ;}관련문제프로그래머스 : 귤 고르기Unordered containerC++의 Unordered 컨테이너는 해시 기반 컨테이너로, 원소들을 정렬 없이 저장하면서 빠른 탐색, 삽입, 삭제 (평균 O(1)) 를 제공합니다.컨테이너 종류 컨테이너 설명 unordered_set 중복 없는 원소 저장 unordered_multiset 중복 허용 unordered_map (key, value) 쌍 저장 unordered_multimap 키 중복 허용 공통 특징 정렬되지 않음 (순서 보장 안됨) 해시 테이블 기반 구조 탐색/삽입/삭제 평균 시간복잡도 O(1)unordered_set 예시#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;int main() { unordered_set&lt;string&gt; fruits; fruits.insert(\"apple\"); fruits.insert(\"banana\"); fruits.insert(\"orange\"); // 존재 확인 if (fruits.count(\"apple\")) { cout &lt;&lt; \"존재!\" &lt;&lt; endl; } // 반복 출력 for (auto&amp; fruit : fruits) { cout &lt;&lt; fruit &lt;&lt; endl; } // 삭제 fruits.erase(\"banana\");}unordered_map 예시#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int main() { unordered_map&lt;string, int&gt; ages; ages[\"Alice\"] = 25; ages[\"Bob\"] = 30; // 접근 cout &lt;&lt; \"Alice: \" &lt;&lt; ages[\"Alice\"] &lt;&lt; endl; // 존재 확인 if (ages.find(\"Charlie\") == ages.end()) { cout &lt;&lt; \"Charlie 없음!\" &lt;&lt; endl; } // 순회 for (auto&amp; [name, age] : ages) { cout &lt;&lt; name &lt;&lt; \"는 \" &lt;&lt; age &lt;&lt; \"살입니다.\" &lt;&lt; endl; } // 삭제 ages.erase(\"Alice\");}주요 API 요약 메서드 설명 insert(value) 요소 삽입 erase(value) 요소 삭제 find(value) 존재 시 iterator 반환, 없으면 end() 반환 count(value) 존재하면 1 반환 (multiset/map은 개수 반환) clear() 전체 삭제 size() 요소 개수 반환 empty() 비어있는지 여부 begin(), end() 반복자 접근 🔥 unordered vs ordered 비교 항목 unordered_map/set map/set 내부 구조 해시 테이블 레드-블랙 트리 (BST) 정렬 ❌ 없음 ✅ 오름차순 정렬 탐색 속도 평균 O(1) O(log N) 키 조건 해시 가능해야 함 &lt; 연산 가능해야 함 Priority queue container 내부구조 default 는 vector container 기반으로 설정 정렬기준 default는 내림차순(less) 기반으로 설정 =&gt; vector container의 경우 sort 시 default 가 오름차순 헤더파일 안에 있습니다.```cpp 기본 생성자 형식 priority_queue &lt; [Data Type] &gt; [변수이름]; ```cppex) priority_queue&lt;int&gt; pq; ```cpp 내부 컨테이너 변경 priority_queue &lt; [Data Type], [Container Type] &gt; [변수이름]; ```cppex) priority_queue&lt;int, deque&lt;int&gt; &gt; pq; - 정렬 기준 변경 priority_queue &lt; [Data Type], [Container Type], [정렬기준] &gt; [변수이름];ex) priority_queue&lt;int , vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; // 오름차순 기준 정렬pq.empty() check whether container is empty. 비어있으면 true 반환 비어있다는 것은 size가 0 이기도함.pq.size() 원소의 개수를 반환합니다. pq.top() 맨 위에있는 원소를 참조 및 반환 합니다.(삭제하는거 아님)pq.push() insert element 인자를 삽입 내부적으로는 push_back 함수를 이용하여 삽입pq.pop() 맨위에있는 인자를 삭제 내부적으로는 pop_heap 알고리즘과 pop_back 함수가 이용되어 우선순위 큐 형태를 유지sort container배열에 적용하는 sort- sort(arr, arr+n);vector container를 사용한 sort- sort(v.begin(), v.end());- sort(v.begin(), v.end(), compare); //사용자 정의 함수 사용- sort(v.begin(), v.end(), greater&lt;자료형&gt;()); //내림차순 (Descending order)- sort(v.begin(), v.end(), less&lt;자료형&gt;()); //오름차순 (default = Ascending order)구조체와 vector를 이용한 정렬구조체 생성자를 사용해서 구조체 임시변수를 하나 선언해 놓고 값을 넣은 후자료구조에 넣어줘야하는 불필요한 작업을 줄인다.#include &lt;iostream&gt;#include &lt;vector&gt;struct loc_t{\tint x, y, z;\tloc_t(int a,int b,int c)\t{\t\tx = a;\t\ty = b;\t\tz = c;\t}\tbool operator&lt;(const loc_t &amp;b)const\t{\t\tif(x != b.x)\t\t\treturn x &lt; b.x;\t\tif(y != b.y)\t\t\treturn y &lt; b.y;\t\tif(z != b.z)\t\t\treturn z &lt; b.z;\t}}int main(){\tvector&lt;loc_t&gt; xyz;\txyz.push_back(loc_t(1, 2, 3));\txyz.push_back(loc_t(4, 3, 6));\txyz.push_back(loc_t(2, 5, 9));\txyz.push_back(loc_t(5, 2, 1));\tsort(xyz.begin(), xyz.end());}사용자 정의 함수를 사용한 sort 방법#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;ctime&gt;using namespace std; class Student{public: string name; int age; Student(string name, int age):name(name),age(age){} }; void Print(vector&lt;Student&gt; &amp;v){ cout &lt;&lt; \"Student : \" ; for(int i=0; i&lt;5; i++){ cout &lt;&lt; \"[\" &lt;&lt; v[i].name &lt;&lt; \", \" &lt;&lt; v[i].age &lt;&lt; \"]\"; } cout &lt;&lt; endl;} bool compare(Student a, Student b){ if(a.name == b.name){ //이름이 같으면, 나이가 적은순 return a.age &lt; b.age; }else{ //이름 다르면, 이름 사전순 return a.name &lt; b.name; } }int main(void){ vector&lt;Student&gt; v; v.push_back(Student(\"cc\", 10)); v.push_back(Student(\"ba\", 24)); v.push_back(Student(\"aa\", 11)); v.push_back(Student(\"cc\", 8)); //cc는 이름이 같으니 나이 기준 오름차순 예시 v.push_back(Student(\"bb\", 21)); Print(v); //정렬 전 출력 sort(v.begin(), v.end(), compare); //[begin, end) compare 함수 기준 정렬 Print(v); //정렬 후 출력 return 0;} queue container 컨테이너 어댑터: queue는 직접 메모리를 관리하지 않고, 다른 컨테이너(deque, list 등)를 내부적으로 사용합니다. FIFO 구조: 요소가 뒤에서 삽입되고, 앞에서 제거됩니다.push()큐의 뒤에 요소를 추가합니다.queue&lt;int&gt; q;q.push(100);pop()큐의 앞 요소를 제거합니다.q.pop(); // 100 제거front()앞쪽 요소를 참조합니다.int frontVal = q.front();back()뒤쪽 요소를 참조합니다.int backVal = q.back();empty()큐가 비어 있는지 확인합니다.if (q.empty()) { cout &lt;&lt; \"Queue is empty.\" &lt;&lt; endl;}size()큐에 있는 요소 개수를 반환합니다.cout &lt;&lt; \"Queue size: \" &lt;&lt; q.size() &lt;&lt; endl;요약 함수 설명 push() 뒤에 요소 추가 pop() 앞 요소 제거 front() 앞 요소 참조 back() 뒤 요소 참조 empty() 큐가 비었는지 확인 size() 요소 개수 반환 string container#include &lt;string&gt;using namespace std;string str = \"check\";문자열 입력 받기#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;string str;cin &gt;&gt; str;scanf(\"%s\", str);문자열 관련 함수// 문자열 탐색// 찾았을 때 반환값은 해당 문자의 시작 인덱스이다.// 중복되는 문자의 경우 제일 먼저 등장한 인덱스를 반환해준다.if (str.find(\"ch\") != string::npos){ /* NOP */}// 문자열 교체int pos = 3;int length = 5;string str1 = \"name\";/* pos위치에서 length길이만큼 문자열로 채우게 된다. pos위치와 length와 문자열 길이의 차이로 인한 에러는.. 각자 센스로 해결하자.*/s.replace(pos, length, str1);// 문자열 추출// 1. 전체 가져오기string str = str.substr();// 2. 5번 인덱스부터 끝까지 가져오기string str = str.substr(5);// 3. 5번 인덱스부터 1길이만큼 가져오기string str = str.substr(5, 1);//문자열 형변환// char -&gt; string, 문자열 객체 선언후 그냥 더하기.char ch = 'A';string temp = \"\";temp += ch;// string -&gt; char, 그냥 인덱싱 하자.string str = \"bigbigpark\";char c = str[0];// int -&gt; stringint num = 5;string str = to_string(num);// string -&gt; int 또는 doublestring n_str = \"1122\";int n1 = stoi(n_str);double n2 = stod(n_str);// char -&gt; int// 자릿수 연산에 많이 등장한다.char ch = '9';int n = ch - '0'; // '0'를 빼게 되면 보이는 그대로 숫자가 저장되게 된다.부록auto 키워드 주의점 1. auto 변수는 선언과 동시에 초기화를 해줘야 한다 주의점 2. auto 변수는 초기화 이후에 타입 변경이 불가능하다.범위 기반 for 문장점: 코드가 짧고 편리하다. std container(vector, list, map…)와 혼합하여 사용할 수 있다. for문 속도차이도 크게 나지 않는다. 참조자(reference)와 auto를 이용한다면 더욱 빠르게 코딩할 수 있다.단점: 반복 배열의 접근 Index가 없다. 모든 배열을 0부터 끝까지 탐색해야 한다.#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){ //vector container 예제 vector&lt;int&gt; numbers_vec = { 0, 1, 2, 3, 4, 5, 6, 7 }; for(int num : numbers_vec) { cout &lt;&lt; num &lt;&lt; ' '; } cout &lt;&lt; '\\n'; // 배열 예제 int numbers_arr[] = { 0, 1, 2, 3, 4, 5, 6, 7 }; for(int num : numbers_arr) { cout &lt;&lt; num &lt;&lt; ' '; }}#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Student{public: int id; string name; Student(int _id, string _name) { this-&gt;id = _id; this-&gt;name = _name; } Student() {} void ShowData() { cout &lt;&lt; \"번호: \" &lt;&lt; this-&gt;id &lt;&lt; \" 이름: \" &lt;&lt; this-&gt;name &lt;&lt; '\\n'; }};int main(){ vector&lt;Student&gt; student_vec = { { 10, \"찰리\"}, { 20, \"제임스\"}, { 30, \"미셸\"} }; for(Student stu : student_vec) { stu.ShowData(); }}배열 복사 및 요소 값의 변경: 복잡한 시스템이나 프로그램인 경우 오브젝트 및 객체의 크기가 클 수 있다. 크기가 큰 객체를 단순히 출력을 하거나 접근을 할 때 다른 메모리 공간에 복사하는 건 시간과 비용 부담이 크다. 참조자(reference)를 이용하면 객체가 복사되지 않고 참조하기 때문에 더 빠르게 처리할 수 있다. auto 타입을 통해 컴파일러에서 자동으로 타입 잡아주기도 가능for(auto &amp;element : element_array)빠른 처리 및 요소 값 변경 방지: 객체는 복사되지 않고 참조로 빠르게 접근하며 단순 값을 출력하는 것이라면 값 변경 시도 자체를 막을 수 있다. 값 변경 시도를 막는 제한자(const)와 빠르게 접근할 수 있는 참조자(reference)를 이용하는 것이다.for(const auto&amp; element : element_array)" }, { "title": "뒤에 있는 큰 수 찾기", "url": "/posts/%EB%92%A4%EC%97%90-%EC%9E%88%EB%8A%94-%ED%81%B0-%EC%88%98-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Stack", "date": "2023-03-02 00:00:00 +0900", "snippet": "뒤에 있는 큰 수 찾기정수로 이루어진 배열 numbers가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다.정수 배열 numbers가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.=&gt; 단순 Brute-Force로 해결할 경우 시간 초과 발생시간초과 발생 풀이#include &lt;string&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; numbers) { vector&lt;int&gt; answer; for(int i = 0; i &lt; numbers.size(); i++) { int bigger_num = 0; for(int j = i + 1; j &lt; numbers.size(); j++) { if(numbers[i] &lt; numbers[j]) { bigger_num = numbers[j]; break; } } if(bigger_num != 0) { answer.push_back(bigger_num); } else { answer.push_back(-1); } } return answer;}스택으로 시간초과 해결#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; numbers) { vector&lt;int&gt; answer(numbers.size(), -1); stack&lt;pair&lt;int, int&gt; &gt; st; for(int i = 0; i &lt; numbers.size(); i++) { while(!st.empty()) { int num = st.top().first; int idx = st.top().second;\t\t\t//현재 스택의 top 값이 비교대상보다 클 때는 뒷 큰수가 될 수 없다. if(num &gt;= numbers[i]) { break; } // 뒷 큰수를 발견한 경우 answer의 해당 idx에 값을 대입 st.pop(); answer[idx] = numbers[i]; } st.push(make_pair(numbers[i], i)); } return answer;}" }, { "title": "촌수계산", "url": "/posts/%EC%B4%8C%EC%88%98%EA%B3%84%EC%82%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS, Graph", "date": "2023-02-27 00:00:00 +0900", "snippet": "촌수계산우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.=&gt; 그래프, BFS 문제먼저 배열에 그래프를 연결하고 bfs로 탐색해나간다.내가 갈 수 있는 지점은 아직 한 번도 방문하지 않은 상태(중복방지이면서 연결된 상태이고 갈 수 있는 노드들을 큐에 넣는다. 그리고 isvisited 라는 방문 여부 배열을 해당 노드의 촌수로 계산하는 역할로도 써서 사용한다. (촌수는 이전 연결 노드 촌수의 +1)Top-Down#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int arr[101][101] = { 0 };int isvisited[101] = { 0 };int cnt[101] = { 0 };int n, tx, ty, m, x, y;queue&lt;int&gt; q;void bfs(int x){\tq.push(x);\twhile (!q.empty())\t{\t\tint cx = q.front();\t\tq.pop();\t\tfor (int i = 1; i &lt;= n; i++)\t\t{\t\t\tif (arr[cx][i] == 1 &amp;&amp; isvisited[i] == 0)\t\t\t{\t\t\t\tq.push(i);\t\t\t\tisvisited[i] = isvisited[cx] + 1;\t\t\t}\t\t}\t}\t}int main(){\t\tscanf(\"%d\", &amp;n);\tscanf(\"%d %d\", &amp;tx, &amp;ty);\tscanf(\"%d\", &amp;m);\t\tfor (int i = 0; i &lt; m; i++)\t{\t\tscanf(\"%d %d\", &amp;x, &amp;y);\t\tarr[y][x] = 1;\t\tarr[x][y] = 1;\t}\tbfs(tx);\tif (isvisited[ty] != 0)\t{\t\tprintf(\"%d\\n\", isvisited[ty]);\t}\telse\t{\t\tprintf(\"-1\\n\");\t}\t\treturn 0;}" }, { "title": "평범한 배낭", "url": "/posts/%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-02-25 00:00:00 +0900", "snippet": "평범한 배낭이 문제는 아주 평범한 배낭에 관한 문제이다.한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.=&gt; 냅색 알고리즘 문제로 dp로 문제를 해결한다.Top-Down#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N, K, V;int dp[101][100001] = { 0 };int weight[101] = { 0 };int value[101] = { 0 };int main() {\tscanf(\"%d %d\", &amp;N, &amp;K);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d %d\", &amp;weight[i], &amp;value[i]);\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tfor (int j = 1; j &lt;= K; j++)\t\t{\t\t\t// 넣을 수 있는 경우\t\t\tif (weight[i] &lt;= j)\t\t\t{\t\t\t\tdp[i][j] = max(dp[i - 1][j], dp[i-1][j-weight[i]] + value[i]);\t\t\t}\t\t\t// 넣을 수 없는 경우\t\t\telse\t\t\t{\t\t\t\tdp[i][j] = dp[i - 1][j];\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", dp[N][K]);}1차원 배열로 문제를 해결하는 경우(Bottum-Up)#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dy[100001] = { 0 };int main(){\tint n, m, w, v;// n: 보석 종류 수, m: 최대 무게, w : 무게, v 가치\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor (int i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d %d\", &amp;w, &amp;v);\t\tfor (int j = m; j &gt;= 1; j--)\t\t{\t\t\tif(w &lt;= j)\t\t\t{\t\t\t\tdy[j] = max(dy[j], dy[j - w] + v);\t\t\t}\t\t\t\t\t}\t}\tprintf(\"%d\\n\", dy[m]);\treturn 0;}" }, { "title": "실무 관련 CS 지식 정리", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EB%B0%98-%EC%8B%A4%EB%AC%B4%EA%B4%80%EB%A0%A8-CS-%EC%A7%80%EC%8B%9D-%EC%A0%95%EB%A6%AC/", "categories": "python", "tags": "python", "date": "2023-02-24 00:00:00 +0900", "snippet": "실무 관련 CS 지식 정리클린 코드네이밍(Naming) snake_case: Python, Ruby 등에서 권장함 camelCase : Java, Javascript 등에서 권장함 PascalCase : 대부분의 프로그래밍 언어에서 클래스를 네이밍할 때 사용함 kebab-case: HTML Element를 표현할 때 사용함. hungarianNoatation : 이름 앞에 변수의 타입을 접두어로 넣어주는 표기법(bCamelCase, szBackgrounColor, strClassName) 주석법적인 정보를 담을 때# Copyright (C) 2021 ...의도를 명확하게 설명할 때# throughput을 늘리기 위해 스레드를 10개까지 늘린다.for idx in range(10): thread = threading.Thread(target=...) thread.start()...중요성을 강조할 때# 최종 결제를 하기 전에 진행해야 하는 validation 함수 def validate_buyable(wallet, price, ...): ...결과를 경고할 때# WARNING: API 서버가 항상 양호한지 알 수 없음.def connect_api_server(): ...`주석 사용시 주요 키워드TODO : 당장은 아니지만 다음에 해야 할 때FIXME : 치명적인 에러를 발생하는 코드는 아니지만 수정해야 할 때XXX : 더 생각해볼 필요가 있을 때포매팅Vertical Formatting한 파일에 코드를 다 넣지 말고, 개념에 맞게 파일을 나눠서 사용합니다.# as-is # store.py에 전부 있음class FruitsStore: ...class ComputerStore: ...# to-be# fruit_store.pyclass FruitsStore: ...# computer_store.pyclass ComputerStore: ...다른 개념의 코드는 Spacing으로 분리하기비슷한 개념의 코드는 붙여서 사용하기def test_user_buy_product(): user = User() product = Product() product.set_sold_out(True) user.get(product) assert result == \"success\"#Horizontal Formatting한 줄에 코드를 다 넣기보단 변수 등을 활용해서 가독성 높이기#as-isproduct_list.extend([Product(\"모니터\"), Product(\"키보드\"), Product(\"노트북\")])#to-beitems = [Product(\"모니터\"), Product(\"키보드\"), Product(\"노트북\")]product_list.extend(items)네이밍 잘해서 길이 줄이기user_with_name_and_email = User(\"그랩\", \"grab@world.com\")#to-beuser = User(\"그랩\", \"grab@world.com\")``````python### 함수함수의 기능을 담는 이름 네이밍하기```pythondef send_data(): ...def input_is_valid(): ...함수 함수의 역할은 하나만 할 수 있도록 하자 (SRP)함수의 역할이 많아진다면, 오류가 날 가능성이 커지고 가독성이 떨어집니다. 또한 함수에 대한 테스트를 진행하기가 어렵습니다.```pythonas-isdef create_user(email, password): # validation 로직 if “@” not in email or len(password) &lt; 6 : raise Exception(“유저 정보를 제대로 입력하세요”)user = {\"email\" : email, \"password\" : password}database = Database(\"mysql\")database.add(user)email_client = EmailClient()email_client.set_config(...)email_client.send(email, \"회원가입을 축하합니다\")return Trueto-bedef create_user(email, password): validate_create_user(email, password)user = build_user(email, password)save_user(user)send_email(email)returndef validate_create_user(email, password): if “@” not in email or len(password) &lt; 6 : raise Exception(“유저 정보를 제대로 입력하세요”)def build_user(email, password): return { “email”: email, “password”: password }def save_user(user): database = Database(“mysql”) database.add(user)def send_email(email): email_client = EmailClient() email_client.set_config(…) email_client.send(email, “회원가입을 축하합니다”)2. 반복하지 말자 (DRY)관심사를 잘 분리하고 의존성을 줄이기 위해 반복되는 코드를 하나의 함수로 만들어 사용합니다```pythonas-isdef create_user(email, password): # validation 로직 if \"@\" not in email or len(password) &lt; 6 : raise Exception(\"유저 정보를 제대로 입력하세요\") ...def update_user(email, password): # validation 로직 if \"@\" not in email or len(password) &lt; 6 : raise Exception(\"유저 정보를 제대로 입력하세요\") to-bedef validate_create_user(email, password): if \"@\" not in email or len(password) &lt; 6 : raise Exception(\"유저 정보를 제대로 입력하세요\")def create_user(email, password): validate_create_user(email, password) ...def update_user(email, password): validate_create_user(email, password) ... 파라미터(매개변수) 수는 적게 유지하자#as-isdef save_user(user_name, email, password, created_at): ...#to-bedef save_user(user:User): ... 사이드 이펙트를 잘 핸들링하자사이드 이펙트(Side Effect)는 함수가 실행됐을 때 함수 이외의 어떤 것들에 변화를 주는 것을 말한다. 사이드 이펙트를 잘 다루지 못하면, 예측하지 못하는 문제들이 발생할 수 있다.#사이드 이펙트가 없습니다.def get_user_instance(email, password): user = User(email, password) return user\t#사이드 이펙트가 있다def update_user_instance(user): user.email = \"new email\" #인자로 받은 user 객체를 업데이트합니다. ...#사이드 이펙트가 있다def create_user(email, password): user = User(email, password) start_db_session() #외부의 DB Session에 변화를 줄 수 있다. ...사이드 이펙트를 완전히 없앨 순 없지만 있을 경우 직관적인 prefix를 붙여 사이드 이펙트가 발생할 수 있음을 명시적으로 표시한다.일반적으로 udpate를 남발하기 보단 순수 함수 형태로 사용하는 것이 더 직관적이고 에러를 방지할 수 있다.as-iscarts = []#사이드 이펙트를 발생시킴def add_cart(product): carts.append(product)product = Product(...)add_cart(product)to-becarts = []#사이드 이펙트가 없는 순수함수def get_added_cart(product): return [...carts, prodcut]product = Product(...)carts = get_added_cart(product)=&gt; 매개변수로 받아온 객체를 바꾸는 것이 아닌 별도의 객체를 리턴해주는 형태를 통해서사이드 이펙트를 줄인다.클래스명사 형태로 뚜렷한 기능에 대해 표현하는 네이밍하기class Client: ...class RequestBody: ... 단일 책임 원칙(SRP) 지키기하나의 클래스는 하나의 책임만 가지도록 합니다.```pythonas-is#Store가 많은 역할을 혼자서 수행합니다.class Store: def communicate_user(self): … def manage_products(self): … def manage_money(self): …to-be책임을 나눠서 Manger 클래스에게 책임을 전가합니다.class CounterManager: def communicate_user(self): …class ProductManager: def manage_products(self): …class Owner: def manage_money(self): …class Store: def init(self, counter_manager: CounterManager, product_manager: ProductManager, owner: Owner): self.counter_manager = counter_manager self.product_manager = product_manager self.owner = ownerdef sell_product(self): self.counter_manager.communicate_user() ...def manage_products(self): ... ``` 2. 응집도를 높이자. 응집도는 클래스의 변수와 메서드들이 얼마나 유기적으로 엮여있냐를 나타내는 지표입니다.응집도가 높을수록 클래스의 메서드들은 인스턴스 변수들을 많이 사용합니다.응집도가 낮을수록 클래스의 메서드들은 인스턴스 변수들을 적게 혹은 사용하지 않습니다as-isclass LowCohesion: def __init__(self): # 응집도 낮음 self.a = ... self.b = ... self.c = ... def process_a(self): print(self.a) def process_b(self): print(self.b) def process_c(self): print(self.c)to-beclass HighCohesion: def __init__(self): self.abc = ... def process_a(self): self.abc.process_a() def process_b(self): self.abc.process_b() def process_c(self): self.abc.process_c() 변경(수정)하기 쉽게 만들자(다형성)새 기능을 수정하거나 기존 기능을 변경할 때, 코드의 변경을 최소화하는 게 중요합니다.일반적으로 클래스(객체)는 구현(Concrete)와 추상(Abstract)으로 나뉘게 됩니다. 구현에는 실제 동작하는 구체적인 코드가, 추상은 인터페이스나 추상 클래스처럼 기능을 개념화한 코드가 들어갑니다.일반적으로 변경하기 쉽게 설계하기 위해선 추상화를 해두고 구체 클래스에 의존하지 않고 추상 클래스(인터페이스)에 의존하도록 코드를 짜는 것이 중요합니다.as-isclass Developer: def coding(self): print(\"코딩을 합니다\")class Designer: def design(self): print(\"디자인을 합니다\")class Analyst: def analyze(self): print(\"분석을 합니다\")class Company: def __init__(self, employees): #구체 클래스에 의존합니다. self.employees = employees # employee가 다양해질수록 코드를 계속 변경해야 한다. def make_work(self): for employee in self.employees: if isinstance(employee, Developer): employee.coding() elif isinstance(employee, Designer): employee.design() elif isinstance(employee, Analyst): employee.analyze()to-be# 추상 클래스 선언class Employee(metaclass=abc.ABCMeta): @abc.abstractmethod def work(self): ...# 추상 클래스 상속class Developer(Employee): def work(self): print(\"코딩을 합니다\")class Designer(Employee): def work(self): print(\"디자인을 합니다\")class Analyst(Employee): def work(self): print(\"분석을 합니다\")#상속을 통해 쉽게 구현이 가능함 -&gt; 확장에 열려있다.class Manager(Employee): def work(self):\t\tprint(\"매니징을 합니다\")class Company: def __init__(self, employees: List[Employee]): #추상 클래스에 의존합니다. self.employees = employees # employee가 늘어나더라도 변경에는 닫혀있다. def make_work(self): for employee in self.employees: employee.work()에러 핸들링 오류 코드보다는 예외 사용하기오류 코드를 사용하게 되면 상단에 오류인지 확인하는 불필요한 로직이 들어가게 됩니다. 오류의 범주에 들어가지 않은 상태를 나타내는 것이 아니라면, 예외(Exception)로 명시적으로 에러 처리를 표현해주는 게 좋습니다.as-isfrom enum import Enum class ErrorCodes(Enum): VALUE_ERROR=\"VALUE_ERROR\"def we_can_raise_error(): ... return ERROR_CODES.VALUE_ERRORdef use_ugly_function(): result = we_can_occur_error() if result == ErrorCodes.VALUE_ERROR: # 처리 코드 ...to-bedef we_can_raise_error(): if ... raise ValueError(\"에러 발생\")def use_awesome_function(): try: we_can_occur_error() ... except ValueError as e: # 에러 처리 로직\t\t\t\t 예외 클래스 잘 정의하기기본 Exception만 쓰기 보단 내장된 built in Exception을 잘 활용하면 좋습니다.상황에 맞게 Custom Exception을 만들어 사용하는 것도 좋습니다.class CustomException(Exception): ...class WithParameterCustomException(Exception): def __init__(self, msg, kwargs): self.msg = msg self.kwargs = kwargs def __str__(): return f\"message {self.msg} with parameter {self(self.kwargs)}\"raise WithParameterCustomException(\"문제가 있다\", {\"name\": \"grab\"}) 에러 핸들링 잘하기에러를 포착했다면 잘 핸들링해줘야 합니다.```pythondef we_can_raise_error(): … raise Exception(“Error!”)BAD: 에러가 났는지 확인할 수 없게 됩니다.def use_ugly_function1(): try: we_can_raise_error() … except: passBAD: 로그만 남긴다고 끝이 아닙니다.def use_ugly_function2(): try: we_can_raise_error() … except Exception as e: print(f”에러 발생{e}”)GOODdef use_awesome_function(): try: we_can_raise_error() … except Exception as e: logging.error(…) # Error Log 남기기 notify_error(…) # 예측 불가능한 외부 I/O 이슈라면 회사 내 채널에 알리기(이메일, 슬랙 etc) raise OtherException(e) # 만약 이 함수를 호출하는 다른 함수에서 추가로 처리해야 한다면 에러를 전파하기 finally: … #에러가 발생하더라도 항상 실행되어야 하는 로직이 있다면 finally 문을 넣어주기에러 핸들링을 모을 수 있으면 한곳으로 모읍니다. 보통 같은 수준의 로직을 처리한다면 한 곳으로 모아서 처리하는 게 더 에러를 포착하기 쉽습니다.```pythonas-isdef act_1(): try: we_can_raise_error1() ... except: #handlingdef act_2(): try: we_can_raise_error2() ... except: #handlingdef act_3(): try: we_can_raise_error3() ... except: #handling 에러가 날 지점을 한눈에 확인할 수 없습니다. act_1이 실패하면 act_2가 실행되면 안 된다면? 핸들링하기 어려워집니다.```pythondef main(): act_1() act_2() act_3()to-bedef act_1(): we_can_raise_error1() …def act_2(): we_can_raise_error2() …def act_3(): we_can_raise_error3() …* 직관적이며 에러가 날 지점을 확인하고 처리할 수 있다.* 트랜잭션같이 한 단위로 묶여야하는 처리에도 유용합니다.```pythondef main(): try: act_1() act_2() act_3() except SomeException1 as e1: ... except SomeException2 as e2:\t ... except SomeException2 as e3 ... finally: ...\t가독성 향상 방법 구체적이고 명시적으로 적을 것#as-isdt = \"20210901KST\"for i in data: ...#to-bedatetime_with_timezone = \"20210901KST\"for product in products: ... 불필요한(애매한) 표현은 제거할 것#as-isproduct_with_price = Product(\"아이폰\", 3000)the_message = 1 #불필요한 관사 포함name_string = \"grab\" #변수명에 타입을 부가적으로 표현함#to-beproduct = Product(\"아이폰\", 3000) message = 1name = \"grab\" Guard clause일반적으로 if-else문이 중첩(nestsed)될수록 코드는 복잡해지고 보기 지저분해집니다.#BADif :\t...\tif :\t\t...\t\tif :\t\t\t...\t\t\twhile :\t\t\t......nested 코드를 줄이고 가독성을 높이기 위해선, 코드 상단에 Fail이 되는 로직을 위로 넣어두는 것이 좋습니다.as-isdef say_hi_to_spring_user(developer): if developer.is_front_end: raise Exception(\"프론트 엔지니어입니다\") elif developer.is_back_end: if not developer.use_java: raise Exception(\"자바를 사용하지 않습니다\") else: if developer.use_spring: print(\"안녕하세요!\") else: raise Exception(\"자바의 다른 프레임워크를 사용합니다\") else: raise Exception(\"who are you?\")to-be#Fail이 되는 부분을 상위로 올리면 코드를 더 쉽게 읽을 수 있다.def say_hi_to_spring_user(developer): if not developer.is_backend: raise Exception(\"백엔드 엔지니어가 아닙니다\") if not developer.use_java: raise Exception(\"자바를 사용하지 않습니다\") if not developer.use_spring: raise Exception(\"스프링을 사용하지 않습니다\") print(\"안녕하세요!\")` Polymorphism(다형성)객체 지향의 꽃이라고 불리는 다형성을 활용하여 if-condition을 줄일 수 있다.```pythonas-isclass Developer: def coding(self): print(“코딩을 합니다”)class Designer: def design(self): print(“디자인을 합니다”)class Analyst: def analyze(self): print(“분석을 합니다”)class Company: def init(self, employees): self.employees = employeesdef make_work(self): for employee in self.employees: if type(employee) == Developer: employee.coding() elif type(employee) == Designer: employee.design() elif type(employee) == Analyst: employee.analyze() to-beEmployee로 추상화해둡니다.class Employee(metaclass=abc.ABCMeta): @abc.abstractmethod def work(self): …class Developer(Employee): def work(self): print(“코딩을 합니다”)class Designer(Employee): def work(self): print(“디자인을 합니다”)class Analyst(Employee): def work(self): print(“분석을 합니다”)class Company: def init(self, employees: List[Employee]): self.employees = employees# if문을 사용하지 않고 다형성을 통해서 이를 해결합니다.def make_work(self): for employee in self.employees: employee.work() ```코드 리팩토링수정 전 코드class GrabStore: def __init__(self): self.money = 0 self.name = \"그랩마켓\" self.products = { 1: {\"name\": \"키보드\", \"price\": 30000}, 2: {\"name\": \"모니터\", \"price\": 50000}, } def set_money(self, money): self.money = money def set_products(self, products): self.products = products def get_money(self): return self.money def get_products(self): return self.productsclass User: def __init__(self): self.money = 0 self.store = GrabStore() self.belongs = [] def set_money(self, money): self.money = money def set_belongs(self, belongs): self.belongs = belongs def get_money(self): return self.money def get_belongs(self): return self.belongs def get_store(self): return self.store def see_product(self, product_id): products = self.store.get_products() return products[product_id] def purchase_product(self, product_id): product = self.see_product(product_id) if self.money &gt;= product[\"price\"]: self.store.products.pop(product_id) # 상점에서 상품 꺼내기 self.money -= product[\"price\"] # 사용자가 돈 내기 self.store.money += product[\"price\"] # 상점에서 돈 받기 self.belongs.append(product) return product else: raise Exception(\"잔돈이 부족합니다\")if __name__ == \"__main__\": user = User() user.set_money(100000) user.purchase_product(product_id=1)수정 후 코드 다른 Store가 들어오면 어떻게 될까?=&gt;1.1. Store를 추상화한다.1.2. 의존성 주입을 한다 Store에 있는 상품과 돈을 마음대로 접근할 수 있다.=&gt;2.1. Store의 책임을 정의하고 캡슐화한다.2.2. User의 결제 로직을 수정한다.2.3. User도 캡슐화해보자! User가 많은 행위를 책임지고 있다. Store가 판매하는 책임을 가져야 하지 않을까?=&gt;3.1. 상점에서 상품을 판매하는 행위를 추상화하고 구체적인 로직을 해당 메서드로 옮긴다. product가 책임을 가져야 하지 않을까?=&gt;4.1. 딕셔너리 타입을 클래스(데이터클래스) 객체로 변환하자. from abc import ABC, abstractmethodfrom dataclasses import dataclass# 일종의 클래스화 된 구조체로 생각 @dataclassclass Product: name: str price: int# 1번 추상 메서드화 수행class Store(ABC): @abstractmethod def __init__(self): self._money = 0 self.name = \"\" self._products = {} # 2 Store의 책임을 정의하고 캡슐화, 3.1. 상점에서 판매하는 행위를 여기로 옮김 @abstractmethod def show_product(self, product_id): pass @abstractmethod def sell_product(self, product_id, money): passclass GrabStore(Store): def __init__(self, products): self._money = 0 self.name = \"그랩마켓\" self._products = products def set_money(self, money: int): self._money = money def set_products(self, products): self._products = products def show_product(self, product_id): return self._products[product_id] def sell_product(self, product_id, money): # Validation 코드는 최소화 product = self.show_product(product_id=product_id) if not product: raise Exception(\"상품이 존재하지 않는다\") self._take_money(money=money) try: _product = self._take_out_product(product_id=product_id) return _product except Exception as e: self._return_money(money) raise e def _take_out_product(self, product_id): return self._products.pop(product_id) def _take_money(self, money): self._money += money def _return_money(self, money): self._money -= moneyclass User: # 1반 의존성 주입 def __init__(self, money, store: Store): self._money = money self.store = store self.belongs = [] def get_money(self): return self._money def get_belongs(self): return self.belongs def get_store(self): return self.store def see_product(self, product_id): product = self.store.show_product(product_id=product_id) return product def purchase_product(self, product_id): product = self.see_product(product_id=product_id) price = product.price if self._check_money_enough(price=price): self._give_money(money=price) try: my_product = self.store.sell_product(product_id=product_id, money=price) self._add_belong(my_product) return my_product except Exception as e: self._take_money(money=price) print(f\"구매중 문제가 발생했습니다 {str(e)}\") else: raise Exception(\"잔돈이 부족합니다\") def _check_money_enough(self, price): return self._money &gt;= price def _give_money(self, money): self._money -= money def _take_money(self, money): self._money += money def _add_belong(self, product): self.belongs.append(product) # List에 값을 추가할 때 append 메서드를 사용if __name__ == \"__main__\": store = GrabStore( products={ 1: Product(name=\"키보드\", price=30000), 2: Product(name=\"냉장고\", price=500000) } ) user = User(money=100000, store=store) user.purchase_product(product_id=2) print(f\"user의 잔돈 : {user.get_money()}\") print(f\"user가 구매한 상품 : {user.get_belongs()}\")절차지향 프로그래밍개념절차지향(Procedure Oriented) 프로그래밍은 프로시저 콜, 즉 함수 호출을 중심으로 프로그래밍을 말한다재사용 가능한 코드들은 별도의 함수로 분리하고 함수 간의 호출로 하고자 하는 일을 수행한다. 이런 프로세스는 주로 “함수”와 “조건문”, “루프문” 을 활용하여 코드를 구성한다.또한 절차지향 프로그래밍은 데이터를 중앙 집중식으로 관리한다. 즉 프로세스 로직과 데이터가 별도의 위치에 분리되어 있다. 프로세스 로직 부분에서는 어떤 데이터가 들어오는지 모르기 때문에 로직 내에 조건문 사용이 많은 경향이 있다.예시def read_input_file(file_path: str) -&gt; str: if file_path.endswith(\".txt\"): reader = get_file_reader(file_type=\"txt\") return reader.read(file_path) elif file_path.endswith(\".csv\"): reader = get_file_reader(file_type=\"csv\") return reader.read(file_path) elif file_path.endswith(\".xlsx\"): reader = get_file_reader(file_type=\"xlsx\") return reader.read(file_path) else: raise ValueError(\"파일 확장자는 txt, csv, xlsx 중 하나여야 합니다.\")def get_file_reader(file_type: str) -&gt; Reader: if file_type == \"txt\": \t\t... elif file_type == \"csv\": ... elif file_type == \"xlsx\": ...def parse_input_data(data: str) -&gt; List[str]: ...def save_data(data: List[str]): ...def main(): # 절차 지향적으로 팡리을 읽고 파싱하고 저장하는 역할을 수행하는 프로그램 data = read_input_file(\"input_file.txt\") parsed_data = parse_input_data(data) save_data(parsed_data) if __name__ == \"__main__\": main()main 함수는 하위 함수들의 호출로 이루어져 있다. main 함수만 보면 이 프로그램이 전체적으로 어떤 일을 하는지 쉽게 파악할 수 있다.장단점절차지향 프로그래밍으로 작성된 코드는 직관적이다. TOP -&gt; DOWN 방식이고 이를 표현하는 작은 단위를 함수로 표현한다. 로직이 복잡한 것이나 계속해서 기능을 확장해나가야 하는 것이 아니라면, 유지보수도 용이하다.그러나 절차지향은 전체 로직이 매우 복잡하거나 동적으로 로직을 바꿔야 하는 등의 기능 확장이 필요할 때 유지 보수하기가 어려워집니다. 또한 데이터와 함수가 분리되어 있기에 함수가 많아질수록 데이터의 변경 사항을 추적하기도 어려워진다.따라서 절차지향은 프로그램이 수행하는 알고리즘이 명확하고, 기능 확장 등이 자주 일어나지 않는 상황에서 사용하기에 좋다.객체지향 프로그래밍개념객체 지향(Object Oriented) 프로그래밍은 객체라고 하는 단위에 책임을 명확히 하고 서로 협력하도록 프로그래밍을 하는 패러다임을 말한다.모든 것을 객체로 나누어 생각하고, 필요할 때 객체들을 활용하고 서로 협력하여 일을 수행한다.절차지향과 다르게 객체는 데이터와 함수(메서드)를 함께 가지고 있다. 객체 내부의 데이터는 외부에 공개할 필요가 없거나 해서는 안 되는 데이터라면 모두 자신 내부에 숨겨 외부에서 알지 못하도록 한다.예시예시코드는 사용자로부터 파일을 입력받아 파일을 파싱한 후, 이 내용을 저장소에 저장하는 코드class Processor: def __init__(self, file_reader: FileReader, data_parser: DataParser, repository: Repository) -&gt; None: self.file_reader = file_reader self.data_parser = data_parser self.repository = repository def execute(self, file_path: str) -&gt; None: data = self.file_reader.read(file_path) parsed_data = self.data_parser.parse(data) self.repository.save(parsed_data)class FileReader: def __init__(self) -&gt; None: self.file_types = [\"txt\"] self.file_history = [] # 만약 절차 지향이라면 file_history 데이터를 중앙 집중으로 관리하게 됩니다. def read(self, file_path: str) -&gt; str: self._validate(file_path) ... def _validate(self, file_path: str) -&gt; None: for file_type in self.file_types: if file_path.endswith(file_type): return raise ValueError(\"파일 확장자는 txt, csv, xlsx 중 하나여야 합니다.\")class DataParser: def parse(self, data: str) -&gt; List[str]: ...class Repository: def init(self, database_url: str, ...): ... def save(self, data: List[str]) -&gt; None: ...class Main: @staticmethod def run(self) -&gt; None: processor = Processor( file_reader=FileReader(), data_parser=DataParser(), repository=Repository() ) processor.execute(\"input_file.txt\") if __name__ == \"__main__\": Main.run()코드는 Processor, FileReader 등 여러 객체(문법적으로는 클래스)로 구성되어있다. 그리고 각 객체는 각자 자신의 역할과 기능이 있다. 예를 들면 FileReader 는 파일을 읽는 역할을, DataParser 는 데이터를 파싱하는 역할을 한. 프로그래밍은 전체적으로 객체와 객체 간의 메서드 호출로 이루어진다. 그리고 각 객체는 자신의 기능을 수행하는데 필요한 데이터를 직접 가지고 있다. 예를 들어, FileReader 는 file_types 속성으로 자신이 파싱할 수 있는 파일 확장자인지 검증합니다. 이 외에 다른 객체들도 본인의 역할을 수행하는 과정에서 발생하는 데이터를 전부 관리할 수 있다.코드는 조금 더 복잡해졌지만, 객체 지향은 기능을 확장할 때 효과적이다.# FileReader는 이제 추상 클래스입니다.class FileReader(ABC): def read(self, file_path: str) -&gt; str: self._validate(file_path) data = self._open_file(file_path) return self._read(data) @abstractmethod def _read(self, data: str) -&gt; str: pass # 공통으로 사용하는 메서드입니다. def _validate(self, file_path: str) -&gt; None: if not file_path.endswith(self.file_type): raise ValueError(f\"파일 확장자가 {self.file_type} 아닙니다.\") @abstractmethod def _open_file(file_path: str) -&gt; str: ...# txt 파일을 읽는 책임을 가진 FileReader 파생 클래스입니다.class TxtFileReader(FileReader): def file_type(self) -&gt; str: return \"txt\" def _read(self, data: str) -&gt; str: ... ...# csv 파일을 읽는 책임을 가진 FileReader 파생 클래스입니다.class CsvFileReader(FileReader): def file_type(self) -&gt; str: return \"csv\" def _read(self, data: str) -&gt; str: ... ...# xlsx 파일을 읽는 책임을 가진 FileReader 파생 클래스입니다.class XlsxFileReader(FileReader): def file_type(self) -&gt; str: return \"xlsx\" def _read(self, data: str) -&gt; str: ... ...객체 지향을 지원하는 대부분의 프로그래밍 언어들은 클래스라는 문법을 제공한다. 객체의 강력한 기능인 상속을 이용하면 한 번 정의해놓은 메서드를 파생 클래스에서 재사용 가능하다. 또한 상속으로 객체간의 계층 구조를 만들고 데이터와 메서드를 재사용할 수 있다.객체 지향의 가장 큰 특징은 같은 역할을 하는 객체를 쉽게 바꾸도록 설계할 수 있다는 것입니다. 예를 들어 위의 경우, 우리가 txt 파일을 읽어야할 경우 다음처럼 Main.run() 함수 내에서 TxtFileReader 를 사용하면 된다.class Main: def run(self) -&gt; None: processor = Processor( file_reader=TxtFileReader(), \tdata_parser=DataParser(), repository=Repository() )class Main: def run(self) -&gt; None: processor = Processor( file_reader=CsvFileReader(), # 이 한줄만 바뀝니다. \tdata_parser=DataParser(), repository=Repository() )이렇게 코드 한줄만으로 가능한 이유는 TxtFileReader, CsvFileReader, XlsxFileReader 클래스가 모두 FileReader 의 파생 클래스이기 때문이다. 이런 객체 지향의 특성을 “다형성”이라고 하며, 어떤 객체에 필요한 객체를 때에 따라 다르게 주입해주는 것을 “의존성 주입”이라고 한다 (뒤에서 다시 다룹니다)장단점객체 지향은 여러 명의 개발자들이 협력을 해야 하거나, 확장 가능하도록 코드를 설계해야 하는 경우에 적합하다.하지만 확장이 가능하고 유연한 만큼, 처음 코드를 보는 사람들은 어렵고 헷갈릴 수 있다. 또한 실행 환경에서 입력에 따라 다양한 작업 흐름이 만들어지기 때문에 디버깅하기가 상대적으로 어렵다.객체 지향의 5대 원칙 SOLIDSRP(Single Responsibility)Single Responsibility Principle(단일 책임 원칙)은 객체는 하나의 책임만을 지녀야 한다는 법칙이다.여러 책임을 동시에 가지는 객체는 처음에 코드를 짤 때는 편하지만, 코드가 복잡해질수록 에러가 날 확률도 높아지며 직관적으로 코드를 이해하기 어려워진다. 따라서 객체를 설계하기 전 책임을 확실하게 부여하는 것이 중요하다.AS-IS#하나의 클래스(객체)가 여러 책임을 가지고 있음class Employee: def coding(self): print(\"코딩을 합니다\") def design(self): print(\"디자인을 합니다\") def analyze(self): print(\"분석을 합니다\")TO-BE#각 객체는 역할을 나눠 각각 하나의 책임만 가지고 있음class Developer: def coding(self): print(\"코딩을 합니다\")class Designer: def design(self): print(\"디자인을 합니다\")class Analyst: def analyze(self): print(\"분석을 합니다\")OCP(Open Closed)Open Closed Principle(개방 폐쇄 원칙)은 객체의 확장에는 열려있고, 수정에는 닫혀있게 해야 한다는 법칙기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계한다.OCP에서 중요한 부분은 요구사항이 변경되었을 때 코드의 변경되어야 할 부분과 그렇지 않아야 할 부분이 명확하게 구분되어 있어야 한다는 점보통 이를 지키기 위해선 인터페이스나 추상 클래스를 통해 추상화시키고 이를 상속, 구현한다. 새로운 기능을 추가한다고 할 때, 다형성을 사용해 기존 코드를 변경하지 않으면서 (변경에 닫혀있음), 추상 클래스를 상속받아 쉽게 코드를 추가할 수 있음(확장에 열려있음)AS-ISclass Developer: def coding(self): print(\"코딩을 합니다\")class Designer: def design(self): print(\"디자인을 합니다\")class Analyst: def analyze(self): print(\"분석을 합니다\")class Company: def __init__(self, employees): self.employees = employees # employee가 다양해질수록 코드를 계속 변경해야 한다. def make_work(self): for employee in self.employees: if isinstance(employee, Developer): employee.coding() elif isinstance(employee, Designer): employee.design() elif isinstance(employee, Analyst): employee.analyze()TO-BE각 객체들의 역할을 아우르는 추상 클래스(고수준)을 생성class Employee(metaclass=abc.ABCMeta): @abc.abstractmethod def work(self): ...class Developer(Employee): def work(self): print(\"코딩을 합니다\")class Designer(Employee): def work(self): print(\"디자인을 합니다\")class Analyst(Employee): def work(self): print(\"분석을 합니다\")#상속을 통해 쉽게 구현이 가능함 -&gt; 확장에 열려있다.class Manager(Employee): def work(self):\t\tprint(\"매니징을 합니다\")class Company: def __init__(self, employees: List[Employee]): self.employees = employees # employee가 늘어나더라도 변경에는 닫혀있다. def make_work(self): for employee in self.employees: employee.work()LSV(Liskov Substitution)Liskov Substitution Principle(리스코브 치환 원칙)은 부모 객체의 역할은 자식 객체도 할 수 있어야 된다는 원칙Liskov Substitution 원칙이 지켜지지 않으면 Open Closed 원칙 역시 위반할 가능성이 높다. 위반사례1import abcclass Employee(metaclass=abc.ABCMeta): @abc.abstractmethod def work(self): ...class Developer(Employee): def work(self): print(\"코딩을 합니다\") return [\"if..\", \"for...\"]class FrontEndDeveloper(Developer): def work(self): print(\"프론트엔드 개발을 합니다\") #결과를 반환하지 않음if __name__ == \"__main__\": def make_code(developer: Developer): code = developer.work() print(f\"총 {len(code)}줄의 코드를 작성하였습니다\") make_code(Developer()) make_code(FrontEndDeveloper()) 위반사례2유명한 직사각형, 정사각형 사례일반적으로 정사각형은 직사각형입니다. 즉 정사각형 is 직사각형의 관계이며, 이는 상속이 가능합니다. (부분 집합의 개념)class Rectangle: def get_width(self): return self.width; def get_height(self): return self.height; def set_width(self, width): self.width = width def set_height(self, height): self.height = heightclass Square(Rectangle): def set_width(self, width): self.width = width self.height = width def set_height(self, height): self.width = height self.height = heightif __name__ == \"__main__\":\tsquare = Square()\tsquare.set_width(20)\tsquare.set_height(30)\tcheck = square.get_width() == 20 &amp;&amp; square.get_height() == 30 #부모의 명세와 다름ISP(Interface Segregation)Interface Segregation Principle(인터페이스 분리 원칙)은 클라이언트가 자신이 이용하지 않는 메서드는 의존하지 않아야 한다는 원칙SOLID의 1 원칙인 Single Responsibility 원칙이 객체가 하나의 책임만을 가져야 한다고 했는데, 여기서는 인터페이스(혹은 추상 클래스)가 하나의 책임만을 가져야 하는 것으로 볼 수 있음.인터페이스를 책임에 맞게 잘 쪼개둔다면, 클라이언트 입장에서는 필요한 역할만 구현(혹은 상속)하여 사용할 수 있다.(불필요한 메서드를 억지로 상속받을 필요 X)AS-ISfrom abc import *class Smartphone(metaclass=ABCMeta):\t@abstractmethod\tdef call(self):\t\t...\t@abstractmethod\tdef send_message(self):\t\t...\t\t@abstractmethod\tdef see_youtube(self):\t\t...\t\t@abstractmethod\tdef take_picture(self):\t\t...#카메라가 없는 클래스에서 take_picture는 불필요한 메서드가 된다.class PhoneWithNoCamera(Smartphone):\t...TO-BE인터페이스를 역할 단위로 나눈다.class Telephone(metaclass=ABCMeta):\t@abstractmethod\tdef call(self):\t\t...\t@abstractmethod\tdef send_message(self):\t\t...\tclass Camera(metaclass=ABCMeta):\t@abstractmethod\tdef take_picture(self):\t\t...class Application(metaclass=ABCMeta):\t@abstractmethod\tdef see_youtube(self): ...class PhoneWithNoCamera(Telephone, Application):\t...DIP(Dependency Inversion)Dependency Inversion Principle(의존성 역전 원칙)은 의존성을 항상 고수준으로 향하게 하여 예측할 수 없는 의존성의 변화를 줄이자는 원칙일반적으로 의존성을 가지는 대상이 변경되면 의존하는 주체도 함께 변경된다. 만약 자주 바뀌는 구현체(저수준)를 의존하게 된다면 코드의 변경이 잦을 것이며, 버그와 사이드 이펙트가 날 확률이 높아진다. 이때 코드가 덜 바뀌는 인터페이스나 추상 클래스(고수준)를 의존한다면 상대적으로 안정적인 코드를 작성할 수 있다.소프트웨어 아키텍처란?소프트웨어 개발 관점에서 아키텍처는 소프트웨어의 전체적인 구조를 잡아주는 설계도를 말한다.아키텍처는 소프트웨어의 큰 그림을 보게 해준다. 좋은 아키텍처는 사람이 세부적인 코드를 일일이 다 보지 않아도, 일관된 코드 구조로 흐름을 쉽게 유추할 수 있도록 한다.또한 개발을 하다 보면 코드를 어떻게 분리하고 모듈화할지, 객체를 어떻게 설계할지 고민하곤 하는데, 아키텍처는 이러한 고민에 뱡향을 제시해주는 일종의 지침이라고도 볼 수 있다.몇몇 유명한 아키텍처들은 자주 사용되며 패턴화되기도 하는데, 한 번쯤 들어봤을 만한 레이어드 아키텍처, MVC 패턴 등이 바로 이렇게 패턴화된 아키텍처이다.레이어드 아키텍처개념레이어드 아키텍처는 많은 분야에서 사용되는 아키텍처이다.이름 그대로 여러 레이어를 분리하여 레이어마다 해야 할 역할을 정의해놓은 구조.대표적인 레이어드 아키텍처인 4 계층(4 Layered) 아키텍처의 각 레이어 정리하면 아래와 같다 프레젠테이션 레이어인터페이스와 애플리케이션이 연결되는 곳웹 통신 프레임워크, CLI 등 인터페이스, 입출력의 변환 등 외부와의 통신을 담당한다. 애플리케이션 레이어소프트웨어가 제공하는 주요 기능(비즈니스 로직)을 구현하는 코드가 모이는 곳로직을 오케스트레이션하고, 트랜잭션의 시작과 끝을 담당합니다.*도메인 레이어도메인과 관련된 객체들이 모이는 곳도메인 모델(엔티티, 값 객체), 도메인 서비스 등 도메인 문제를 코드로 풀어내는 일을 담당 인프라스트럭처 레이어다른 레이어을 지탱하는 기술적 기반을 담은 객체들이 모이는 곳DB와의 연결, ORM 객체, 메시지 큐 등 애플리케이션 외적인 인프라들과의 어댑터 역할을 담당레이어드 아키텍처는 의존성의 방향은 다음과 같다. 프레젠테이션 레이어 -&gt; 애플리케이션 레이어 -&gt; 도메인 레이어 -&gt; 인프라스트럭처 레이어즉 프레젠테이션 레이어에 있는 코드는 애플리케이션 레이어에 있는 코드에 의존해야 한다. 그 반대인 애플리케이션 레이어 코드가 프레젠테이션 레이어에 있는 코드에 의존하면 안된다. 이처럼 의존성의 흐름은 항상 프레젠테이션 레이어에서 인프라스트럭쳐 레이어로 흘러야 한다.위는 4개의 레이어로 구성한 예이고, 3개의 레이어로 구성할 수도 있다. 3 레이어의 경우 보통 다음처럼 구성한다.프레젠테이션 레이어 -&gt; 애플리케이션 레이어 -&gt; 데이터 접근 레이어#예시간단한 예를 살펴보겠습니다.쇼핑몰 웹 서비스의 백엔드 서버를 만든다고 해보죠. 프로젝트 구조는 다음과 같이 구성할 수 있다.src/ presentation_layer/ product_controller.py user_controller.py application_layer/ product_service.py user_service.py domain_layer/ product.py user.py infrastructure_layer/ \trepositories/ \t product_repository.py \t user_repository.py database.py orm.py 프레젠테이션 레이어\"\"\"REST API 형태로 클라이언트에게 입력을 받고, 이를 애플리케이션 서비스가 활용할 수 있는 형태로 바꾸어 전달합니다.애플리케이션 서비스가 결과를 내놓으면 이를 REST API 에서 약속한 형태로 변환하여 클라이언트에게 HTTP 통신으로 반환합니다.\"\"\"from fastapi import FastAPIfrom src.presentation_layer.web import appfrom src.application_layer import product_service @app.post(\"/products\", status_code=200)def register_products(json_req) -&gt; None: product = product_service.create_product(name=json_req.name, price=json_req.price) response = { \"product\": product } return response 애플리케이션 레이어# src/application_layer/product_service.py\"\"\"프레젠테이션 레이어에서 넘겨받은 입력을 비즈니스 로직에 맞게 처리합니다. 이런 처리 로직을 서비스라고 하는데, 필요에 따라 도메인 모델을 만들고, 저장소에 저장하는 등 여러 세부적인 로직을 오케스트레이션 합니다.이후 다시 프레젠테이션 레이어에 처리한 결과를 넘겨줍니다.\"\"\"from src.domain_layer.product import Productfrom src.infrastructure_layer.database import dbfrom src.infrastructure_layer.repositories.product_repository import ProductRepositorydef create_product(name: str, price: str) -&gt; bool: try: product = Product(name, price) with db.Session() as session: product_repository = ProductRepository(session) product_repository.save(product) session.commit() return product except: raise Exception(\"Product Not Created\") 도메인 레이어# src/domain_layer/product.py\"\"\"도메인 레이어는 도메인의 내용들을 표현합니다.\"\"\"from sqlalchemy import Column, String, Integer# DB와 연결하는 일은 인프라스트럭처 레이어에서의 일입니다.from src.infrastructure_layer.database import Base # 도메인 레이어의 컴포넌트(Product)는 인프라스트럭쳐 레이어의 컴포넌트(Base)에 의존합니다.class Product(Base): __tablename__ = 'product' id = Column(Integer, primary_key=True) name = Column(String) price = Column(Integer)장점레이어마다 정해진 역할이 있다. SRP(단일 책임 원칙)와 비슷하게 레이어 간의 책임을 두고 분리해서 유지보수 및 코드 관리가 용이하다.레이어 간의 의존 흐름이 바깥쪽(프레젠테이션 레이어)에서 안쪽(인프라스트럭쳐 레이어)으로 일정합니다. 새로운 기능을 개발할 때 통일된 흐름에 맞게 빠르게 개발이 가능하다.코드를 처음 보는 사람은 의존성의 흐름에 따라 자연스럽게 전체적인 구조를 쉽게 파악할 수 있다.문제점레이어드 아키텍처의 단점은 소프트웨어가 최종적으로 인프라스트럭처(ex. DB)에 의존성을 갖도록 한다는 것프레젠테이션 레이어 -&gt; 애플리케이션 레이어 -&gt; 도메인 레이어 -&gt; 인프라스트럭쳐 레이어소프트웨어에서 중요한 부분은 비즈니스 로직을 처리하는 “애플리케이션 레이어”와 “도메인 레이어”그런데 도메인 레이어가 인프라스트럭쳐, 특히 DB를 의존하게 된다면 어떻게 될까요? 도메인 레이어와 애플리케이션 레이어가 변경에 쉽게 영향을 받을 수밖에 없다.DB가 도메인 즉 소프트웨어의 설계 핵심에 영향을 미치다 보니, 소프트웨어의 모든 구조가 DB 중심의 설계가 됩니다. 이렇게 되면 애플리케이션 설계에 앞서 데이터베이스를 먼저 선택하고, 데이터베이스 설계(데이터 모델링)부터 하게 됩니다. 또한 객체 지향에서 추구하는 “액션”이 먼저가 되는 것이 아니라 “상태” 중심적으로 설계를 하다 보니, 점점 객체 지향에서 벗어나는 코드들이 생기게 됩니다." }, { "title": "상자넣기", "url": "/posts/%EC%83%81%EC%9E%90%EB%84%A3%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-02-23 00:00:00 +0900", "snippet": "상자넣기정육면체 모양의 상자가 일렬로 늘어서 있다. 상자마다 크기가 주어져 있는데, 앞에 있는 상자의 크기가 뒤에 있는 상자의 크기보다 작으면, 앞에 있는 상자를 뒤에 있는 상자 안에 넣을 수가 있다. 예를 들어 앞에서부터 순서대로 크기가 (1, 5, 2, 3, 7)인 5개의 상자가 있다면, 크기 1인 상자를 크기 5인 상자에 넣고, 다시 이 상자를 크기 7인 상자 안에 넣을 수 있다. 하지만 이렇게 상자를 넣을 수 있는 방법은 여러 가지가 있을 수 있다. 앞의 예에서 차례대로 크기가 1, 2, 3, 7인 상자를 선택하면 총 4개의 상자가 한 개의 상자에 들어가게 된다.=&gt; 최대 증가 수열을 구하는 문제로 dp로 문제를 해결한다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n;int dp[1001] = { 0 };int main() {\tvector&lt;int&gt; v;\tint temp, result = 0;\tscanf(\"%d\", &amp;n);\t\tfor (int i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d\", &amp;temp);\t\tv.push_back(temp);\t}\tdp[0] = 1;\tfor (int i = 1; i &lt; n; i++)\t{\t\tint max_num = 0;\t\tfor (int j = i - 1; j &gt;= 0; j--)\t\t{\t\t\tif (v[j] &lt; v[i] &amp;&amp; dp[j] &gt; max_num)\t\t\t{\t\t\t\tmax_num = dp[j];\t\t\t}\t\t}\t\tdp[i] = max_num + 1;\t}\tfor (int i = 0; i &lt; n; i++)\t{\t\tif (result &lt; dp[i])\t\t{\t\t\tresult = dp[i];\t\t}\t}\tprintf(\"%d\\n\", result);}" }, { "title": "점프", "url": "/posts/%EC%A0%90%ED%94%84/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-02-22 00:00:00 +0900", "snippet": "점프N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.=&gt; 헷갈렸던 내용으로는 arr[i][j] 값이 0이었을 때 즉 종착점일 때는 dp 과정을 수행하면 안된다는 것이다.(continue문으로 건너뛰기)#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int N;int arr[1001][1001] = {0};long long int dp[1001][1001] = {0};int main() {\tscanf(\"%d\", &amp;N);\t\tfor (int i = 1; i &lt;= N; i++)\t{\t\tfor (int j = 1; j &lt;= N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\tdp[1][1] = 1;\t// 우측 하방으로 이동하므로 i, j 모두 양의 방향으로 스캔한다.\tfor (int i = 1; i &lt;= N; i++)\t{\t\tfor (int j = 1; j &lt;= N; j++)\t\t{\t\t\t// 0 인경우 제자리를 다시 더해주는 일을 막기 위해 continue로 건너뛴다.\t\t\tif (arr[i][j] == 0)\t\t\t\tcontinue;\t\t\t// dp 값이 0인 곳은 도달할 수 없는 곳이므로 건너 뛴다.\t\t\tif (dp[i][j] != 0)\t\t\t{\t\t\t\tif (i + arr[i][j] &lt;= N)\t\t\t\t\tdp[i + arr[i][j]][j] += dp[i][j];\t\t\t\tif (j + arr[i][j] &lt;= N)\t\t\t\t\tdp[i][j + arr[i][j]] += dp[i][j];\t\t\t}\t\t\t\t\t\t\t\t}\t\t\t}\tprintf(\"%lld\\n\", dp[N][N]);}" }, { "title": "가장 긴 증가하는 부분 수열", "url": "/posts/%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-02-19 00:00:00 +0900", "snippet": "가장 긴 증가하는 부분 수열수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.=&gt; DP로 문제를 해결한다.이전에 나온 숫자들 중에서, 현재 값 보다 작은 값 중에서, 가지고 있는 부분 수열의 길이 중 가장 긴 부분 수열을 가진 길이에 + 1을 한 값이 현재 위치에서 최대 부분 증가 수열이 된다.#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int N;int A[1001] = { 0 };int dp[1001] = { 0 };int main() {\tscanf(\"%d\", &amp;N);\t\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d\", &amp;A[i]);\t}\tdp[1] = 1;\tfor (int i = 2; i &lt;= N; i++)\t{\t\tint max_num = 0;\t\tfor (int j = i - 1; j &gt;= 1; j--)\t\t{\t\t\tif (A[i] &gt; A[j] &amp;&amp; max_num &lt; dp[j])\t\t\t{\t\t\t\tmax_num = dp[j];\t\t\t}\t\t}\t\tdp[i] = max_num + 1;\t}\t// 반드시 마지막 dp 배열의 값이 최대 부분 증가수열인 것은 아니기 때문에 최댓값 탐색 수행\tint result = 0;\tfor (int i = 1; i &lt;= N; i++)\t{\t\tif (result &lt; dp[i])\t\t{\t\t\tresult = dp[i];\t\t}\t}\t\tprintf(\"%d\\n\", result);}" }, { "title": "파이썬 동시성과 병렬성", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%8F%99%EC%8B%9C%EC%84%B1%EA%B3%BC-%EB%B3%91%EB%A0%AC%EC%84%B1/", "categories": "python", "tags": "python", "date": "2023-02-12 00:00:00 +0900", "snippet": "파이썬 동시성과 병렬성프로세스(Process)란?프로세스(process)란 실행중에 있는 프로그램(Program)을 의미한다.스케줄링의 대상이 되는 작업(task)과 같은 의미로 쓰인다.프로세스 내부에는 최소 하나의 스레드(thread)를 가지고있는데, 실제로는 스레드(thread)단위로 스케줄링을 한다.하드디스크에 있는 프로그램을 실행하면, 실행을 위해서 메모리 할당이 이루어지고, 할당된 메모리 공간으로 바이너리 코드가 올라가게 된다. 이 순간부터 프로세스라 불린다.(1).프로세스 운영체제 -&gt; 할당 받는 자원 단위(실행 중인 프로그램) CPU동작 시간, 주소공간(독립적) Code, Data, Stack, Heap -&gt; 독립적 최소 1개의 메인스레드 보유 파이프, 파일, 소켓등을 사용해서 프로세스간 통신(Cost High)-&gt; Context Switching 비용이 크다.스레드 (Thread)란 ?스레드란 프로세스 내부에 있는 CPU 수행 단위를 말한다.(2).스레드 프로세스 내에 실행 흐름 단위 프로세스 자원 사용 Stack만 별도 할당 나머지는 공유(Code, Data, Heap) 메모리 공유(변수 공유) 한 스레드의 결과가 다른 스레드에 영향 끼침 동기화 문제는 정말 주의(디버깅 어려움)프로세스(Process) vs 스레드 (Thread)프로세스 : 별도의 메모리 공간에서 실행스레드 : 동일한 프로세스 내의 공유 메모리 공간에서 실행멀티 스레드와 멀티 프로세스(3).멀티 스레드 한 개의 단일 어플리케이션(응용프로그램) -&gt; 여러 스레드로 구성 후 작업 처리 시스템 자원 소모 감소(효율성), 처리량 증가(Cost 감소) 통신 부담 감소, 디버깅 어려움, 단일 프로세스에는 효과 미약, 자원 공유 문제(교착상태), 프로세스 영향준다.(4).멀티 프로세스 한 개의 단일 어플리케이션(응용프로그램) -&gt; 여러 프로세스로 구성 후 작업 처리 한 개의 프로세스 문제 발생은 확산 없음(프로세스 Kill) 캐시 체인지, Cost 비용 매우 높음(오버헤드), 복잡한 통신 방식 사용" }, { "title": "동전 1", "url": "/posts/%EB%8F%99%EC%A0%84-1/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-02-09 00:00:00 +0900", "snippet": "동전 10원을 만드는 경우의 수는 기본적으로 1개1(=j)부터 10(=k)까지 dp[j] += dp[j - 1] 을동전 2에 대해서는 0원과 1원 경우의 수는 불가능하므로 넘기고, j = 2부터 10(=k)까지 dp[j] += dp[j - 2] 를 해준다.동전 5에 대해서도 j = 5부터 10(=k)까지 dp[j] += dp[j - 5] 를 해준다.#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int n, k;int arr[10001] = { 0 };int main() {\tvector&lt;int&gt; num;\tscanf(\"%d %d\", &amp;n, &amp;k);\t\tfor (int i = 0; i &lt; n; i++)\t{\t\tint temp;\t\tscanf(\"%d\", &amp;temp);\t\tnum.push_back(temp);\t}\tarr[0] = 1;\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = num[i]; j &lt;= k; j++)\t\t{\t\t\tarr[j] += arr[j - num[i]];\t\t}\t}\tprintf(\"%d\\n\", arr[k]);\treturn 0;}" }, { "title": "합이 최대가 되는 경로 찾기", "url": "/posts/%ED%95%A9%EC%9D%B4-%EC%B5%9C%EB%8C%80%EA%B0%80-%EB%90%98%EB%8A%94-%EA%B2%BD%EB%A1%9C-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2023-02-08 00:00:00 +0900", "snippet": "합이 최대가 되는 경로 찾기dp 문제로 경계면에서 따로 if~else 문으로 처리하지 않고 여유 공간을 확보하고 값을 0으로 채워 식을 간단히 세울 수 있다는 것을 알려준 문제#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;// dp[i + 1][j] 에서 i가 n이더라도 array out of bound index error가 나지 않도록 1002 까지 크기를 확보해준다.int arr[1002][1002] = { 0 };int dp[1002][1002] = { 0 };int main() {\tscanf(\"%d\", &amp;n);\tfor (int i = 1; i &lt;= n; i++)\t{\t\tfor (int j = 1; j &lt;= n; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\tfor (int i = n ; i &gt;= 1; i--)\t{\t\tfor (int j = 1; j &lt;= n; j++)\t\t{\t\t\t// 경계값의 경우 모두 공간이 확보되어있고 0으로 그 값이 초기화 되어 있기 때문에 이렇게 표현해도 문제가 없다.\t\t\tdp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) + arr[i][j];\t\t}\t}\t\t\t\t\t\t\tprintf(\"%d\\n\", dp[1][n]);\t\treturn 0;}" }, { "title": "Embedded C 디자인 패턴", "url": "/posts/Embedded-C-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/", "categories": "C", "tags": "", "date": "2023-01-28 00:00:00 +0900", "snippet": "Embedded C 디자인 패턴Finite State Machine (FSM):This pattern is used to organize code for systems that have a limited number of states and transitions between those states.typedef enum { STATE_A, STATE_B, STATE_C} state_t;state_t current_state = STATE_A;void update_state(state_t new_state) { current_state = new_state;}void state_machine() { switch (current_state) { case STATE_A: // Do something if (condition) { update_state(STATE_B); } break; case STATE_B: // Do something else if (condition) { update_state(STATE_C); } break; case STATE_C: // Do something different if (condition) { update_state(STATE_A); } break; }}Command-Query Separation (CQS):This pattern separates the code that changes the state of a system from the code that reads the state of a system, making the code more readable and maintainablebool is_alarm_enabled = false;void set_alarm(bool enabled) { is_alarm_enabled = enabled;}bool get_alarm() { return is_alarm_enabled;}Singleton프로그램 전체에서 오직 하나의 인스턴스만을 생성하도록 하는 패턴입니다.typedef struct { int value;} singleton_t;singleton_t *singleton_instance = NULL;singleton_t *get_singleton() { if (singleton_instance == NULL) { singleton_instance = (singleton_t *)malloc(sizeof(singleton_t)); } return singleton_instance;}Template Method:알고리즘의 구조를 정의하면서 하위 클래스에서 세부적인 구현을 결정하도록 하는 패턴입니다typedef struct { void (*init)(); void (*run)(); void (*cleanup)();} algorithm_t;void init() { // Do something}void run() { // Do something}void cleanup() { // Do something}algorithm_t algorithm = { init, run, cleanup};Observer:객체 간의 일대다 관계를 정의하여 하나의 객체의 변화를 여러 객체에 알립니다.typedef struct observer_s observer_t;struct observer_s { void (*notify)(observer_t*, int); observer_t* next;};typedef struct subject_s subject_t;struct subject_s { observer_t* head; int value;};void subject_attach(subject_t* s, observer_t* o) { o-&gt;next = s-&gt;head; s-&gt;head = o;}void subject_set_value(subject_t* s, int value) { s-&gt;value = value; observer_t* o = s-&gt;head; while (o) { o-&gt;notify(o, value); o = o-&gt;next; }}Factory Method:객체를 생성하는 공장 클래스를 정의하면서 객체의 생성 과정을 캡슐화하여 인터페이스를 통일시킵니다.typedef struct { void (*print)();} object_t;void print_a() { printf(\"I am object A\\n\");}void print_b() { printf(\"I am object B\\n\");}object_t* create_object(char type) { object_t* object = malloc(sizeof(object_t)); if(type == 'A') { object-&gt;print = print_a; } else { object-&gt;print = print_b; } return object;}" }, { "title": "파이썬 중고급문법", "url": "/posts/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2023-01-03 00:00:00 +0900", "snippet": "알고리즘 정리1차원 배열 구간합 일반적인 생각으로 구간합을 계산할 경우 n^2의 시간복잡도가 나타난다. 이를 위해 sum 값을 구간합만큼 계산하고 슬라이딩 윈도우처럼 한칸씩 움직이며 새롭게 추가되는 값은 +를 빠지는 값은 -를 하여sum 값을 업데이트 하고 max 값과 비교한다. 이를 통해 시간 복잡도를 n까지 줄일 수 있다.#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;\t\t\tint main(){\tint n, k, i, sum=0, result = 0;\tscanf(\"%d %d\", &amp;n, &amp;k);\tvector&lt;int&gt; a(n);\tfor(i=0; i&lt;n; i++){\t\tscanf(\"%d\", &amp;a[i]);\t}\tfor(i = 0; i &lt; k; i++){\t\tsum=sum+a[i];\t}\tres=sum;\tfor(i=k; i&lt;n; i++){\t\tsum=sum+(a[i]-a[i-k]);\t\tif(sum&gt;res) result=sum;\t}\tprintf(\"%d\\n\", result);\treturn 0;}재귀함수의 이해재귀함수와 스택프레임에 대해서 이해하기 위해서 가장 좋은 예시로 이진수 계산을 재귀로 구현하는 방법이 있다.우리가 이진수로의 변환을 위해서 2로 숫자를 계속 나눠주고 나머지를 표시하고 최종적으로 몫이 0이 됐을 때 나머지들을 거꾸로 읽어나간다.이 때 스택의 개념을 사용할 수 있는데, 스택의 경우 LIFO(Last in First out) 방식을 사용하기 때문이다.재귀함수가 호출 되는 시점을 기준으로 이전은 스택에 넣기 전, 스택에 넣기 후로 표현할 수 있다.보통 재귀로 표현하는 경우 이러한 스택의 특징을 활용하는 경우가 많기 때문에 목표하는 동작을 스택에 넣은 후,즉, 재귀함수를 호출하고 동작을 넣는다.#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;\tvoid recur(int x){\tif(x==0) \t\treturn;\telse\t{\t\tprintf(\"%d\", x%2); // 1101 \t\tD(x/2);\t\t// recur(1) 1 = &gt; recur(2) 0 = &gt; recur(5) 1 =&gt; recur(11) 1\t\tprintf(\"%d\", x%2); // 1011 =&gt; 목표하는 동작\t}}\tint main(){\tint n;\tscanf(\"%d\", &amp;n);\trecur(n);\treturn 0;}투 포인터 알고리즘 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘 주로 단순 Brute Force 방식으로 접근 시 시간 초과가 걸리는 경우 투 포인터를 사용하여 메모리와 시간 효율성을 높이는데 쓴다.포인터의 경우 크게 2가지 방식으로 쓴다. 앞에서 시작하는 포인터와 끝에서 시작하는 포인터가 어느 한 지점에서 만나고 종료하는 방식 빠른 포인터가 느린 포인터 보다 앞서는 방식시간 복잡도의 경우 매 루프마다 항상 두 포인터 중 하나는 1씩 증가하고 각 포인터가 n번 누적 증가하면 종료=&gt; O(N)예시문제 : 공통원소 찾기 정렬하여 공통원소를 찾기 용이하도록 한다. 오름차순으로 정렬된 수열을 투 포인터를 사용해서 공통원소를 검색한다. 공통원소를 정답 리스트에 넣고 리턴#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){\tint n, m, i, p1=0, p2=0, p3=0;\tscanf(\"%d\", &amp;n);\t\tvector&lt;int&gt; a(n);\tfor(i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d\", &amp;a[i]);\t}\tsort(a.begin(), a.end());\t\tscanf(\"%d\", &amp;m);\tvector&lt;int&gt; b(m);\tvector&lt;int&gt; c;\tfor(i = 0; i &lt; m; i++)\t{\t\tscanf(\"%d\", &amp;b[i]);\t}\tsort(b.begin(), b.end());\t// 두 벡터 모두 정렬 완료\t// 투포인터 알고리즘\twhile(p1 &lt; n &amp;&amp; p2 &lt; m)\t{\t\t// 공통 원소를 찾았을 때\t\tif(a[p1] == b[p2])\t\t{\t\t\tc.push_back(a[p1++]);\t\t\tp2++;\t\t}\t\t//b의 원소가 더 클 경우 p1 포인터 증가\t\telse if(a[p1] &lt; b[p2])\t\t{\t\t\tp1++;\t\t}\t\t//a의 원소가 더 클 경우 p2 포인터 증가\t\telse \t\t\tp2++;\t}\tfor(i = 0; i &lt; p3; i++)\t{\t\tprintf(\"%d \", c[i]);\t}\treturn 0;}이분 검색(Binary Search) 알고리즘 검색할 범위를 절반씩 줄여가며(mid) 목표값을 찾아가는 검색 방법 정렬 이후 해당 검생 방법을 사용한다.중간 위치(mid)값을 찾을 때는 (시작 위치 + 종료 위치) /2의 결과가 중간 위치 값이 중간 위치의 값을 키 값(찾을 데이터)과 비교하여 같다면 검색 종료, 작다면 왼쪽 데이터를 다시 검사, 크다면 오른쪽 데이터를 다시 검사#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main(){ int n, key, lt=0, rt = 0, mid = 0, tmp = 0; vector&lt;int&gt; a; scanf(\"%d %d\", &amp;n, &amp;key); for(int i = 0; i &lt; n; i++) { scanf(\"%d\", &amp;tmp); a.push_back(tmp); } // 검색에 앞서 정렬 수행 sort(a.begin(), a.end()); rt=n-1; while(lt &lt;= rt) { mid=(lt + rt)/2; // 목표값 탐색 완료한 경우 if(a[mid]==key) { printf(\"%d\\n\", mid+1); break; } // 중간값이 키 값보다 큰 경우 =&gt; 중간 값이 왼쪽으로 한칸 이동하기 위해 rt = mid - 1 else if(a[mid] &gt; key) rt=mid-1; // 중간값이 키 값보다 작은 경우 =&gt; 중간 값이 오른쪽으로 한칸 이동하기 위해 lt = mid + 1 else lt=mid+1; } return 0;}반올림을 하는 하나의 방법반올림을 수행하려는 타겟 값에 0.5를 더하고 그 값을 (int) 를 붙여 int 형으로 명시적 형변환을 수행한다.=&gt; int 형을 취하면 소수점이 버려지는 성질 활용병합정렬, Divde and Conquer분할 정복(divide and conquer) 방법 문제를 작은 2개의 문제로 분리하고 각각을 해결한 다음, 결과를 모아서 원래의 문제를 해결하는 전략 분할 정복 방법은 대개 재귀를 사용하여 구현병합정렬의 단계 분할(Divide): 입력 배열을 같은 크기의 2개의 부분 배열로 분할한다. 정복(Conquer): 부분 배열(소문제)을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 3. 호출 을 이용하여 다시 분할 정복 방법을 적용한다. 결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병한다.#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int a[101], tmp[101];void divide(int lt, int rt){\tint mid;\tint p1, p2, p3;\tif(lt&lt;rt)\t{\t\tmid=(lt+rt) / 2;\t\t// 분할 단계 후위 순회의 개념, 자식 노드 2개 모두 동작 이후 부모 노드의 할일 수행\t\tdivide(lt, mid);\t\tdivide(mid+1, rt);\t\tp1 = lt; \t\tp2 = mid+1;\t\tp3 = lt;\t\t// 정복 단계 : 각 배열의 값을 비교하면서 하나의 배열로 통합 및 정렬 수행\t\twhile(p1 &lt;= mid &amp;&amp; p2 &lt;= rt)\t\t{\t\t\tif(a[p1] &lt; a[p2]) \t\t\t\ttmp[p3++]=a[p1++];\t\t\telse \t\t\t\ttmp[p3++]=a[p2++];\t\t}\t\t// 하나의 배열이 포인트가 끝났을 때, 나머지 배열의 값들은 단순 대입 수행\t\twhile(p1&lt;=mid) \t\t\ttmp[p3++]=a[p1++];\t\twhile(p2&lt;=rt) \t\t\ttmp[p3++]=a[p2++];\t\t// 결합 단계 : 부분 배열들의 정렬이 끝나면 원본에 덮어쓰기 수행\t\tfor(int i=lt; i&lt;=rt; i++)\t\t{\t\t\ta[i]=tmp[i];\t\t}\t}}int main() {\\\tint n, i;\tscanf(\"%d\", &amp;n);\tfor(i=1; i&lt;=n; i++)\t{\t\tscanf(\"%d\", &amp;a[i]);\t}\tdivide(1, n);\tfor(i=1; i&lt;=n; i++)\t{\t\tprintf(\"%d \", a[i]);\t}\treturn 0;}순열, 조합 기초적인 중복 순열 예제 #include &lt;iostream&gt;#include &lt;cstdio&gt;int n, k;int arr[5] = { 0, };void perm(int idx, int cnt){ if (cnt == k) { for (int i = 0; i &lt; k; i++) { printf(\"%d \", arr[i]); } printf(\"\\n\"); return; } for (int i = n; i &gt;= 1; i--) { arr[idx] = i; perm(idx + 1, cnt + 1); } return;}int main() { scanf(\"%d %d\", &amp;n, &amp;k); perm(0, 0); return 0;} 중복되지 않는 순열 코드순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력해해서는 안된다. =&gt; 방문 여부 체크사전 순 증가하는 순서로 출력해야한다. =&gt; 배열 정렬N개의 숫자로 중복되지 않은 순열을 출력하는 문제#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };bool isvisited[10001] = { false, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\t\tif (isvisited[arr[i]] == true)\t\t\tcontinue;\t\telse\t\t\tansarr[cnt] = arr[i];\t\tisvisited[arr[i]] = true;\t\tdfs(cnt + 1);\t\tisvisited[arr[i]] = false;\t}\treturn;}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + (N + 1));\tdfs(0);\treturn 0;}nPr의 순열 구하는 예제#include&lt;cstdio&gt;using namespace std;int n, r, cnt=0;int arr[20], res[20], isvisited[20];void DFS(int L){\tif(L == r)\t{\t\tfor(int j = 0; j &lt; L; j++)\t\t{\t\t\tprintf(\"%d \", res[j]);\t\t}\t\tcnt++;\t\tprintf(\"\\n\");\t}\telse\t{\t\tfor(int i=1; i&lt;=n; i++)\t\t{\t\t\tif(isvisited[i]==0)\t\t\t{\t\t\t\tres[L]=arr[i];\t\t\t\tisvisited[i]=1;\t\t\t\tDFS(L+1);\t\t\t\tisvisited[i]=0;\t\t\t}\t\t}\t}}int main(){\t\tscanf(\"%d %d\", &amp;n, &amp;r);\tfor(int i=1; i&lt;=n; i++){\t\tscanf(\"%d\", &amp;arr[i]);\t}\tDFS(0);\tprintf(\"%d\\n\", cnt);\treturn 0;}cout, cin, scanf, printfc++ 의 표준 입출력 스트림 cout, cin 함수의 경우 scanf, printf 에 비해 느리다.이를 위해ios_base::sync_with_stdio(false);cin..tie(NULL);코드를 추가하여 C와 C++의 표준 stream의 동기화를 끊고 속도를 높인다.이렇게 동기화를 끊게 되면 대신 scanf, printf 함수의 사용이 불가해진다.구조체와 vector를 이용한 정렬구조체 생성자를 사용해서 구조체 임시변수를 하나 선언해 놓고 값을 넣은 후자료구조에 넣어줘야하는 불필요한 작업을 줄인다.#include &lt;iostream&gt;#include &lt;vector&gt;struct loc_t{\tint x, y, z;\tloc_t(int a, b, c)\t{\t\tx = a;\t\ty = b;\t\tz = c;\t}\tbool operator&lt;(const loc_t &amp;b)const\t{\t\tif(x != b.x)\t\t\treturn x &lt; b.x;\t\tif(y != b.y)\t\t\treturn y &lt; b.y;\t\tif(z != b.z)\t\t\treturn z &lt; b.z;\t}}int main(){\tvector&lt;loc_t&gt; xyz;\txyz.push_back(loc_t(1, 2, 3));\txyz.push_back(loc_t(4, 3, 6));\txyz.push_back(loc_t(2, 5, 9));\txyz.push_back(loc_t(5, 2, 1));\tsort(xyz.begin(), xyz.end());}미로탐색 로직(DFS)미로 탐색에서 경로의 가지수를 모두 체크하는 문제의 경우 DFS를 활용한다.isvisited 라는 체크 배열을 활용 및 해제하는 것 잊지 말기#include&lt;cstdio&gt;int map[10][10] = {0,};int isvisited[10][10] = {0,};int dx[4]={1, 0, -1, 0};int dy[4]={0, 1, 0, -1};int cnt=0;void DFS(int x, int y){\t\tif(x==7 &amp;&amp; y==7){\t\tcnt++;\t}\telse{\t\tfor(i=0; i&lt;4; i++){\t\t\tint nx = x + dx[i];\t\t\tint ny = y + dy[i];\t\t\tif(nx &lt; 1 || nx &gt; 7 || ny &lt; 1 || ny &gt; 7)\t\t\t\tcontinue;\t\t\tif(map[nx][ny]==0 &amp;&amp; isvisited[nx][ny]==0){\t\t\t\tisvisited[nx][ny]=1;\t\t\t\tDFS(xx, yy);\t\t\t\tisvisited[nx][ny]=0;\t\t\t}\t\t\t\t}\t}}int main(){\tfreopen(\"input.txt\", \"r\", stdin);\tint i, j;\tfor(i = 1; i&lt; = 7; i++)\t{\t\tfor(j = 1; j&lt; = 7; j++)\t\t{\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t}\t}\tisvisited[1][1]=1;\tDFS(1, 1);\tprintf(\"%d\\n\", cnt);\treturn 0;}미로 탐색에서 최단거리로 이동하는 문제의 경우 DFS를 활용한다.isvisited 라는 체크 배열을 활용 및 해제하는 것 잊지 말기#include&lt;cstdio&gt;using namespace std;int dx[4]={-1, 0, 1, 0};int dy[4]={0, 1, 0, -1};int dis[7][7] = { 0 };int board[7][7] = { 0 };void bfs(int y, int x){\tqueue&lt;pair&lt;int, int&gt; &gt; q;\tq.push(make_pair(0, 0));\t\twhile(!q.empty()) {\t\tint cy = q.front().first;\t\tint cx = q.second().second;\t\tq.pop();\t\tfor(int i = 0; i &lt; 4; i++) \t\t{\t\t\tint ny = cy + dy[i];\t\t\tint nx = cx + dx[i];\t\t\t\t\t\tif(x &gt;= 0 &amp;&amp; x &lt; 7 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 7 &amp;&amp; board[x][y] == 0) \t\t\t{\t\t\t\tq.push(make_pair(x, y));\t\t\t\tboard[ny][nx] = 1;\t\t\t\tdis[ny][nx] = dis[cy][cx] + 1;\t\t\t}\t\t}\t}\t\treturn ;}int main(){\t\tfor(int i=0; i&lt;7; i++) \t{\t\tfor(int j=0; j&lt;7; j++) \t\t{\t\t\tscanf(\"%d\", &amp;board[i][j]);\t\t}\t}\t\tboard[0][0]=1;\tbfs(0, 0);\tif(dis[6][6]==0) \t\tprintf(\"-1\\n\");\t\telse \t\tprintf(\"%d\\n\", dis[6][6]);\treturn 0;}가중치가 있는 최단거리(최소 비용)문제 그래프 DFS(가중치 방향그래프)#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n, cost=87654321;int map[30][30] = { 0 };int isvisited[30] = { 0 }; //vertex 들의 방문여부 체크void DFS(int v, int sum){\t\tif(v==n)\t{\t\t// 최소비용 업데이트\t\tif(sum &lt; cost) \t\t\tcost = sum;\t\treturn;\t}\t\tfor(int i = 1; i &lt;= n; i++)\t{\t\tif(map[v][i] &gt; 0 &amp;&amp; isvisited[i] == 0)\t\t{\t\t\tisvisited[i]=1;\t\t\tDFS(i, sum+map[v][i]);\t\t\t// 방문 여부 초기화\t\t\tisvisited[i]=0;\t\t}\t}\treturn;}int main(){\tint m, i, a, b, c;\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(i=1; i&lt;=m; i++)\t{\t\tscanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);\t\tmap[a][b]=c;\t}\tisvisited[1]=1;\tDFS(1, 0);\tprintf(\"%d\\n\", cost);\t\treturn 0;} 같은 문제의 다른풀이(vector, pair 자료구조 활용)#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n, cost=87654321;vector&lt;pair&lt;int, int&gt; &gt; map[30];int isvisited[30] = { 0 }; //vertex 들의 방문여부 체크void DFS(int v, int sum){\t\tif(v==n)\t{\t\t// 최소비용 업데이트\t\tif(sum &lt; cost) \t\t\tcost = sum;\t\treturn;\t}\t\tfor(i = 0; i &lt; map[v].size(); i++)\t{\t\t\tif(isvisited[map[v][i].first()] == 0)\t\t\t{\t\t\t\tisvisited[map[v][i].first()]=1;\t\t\t\tDFS(map[v][i].first(), sum + isvisited[v][i].second());\t\t\t\tisvisited[map[v][i].first()]=0;\t\t\t}\t\t}\treturn;}int main(){\tint m, i, a, b, c;\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(i=1; i&lt;=m; i++)\t{\t\tscanf(\"%d %d %d\", &amp;a, &amp;b, &amp;c);\t\tmap[a].push_back(make_pair(b, c));// b : 연결정보, c 가중치 값\t}\tisvisited[1]=1;\tDFS(1, 0);\tprintf(\"%d\\n\", cost);\t\treturn 0;}조세퍼스1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 M(≤ N)이 주어진다. 이제 순서대로 M번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, M)-조세퍼스 순열이라고 한다.#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;int main() {\tint N, K;\tqueue&lt;int&gt; q;\tscanf(\"%d %d\", &amp;N, &amp;K);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tq.push(i);\t}\tprintf(\"&lt;\");\tif (q.size() == 1)\t{\t\tprintf(\"1&gt;\");\t\treturn 0;\t}\twhile (!q.empty())\t{\t\tfor (int i = 1; i &lt; K; i++)\t\t{\t\t\tq.push(q.front());\t\t\tq.pop();\t\t}\t\tprintf(\"%d, \", q.front());\t\tq.pop();\t\tif (q.size() == 1)\t\t{\t\t\tprintf(\"%d&gt;\", q.front());\t\t\tbreak;\t\t}\t}\t\treturn 0;}최대 힙 최대 트리(Max Tree)는 각 노드의 키(Key)값이 (자식 노드가 있다면) 그 자식의 키(Key)값보다 작지 않은(=크거나 같은) 트리#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int main(){\tint num;\tpriority_queue&lt;int&gt; pq;\twhile(true)\t{\t\tscanf(\"%d\",&amp;num);\t\tif(num==-1) \t\t\tbreak;\t\tif(num==0)\t\t{\t\t\tif(pq.empty()) \t\t\t\tprintf(\"-1\\n\");\t\t\telse{\t\t\t\tprintf(\"%d\\n\", pq.top());\t\t\t\tpq.pop();\t\t\t}\t\t}\t\telse \t\t\tpq.push(num);\t}\treturn 0;}최소 힙 최소 트리(Min Tree)는 각 노드의 키(Key)값이 (자식 노드가 있다면) 그 자식의 키(Key)값보다 크지 않은(=작거나 같은) 트리최소힙은 C++에서 다음과 같이 만들 수 있다.priority_queue&lt;int, vector, greater&gt; q;혹은 주어진 숫자에 음수를 곱하고 이를 기존 최대 힙에 넣어 최소 힙의 역할을 할 수 있도록 대신하는 방법도 있다.최대 힙, 최소 힙 모두 완전 이진 트리 (Complete Binary Tree)#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int main(){\tint num;\tpriority_queue&lt;int&gt; pq;\t// 혹은 최소힙으로 문제 해결\t//priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;\twhile(true)\t{\t\tscanf(\"%d\",&amp;num);\t\tif(num == -1) \t\t\tbreak;\t\tif(num == 0)\t\t{\t\t\tif(pq.empty()) \t\t\t\tprintf(\"-1\\n\");\t\t\telse\t\t\t{\t\t\t\tprintf(\"%d\\n\", -1 * pq.top());\t\t\t\tpq.pop();\t\t\t}\t\t}\t\telse \t\t\tpq.push(-1 * num);\t}\treturn 0;}동적 계획법(Dynamic Programming)동적 계획법(Dynamic programming)이란 복잡한 문제를 간단한 여러 개의 문제로 나누어 푸는 방법을 말한다.처음 주어진 문제를 더 작은 문제들로 나눈 뒤 각 조각의 답을 계산하고, 이 답들로부터 원래 문제에 대한 답을 계산해낸다는 점에서 분할 정복(Divide &amp; Conquer)과 비슷하지만, 동적 계획법에서는 쪼개진 작은 문제가 중복되지만, 분할 정복은 절대로 중복될 수가 없다는 차이점이 있다.DP 문제의 특성 Overlapping Subproblem (부분 문제가 겹친다.) Optimal Substructure (최적 부분 구조)DP 문제의 풀이방법 2가지1. Top-Down(재귀, 메모이제이션(Memoization))큰 문제를 작은 문제로 나눈다.F(n-1), F(n-2)로 나눈다.작은 문제를 푼다.F(n-1) + F(n-2) 코드로 표현 #include&lt;iostream&gt;using namespace std;int dy[50];int DFS(int n){ if(dy[n] &gt; 0) return dy[n]; if(n==1 || n==2) return n; else // 메모이제이션 기법 사용 return dy[n] = DFS(n-1) + DFS(n-2);}int main(){ ios_base::sync_with_stdio(false); int n; cin &gt;&gt; n; cout &lt;&lt; DFS(n); return 0;} 재귀호출을 하는 방식으로 푼다. 시간 제약이 클 경우 메모이제이션을 사용해서 해결한다. ** 메모이제이션(Memoization) 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장(배열 등)함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술2. Bottom-Up문제를 크기가 작은 문제부터 차례대로 쓴다.문제의 크기를 조금씩 크게 만들면서 문제를 푼다.작은 문제를 풀면서 큰 문제의 답을 구한다.F(n-1) + F(n-2) 코드로 표현 #include&lt;iostream&gt;using namespace std;int dy[50];int main(){ ios_base::sync_with_stdio(false); int n; cin &gt;&gt; n; dy[1] = 1; dy[2] = 2; for(int i=3; i&lt;=n; i++) { dy[i] = dy[i-1] + dy[i-2]; } cout &lt;&lt; dy[n]; return 0;} 주로, 점화식을 세워서 문제 해결 예시 문제2차원 배열의 영역 중 부분 2차원 영역 내 원소 합의 최댓값이 되는 위치의 최댓값 출력하는 문제각 배열 포인트(y, x)에 a[0][0]~a[y][x] 영역의 총합을 저장하는 배열 dy를 선언하고점화식을 새워 문제를 해결한다.dy 배열을 업데이트 하는 점화식dy[i][j] = dy[i-1][j] + dy[i][j-1] - dy[i-1][j-1] + a[i][j];부분 배열의 총합을 구하는 식tmp = dy[i][j] - dy[i-n][j] - dy[i][j-m] + dy[i-n][j-m];#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int a[701][701] = { 0 };int dy[701][701] = { 0 };int main(){\tint h, w, n, m, i, j, tmp, max_num = -8765432;\tscanf(\"%d %d\", &amp;h, &amp;w);\tfor(i = 1; i &lt;= h; i++)\t{\t\tfor(j = 1; j &lt;= w; j++)\t\t{\t\t\tscanf(\"%d\", &amp;a[i][j]);\t\t\tdy[i][j] = dy[i-1][j] + dy[i][j-1] - dy[i-1][j-1] + a[i][j];\t\t}\t}\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(i = n; i &lt;= h; i++)\t{\t\tfor(j = m; j &lt;= w; j++)\t\t{\t\t\t// 중복되서 빠지는 a[0][0]~a[i-n][j-m] 까지의 영역 한번 더해준다.\t\t\ttmp = dy[i][j] - dy[i-n][j] - dy[i][j-m] + dy[i-n][j-m];\t\t\tif(tmp &gt; max_num) \t\t\t\tmax_num=tmp;\t\t\t\t}\t}\tprintf(\"%d\\n\", max_num);\treturn 0;}수식만들기 문제(DFS)#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int a[20], op[5], n, maxi = -8765432, mini = 8765432;void DFS(int L, int res){\tif(L == n)\t{\t\tif(res &gt; maxi) \t\t\tmaxi = res;\t\tif(res &lt; mini) \t\t\tmini = res;\t}\telse\t{\t\tif(op[0] &gt; 0)\t\t{\t\t\top[0]--;\t\t\tDFS(L + 1, res + a[L]);\t\t\top[0]++;\t\t}\t\tif(op[1] &gt; 0)\t\t{\t\t\top[1]--;\t\t\tDFS(L + 1, res - a[L]);\t\t\top[1]++;\t\t}\t\tif(op[2] &gt; 0)\t\t{\t\t\top[2]--;\t\t\tDFS(L + 1, res * a[L]);\t\t\top[2]++;\t\t}\t\tif(op[3] &gt; 0)\t\t{\t\t\top[3]--;\t\t\tDFS(L + 1, res / a[L]);\t\t\top[3]++;\t\t}\t}\treturn ;}\tint main(){\tscanf(\"%d\", &amp;n);\t//숫자 입력\tfor(int i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d\", &amp;a[i]);\t}\t//연산자 가용 횟수 입력(+, - *, /)\tfor(int i = 0; i &lt; 4; i++)\t{\t\tscanf(\"%d\", &amp;op[i]);\t}\tDFS(1, a[0]);\tprintf(\"%d\\n%d\\n\", maxi, mini);\treturn 0;}최대 부분 증가수열(LIS : Longest Increasing Subsequence)원소가 n개인 배열의 일부 원소를 골라내서 만든 부분 수열 중, 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 한다.이 문제의 경우 각 배열의 포인트마다 최대 부분 증가수열의 원소 갯수를 저장하고 이를 활용하여 문제를 해결한다. (DP 문제)#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){\tios_base::sync_with_stdio(false);\tfreopen(\"input.txt\", \"rt\", stdin);\tint n, res=0;\tcin&gt;&gt;n;\tvector&lt;int&gt; arr(n+1), dy(n+1);\tfor(int i=1; i&lt;=n; i++)\t{\t\tcin&gt;&gt;arr[i];\t}\tdy[1]=1;\tfor(int i=2; i&lt;=n; i++)\t{\t\tint max=0;\t\tfor(int j=i-1; j&gt;=1; j--)\t\t{\t\t\t//arr[i] : 탐색하려는 항, arr[j] 는 arr[i] 앞들의 항 \t\t\tif(arr[j] &lt; arr[i] &amp;&amp; dy[j] &gt; max)\t\t\t{\t\t\t\tmax = dy[j];\t\t\t}\t\t}\t\t// 앞의 항 중 최댓값(최대 증가수열)을 찾고 그 값에 +1을 하여 저장한다.\t\tdy[i] = max+1;\t\t//최댓값 탐색\t\tif(dy[i] &gt; res) \t\t\tres=dy[i];\t}\tcout &lt;&lt; res;\treturn 0;}냅색 알고리즘(Knapsack Algorithm)ex)가방에 j 무게 만큼 담을 수 있을 때 보석의 최대 가치를 구하는 문제=&gt; DP로 문제를 해결각 무게의 보석을 넣어가면서 지금 현재 가방 무게별 최대 가치를 업데이트 시켜나간다.보석의 개수가 무한할 경우(1차원 배열로 앞에서 부터 탐색)#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dy[1001] = { 0 };int main(){\tint n, m, w, v;// n: 보석 종류 수, m: 최대 무게, w : 무게, v 가치\tscanf(\"%d %d\", &amp;n, &amp;m);\t\tfor(int i= 0 ; i &lt; n; i++)\t{\t\tscanf(\"%d %d\", &amp;w, &amp;v);\t\tfor(int j = w; j &lt;= m; j++)\t\t{\t\t\tdy[j] = max(dy[j], dy[j-w]+v);\t\t}\t}\tprintf(\"%d\\n\", dy[m]);\treturn 0;}Union &amp; Find 알고리즘Disjoint-Set : 공통 원소가 없는 집합을 말함.여러 노드 중 두 노드를 선택하여 같은 그래프에 속해 있는 지 확인하는 알고리즘.① Find(x) : 원소 𝑥가 속한 부분집합을 찾는다. 보통 𝑥가 속한 부분집합의 대표 원소를 되돌려준다.② Union(x, y) : 원소 𝑥가 속한 부분집합과 원소 𝑦가 속한 부 분집합의 합집합을 구한다. 각 부분집합은 트리로 나타낸다.3) 구현(배열 이용) 미리 해야할 과정노드의 개수 만큼 배열을 선언한다.각 노드의 루트노드를 가르키는 배열을 선언하고, 초기화 한다. (parent배열)주어진 조건에 맞게 각 노드의 parent 배열의 값은 그 노드가 가르키는 노드로 바꿔준다.ⓐ Find : 루트 노드를 찾는 함수이므로 루트에 도달할 때까지 계속 부모노드를 찾아 올라간다.ⓑ Union : 𝑥를 (혹은 𝑦를) 포함하는 부분집합을 나타내는 트리를 다른 것의 부트리로 만들면 된다.#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;int unf[1001];int Find(int v){\tif(v == unf[v]) \t\treturn v;\telse \t\treturn unf[v] = Find(unf[v]);//메모이제이션(경로 압축)}void Union(int a, int b){\ta = Find(a);\tb = Find(b);\tif(a != b) \t\tunf[a] = b;}int main(){\tint i, n, m, a, b, fa, fb, j;\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor(i = 1; i &lt;= n; i++)\t{\t\tunf[i] = i;\t}\tfor(i = 1; i &lt;= m; i++)\t{\t\tscanf(\"%d %d\", &amp;a, &amp;b);\t\tUnion(a, b);\t}\tscanf(\"%d %d\", &amp;a, &amp;b);\tfa = Find(a);\tfb = Find(b);\t// 같은 집합안에 원소인지 확인(루트노드가 같은지)\tif(fa == fb) \t\tprintf(\"YES\\n\");\telse \t\tprintf(\"NO\\n\");\treturn 0;}보석의 개수가 유한할 경우(1차원 배열로 뒤에서부터 탐색)=&gt; 뒤에서부터 탐색할 경우 비교적 무게가 작은 보석을 2번 이상 넣는 경우의 수를 없앨 수 있다.#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int dy[100001] = { 0 };int main(){\tint n, m, w, v;// n: 보석 종류 수, m: 최대 무게, w : 무게, v 가치\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor (int i = 0; i &lt; n; i++)\t{\t\tscanf(\"%d %d\", &amp;w, &amp;v);\t\tfor (int j = m; j &gt;= w; j--)\t\t{\t\t\tdy[j] = max(dy[j], dy[j - w] + v);\t\t\t\t\t}\t}\tprintf(\"%d\\n\", dy[m]);\treturn 0;}플로이드-와샬 알고리즘각 노드의 개수 * 2 크기의 최단거리 테이블을 만들고 모든 경우의 수를 고려하여 최단거리 테이블을 갱신하며 최단거리를 계산합니다.플로이드-와샬 알고리즘의 로직 순서 최단 거리 테이블을 Inf(각 노드의 수 * 거리의 최대값보다 큰 값)로 초기화. 그래프에서 어떠한 정점을 거치지 않고 다른 정점으로 갈 수 있는 경우를 최단 거리 테이블에 입력. 최단거리 테이블에서 자기 자신으로 가는 거리를 0으로 변경. 삼중 for문을 사용하여 각 k번째 노드를 거쳐서 한 정점에서 다른 정점으로 갈 수 있는 모든 경우의 수를 고려하여 최단거리 테이블 갱신. #include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int main(){\tint n, m, a, b, c;\tcin&gt;&gt;n&gt;&gt;m;\tvector&lt;vector&lt;int&gt; &gt; dis(n+1, vector&lt;int&gt;(n+1, 5000));\t\t\tfor(int i=1; i&lt;=m; i++){\t\tcin&gt;&gt; a &gt;&gt; b &gt;&gt; c;\t\tdis[a][b]=c;\t\t}\tfor(int i=1; i&lt;=n; i++) \t{\t\tdis[i][i]=0;\t}\t// i 출발지, k 중간 경유지, j 도착지\tfor(int k=1; k&lt;=n; k++)\t{\t\tfor(int i=1; i&lt;=n; i++)\t\t{\t\t\tfor(int j=1; j&lt;=n; j++)\t\t\t{\t\t\t\tif(dis[i][j] &gt; dis[i][k] + dis[k][j])\t\t\t\t{\t\t\t\t\tdis[i][j] = dis[i][k] + dis[k][j];\t\t\t\t}\t\t\t}\t\t}\t}\tfor(int i=1; i&lt;=n; i++)\t{\t\tfor(int j=1; j&lt;=n; j++)\t\t{\t\t\t//도달할 수 없는 정점의 경우\t\t\tif(dis[i][j] == 5000)\t\t\t{\t\t\t\tcout&lt;&lt;\"M \";\t\t\t}\t\t\telse cout&lt;&lt; dis[i][j] &lt;&lt;\" \";\t\t}\t\tcout&lt;&lt; '\\n';\t}\treturn 0;}" }, { "title": "파이썬 중고급문법", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%A4%91%EA%B3%A0%EA%B8%89%EB%AC%B8%EB%B2%95-%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC/", "categories": "python", "tags": "python", "date": "2023-01-02 00:00:00 +0900", "snippet": "파이썬 중고급문법변수 범위(Variable Scope) 먼저 함수 내 로컬에 변수가 있는지 확인하고 전역 변수를 확인한다.var = 10def func(): global var var = 20 print(var) # 20func() print(var) # 10 로컬에서도 전역 변수를 사용함을 알리기 위해 global을 앞에 붙혀 사용하고 그 값을 재정의, 수정할 수 있다.var = 50def func(): global var var = 60 print(var) # 60func() 함수 내 함수(Closure) 사용시 변수를 내부에 공유할 때 nonlocal 예약어를 사용한다.def outer(): var = 10 def inner(): nonlocal var var += 10 print(var) # 20 return innerin_test = outer() # Closurein_test() # inner 함수 실행 =&gt; nonlocal 부재시 UnboundLocalError 발생in_test() locals() 메서드로 함수 내 지역 변수들을 모두 print 해볼 수 있음 =&gt; 디버깅 시 주로 사용def func(var): x = 10 def printer(): print('Printer func') print('Func Inner', locals()) # 지역변수 x, var 호출func(\"Hi\") # var =&gt; \"HI\" 마찬가지로 globals() 메서드로 파일 내 전역 변수를 확인할 수 있다.var = 10def func(): global var var = 20 print(var) # 20func() print(var) # 10print('Ex7 &gt;', globals()) # 전역 전체 출력globals()['test_variable'] = 100print('Ex7 &gt;', globals())Lambda 함수람다함수의 장점 코드의 간결함 메모리의 절약함수처럼 별도의 메모리가 할당되지 않는다.힙 영역을 사용하여 즉시 소멸한다.파이썬 가비지 컬렉션lambda 함수는 return 키워드 없이 표현식을 자동으로 리턴해준다.lambda 매개변수 : 표현식cal = lambda x, y, z: x + y - zprint(cul(10, 15, 20))map 함수 map(function, iterable)첫 번째 매개변수로는 함수두 번째 매개변수로는 반복 가능한 자료형(리스트, 튜플 등)map 함수의 반환 값은 map객체 이기 때문에 해당 자료형을 list 혹은 tuple로 형 변환시켜주어야 한다.def square(x): return x **2x = [x * 10 for x in range(10)]# result = list(map(square , x))result = list(map(lambda i: i ** 2 , x))Filter 함수 filter(function, iterable)filter 함수를 사용하면 특정 조건에 해당하는 리스트 원소들을 골라내는 역할을 한다.# 짝수만 골라내는 필터함수lst = [i for i in range(1, 11)]result = list(filter(lambda x: x % 2 == 0, lst))def even_func(nums): def is_even(x): return x % 2 == 0 return filter(is_even, nums)lst2 = list(also_evens(digits2))reduce 함수 reduce(function, iterable)파이썬의 functools 내장 모듈의 reduce() 함수는 여러 개의 데이터를 대상으로 주로 누적 집계를 내기 위해서 사용합니다.from functools import reducediglstits3 = [x for x in range(1, 11)]result = reduce(lambda x, y: x + y, lst)def odd_func(nums): def plus(x, y): return x + y return reduce(plus, nums)``` 파이썬의 Shallow Copy, Deep Copyimmutable : int, str, float, bool, unicode..mutable : list…Mutable 한 특성을 가진 자료형의 경우 그 특성 때문에 복사를 하는 경우 원본 배열의 값이 바뀌어 버릴 수 있다.(주소를 공유할 때)Call by Reference(주소값 공유)# coppya_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]b_list = a_listShallow Copy 체를 새로운 객체로 복사하지만 원본 객체의 주소값을 복사하는 것# Shallow copyimport copyc_list = [1, 2, 3, [4, 5, 6], [7, 8, 9]] # 안에 있는 리스트는 여전히 주소를 공유하고 있어 값 변경시 두 리스트 모두 원소값 변경d_list = copy.copy(c_list) Deep Copy 내부에 객체들까지 모두 새롭게 copy 되는 것# Shallow copyimport copye_list = [1, 2, 3, [4, 5, 6], [7, 8, 9]] # 내부요소들까지 전부 새롭게 복사되었기 때문에 어떤 원소의 값을 변경하더라도 원본 값은 그대로 유지f_list = copy.deepcopy(e_list) Context ManagerContext Manager : 원하는 타이밍에 정확하게 리소스를 할당하고 제공, 반환하는 역할=&gt; ex) with 구문file = open('./file.txt', 'w')try: file.write('HELLO WORLD!!')finally: file.close()with 문을 사용하여 종료시 자원 자동 반환with open('./file.txt', 'w') as f: f.write('HELLO WORLD!!')Class 를 사용하여 Exception Handling과 함께 Context Manager를 사용한다.enter, exit 두 메서드를 사용하여 with 구문 처럼 사용할게 할 수 있다.__enter__에 원하는 자원의 할당, 연결 등의 작업을 해 주고, __exit__에서 자원의 제거, 연결 해제 등의 마무리 작업을 설정한다.class MyFileWriter(): def __init__(self, file_name, method): print('MyFileWriter started : __init__') self.file_obj = open(file_name, method) def __enter__(self): print('MyFileWriter started : __enter__') return self.file_obj def __exit__(self, exc_type, value, trace_back): print('MyFileWriter started : __exit__') ## 예외 발생 시 if exc_type: print(\"Logging exception {}\".format((exc_type, value, trace_back))) self.file_obj.close() with MyFileWriter('testfile3.txt', 'w') as f: f.write('Context Manager Test3.\\nContextlib Test3.')Contextlib 예시 실행시간을 측정하는 타이머 context manager 제작time 패키지에 monotonic 메서드는 단조시간을 출력해주는 함수이다.단조시간은 운영체제나 CPU 등과 같은 하드웨어에서 시간을 계산하는 함수이다.실제시간과 다르기 때문에 다른 요인에 의해서 바뀌지 않고 예외가 발생하지 않아 코드 내 시간 측정에 사용할 경우 용이하다.import timeclass ExcuteTimerCls(object): def __init__(self, msg): self._msg = msg def __enter__(self): self._start = time.() return self._start def __exit__(self, exc_type, exc_value, exc_traceback): if exc_type: print(\"Logging exception {}\".format((exc_type, exc_value, exc_traceback))) else: # 예외 발생하지 않을 시 총 실행시간을 출력함 print('{}: {} s'.format(self._msg, time.monotonic() - self._start)) # with 문을 정상적으로 탈출했다는 것을 명시 return True # Truewith ExcuteTimerCls(\"Start! job\") as v: # __enter__의 리턴 값이 v에 해당한다. print('Received start monotonic1 : {}'.format(v)) # 어떠한 작업을 수행 for i in range(10000000): pass # raise Exception(\"Raise! Exception.\") # 강제로 발생# with 문 탈출 시 작업 총 실행시간을 보여준다.Context Manager Annotation에 관해..@contextlib.contextmanager =&gt; Contextlib 데코레이터 사용contextlib 패키지를 사용하여 Annotation을 사용한다.import contextlibimport time@contextlib.contextmanagerdef my_file_writer(file_name, method): f = open(file_name, method) yield f # __enter__ f.close() # __exit__with my_file_writer('file.txt', 'w') as f: f.write('HELLO WORLD') 실행시간을 측정하는 코드에 예외처리와 contextlib annotation을 추가한 예시@contextlib.contextmanagerdef ExcuteTimerDc(msg): start = time.monotonic() try: yield start #__enter__ except BaseException as e: print('Logging exception: {}: {}'.format(msg, e)) raise else: #__exit__ print('{}: {} s'.format(msg, time.monotonic() - start))with ExcuteTimerDc(\"Start! job\") as v: print('Received start monotonic2 : {}'.format(v)) # Excute job. for i in range(10000000):Python UnderscoreUnderscore 를 통해 인터프리터(에서 사용하는 변수), 값 무시, 네이밍 등을 수행할 수 있다.Property프로퍼티(Property) 사용 장점 파이써닉한 코드 변수 제약 설정 Getter, Setter 효과 동등(코드 일관성) 캡슐화-유효성 검사 기능 추가 용이 대체 표현(속성 노출, 내부의 표현 숨기기 가능) 속성의 수명 및 메모리 관리 용이 디버깅 용이 Getter, Setter 작동에 대해 설계된 여러 라이브러리(오픈소스) 상호 운용성 증가 Unpacking*, _ 를 통해 데이터 패킹이나 값 무시 등을 수행할 수 있다.x, _, y = (1, 2, 3)a, *i, b = (1, 2, 3, 4, 5)print('Ex1 &gt;', x, y, a, b, i) # 1 3 1 [2,3,4] 5public, private파이썬에는 공식적인 public, private 지정자는 없다.다만 어느정도 약속된 기호로,name : public_name : protected__name : private와 같이 사용하곤 한다.Getter, Setterproperty를 활용한 getter와 setterclass SampleA: def __init__(self): self.x = 0 self.__y = 0 # private @property def y(self): return self.__y # getter @y.setter def y(self, value): self.__y = value @y.deleter def y(self): del self.__y # 메모리에서 소거a = SampleA()a.x = 1a.y = 2print('Ex1 &gt; x : {}'.format(a.x))print('Ex1 &gt; y : {}'.format(a.y))del a.y # deleter 메서드 호출Method Overriding 서브클래스(자식)에서 슈퍼(부모)클래스를 호출 후 사용 메서드 재 정의 후 사용 가능 부모클래스의 메소드 추상화 후 사용 가능(구조적 접근) 확장 가능, 다형성(다양한 방식으로 동작) 가독성 증가, 오류가능성 감소, 메소드 이름 절약, 유지보수성 증가 등overriding의 다형성에 관한 예제import datetimeclass Logger(object): def log(self, msg): print(msg)class TimestampLogger(Logger): def log(self, msg): message = \"{ts} {msg}\".format(ts=datetime.datetime.now(), msg=msg) # super().log(message) super(TimestampLogger, self).log(message) # 위 주석 코드와 동일하게 동작class DateLogger(Logger): def log(self, msg): message = \"{ts} {msg}\".format(ts=datetime.datetime.now().strftime('%Y-%m-%d'), msg=msg) # super().log(message) super(DateLogger, self).log(message) # 위 주석 코드와 동일하게 동작l = Logger()t = TimestampLogger()d = DateLogger()Method Overloading메소드 오버로딩 효과 동일 메서드 재정의 네이밍으로 기능 예측 코드 절약, 가독성 향상 메소드 파라미터 기반 호출 방식자료형에 따른 메서드 오버로딩 예제class SampleB(): def add(self, datatype, *args): if datatype =='int': return sum(args) if datatype =='str': return ''.join([x for x in args])b = SampleB()# 숫자 연산print('Ex2 &gt; ', b.add('int', 5, 6))# 문자열 연산print('Ex2 &gt; ', b.add('str', 'Hi ', 'Geeks'))multipledispatch 패키지를 통한 메소드 오버로딩from multipledispatch import dispatchclass SampleC(): @dispatch(int,int) def product(x, y): return x * y @dispatch(int,int,int) def product(x, y, z): return x * y * z @dispatch(float,float,float) def product(x, y, z): return x * y * z c = SampleC()# 정수 파라미터 2개print('Ex3 &gt; ', c.product(5, 6))# 정수 파라미터 3개print('Ex3 &gt; ', c.product(5, 6, 7))# 실수 파라미터 3개print('Ex3 &gt; ', c.product(5.0, 6.0, 7.0))Meta Class 클래스를 만드는 역할 -&gt; 의도하는 방향으로 클래스 커스텀 프레임워크 작성 시 필수 동적 생성(type함수), 커스텀 생성(type상속) 커스텀 클래스 -&gt; 검증클래스 등 엄격한 Class 사용 요구, 메소드 오버라이드 요구Class와 Object는 파이썬에서 같은 의미로 받아들일 수 있다.모든 Class의 원형(Meta)은 type 이다.모든 Class의 Metalclass는 type 이다. 메타클래스 동적 생성 방법 중요 동적 생성 한 메타클래스 -&gt; 커스텀 메타클래스 생성 의도하는 방향으로 직접 클래스 생성에 관여 할 수 있는 큰 장점type 동적 클래스 생성 예제받는 인자는 총 3가지 Name(이름), Bases(상속), Dict(속성(Attribute),메서드(Method))s1 = type('sample1', (), {})print('Ex1 &gt; ', s1)print('Ex1 &gt; ', type(s1))print('Ex1 &gt; ', s1.__base__)print('Ex1 &gt; ', s1.__dict__)class SampleEx: attr1 = 30 attr2 = 100 def add(self, m, n): return m + n def mul(self, m, n): return m * nex = SampleEx()print('Ex2 &gt;', ex.attr1)print('Ex2 &gt;', ex.attr2)print('Ex2 &gt;', ex.add(100, 200))print('Ex2 &gt;', ex.mul(100, 20))print()# SampleEx 클래스를 Type 으로 동적 생성s3 = type( 'Sample3', (object, ), # 생략 가능(상속받는 CLass X) {'attr1': 30, 'attr2': 100, 'add': lambda x, y: x + y, 'mul': lambda x, y: x * y} # 람다 함수로 표현 )print('Ex2 &gt;', s3.attr1)print('Ex2 &gt;', s3.attr2)print('Ex2 &gt;', s3.add(100, 200))print('Ex2 &gt;', s3.mul(100, 20))메타클래스 상속 type클래스 상속 metaclass 속성 사용 커스텀 메타 클래스 생성 클래스 생성 가로채기(intercept) 클래스 수정하기(modify) 클래스 개선(기능추가) 수정된 클래스 반환 # 특정 값을 곱하여 리스트를 리턴하는 메서드def cus_mul(self, d): for i in range(len(self)): self[i] = self[i] * d# 리스트 값을 교체하는 역할을 하는 메서드def cus_replace(self, old, new): while old in self: self[self.index(old)] = new # list를 상속받음, 메소드 2개 추가CustomList1 = type( 'CustomList1', (list, ), { 'desc': '커스텀 리스트1', 'cus_mul': cus_mul, 'cus_replace': cus_replace } ) c1 = CustomList1([1, 2, 3, 4, 5, 6, 7, 8, 9])c1.cus_mul(1000)c1.cus_replace(1000, 7777)print('Ex1 &gt; ', c1) print('Ex1 &gt; ', c1.desc) Type을 상속받는 커스텀 메타클래스 생성 예제class MetaClassName(type):def __new__(metacls, name, bases, namespace): ....def cus_mul(self, d): for i in range(len(self)): self[i] = self[i] * d# 리스트 값을 교체하는 역할을 하는 메서드def cus_replace(self, old, new): while old in self: self[self.index(old)] = new# new -&gt; init -&gt; call 순서class CustomListMeta(type): # 생성된 인스턴스 초기화 def __init__(self, object_or_name, bases, dict): print('__init__ -&gt; ', self, object_or_name, bases, dict) super().__init__(object_or_name, bases, dict) # 인스턴스 실행 def __call__(self, *args, **kwargs): print('__call__ -&gt; ', self, args, kwargs) return super().__call__(*args, **kwargs) # 클래스 인스턴스 생성(메모리 초기화) def __new__(metacls, name, bases, namespace): print('__new__ -&gt; ', metacls, name, bases, namespace) namespace['desc'] = '커스텀 리스트2' namespace['cus_mul'] = cus_mul namespace['cus_replace'] = cus_replace return type.__new__(metacls, name, bases, namespace)CustomList2 = CustomListMeta( 'CustomList2', (list, ), {} )c2 = CustomList2([1, 2, 3, 4, 5, 6, 7, 8, 9])c2.cus_mul(1000)c2.cus_replace(1000, 7777)print('Ex2 &gt; ', c2)print('Ex2 &gt; ', c2.desc)# 상속 확인print(CustomList2.__mro__)Descripter(디스크립터)디스크립터(descriptor)를 간단하게 한 줄로 요약하면, get, set 또는 delete 스페셜 메소드 중 한개 이상 구현 되어 있는 객체 객체에서 서로다른 객체를 속성값으로 가지는 것. Read, Write, Delete 등을 미리 정의 가능 data descriptor(set, del), non-data descriptor(get) 읽기 전용 객체 생성 장점, 클래스를 의도하는 방향으로 생성 가능)디스크립터 기본 예제 디스크립터는 스태틱 필드(static field)로 만든 경우만 동작한다 =&gt; Descriptor instance 디스크립터는 객체를 통한 접근과 클래스 이름을 통한 접근 모두를 허용한다instance vs static 인스턴스 필드(instance field) : 객체 별로 “따로” 보관되는 데이터 =&gt; 인스턴스 변수 스태틱 필드(static field) : 모든 객체가 “공유”하는 데이터 =&gt; 클래스 변수class DescriptorEx1(object): def __init__(self, name = 'Default'): self.name = name def __get__(self, obj, objtype): return \"Get method called. -&gt; self : {}, obj : {}, objtype : {}, name : {}\".format(self, obj, objtype, self.name) def __set__(self, obj, name): print('Set method called.') if isinstance(name, str): self.name = name else: raise TypeError(\"Name should be string\") def __delete__(self, obj): print('Delete method called.') self.name = Noneclass Sample1(object): # Descriptor instance name = DescriptorEx1() s1 = Sample1() # __set__ 호출 s1.name = \"Descriptor Test1\"# 예외 발생# s1.name = 7# attr 확인# __get__ 호출print('Ex1 &gt; ', s1.name)# __delete__ 호출del s1.name# 재확인# __get__ 호출print('Ex1 &gt; ', s1.name)print()print()디스크립털르 활용한 응용 예제class LoggedScoreAccess: def __init__(self, value=60): self.value = value def __get__(self, obj, objtype=None): logging.info('Accessing %r giving %r', 'score', self.value) return self.value def __set__(self, obj, value): logging.info('Updating %r to %r', 'score', self.value) self.value = valueclass Student: # Descriptor instance score = LoggedScoreAccess() def __init__(self, name): # Regular instance attribute self.name = name s1 = Student('Kim')s2 = Student('Lee')# 점수 확인(s1)print('Ex2 &gt; ', s1.score)s1.score += 10print('Ex2 &gt; ', s1.score)# 점수 확인(s2)print('Ex2 &gt; ', s2.score)s2.score += 20print('Ex2 &gt; ', s2.score)# __dict__ 확인print('Ex2 &gt; ', vars(s1))print('Ex2 &gt; ', vars(s2))print('Ex2 &gt; ', s1.__dict__)print('Ex2 &gt; ', s2.__dict__)" }, { "title": "소수의 개수", "url": "/posts/%EC%86%8C%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98(%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98-%EC%B2%B4)/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-21 00:00:00 +0900", "snippet": "소수의 개수에라토스테네스의 체 알고리즘으로 소수를 찾는 방법타겟 숫자의 제곱근 값까지의 배수들을 지워 소수들을 탐색하는 알고리즘#include&lt;stdio.h&gt;\t\t\tint main(){\tfreopen(\"input.txt\", \"rt\", stdin);\tint n, i, j, flag, cnt=0;\tscanf(\"%d\", &amp;n);\tfor(i = 2; i &lt;= n; i++){\t\tflag = 1;\t\tfor(j=2; j * j &lt;= i; j++){\t\t\tif(i % j ==0){\t\t\t\tflag=0;\t\t\t\tbreak;\t\t\t}\t\t}\t\tif(flag == 1) cnt++;\t}\tprintf(\"%d\\n\", cnt);\treturn 0;}" }, { "title": "FreeRTOS 내용정리", "url": "/posts/FreeRTOS-%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/", "categories": "Embedded Engineering, RTOS", "tags": "Embedded Engineering, RTOS", "date": "2022-12-20 00:00:00 +0900", "snippet": "FreeRTOS 내용정리Task 태스크는 가상의 CPU를 각자 가지고 있는 것처럼 동작한다.(Time Division) 태스크 간에는 커널 서비스인 Inter Process Communication 방법을 사용하여 통신한다.Round Robin 스케쥴링 모든 태스크들이 CPU 자원을 공평하게 나누어 사용하는 개념 각 태스크가 점유하는 시간을 타임 퀀텀이라고 하고 그 시간은 대락 1ms~20ms 사이이다. 비 선점형 스케쥴링을 필요로 할 때 사용한다.Priority 스케쥴링 태스크를 중요도에 의해 가중치를 두어 우선적으로 실행 할 수 있도록 하는 개념 RTOS 에서 피룻적으로 지원하는 스케쥴링 방법 선점형 스케쥴링의 특성을 가짐Blocking I/O, Non blocking I/OBlocking I/O 태스크가 시스템콜을 호출했어도 점유한 데이터가 즉시 가용되지 않더라도 그 동작이 완료될 때 까지 suspending 상태를 유지한 것을 말함.Non blocking I/O 태스크가 시스템콜을 호출했어도 점유한 데이터가 즉시 가용되지 않을 땐 리턴하는 것이 특징 Blocking 과는 다르게 프로세스가 쉬고있지 않음.RTOS 정의 및 특징RTOS 는 임베디드 시스템 전용 운영체제이자 실시간 멀티태스킹 지원을 위한 운영체제이다.RTOS 특징은 크게 다음과 같다. Hard Realtime Scalability Preemptive(선점형) Multitasking Deterministic(예측가능) Portability RobustnessReal-Time 시스템정해진 시간 내에 임무를 수행하는 시스템Soft RealTime System 가능한 빠르게 임무를 수행하는게 목표이고, 정해진 시간 내에 수행할 필요는 없음(Timeout 발생해도 계속 실행)Hard RealTime System 어떤 사건이 발생했을 때 정확하게 동작하는 것은 물론이고, 정해진 시간 내에 수행해야함(Timeout 발생 시 fail)RTOS 종류FreeRTOS, Green Hills, VxWorks, Window Embedded, Texas InstrumentsFreeRTOS 특징 Portable(이식성 좋음) ROMable(설정이나 응용프로그램에 따라 메모리의 크기를 바꿀 수 있음) 선점형 스케쥴링 Round-Robin 지원 Real-Time 기반으로 빠른 응답성을 가짐 Multitasking MIT LicenseCMSISCortex Microcontroller Software Interface Standard의 약자.즉 다양한 칩 벤더가 Cortex 시리즈의 IP를 라이센스해가면서 하드웨어 독립적인 표준화된 소프트웨어 인터페이스가 필요하게 된다. 스펙은 ARM에 사용자 등록을 하면 받을 수 있다. CMSIS는 CMSIS-CORE, CMSIS-Driver, CMSIS-DSP, CMSIS-RTOS API, CMSIS-Pack, CMSIS-SVD, CMSIS-DAP 로 구성된다.CMSIS 소프트웨어 인터페이스는 소프트웨어 재사용을 단순화하고 MCU 개발자의 학습 곡선을 줄여 개발 속도를 단축 시킨다.CMSIS 는 프로세서 및 주변 장치, 실시간 운영 체제 및 미들웨어 구성 요소에 대한 인터페이스를 제공한다. CMSIS 에는 장치, 보드 및 소프트웨어에 대한 전달 메카니즘이 포함되어 있고, 여러 타 사 업체의 소프트웨어 구성요소와 결합이 가능하다.포팅(Porting)이식(移植) 또는 포팅(porting)은 컴퓨터 과학에서 실행 가능한 프로그램이 원래 설계된 바와 다른 컴퓨팅 환경(이를테면 CPU, 운영 체제, 서드 파티 라이브러리 등)에서 동작할 수 있도록 하는 과정을 가리킨다. 이 용어는 소프트웨어나 하드웨어가 다른 환경에서 사용할 수 있게 변경되는 것에도 해당한다. 소스 하나로 여러 플랫폼에서 사용할 수 있는 것을 크로스 플랫폼으로 부른다.태스크 함수 구성 요소태스크 함수의 경우 태스크 함수, 함수의 이름, 스택 항목의 개수, 태스크 전달 파라미터, 우선순위, 핸들러 등으로 구성된다.그리고 태스크 스택의 경우 heap 영역이나 .bss 영역에 저장된다.그리고 태스크의 우선순위를 매길 때 보통 높은 숫자가 높은 우선순위를 나타내기 때문에,낮은 우선순위에는 명확한 낮은 숫자를, 높은 우선 순위에는 명확히 높은 숫자를 사용하여 한 눈에 구분이 가게하는 것이 좋다.그리고 Task의 경우TaskMain() Task1() Task2() Task3()와 같은 함수를 가지고 있다.TaskCreate() 함수태스크 객체를 만들어주는 함수로 태스크 스택 항목의 개수 우선순위, 전달 파라미터 등을 설정한다.TaskDelete() 함수태스크 객체를 없애주는 역할을 하는 함수TaskSuspend() 함수해당 태스크 핸들러를 매개변수로 받아 태스크를 blocked 상태로 진입하게 만든다.vTaskPrioritySet(), vTaskResume()각각 태스크 우선순위를 재설정하는 함수와, 그 태스크를 변경된 우선순위에 맞춰 다시 실행시키는 함수를 가리킨다.TaskDelay() 함수1초 만큼 task가 잠시 blocked 상태에 가있다가 다시 ready=&gt;running 상태로 진입잠시 blocked 상태로 이동하고 다른 태스크가 running 상태에 진입하기 때문에 문맥 전환(Context Switch) 가 발생한다.runnig task 가 아예 비어있는 것을 막기 위해 우선순위가 가장 낮은 idle task 를 만들고 비어있을 경우 idle task가 running 상태로 진입TaskDelay 함수를 통해 각 태스크가 할당받을 시간을 정해 놓고 번갈아가며 task가 running 상태에 진입할 수 있도록하여 멀티태스킹을 구현한다.IdleTask() 함수우선순위 0인 최하위 우선순위 함수TaskStartScheduler() 함수에서 생성되고 삭제할 수 없다.CPU 저전력 모드 처럼 별다른 동작을 하지 않는 함수우선순위와 실행시간의 관계우선순위가 높다고 그 task가 자주, 오래 실행되는 것이 아니다. =&gt; 휴면을 적게 할수록 오래 실행한다.즉 우선순위가 높고 그 task가 휴면을 적게 한다면 자주, 오래 실행할 것이다.printf(), fflush() 함수printf() 함수의 경우 문자열 버퍼가 있고 그 버퍼가 꽉 채워져야 버퍼를 배출한다.fflush(stdout) 함수의 경우 문자열 버퍼를 배출하고 버퍼를 비운다.==&gt; fflush(stdout) 의 경우 UART 를 통해 HW 동작을 야기하고 화면 상에 출력하기 때문에 동작이 상대적으로 느리다.attribute우리가 함수를 선언할 때 부여하는 속서을 말한다. 이 attribute 다음에는 쌍괄호로 싸여진 속성인자가 따라온다.attribute((weak)) func(void); , void func(void) attribute((weak));같이 weak 함수를 선언해서 컴파일 시 같은 이름의 심볼이 있을 경우 weak 속성의 심볼을 제거하고 weak가 아닌 것을 사용하는 것을 말한다.__attribute__를 이용할 시에는 최대한 헤더파일에서 정의하지 않을 것을 추천weak 심볼들의 경우 상황에 따라 꺼낼 수 있는 함수들의 default implementation 을 제공할 때 사용된다.태스크 스택 메모리(task stack memory)태스크 스택 메모리에는 정적, 동적 메모리 영역을 사용할 수 있다.태스크 스택의 경우 태스크에서 호출하는 함수의 중복 호출 횟수, 함수에서 사용되는 모든 지역변수의 크기 등에 의해 결정된다.이 중 동적메모리 사용은 메모리 단편화(Memory Fragmentation)을 야기할 수 있다.메모리 단편화(Memory Fragmentation)기억 장치의 빈 공간이나 데이터가 여러 개로 쪼개지는 현상을 말한다. 이 이유로, 요청한 메모리의 크기가 가용한 메모리의 크기보다 작은데도 불구하고 메모리 할당에 실패할 수 있는 문제를 낳는다.메모리 단편화를 피하기 위해서 가급적 큰 크기로 메모리를 할당하고, 부팅하자마자 main.c 극 초반에서 메모리를 할당하는 방법으로 메모리 단편화를 최소화한다.스택 오버플로우(Stack Overflow)FreeRTOS의 경우 Stack Overflow 검사를 위한 파라미터 옵션이 존재한다. =&gt; 이 옵션 역시 모든 것을 커버하지는 못함( 그 이유로는 문맥 전환(Context change) 중에 오버플로우를 검사하는 방식으로 이외 시간에 발생하는 스택 오버플로우는 찾지 못 한다.)스택 오버플로우 검사의 경우 스택 메모리 마지막 영역 지점에 특정 패턴 값을 초기에 채워 놓고 그 값이 오염되어있는지 여부에 대해 확인하는 방법으로 검사를 수행한다.=&gt; 다소 느림또는 스택 포인터가 유효한 범위를 벗어난 스택 공간 내에 있는 것이 실시간으로 확인될 경우 hook 함수를 호출하여 검출하는 방식도 있다.=&gt; 문맥 전환시에만 검사TCB(Task Control Block)Task에 관련된 모든 정보가 저장되어있는 블록(구조체)동시성 문제(Concurrent Entrancy) 공유자원이 있다.(공유하는 변수나, 함수) 비원자적인 연산(읽기 =&gt; 수정 =&gt; 쓰기)특정 함수나 변수를 서로 다른 태스크에서 동시에 호출될 때 의도치 않은 결과가 나타나는 문제이러한 임계 영역을 보호하기 위해 장치를 마련한다. 인터럽트 중단 스케쥴링 중단 세마포어임계 영역(Critical Section)공유자원이 사용 중인 함수 내 일부 혹은 전체 영역재진입(Reentrancy)멀티태스킹 환경에서 함수들은 재진입이 가능하도록 가급적 HW 자원, 전역 변수 사용 등의 행위를 하지 않아야 한다.멀티태스킹 환경이지만 단일 태스크만이 독점하여 사용할 것으로 확신하는 경우에는 해당 함수가 재진입이 아니어도 무방하다.함수가 재진입 가능하도록 하는 조건(상호 배제 방법(Mutual Exclusion)) 전역 변수 사용 X 세마포어 같은(세마포어, 뮤텍스) 커널 리소스로 전역변수 보호 전역변수 사용 동안 인터럽트 작동 임시 중지크리티컬 섹션(Critical Section)크리티컬 섹션에서는 임시적으로 인터럽트를 비활성화하여 보호한다.이러한 인터럽트 비활성화 시간은 RTOS 시스템에서 이벤트의 응답시간을 결정하므로 중요한 성능 지표가 된다.이 인터럽트 비활성화는 응용프로그램에서도 사용할 수 있으나 freeRTOS 서비스 호출 시에는 인터럽트는 꼭 활성화가 되어있어야한다.FreeRTOS 우선 순위taskENTER_CRITICAL =&gt; 일반 인터럽트(Tick, IRQ) =&gt; 높은 우선순위 =&gt; 낮은 우선순위(EX. IDLE Task)태스크 문맥전환(Context Switch)문맥(Context)는 모든 CPU의 레지스터를 말한다.문맥 전환은 선점된 태스크의 모든 레지스터 값을 스택에 저장하고, 전에 저장했던 레지스터 값을 CPU로 복구하여 새로운 태스크를 실행하는 것을 말한다.코루틴(Coroutine)코루틴은 RAM 제약이 심한 프로세서에서만 사용하고 32비트 MCU의 경우 잘 사용하지 않는다.우선순위가 IDLE TASK와 같이 가장 낮은 우선순위를 가진다.특징은 스택메모리를 가지고 있지 않고 IDLE TASK의 스택 메모리를 공유한다. =&gt; 메모리 효율성 증대대신 스택메모리를 공유하기 때문에 코루틴 내부 지역 변수 값이 의도치 않게 변경될 수 있음 =&gt; static으로 선언하여 .bss 영역에 잡히도록 수정시스템 성능 최적화 기법 속도를 느리게만드는 전역 변수 선언량, 그리고 이를 사용하는 빈도 수를 태스크에서 줄인다. 시간 소요가 많은 인터럽트 루틴은 IPC를 활용하여 태스크에서 그 일을 수행하도록 한다. 빈번이 호출되는 함수는 인라인 어셈블리 등을 활용한다 TICK 시간이 지켜지는지 확인한다.FreeRTOS에서의 우선순위 배정 해당 태스크의 중요도에 따른 우선순위 배정이 아닌 일의 마감시간(or 응답시간)을 철저히 준수할 수 있도록 우선순위를 배정해야한다. 처음 그 기능(태스크)의 구현단계부터 마감시간을 염두해두고 설계를 진행해야한다.세마포어(Semaphore) 임계구역을 보호하는 가장 안전한 방법 중 하나 세마포어는 P(잠금), V(잠금 해제), 초기화 이 세가지에 의해서만 접근이 가능한 일종의 protect 변수 개념세마포의 2가지 기능1, 상호 배제(임계구역 보호) IPC(이벤트 전달)FREE RTOS에서의 세마포어 함수 초기화 함수 : vSemaPhoreCreateBinary(), xSemaPhoreCreateBinary() P연산 함수 : xSemaPhoreTake() V연산 함수 : xSemaPhoreGive()태스크 간 통신(IPC) 전역변수를 사용한 통신 방법 =&gt; 임계 영역에 따른 의도치 않은 동작 발생 가능 메시지 전송 =&gt; 메시지 메일박스(이벤트 플래그, 세마포어), 큐우선순위역전(Priority Inversion)높은 우선순위의 태스크가 낮은 우선순위 태스크가 끝날때까지 기다리는 현상뮤텍스(MUTEX : Mutual Exclusion Semaphore) 태스크가 자원에 대한 독점적인 액세스를 얻고자 할 때 사용한다. 일종의 바이너리 세마포어이다. 우선순위 역전현상을 해결할 때 사용한다." }, { "title": "시저 암호", "url": "/posts/%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-18 00:00:00 +0900", "snippet": "시저 암호#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string solution(string s, int n) { string answer = \"\"; for(int i = 0; i &lt; s.length(); i++) { // 소문자인 경우 if(s[i] &gt;= 'a' &amp;&amp; s[i] &lt;= 'z') { // 시저 암호가 경계를 넘어갈 경우에 대한 계산 if(s[i] + n &gt; 'z') { answer += 'a' + (s[i] + n - 'z' - 1); } else { answer += s[i] + n; } } // 대문자인 경우 else if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z') { // 시저 암호가 경계를 넘어갈 경우에 대한 계산 if(s[i] + n &gt; 'Z') { answer += 'A' + (s[i] + n - 'Z' - 1); } else { answer += s[i] + n; } } // 공백인 경우 else { answer += s[i]; } } return answer;}" }, { "title": "명예의 전당 (1)", "url": "/posts/%EB%AA%85%EC%98%88%EC%9D%98-%EC%A0%84%EB%8B%B9-(1)/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-18 00:00:00 +0900", "snippet": "명예의 전당 (1)내림차순으로 정렬하여 명예의 전당 목록의 개수 k를 초과하는 경우 pop_back 하여 최하위 점수를 졸업시키는 방식으로 문제를 해결한다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;vector&lt;int&gt; solution(int k, vector&lt;int&gt; score) { vector&lt;int&gt; answer; vector&lt;int&gt; temp_score; for(int i = 0; i &lt; score.size(); i++) { temp_score.push_back(score[i]); sort(temp_score.begin(), temp_score.end(), greater&lt;int&gt;()); if(temp_score.size() &gt; k) { temp_score.pop_back(); } int temp_idx = (temp_score.size() - 1) &lt; 0 ? 0 : temp_score.size() - 1; cout &lt;&lt; temp_idx &lt;&lt; endl; answer.push_back(temp_score[temp_idx]); } return answer;}" }, { "title": "연속 부분 수열 합의 개수", "url": "/posts/%EC%97%B0%EC%86%8D-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-%ED%95%A9%EC%9D%98-%EA%B0%9C%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-16 00:00:00 +0900", "snippet": "연속 부분 수열 합의 개수중복된 값을 저장하지 않는 set 컨테이너를 사용하여 문제를 풀이한다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int solution(vector&lt;int&gt; elements) { set&lt;int&gt; s; int len = elements.size(); int answer = 0; for (int i = 0 ; i &lt; len ; ++i) { int temp_sum = 0; for (int j = i ; j &lt; i + len ; ++j) { // temp_sum 값을 쌓아가면서 자연스럽게 길이가 1~lrn 까지인 연속 부분 수열을 계산할 수 있다. temp_sum += elements[j % len]; s.insert(temp_sum); } } answer = s.size(); return answer;}" }, { "title": "햄버거 만들기", "url": "/posts/%ED%96%84%EB%B2%84%EA%B1%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-15 00:00:00 +0900", "snippet": "햄버거 만들기1231의 조합을 뒤에서부터 찾고 찾은 경우 pop 하는 문제=&gt; stack의 개념처럼 생각하고 인덱스 접근이 용이한 vector로 문제 해결#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; ingredient) { // 1 빵 2 야채 3 고기 1231 int answer = 0; vector&lt;int&gt; burger; for(int i = 0; i &lt; ingredient.size(); i++) { burger.push_back(ingredient[i]); if(burger.size() &gt;= 4) { int burger_size = burger.size(); if(burger[burger_size - 1] == 1 &amp;&amp; burger[burger_size - 2] == 3 &amp;&amp; burger[burger_size - 3] == 2 &amp;&amp; burger[burger_size - 4] == 1) { for(int i = 0; i &lt; 4; i++) { burger.pop_back(); } answer++; } } } return answer;}" }, { "title": "기사단원의 무기", "url": "/posts/%EA%B8%B0%EC%82%AC%EB%8B%A8%EC%9B%90%EC%9D%98-%EB%AC%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-13 00:00:00 +0900", "snippet": "기사단원의 무기기본적으로 약수를 구하는 문제로 약수를 구하면서 시간초과를 피하기 위해 해당 숫자의 제곱근까지만 탐색하고 대신 약수가 제곱근 값이 아닌 경우 +2, 약수가 제곱근인 경우 +1 만 해주는 방식으로 약수를 구한다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int solution(int number, int limit, int power) { // number 기사단원 수 limit 공격력의 제한수치, 제한 수치를 초과한 기사가 사용할 무기 공격력 power int answer = 0, ori_power = 0; vector&lt;int&gt; v; //j는 타겟 숫자 1~number까지 순회 for(int j = 1; j &lt;= number; j++) { // j를 1~ j의 제곱근까지 돌면서 약수의 개수를 구한다. // i 제곱의 숫자가 j인 경우에만 +1을 나머지의 경우 다른 숫자를 짝으로 가지므로 +2를 해준다. ori_power = 0; for(int i = 1; i &lt;= sqrt(j); i++) { if(j % i == 0) { ori_power += 2; if(i * i == j) { ori_power--; } } } v.push_back(ori_power); } // 제한수치를 초과하는 무기 공격력을 가진 기사의 경우 주어진 무기 공격력 power값으로 대체 for(int i = 0; i &lt; v.size(); i++) { if(limit &lt; v[i]) { answer += power; } else { answer += v[i]; } } return answer;}" }, { "title": "삼총사", "url": "/posts/%EB%93%B1%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-11 00:00:00 +0900", "snippet": "등수 구하기#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main(){\t\tvector&lt;int&gt; v;\tint N, new_score, P, answer = 0, number, tmp_save_num = 0;\tscanf(\"%d %d %d\", &amp;N, &amp;new_score, &amp;P);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;number);\t\tv.push_back(number);\t}\tfor (int i = 0; i &lt; v.size(); i++)\t{\t\tif (new_score &lt;= v[i])\t\t{\t\t\tif (new_score == v[i])\t\t\t\ttmp_save_num++;\t\t\tanswer++;\t\t}\t\tif (answer &gt;= P)\t\t{\t\t\tanswer = -1; /* 3 1 3 1 1 1 위 반례를 해결하기 위해 추가 answer 가 -1로 확정 난 경우 tmp_save_num 값은 초기화 시켜줘야 뒤에서 추가로 빼주는 오류를 범하지 않는다. */\t\t\ttmp_save_num = 0;\t\t\tbreak;\t\t}\t}\tif (tmp_save_num != 0)\t{\t\tanswer -= tmp_save_num;\t}\t\t\tif (answer != -1)\t{\t\tanswer++;\t}\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "삼총사", "url": "/posts/%EC%82%BC%EC%B4%9D%EC%82%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-10 00:00:00 +0900", "snippet": "삼총사단순 브루트 포스 문제#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;int&gt; number) { int answer = 0; for(int i = 0; i &lt; number.size(); i++) { for(int j = i + 1; j &lt; number.size(); j++) { for(int k = j + 1; k &lt; number.size(); k++) { if(number[i] + number[j] + number[k] == 0) { answer++; } } } } return answer;}" }, { "title": "과일 장수", "url": "/posts/%EA%B3%BC%EC%9D%BC-%EC%9E%A5%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-10 00:00:00 +0900", "snippet": "과일 장수#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(int k, int m, vector&lt;int&gt; score) { int answer = 0; sort(score.begin(), score.end(), greater&lt;int&gt;()); for(int i = 0; i &lt; score.size(); i++) { if(i % m == m - 1) { answer += score[i] * m; } } return answer;}" }, { "title": "콜라 문제", "url": "/posts/%EC%BD%9C%EB%9D%BC%EB%AC%B8%EC%A0%9C/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-09 00:00:00 +0900", "snippet": "콜라 문제#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(int a, int b, int n) { int answer = 0, rem = 0, quot = 0; while(n &gt;= a) { rem = n % a; quot = n / a; answer += (quot* b); n = (quot * b) + rem; } return answer;}" }, { "title": "창고 다각형", "url": "/posts/%EC%B0%BD%EA%B3%A0-%EB%8B%A4%EA%B0%81%ED%98%95/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-09 00:00:00 +0900", "snippet": "창고 다각형가장 높은 지점(지붕 높이가 되는 기둥 위치)를 주변으로 각각 왼쪽 끝, 오른쪽 끝 부터 탐색하면서 각각의 기둥 최대 높이를 면적에 더해가면 최종적으로최소 면적을 가진 다각형 창고가 완성된다.#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;/*지붕은 수평 부분과 수직 부분으로 구성되며, 모두 연결되어야 한다.지붕의 수평 부분은 반드시 어떤 기둥의 윗면과 닿아야 한다.지붕의 수직 부분은 반드시 어떤 기둥의 옆면과 닿아야 한다.지붕의 가장자리는 땅에 닿아야 한다.비가 올 때 물이 고이지 않도록 지붕의 어떤 부분도 오목하게 들어간 부분이 없어야 한다.*/int main(){\tint N, L, H;\tint arr[1001] {0,};\tint max_h = 0, max_l = 0, search_max_l = 0, search_max_r = 0, min_area = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d %d\", &amp;L, &amp;H);\t\tarr[L] = H;\t\tif (max_h &lt; H)\t\t{\t\t\tmax_h = H;\t\t\tmax_l = L;\t\t}\t}\tfor (int i = 1; i &lt; max_l; i++)\t{\t\tsearch_max_l = max(search_max_l, arr[i]);\t\tmin_area += search_max_l;\t}\tfor (int i = 1000; i &gt;= max_l; i--)\t{\t\tsearch_max_r = max(search_max_r, arr[i]);\t\tmin_area += search_max_r;\t}\tprintf(\"%d\\n\", min_area);\treturn 0;}" }, { "title": "신입사원 교육", "url": "/posts/PCCP-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC-2-%EC%8B%A0%EC%9E%85%EC%82%AC%EC%9B%90-%EA%B5%90%EC%9C%A1/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-12-06 00:00:00 +0900", "snippet": "신입사원 교육단순 sort 방식으로는 시간 초과 발생#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;int&gt; ability, int number) { int answer = 0, min_sum = 0; for(int i = 0; i &lt; number; i++) { sort(ability.begin(), ability.end()); min_sum = ability[0] + ability[1]; ability[0] = min_sum; ability[1] = min_sum; } for(int i = 0; i &lt; ability.size(); i++) { answer += ability[i]; } return answer;}우선순위 큐로 최소힙 구현 후 문제 해결최대힙(max heap) 은priority_queue&lt; int, vector&lt;int&gt;, less&lt;int&gt; &gt; pQ;// ORpriority_queue&lt;int&gt; pQ;최소합(min heap) 은priority_queue&lt; int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pQ;우선순위 큐 관련 함수#include &lt;iostream&gt;#include &lt;queue&gt;use namespace std;int main(void) {\t// 우선순위큐 선언 - 최대 힙 \tpriotriy_queue&lt;자료형&gt; 변수명; \t// 연산자 오버로딩을 통해 원하는 우선순위대로 정렬한 힙 priority_queue&lt;int,container,비교함수&gt; 변수명; \t//push(element) //pop() //top() //empty() //size() //우선순위큐 비교함수 - 최소힙 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; 변수명 ;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int solution(vector&lt;int&gt; ability, int number) { priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq; int answer = 0, min_sum = 0; for(int i = 0; i &lt; ability.size(); i++) { pq.push(ability[i]); } for(int i = 0; i &lt; number; i++) { int a, b; a = pq.top(); pq.pop(); b = pq.top(); pq.pop(); min_sum = a + b; pq.push(min_sum); pq.push(min_sum); } while(!pq.empty()) { answer += pq.top(); pq.pop(); } return answer;}" }, { "title": "실습용 로봇", "url": "/posts/PCCP-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC-2-%EC%8B%A4%EC%8A%B5%EC%9A%A9-%EB%A1%9C%EB%B4%87/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-11-28 00:00:00 +0900", "snippet": "실습용 로봇#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// 상 우 하 좌int dy[4]= {1, 0, -1, 0};int dx[4] = {0, 1, 0, -1};vector&lt;int&gt; solution(string command) { vector&lt;int&gt; answer; int cx = 0, cy = 0, dir = 0; for(int i = 0; i &lt; command.length(); i++) { if(command[i] == 'R') { dir = (dir + 1) % 4; } else if(command[i] == 'L') { dir -= 1; if(dir == -1) dir = 3; } else if(command[i] == 'B') { cx += dx[(dir + 2) % 4]; cy += dy[(dir + 2) % 4]; } else { cx += dx[dir]; cy += dy[dir]; } } answer.push_back(cx); answer.push_back(cy); return answer;}" }, { "title": "RTOS 강의 정리", "url": "/posts/RTOS_%EA%B0%95%EC%9D%98-%EC%A0%95%EB%A6%AC/", "categories": "embedded-engineering", "tags": "embedded-engineering", "date": "2022-11-27 00:00:00 +0900", "snippet": "RTOS 강의 정리RTOS(Real Time Operating System)RTOS 는 실시간 응용 프로그램을 위해 개발된 운영체제이다.신뢰성이 필수적인 환경에서 임베디드 소프트웨어에 주로 많이 사용한다.일반적인 RTOS 커널 바이너리 이미지 크기는 4K~9KBytes 정도이다.RTOS 중요점 6가지 하드리얼타임을 구현하는 법 인터럽트를 안정적, 효율적으로 운용하는 법 잦은 상호배제로 인한 시스템 성능 저하를 극복하는 법 태스크 우선순위 결정을 확실하게 하는 법 내가 만든 태스크가 실시간으로 동작하는지 테스트하기 포팅 노하우멀티 태스킹이란?커널 API(메인 태스크에 존재)에 태스크 함수를 할당하여 필요할 때 특정 태스크를 실행시키는 것즉 메인 태스크는 계속 돌아가면서 서브 태스크 함수가 호출되어 실행되어 멀티로 돌아가게 되는 것을 멀티 태스킹이라고 한다." }, { "title": "책 리뷰(파이썬 클린 코드)", "url": "/posts/Book_Review(%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%81%B4%EB%A6%B0-%EC%BD%94%EB%93%9C)/", "categories": "Book Review", "tags": "Book Review", "date": "2022-11-26 00:00:00 +0900", "snippet": "책 리뷰(파이썬 클린 코드)파이썬의 코딩 스타일PEP-8의 특징검색 효율성코드에서 토큰을 grep 할 수 있는 기능. 즉, 특정 파일이나 파일의 일부에서 특정 문자열을 찾는 기능일관성코드가 일정한 포맷을 가져 가독성을 높인다.코드 품질코드를 구조화 하여 살펴보면 한 눈에 코드를 이해하고 버그와 실수를 쉽게 찾을 수 있다.docstring주석을 다는 것이 아닌 코드의 특정 컴포넌트에 대한 문서화를 말한다. 파이썬의 경우 동적 타이핑을 하기 때문에 타입 등의 정의를 미리 docstring 을 통해 표현해두면 실수를 줄일 수 있다.annotation기본 아이디어는 코드 사용에게 함수 인자로 어떤 값이 와야 하는지 힌트를 주는 것annotation 을 사용하게 되면 annotations 라는 특수한 속성이 생긴다. 이 속성을 통해 어노테이션 이름과 값을 매핑한 사전 타입의 값을 확인할 수 있다.class Hello: def world(self, num : int) -&gt; int: return numPythonic Code인덱스와 슬라이스numbers = [1, 2, 3, 4, 5, 6, 7]numbers[-1]numbers[2:5] # 3, 4, 5numbers[:3] # 4, 5, 6, 7numbers[::] # 1, 2, 3, 4, 5, 6, 7numbers[1:7:2] # 2 4 6" }, { "title": "파이썬 객체지향 프로그래밍", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/", "categories": "python", "tags": "python", "date": "2022-11-09 00:00:00 +0900", "snippet": "파이썬 객체지향 프로그래밍데코레이터 패턴 기본데코레이터 패턴 테코레이터 패턴은 함수의 객체와 함수를 변경하는 다른 객체를 Wrapping 해준다. 즉, 기존의 함수를 꾸며주는 역할을 한다. 데코레이터 패턴에서 데코레이터에 인자를 넘길 수 있다 # decorator# wrapping을 수행할 함수def copyright(func): def new_func(): print(\"@ amamovsdfjkldjsakfljdskaljfkdsla\") func() return new_func@copyrightdef smile(): print(\"🙃\")@copyrightdef angry(): print(\"🤯\")@copyrightdef love(): print(\"🥰\")# smile = copyright(smile) # 함수 재정의# angry = copyright(angry) # 함수 재정의# love = copyright(love) # 함수 재정의smile()angry()객체 지향 프로그래밍(Object Oriented Programming, OOP) 프로그램을 실제 세상에 가깝게 모델링하는 기법 데이터를 추상화시켜 속성과 행위를 가진 객체로 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법 클래스 (class) 특별한 데이터와 메서드의 집합 설계도라고 할 수 있다. 객체 (object) class에 선언된 모양 그대로 생성된 실체인스턴스 (instance) 객체가 소프트웨어에 실체화될 때 즉, 메모리에 할당되어 사용될 때 해당 객체를 인스턴스라고 한다. 객체는 인스턴스의 상위 개념이지만, 일반적으로 인스턴스와 같은 의미로 사용된다. 하나의 클래스로 만들어진 여러 인스턴스들은 각각 독립적이다. OOP 원칙캡슐화 : encapsulation객체(object)의 속성과 행위(methods)를 하나로 묶고, 구현된 일부를 외부에 감추어 은닉한다.추상화 : abstraction불필요한 정보는 숨기고 중요한(필요한) 정보만을 표현함으로써 공통의 속성이나 행위(methods)를 하나로 묶어 이름을 붙이는 것이다.상속 : Inheritance부모 class의 속성과 행위(methods)을 그대로 상속 받고 행위(methods)의 일부분을 수정해야 할 경우 상속받은 자식 class에서 해당 행위(methods)만 다시 수정하여 사용할 수 있도록 한다. 또한 자식 class에서 추가적으로 속성이나 행위(methods)를 정의할 수 있게 한다.다형성 : Polymorphism여러 형태를 가질 수 있도록 한다. 즉, 객체를 부품화할 수 있도록 한다.A 공장에서 만든 타이어를 YSS 자동차 회사에서 사용할 수 있고 YYR 자동차 회사에서도 사용할 수 있다.또한, 이 타이어는 탱크의 타이어 개발에 재료로 사용될 수도 있다.# * 객체(object)의 **속성과 행위(methods)**를 하나로 묶고, 구현된 일부를 외부에 감추어 은닉한다.# ** 사칙연산 계산기class Cal: # 생성자 : 메모리에 올라오는 순간 즉시 실행됨 def __init__(self, a, b): self.a = a self.b = b def add(self, a, b): return self.a + self.b def sub(self, a, b): return self.a - self.b def mul(self, a, b): return self.a * self.b def div(self, a, b): return self.a / self.b# 클래스 하나로 선언된 각기 다른 인스턴스들은 모두 각각 독립적이다.cal1 = Cal(1, 2)print(cal1.add())init 강의에서 등장한 init 메서드는 생성자 함수라고 하며 인스턴스가 만들어질 때 인스턴스를 초기화 init 메서드는 특별한 기능이 있는 매직 메서드중 하나이며 함수 이름을 다른 이름으로 바꿀 수 없음 attribute 인스턴스에는 데이터(속성값)와 메서드(속성메서드)로 이루어지는 클래스 attribute가 있다. 메서드는 함수인데, 그 첫 번째 파라미터는 호출된 인스턴스 자신(self) attribute는 점(.) 뒤에 나오는 모든 이름입니다. 인스턴스.attribute, 인스턴스.attribute() 클래스 인스턴스 생성이란 함수 표기법 (my_func( ))을 사용하여 초기 상태의 객체를 생성하는 것 Cal라는 클래스가 있다고 가정합시다. Cal( )을 호출하여 인스턴스를 생성하는데 이때 Cal( )을 생성자라고 한다. 이 생성자를 호출하면 Cal.new( )라는 매직 메서드가 호출되어 인스턴스가 할당되고 그 다음 Cal.init( ) 메서드가 인스턴스를 초기화한다.추상화(abstraction)불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 공통의 속성 값이나 메서드들을 하나로 묶어 이름을 붙이는 것class Robot: # 클래스 변수 : 인스턴스들이 공유하는 변수 population = 0 # 생성자 함수 def __init__(self, name, code): self.name = name # 인스턴스 변수 self.code = code # 인스턴스 변수 Robot.population += 1 # 인스턴스 메서드 def say_hi(self): # code print(f\"Greetings, my masters call me {self.name}.\") # 인스턴스 메서드 def cal_add(self, a, b): return a + b # 인스턴스 메서드 def die(self): print(f\"{self.name} is being destroyed!\") Robot.population -= 1 if Robot.population == 0: print(f\"{self.name} was the last one.\") else: print(f\"There are still {Robot.population} robots working.\") # 클래스 메서드 데코레이터 # cls는 class를 받는다. @classmethod def how_many(cls): print(f\"We have {cls.population} robots.\")print(Robot.population) # 0siri = Robot(\"siri\", 21039788127)print(Robot.population) # 1jarvis = Robot(\"jarvis\", 2311213123)print(Robot.population) # 2bixby = Robot(\"bixby\", 124312423)print(Robot.population) # 3bixby2 = Robot(\"bixby2\", 124312423)bixby23 = Robot(\"bixby2\", 124312423)print(siri.name)print(siri.code)jarvis.say_hi()siri.say_hi()siri.cal_add(2, 3)# 클래스 메서드 가져온다.Robot.how_many()추상화 관련 수업 노트 자료먼저, 추상화의 사전적 정의는 구체적 표상이나 개념에서 공통된 성질을 뽑아 이를 일반적인 개념으로 파악하는 정신 작업입니다.즉, 추상화는 공통된 것들을 하나로 묶어 일반화하는 사고 과정입니다.추상화 작업을 통해 얻는 이점은 공통된 현실 문제에 있어서 일반적인 솔루션을 만듦으로써 새로운 현실 문제가 발생했을 때 쉽게 해결할 수 있습니다.저희 예제에서 사람들에게 편의를 제공하는 음성 인공지능 서비스인 시리, 자비스, 빅스비가 있었습니다.이 음성 로봇들은 공통된 기능이 있어서 Robot이라는 class를 통해 일반화(추상화) 작업을 하고 만들어진 Robot class(설계도) 통해 새롭게 음성 로봇인 시리, 자비스, 빅스비 로봇을 만들었었죠.만약 추가적으로 새롭게 시리, 자비스, 빅스비와 공통된 기능을 수행하는 프로그램인 “드로이드”를 제작한다고 합시다.이 경우 만들어진 Robot class를 통해 인스턴스로 찍어내기만 하면 빠르고 쉽게 새로운 드로이드 프로그램을 만들 수 있습니다.만약 추상화(일반화) 사고 과정을 통해 Robot이라는 class를 만들지 않았다면 다시 처음부터 “안녕이라고 했을 때 이를 컴퓨터가 알아들을 수 있도록 컴퓨터 언어로 바꾸고 인공지능 기술을 사용하여 이에 반응하는 기능인 say_hi”, “덧셈 기능을 수행하는 cal_add” 등 기능을 다시 만들어야 합니다.이는 메모리 낭비, 인건 낭비, 유지보수의 어려움 등의 문제로 이어지게 되겠죠.이제 다른 관점에서 생각해본다면, 시리, 자비스, 빅스비 로봇을 만든 회사에서 Robot class 안에 존재하는 “say_hi”, “add_cal” 기능을 다른 회사에 판다고 생각한다면 Robot class 가 적힌 스크립트 파일을 그대로 판매하면 됩니다.만일 추상화(일반화) 과정으로 Robot class를 만들지 않았다면 해당하는 기능을 다시 따로 만들어 판매해야 합니다. 다시 따로 만들다가 기다리던 회사는 다른 회사와 계약해 버리면 슬픈 상황이겠죠.실무에서는 동일한 결로 적용됩니다.관련 예시예를들어 딥러닝 알고리즘을 개발하는 엔지니어가 VGG16 모델(프로그램)과 ResNet 모델(프로그램)의 성능을 비교하는 프로그램을 짠다고 합시다.동일한 데이터 셋과 환경에서 VGG 모델과 ResNet 모델의 성능 차이를 비교한다고 했을 때 각각 모델(프로그램)에 대하여 “데이터 셋 로드”, “데이터 전처리”, “손실함수 적용” 등 동일한 환경에서 동일한 기능이 수행됩니다. 이 경우에 동일한 기능을 하는 Machine이라는 class를 만들고 이 class를 상속을 받아 각 모델에 해당하는 특별한 기능(비교 대조할 기능)을 다시 재정의하게 되면 처음부터 하나하나 동일한 코드를 작성해서 코딩하는 것이 아니라 재사용되는 공통된 로직 위에서 특별히 비교할 기능을 구현해서 사용하면 가독성도 좋고 안전하게 실험이 가능합니다.네임스페이스(namespace)namespace : 개체를 구분할 수 있는 범위클래스 메서드 역시 인스턴스를 통해 접근이 가능하다.원리는 파이썬의 동작 원리 중 “인스턴스의 namespace에 없다면 자동적으로 class namespace로 접근한다” 라는 내용이 있기 때문\"\"\"#* namespace : 개체를 구분할 수 있는 범위#* __dict__ : 네임스페이스를 확인할 수 있다.#* dir() : 네임스페이스의 key 값을 확인할 수 있다.#* __doc__ : class의 주석을 확인한다.#* __class__ : 어떤 클래스로 만들어진 인스턴스인지 확인할 수 있다.\"\"\"class Robot: # class 에 대한 정보를 확인하는 주석으로 __doc__ 을 통해 확인이 가능하다. \"\"\" [Robot Class] Author : 윤상석 Role : ???? \"\"\" # 클래스 변수 : 인스턴스들이 공유하는 변수 population = 0 # 생성자 함수 def __init__(self, name): self.name = name # 인스턴스 변수 Robot.population += 1 # 인스턴스 메서드 def say_hi(self): # code print(f\"Greetings, my masters call me {self.name}.\") # 인스턴스 메서드 def cal_add(self, a, b): return a + b # 인스턴스 메서드 def die(self): print(f\"{self.name} is being destroyed!\") Robot.population -= 1 if Robot.population == 0: print(f\"{self.name} was the last one.\") else: print(f\"There are still {Robot.population} robots working.\") # 클래스 메서드 @classmethod def how_many(cls): print(f\"We have {cls.population} robots.\")siri = Robot(\"siri\") # {'name': 'siri'}jarvis = Robot(\"jarvis\")bixby = Robot(\"bixby\")print(Robot.__dict__)print(siri.__dict__)print(jarvis.__dict__)print(siri.name) # 인스턴스의 namespace에 없다면 자동적으로 class namespace로 접근한다.print(bixby.name)siri.cal_add(2, 3)print(siri.population) # 인스턴스의 namespace에 없다면 자동적으로 class namespace로 접근한다.siri.how_many()Robot.say_hi(siri)siri.say_hi()print(dir(siri))print(dir(Robot))print(Robot.__doc__)print(siri.__class__) # __main__.Robot@classmethod 이해@classmethod 데코레이터를 사용해서 클래스에 메서드를 선언하면 해당 메서드는 클래스(class) 메서드가 되며, 첫번째 매개 변수로 클래스 인스턴스가 아닌 클래스 자체가 넘어오게 된다.첫번째 매개 변수의 이름은 보통 관행적으로 cls라고 하며, 클래스 메서드는 이 cls를 통해 클래스 속성(attribute)에 접근하거나, 클래스 메서드를 호출할 수 있다. 하지만, 인스턴스 메서드와 달리 인스턴스 속성에 접근하거나 다른 인스턴스 메서드를 호출하는 것은 불가능합니다.파이썬에서는 생성자 오버로딩(overloading)을 지원하기 때문에, 클래스 메서드는 특히 팩토리 메서드를 작성할 때 유용하게 사용됩니다.@staticmethod 이해클래스에서 바로 메서드에 대한 호출이 가능해진다.이러한 정적 메서드는 인스턴스 속성, 인스턴스 메서드가 필요 없을 때 사용한다.class Calc: @staticmethod def add(a, b): print(a + b) @staticmethod def mul(a, b): print(a * b) Calc.add(10, 20) # 클래스에서 바로 메서드 호출Calc.mul(10, 20) # 클래스에서 바로 메서드 호출self,cls 에 대한 이해self는 인스턴스 그자체를 말한다.cls 의 경우 해당하는 class 그 자체를 가리킨다.# [self의 이해]# ** self는 인스턴스 객체이다!!# ** 클래스 안에 있는 self의 주소와 만들어진 인스턴스의 주소는 같다! 즉, self는 인스턴스 그 자체이다!class SelfTest: # 클래스 변수 name = \"amamov\" def __init__(self, x): self.x = x # 인스턴스 변수 # 클래스 메서드 @classmethod def func1(cls): print(f\"cls: {cls}\") print(\"func1\") # 인스턴스 메서드 def func2(self): print(f\"self : {self}\") print(\"class안의 Slef 주소 : \", id(self)) print(\"func2\")test_obj = SelfTest(17)test_obj.func2()SelfTest.func1()# SelfTest.func2()# print(SelfTest.x)print(\"인스턴스의 주소: \", id(test_obj))\"\"\"self : &lt;__main__.SelfTest object at 0x7f845f70c310&gt;class안의 Self 주소 : 140206513636112func2cls: &lt;class '__main__.SelfTest'&gt;func1인스턴스의 주소: 140206513636112\"\"\"test_obj.func1()print(test_obj.name)매직 메소드(magic method)init 우리가 보통 생성자라고 부르는 메소드입니다. new 메소드로 인해 객체가 생성되고 나면 호출됩니다. 데이터를 초기화 하는등의 목적으로 사용합니다.del 객체가 소멸될 때 호출됩니다.str, repr 객체의 문자열 표현을 위해 사용됩니다. 자세한 내용은 이전 포스팅을 참조해 주세요.call함수를 호출하는 것처럼 클래스의 객체도 호출하게 만들어주는 메서드class Robot: \"\"\" [Robot Class] Date : ??:??:?? Author : Amaco \"\"\" def __init__(self, name): self.name = name Robot.population += 1 def die(self): print(f\"{self.name} is being destroyed!\") Robot.population -= 1 if Robot.population == 0: print(f\"{self.name} was the last one.\") else: print(f\"There are still {Robot.population} robots working.\") def say_hi(self): print(f\"Greetings, my masters call me {self.name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.population} robots.\" @staticmethod def are_you_robot(): print(\"yes!!\") # 메소드 오버라이딩 def __str__(self): return f\"{self.name} robot!!\" def __call__(self): print(\"call!\") return f\"{self.name} call!!\"droid1 = Robot(\"R2-D2\")droid1.say_hi()print(dir(droid1))print(droid1) # &lt;__main__.Robot object at 0x7fde1c742110&gt; -&gt; R2-D2 robot!!droid1() # __call__ 이라는 매직 메서드를 사용하면 인스턴스도 호출이 가능해지고 __call__ 함수가 호출된다.상속(inheritance) 부모 클래스가 갖는 모든 메서드와 속성이 자식 클래스에 그대로 상속된다. 자식 클래스에서 별도의 메서드나 속성을 추가할 수 있다. 메서드 오버라이딩(Overridding =&gt; 부모 클래스의 메서드를 자식 메서드에서 다시 재정의하는 것) super() Python의 모든 클래스는 object 클레스를 상속한다. : 모든 것은 객체이다.MyClass.mro() –&gt; 상속 관계를 보여준다.```python“”” [클래스 상속] 부모 클래스가 갖는 모든 메서드와 속성이 자식 클래스에 그대로 상속된다. 자식 클래스에서 별도의 메서드나 속성을 추가할 수 있다. 메서드 오버라이딩 super() Python의 모든 클래스는 object 클레스를 상속한다. : 모든 것은 객체이다. MyClass.mro() –&gt; 상속 관계를 보여준다.“”” class Robot:\"\"\"[Robot Class]Date : ??:??:??Author : Amaco\"\"\"population = 0def __init__(self, name): self.name = name Robot.population += 1def die(self): print(f\"{self.name} is being destroyed!\") Robot.population -= 1 if Robot.population == 0: print(f\"{self.name} was the last one.\") else: print(f\"There are still {Robot.population} robots working.\")def say_hi(self): print(f\"Greetings, my masters call me {self.name}.\")def cal_add(self, a, b): return a + b@classmethoddef how_many(cls): return f\"We have {cls.population} robots.\" # class variable을 원활하게 사용하기 위해 class method 사용@staticmethoddef are_you_robot(): print(\"yes!!\")def __str__(self): return f\"{self.name} robot!!\"def __call__(self): print(\"call!\") return f\"{self.name} call!!\"class Siri(Robot): def call_me(self): print(“네?”)def cal_mul(self, a, b): self.a = a return a * b@classmethoddef hello_apple(cls): print(f\"{cls} hello apple!!\")siri = Siri(“iphone8”) # 부모의 argument는 상속받은 자식 인스턴스에도 필요siri.call_me()print(siri.cal_mul(7, 8))print(siri.a)Siri.hello_apple()메서드 오버라이딩의 예시```pythonclass Robot: \"\"\" [Robot Class] Date : ??:??:?? Author : Amaco \"\"\" population = 0 def __init__(self, name): self.name = name Robot.population += 1 def die(self): print(f\"{self.name} is being destroyed!\") Robot.population -= 1 if Robot.population == 0: print(f\"{self.name} was the last one.\") else: print(f\"There are still {Robot.population} robots working.\") def say_hi(self): print(f\"Greetings, my masters call me {self.name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.population} robots.\" @staticmethod def are_you_robot(): print(f\"{Robot.population} num!\") print(\"yes!!\") def __str__(self): return f\"{self.name} robot!!\" def __call__(self): print(\"call!\") return f\"{self.name} call!!\"class Siri(Robot): def __init__(self, name, age): self.name = name self.age = age Siri.population += 1 def call_me(self): print(\"네?\") def cal_mul(self, a, b): self.a = a return a * b @classmethod def hello_apple(cls): print(f\"{cls} hello apple!!\") # 메서드 오버라이딩 def say_hi(self): print(f\"Greetings, my masters call me {self.name}. by apple.\") # 클래스 메서드 오버라이딩 @classmethod def how_many(cls): return f\"We have {cls.population} robots. by apple\"siri = Siri(\"iphone8\", 17)siri.say_hi()print(Siri.how_many())super 명령어는 이런 상속 관계에서 상속의 대상인 부모 클래스를 호출하는 함수class Robot: \"\"\" [Robot Class] Date : ??:??:?? Author : Amaco \"\"\" population = 0 def __init__(self, name): self.name = name Robot.population += 1 def die(self): print(f\"{self.name} is being destroyed!\") Robot.population -= 1 if Robot.population == 0: print(f\"{self.name} was the last one.\") else: print(f\"There are still {Robot.population} robots working.\") def say_hi(self): print(f\"Greetings, my masters call me {self.name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.population} robots.\" @staticmethod def are_you_robot(): print(f\"{Robot.population} num!\") print(\"yes!!\") def __str__(self): return f\"{self.name} robot!!\" def __call__(self): print(\"call!\") return f\"{self.name} call!!\"class Siri(Robot): def __init__(self, name, age): super().__init__(name) # 부모 클래스의 __init__을 호출 self.age = age def call_me(self): print(\"네?\") def cal_mul(self, a, b): return a * b def cal_flexable(self, a, b): super().say_hi() # 부모 클래스의 say_hi 메서드 호출, 결과 : Greetings, my masters call me iphone8. self.say_hi() # Greetings, my masters call me iphone8. by apple. return self.cal_mul(a, b) + self.cal_add(a, b) + super().cal_add(a, b) # 메서드 오버라이딩을 하지 않았기 때문에 self.cal_add 메서드와 super().cal_add 메서드는 서로 같다 @classmethod def hello_apple(cls): print(f\"{cls} hello apple!!\") def say_hi(self): print(f\"Greetings, my masters call me {self.name}. by apple.\") @classmethod def how_many(cls): return f\"We have {cls.population} robots. by apple\"siri = Siri(\"iphone8\", 17)print(siri.age)print(siri.name)siri.say_hi()print(Siri.how_many())print(siri.cal_flexable(1, 3))다형성(Polymorphism)하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미한다.부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현한다.다형성에는 오버로딩(Overloading : 같은 이름을 가진 메서드나 생성자를 다양하게 정의하는 것), 오버라이딩(Overriding : 상위 클래스의 메서드를 하위 클래스에서 재정의하는 것)\"\"\"#* polymorphism#* 여러 형태를 가질 수 있도록 한다. 즉, 객체를 부품화할 수 있도록 한다.#* 같은 형태의 코드가 다른 동작을 하도록 하는 것\"\"\"class Robot: \"\"\" Robot Class \"\"\" __population = 0 def __init__(self, name, age): self.__name = name self.__age = age Robot.__population += 1 @property def name(self): return f\"yoon {self.__name}\" @property def age(self): return self.__age @age.setter def age(self, new_age): if new_age - self.__age == 1: self.__age = new_age else: raise ValueError() def __say_hi(self): print(f\"Greetings, my masters call me {self.__name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.__population} robots.\"class Siri(Robot): def say_apple(self): print(\"hello my apple\")class SiriKo(Robot): def say_apple(self): print(\"안녕하세요\")class Bixby(Robot): def say_samsung(self): print(\"안녕하세요ㅕ\")컴포지션(composition)컴포지션이란, 상속과 다르게 단순히 사용한다는 개념이다. 즉, 기존의 상속 개념에서의 자식클래스가 부모클래스의 모든 속성을 물려받는게 아니라, 자식클래스가 필요한 속성만 부모클래스로부터 가져와 사용하는 것이다.일반적으로 상속은 암시적 선언이라고 하며, 컴포지션은 명시적 선언이라고 한다.\"\"\"#* composition#* 다른 클래스의 일부 메서드를 사용하고 싶지만, 상속은 하고 싶지 않을 경우#* 1. 부모 클래스가 변하면 자식 클래스는 계속 수정되어야 한다.#* 2. 부모 클래스의 메서드를 오버라이딩 하는 경우 내부 구현 방식의 얕은 이해로 오류가 생길 가능성 증가\"\"\"class Robot: \"\"\" Robot Class \"\"\" __population = 0 def __init__(self, name, age): self.__name = name self.__age = age Robot.__population += 1 @property def name(self): return f\"yoon {self.__name}\" @property def age(self): return self.__age @age.setter def age(self, new_age): if new_age - self.__age == 1: self.__age = new_age else: raise ValueError() def __say_hi(self): self.cal_add(1, 3) print(f\"Greetings, my masters call me {self.__name}.\") def cal_add(self, a, b): return a + b + 1 @classmethod def how_many(cls): return f\"We have {cls.__population} robots.\"class Siri(Robot): def say_apple(self): print(\"hello my apple\")class SiriKo(Robot): def say_apple(self): print(\"안녕 사과\")class Bixby(Robot): def say_sanmgsung(self): print(\"hello my sangsung\")class BixbyKo(Robot): def say_samsung(self): print(\"안녕 삼성\")# 컴포지션의 예# 필요한 메서드를 가져와 사용한다.class BixbyCal: def __init__(self, name, age): self.Robot = Robot(name, age) def cal_add(self, a, b): return self.Robot.cal_add(a, b)파이썬의 모든 것은 객체(Instance) mro() 메서드는 상속의 관계를 보여주는 메서드이다. int, str 등 파이썬에서 사용하는 변환 메서드 역시 실제로는 클래스이다. 파이썬의 경우 다중 상속도 가능하다.class Robot(object): \"\"\" Robot Class \"\"\" population = 0 def __init__(self, name): self.name = name Robot.population += 1 def say_hi(self): print(f\"Greetings, my masters call me {self.name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.population} robots.\"class Siri(Robot): def call_me(self): print(\"네?\") def cal_mul(self, a, b): return a * bsiri = Siri(\"iphone8\")print(Siri.mro()) # * [&lt;class '__main__.Siri'&gt;, &lt;class '__main__.Robot'&gt;, &lt;class 'object'&gt;]print(Robot.mro()) # * [&lt;class '__main__.Robot'&gt;, &lt;class 'object'&gt;]print(object)print(dir(object))print(object.__name__)print(int.mro())print(int.__init__(8.9))print(int(8.9))class A: passclass B: passclass C: pass# 다중 상속class D(A, B, C): passprint(D.mro())캡슐화(Encapsulation)객체(object)의 속성과 행위(method)를 하나로 묶고, 구현된 일부를 감추어 은닉한다.private vs public변수나 메서드 앞에 __를 붙이면 private 특성(외부에서 접근을 금지하는 특성)으로 변한다.상속을 한 경우에도 마찬가지고 __를 붙인 경우 접근이 불가능해지고 오버라이딩은 가능하다.파이썬에서는 protect 변수는 없지만 변수나 메소드 앞에 _ 하나 붙여서 protect 기능을 하도록 약속하고 사용하는 경우도 있다.class Robot: \"\"\" Robot Class \"\"\" __population = 0 def __init__(self, name, age): self.name = name self.__age = age Robot.population += 1 def __say_hi(self): print(f\"Greetings, my masters call me {self.name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.population} robots.\"class Siri(Robot): def __init__(self, name, age): super().__init__(name, age) self._age = 999 # 상속이 되는 것이 아닌 다시 재정의 됨(Overriding) print(self.name) print(self._age)ss = Robot(\"yss\", 8)ss.age = -999 # Error 발생ssss = Siri(\"iphone8\", 9)print(ssss._age)@property, getter와 setterproperty 데코레이터와 getter와 setter 를 사용하여 간접적으로 private 변수를 get하거나 set하는 방법이 있다.인스턴스 변수 값을 사용해서 적절한 값으로 보내고 싶을 때인스턴스 변수 값에 대한 유효성 검사 및 수정class Robot: \"\"\" Robot Class \"\"\" __population = 0 def __init__(self, name, age): self.__name = name self.__age = age Robot.__population += 1 @property def name(self): return f\"yoon {self.__name}\" @property def age(self): return self.__age # setter에서 값이 설정될 때 특정 조건을 추가시켜 특정 케이스에서 에러를 발생시키게 만든다. @age.setter def age(self, new_age): if new_age - self.__age == 1: self.__age = new_age else: raise ValueError() def __say_hi(self): print(f\"Greetings, my masters call me {self.__name}.\") def cal_add(self, a, b): return a + b @classmethod def how_many(cls): return f\"We have {cls.__population} robots.\"droid = Robot(\"R2-D2\", 2)print(droid.age) # set이라는 attribute를 찾고 실행시킨다.# droid.age = 7droid.age += 1print(droid.age)print(droid.name)slot 객체 내에 있는 변수들은 __dict__를 통해서 관리가 된다. __slots__을 통해 변수를 관리 : 파이썬 인터프리터에게 통보 해당 클래스가 가지는 속성을 제한한다. __dict__를 통해 관리되는 객체의 성능을 최적화한다. -&gt; 다수의 객체 생성시 메모리 사용 공간 대폭 감소한다. __slot__을 사용할 때 클래스의 메서드 등의 접근 횟수가 많아짐에 따라 속도가 더 빨라진다.import timeitclass WithoutSlotClass: def __init__(self, name, age): self.name = name self.age = agewos = WithoutSlotClass(\"amamov\", 12)print(wos.__dict__)wos.__dict__[\"hello\"] = \"world\"print(wos.__dict__)class WithSlotClass: __slots__ = [\"name\", \"age\"] # set def __init__(self, name, age): self.name = name self.age = agews = WithSlotClass(\"amamov\", 12)print(ws.__dict__) # 에러 발생 =&gt; dict라는 성분은 없다.print(ws.__slots__)# * 메모리 사용량 비교def repeat(obj): def inner(): obj.name = \"amamov\" obj.age = 222 del obj.name del obj.age return inneruse_slot_time = timeit.repeat(repeat(ws), number=9999999)no_slot_time = timeit.repeat(repeat(wos), number=9999999)print(\"use slot : \", min(use_slot_time))print(\"no slot : \", min(no_slot_time))Callable Types메서드의 매개변수 값과 리턴 값의 형식 표현해줄 수 있다.함수를 넘겨줄 때는 Callable 객체를 사용한다.from typing import Callabledef add(a: int, b: int) -&gt; int: return a + bprint(add(1, 33))def tets(): passdef foo(func: Callable[[int, int], int]) -&gt; int: return func(2, 3)print(foo(tets))Class Typesclass Hello: def world(self) -&gt; int: return 7class World: passhello: Hello = Hello()world: World = World()def foo(ins: Hello) -&gt; int: return ins.world()print(foo(hello))print(foo(world)) # 에러 발생!# * class type 보충from typing import Optional# class 안에서 자기 자신을 인자로 삼아야할 경우에는 \"Node\"와 같이 표현해야하고 이를 대체할 수 있는 방법으로 Optional을 사용한다.class Node: def __init__(self, data: int, node: Optional[\"Node\"] = None): self.data = data self.node = nodenode2 = Node(12)node1 = Node(27, node2)node0 = Node(30, node1)Union Typesxxx: Union[int, str] 와 같이 변수에 올 수 있는 타입을 모두 정의해주는 방식을 말한다.from typing import Unionxxx: Union[int, str] = 3xxx = \"17\"def foo(x: Union[int, str]) -&gt; Union[int, str]: return xfoo(xxx)Optional Types아래 코드는 xxx: Union[str, None] = “amamov” 와 같은 동작을 한다.즉 특정한 경우 다른 타입도 대입이 될 때 사용한다.from typing import Union, Optionaldef foo(name: str) -&gt; Optional[str]: if name == \"amamov\": return None else: return namexxx: Optional[str] = foo(\"amamov\")Final Types상수 자료형으로 이해변수에 :Final을 붙이면 상수 자료형으로 인식하게 할 수 있음(pyright 실행 기준)from typing_extensions import FinalRATE: Final = \"dasdsa\"Type AliasType이 복잡해질 때 이에 대한 별칭을 지어줘서 재사용성을 증가시킨다.from typing import Union, List, Tuple, Dict, Optionalfrom typing_extensions import TypedDict# * type aliasValue = Union[ int, bool, Union[List[str], List[int], Tuple[int, ...]], Optional[Dict[str, float]]]X = intx: X = 8value: Value = 17def cal(v: Value) -&gt; Value: # ddmasda return v# * dict aliasddd: Dict[str, Union[str, int]] = {\"hello\": \"world\", \"world\": \"wow!!\", \"hee\": 17}# json 자료형과 같은 경우에서 많이 사용class Point(TypedDict): x: int y: float z: str hello: intpoint: Point = {\"x\": 8, \"y\": 8.4, \"z\": \"hello\", \"hello\": 12}" }, { "title": "Digit Recognizer", "url": "/posts/Kaggle-Digit-Recognizer/", "categories": "python", "tags": "python", "date": "2022-10-23 00:00:00 +0900", "snippet": "Digit Recognizerimport osimport numpy as np # linear algebraimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)from sklearn.model_selection import train_test_splitimport matplotlib.pyplot as pltfrom keras.utils.np_utils import to_categorical# cnn을 통해 최종적으로 결과를 받으면 라벨수만큼의 각각의 확률값으로 반환된다. 결과값을 받기 편하게 하기위한 함수from keras.models import Sequential# 케라스 모델구성기본 함수from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D, BatchNormalization# 케라스에서 필요한 레이어들 간편하게 쓸수 있다.from keras.preprocessing.image import ImageDataGenerator# 이미지를 조금 변화해줌으로써 성능을 올릴수 있다. 그랜드 마스터 Chris Deotte 의 25 Million Images! [0.99757] MNIST 커널에서 참고했다.(그외에도 거의 많이 참고했다.)from keras.callbacks import EarlyStopping, ModelCheckpoint, ReduceLROnPlateau# 콜벡 모델이 어떤 기준으로 돌다가 멈추고 저장하고 하는것들을 설정해줄수 있다.import warningsfrom keras.models import load_modelwarnings.filterwarnings('ignore')import tensorflow as tf# Input data files are available in the read-only \"../input/\" directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directorytrain_data = pd.read_csv('./train.csv')test_data = pd.read_csv('./test.csv')# X의 라벨값을 CNN에 넣을수 없고 이따 예측비교시 쓸거니까 분리해준다.Y_train = train_data[\"label\"]X_train = train_data.drop(labels = [\"label\"],axis = 1)# 0~255 사이의 픽셀명암의 숫자를 계산하기 편하기 255로 나눠 비율은 유지하고 숫자는 작게X_train = X_train / 255.0X_test = test_data / 255.0#이제 (28,28) 모양으로 RESHAPEX_train = X_train.values.reshape(-1,28,28,1)X_test = X_test.values.reshape(-1,28,28,1)#아까 뺴놓은 라벨값도 CNN결과값이랑 비교할수 있는 형태로Y_train = to_categorical(Y_train, num_classes = 10)datagen = ImageDataGenerator( rotation_range=10, zoom_range=0.1, width_shift_range=0.1, height_shift_range=0.1,)X_train, X_valid, y_train, y_valid = train_test_split(X_train, Y_train, test_size = 0.1)state = \"define model\"if state != \"load model\": model = Sequential() model.add(Conv2D(16,kernel_size=3,activation= 'relu', input_shape = (28,28,1) )) model.add(BatchNormalization()) model.add(Conv2D(16,kernel_size=3,activation='relu')) model.add(BatchNormalization()) model.add(Conv2D(16,kernel_size=5,activation = 'relu', padding='same',strides=2)) model.add(BatchNormalization()) model.add(Dropout(0.4)) model.add(Conv2D(32,kernel_size=3,activation= 'relu')) model.add(BatchNormalization()) model.add(Conv2D(32,kernel_size=3,activation='relu')) model.add(BatchNormalization()) model.add(Conv2D(32,kernel_size=5,activation = 'relu', padding='same',strides=2)) model.add(BatchNormalization()) model.add(Dropout(0.4)) model.add(Conv2D(64,kernel_size=4,activation= 'relu')) model.add(BatchNormalization()) model.add(Flatten()) model.add(Dropout(0.4)) model.add(Dense(10,activation='softmax')) model.summary()else: model = load_model('digit_recognizer.h5') model.summary()# 학습 결과가 수렴할 때 조기에 학습을 종료할 때 사용(현재 disable 상태)early_stopping = EarlyStopping(patience=100, min_delta=0.001, restore_best_weights=True)model.compile(optimizer='adam',loss='mean_squared_error',metrics=['accuracy'])callbacks = [early_stopping]# 10도 정도 돌리고 10% 정도 줌하고, 왼쪽, 오른쪽 시프트를 해서 다양한 변화를 준 데이터를 추가해준다.(이따 케라스 모델 fit_generator 할때 사용예정)history = model.fit_generator(datagen.flow(X_train,y_train, batch_size=64), epochs = 100, steps_per_epoch = X_train.shape[0]//64, validation_data = (X_valid,y_valid), callbacks=callbacks, verbose=1)model.save('digit_recognizer.h5')results = model.predict(X_test)results = np.argmax(results,axis = 1)results = pd.Series(results,name=\"Label\")submission = pd.concat([pd.Series(range(1,28001),name = \"ImageId\"),results],axis = 1)submission.to_csv(\"submission.csv\",index=False)# 모델 로드 및 예측 사용\"\"\"model = load_model('digit_recognizer.h5')model.summary()test_num = plt.imread('img_1.jpg')test_num = test_num[:,:,0]test_num = (test_num &gt; 125) * test_numtest_num = test_num.astype('float32') / 255.0test_num = test_num.reshape((1, 28, 28, 1))answer = model.predict(test_num)answer = np.argmax(answer,axis = 1)print(answer)\"\"\"" }, { "title": "Titanic - Machine Learning from Disaster", "url": "/posts/Kaggle-Titanic-Machine-Learning-from-Disaster/", "categories": "python", "tags": "python", "date": "2022-10-22 00:00:00 +0900", "snippet": "Titanic - Machine Learning from Disasterimport pandas as pdimport numpy as npfrom sklearn.tree import DecisionTreeClassifierfrom sklearn.ensemble import RandomForestClassifierfrom sklearn.model_selection import cross_val_scoretrain = pd.read_csv('./train.csv')# 결측값age_avg = train['Age'].mean(skipna=True)fare_avg = train['Fare'].mean(skipna=True)train['Age'] = train['Age'].fillna(age_avg)train['Fare'] = train['Fare'].fillna(fare_avg)# dict 형으로 문자열을 숫자로 변환train['Sex'] = train['Sex'].map({'male' : 0, 'female' : 1})train['Embarked'] = train['Embarked'].map({'S' : 0, 'Q' : 1, 'C' : 2})train['Embarked'] = train['Embarked'].fillna(0)#-------------------------------------------------------------------------------train_x = train[['Pclass', 'SibSp', 'Sex', 'Age', 'Fare', 'Embarked']]train_y = train['Survived']# 모델 생성(의사 결정 트리)\"\"\"DecisionTreeClassifier 분류법1. 여러가지 독립 변수 중 하나의 독립 변수를 선택하고 그 독립 변수에 대한 기준값(threshold)을 정한다. 이를 분류 규칙이라고 한다. 최적의 분류 규칙을 찾는 방법은 이후에 자세히 설명한다.2. 전체 학습 데이터 집합(부모 노드)을 해당 독립 변수의 값이 기준값보다 작은 데이터 그룹(자식 노드 1)과 해당 독립 변수의 값이 기준값보다 큰 데이터 그룹(자식 노드 2)으로 나눈다.3. 각각의 자식 노드에 대해 1~2의 단계를 반복하여 하위의 자식 노드를 만든다. 단, 자식 노드에 한가지 클래스의 데이터만 존재한다면 더 이상 자식 노드를 나누지 않고 중지한다.\"\"\"# model = DecisionTreeClassifier()\"\"\"Random Forest 분류법상위 모델들이 예측하는 편향된 결과보다, 다양한 모델들의 결과를 반영함으로써 더 다양한 데이터에 대한 의사결정을 내릴 수 있게 함.건강의 위험도를 예측하기 위해서는 많은 요소를 고려 성별, 키, 몸무게, 지역, 운동량, 흡연유무, 음주 여부, 혈당, 근육량, 기초 대사량 등 수많은 요소가 필요Feature가 30개라 했을 때 30개의 Feature를 기반으로 하나의 결정 트리를 만든다면 트리의 가지가 많아질 것이고, 이는 오버피팅의 결과를 야기30개의 Feature 중 랜덤으로 5개의 Feature만 선택해서 하나의 결정 트리 생성계속 반복하여 여러 개의 결정 트리 생성여러 결정 트리들이 내린 예측 값들 중 가장 많이 나온 값을 최종 예측값으로 지정이렇게 의견을 통합하거나 여러 가지 결과를 합치는 방식을 앙상블(Ensemble)이라고 함하나의 거대한 (깊이가 깊은) 결정 트리를 만드는 것이 아니라 여러 개의 작은 결정 트리를 만드는 것분류 : 여러 개의 작은 결정 트리가 예측한 값들 중 가장 많은 값, 회귀 : 평균\"\"\"model = RandomForestClassifier()# 학습하기model.fit(train_x, train_y)# 평가하기scores = cross_val_score(model, train_x, train_y, scoring = 'accuracy', cv = 5) # cross-validation 5print(scores.mean())# 테스트 데이터 예측하기test = pd.read_csv('./test.csv')test['Age'] = test['Age'].fillna(age_avg)test['Fare'] = test['Fare'].fillna(fare_avg)test['Sex'] = test['Sex'].map({'male' : 0, 'female' : 1})test['Embarked'] = test['Embarked'].map({'S' : 0, 'Q' : 1, 'C' : 2})test['Embarked'] = test['Embarked'].fillna(0)test_x = test[['Pclass', 'SibSp', 'Sex', 'Age', 'Fare', 'Embarked']]test_y_pred = model.predict(test_x)# 샘플 파일 형식에 맞춰 변환submission = pd.read_csv(\"./sample_submission.csv\")submission['Survived'] = test_y_predsubmission.to_csv('submission.csv', index = False)" }, { "title": "Python Code Style", "url": "/posts/Python-Code-Style/", "categories": "python", "tags": "python", "date": "2022-10-21 00:00:00 +0900", "snippet": "Python Code Style연산17 // 3 # 몫 317 % 3 # 나머지 25 ** 2 # 자승 표현 25round(3.141414, 2) # 반올림하여 두번 째 자리까지 표현print(r'c:\\user\\folder') # raw 데이터라는 표시로 문자열 그대로 출력print(\"\"\"line 1line 2line 3\"\"\")문자열 슬라이싱word = 'python'print(word[0:2]) # pyprint(word[2:]) # thonprint(word[-1]) # nf-stringsname = 'Jun'family = 'orei'print(f'My name is {name}. My family name is {family})리스트리스트 메소드r = [1, 2, 3, 4, 5, 1, 2, 3]print(r.index(3, 3)) # 3을 3번째 인덱스(4) 부터 검색해서 찾고 그 위치를 반환하세요 답 : 7print(r.count(3)) # 3의 개수를 세서 반환하세요 =&gt; 2r.sort() # 오름 차순으로 반환r.sort(reverse=True) # 내림 차순으로 반환r.reverse() # 정렬 이전 원본 상태로 되돌리기s = 'my name is kwon'to_split = s.split(' ') # 공백란을 기준으로 총 4개의 문자열로 반환x = ' '.join(to_split) # join 함수를 사용하여 s 문자열로 복원수치 전달과 참조 전달수치 전달의 경우 수치만 전달하는 것이기 때문에 id값(주소값) 이 다르다.(변수)반대로 참조 전달의 경우 주소를 복사하고 전달하는 것이기 때문에 id값이 같다.(리스트)튜플(Tuple)리스트의 경우 대괄호 [] 를 통해 표현하지만, 튜플은 소괄호 () 로 표현한다.튜플은 값의 대입이 안된다.(immutable =&gt; 수치 변경 불가능)인덱싱 및 슬라이싱은 지원한다.튜플의 언패킹num_tuple = (10, 20)x, y = num_tupleprint(x, y) # 10, 20사전형(Dictionary)집합형(Set)for else 문주로 for 문에서 특정 경우 flag 를 활용하여 break문으로 탈출하고 하는 경우 for else문으로 대체하여 사용한다.for fruit in ['apple', 'banana', 'orange']\tprint(fruit)else:\tprint('finish') # for 문에서 break로 빠지지 않는 이상 출력enumerate 함수for i, fruit in enmuerate(['apple', 'banana', 'orange'])\tprint(i, fruit) # 0 apple 1 banana ...zip 함수a = [1, 2, 3]b = ['a', 'b', 'c']for x, y in zip(a, b):\tprint(x, y) # 1 'a' \\n 2 'b'...사전형을 for 문으로 처리하기dict = {'appple' : 1, 'banana' : 200}for k, v in dict.items():\tprint(k, ':', v)Docstrings함수 내 함수의 의미 및 Argument, return 값들을 알려주는 주석def ex_func(param1, param2):\tdef ex_func(param1, param2): \"\"\" :param param1: :param param2: :return: \"\"\"\treturn Trueex_func.__doc__ # 함수의 doc string을 출력해볼 수 있음함수 내 함수주로 특정 함수 내에서만 쓰이는 함수를 정의할 때 함수 내 함수를 정의한다.def calc(a, b):\tdef plust(c, d):\t\treturn c + d\tr1 = plus(a, b)\t\treturn r1클로저이렇게 함수를 둘러싼 환경(지역 변수, 코드 등)을 계속 유지하다가, 함수를 호출할 때 다시 꺼내서 사용하는 함수를 클로저(closure)라고 한다.def outer(a, b):\tdef inner():\t\treturn a+b\treturn inner\tf = outer(1, 2)r = f() # 3def circle_area(pi):\t\tdef area(rad):\t\treturn pi * rad * rad\treturn area# outer 함수 호출ca1 = circle_area(3.14)ca2 = circle_area(3.141414)# inner 함수 호출print(ca1(10))print(ca2(10))데코레이터람다람다 함수의 경우 ㅎ함수를 딱 한줄로 표현하게 해주는 형식을 말한다.람다 함수의 표현 형태는 다음과 같다lambda 매개변수 : 표현식date = ['MON', 'TUE', 'WED', 'THU', 'FRI']def change_words(words, func):\tfor word in words:\t\tprint(funct(word))def sample_func(word):\treturn word.capitalize() # 문자열에서 첫문자를 대문자로 만들어 리턴sample_func2 = lambda word : word.capitalize()change_words(date, sample_func) change_words(date, lambda word:word.capitalize()) 제네레이터def test_generator(): print('yield 1 전') yield 1 print('yield 1과 2사이') yield 2 print('yield 2와 3사이') yield 3 print('yield 3 후')g = test_generator()next(g) # yield 1 전next(g) # yield 1과 2사이next(g) # yield 2와 3사이next(g) # yield 3 후yield from 으로 for 문 대체def three_generator(): a = [1, 2, 3] for i in a:\t\tyield i gen = three_generator()def three_generator_after(): a = [1, 2, 3] yield from agen = three_generator()gen1 = three_generator_after()사전 내포 표기아래 dictionary 자료형의 for 반복문 표현을 다음과 같이 축약할 수 있다.w = ['a', 'b', 'c']f = [1, 2, 3]d = {}for x, y in zip(w, f):\td[x] = yd = {x : y for x, y in zip(w, f)} 제네레이터 내포 표기def g():\tfor i range(10):\t\tyield ica = g()g = (i for i in range(10))print(type(g)) # 튜플이 아닌 제네레이터 타입이 된다.예외 처리try~except~finally 형태로 표현l = [1, 2, 3]try:\tl[i]except IndexError as ex:\tprint(\"don't worry : {}\".format(ex))except Exception as ex:\tprint(\"other:{}\".format(ex))else:\tprint(done) # 에러 발생하지 않을 때 출력finally:\tprint('clean up') # 어떠한 상황에서도 마지막에 출력할 내용독자 예외 작성# 독자적으로 선언한 에러class UppercaseError(Exception):\tpassdef word_check():\twords = ['APPLE', 'orange', 'banana']\tfor word in words:\t\tif word.isupper():\t\t\traise UppercaseError(word) # 이 경우일 때 해당 에러 raise\t\ttry:\tcheck()except UppercaseError as exc:\tprint('upper case error occured!')Import 문과 as파이썬 package 에는 init.py 파일이 반드시 필요하다.예를 들어personal_package=&gt; utils.py=&gt; init.py와 같은 파일구조를 가지고 있을 때import personal_package.utils # 주로 이와 같이 call path를 모두 불러오는 것이 코드가 길어지더라도 어디에서 불러오는지 명확하게 알 수 있음from personal_package import utilsfrom personal_package import utils as u # utils 를 줄여서 u로 표현하는 방법패키지(package)란?패키지(Packages)는 도트(.)를 사용하여 파이썬 모듈을 계층적(디렉터리 구조)으로 관리할 수 있게 해준다. 패키지 구조로 파이썬 프로그램을 만드는 것이 공동 작업이나 유지 보수 등 여러 면에서 유리하다. 또한 패키지 구조로 모듈을 만들면 다른 모듈과 이름이 겹치더라도 더 안전하게 사용할 수 있다.init.py, all 의 의미init.py 파일은 해당 디렉터리가 패키지의 일부임을 알려주는 역할을 한다.python3.3 버전부터는 init.py 파일이 없어도 패키지로 인식한다(PEP 420). 하지만 하위 버전 호환을 위해 init.py 파일을 생성하는 것이 안전한 방법이다.all__이 의미하는 것은 패키지 디렉터리에서 * 기호를 사용하여 import할 경우 이곳에 정의된 __all 내 선언된 모듈에 대해서만 import된다는 의미이다.setup.pyPycharm IDE 에서는 Tools=&gt; Create setup.py 를 통해 setup 파일을 생성할 수 있다.from setuptools import setupsetup( name='digit-recognizer', version='1.0.0', packages=[''], url='', license='Free', author='dram1', author_email='', description='digit package') 그리고 Tools=&gt; Run setup.py task를 선택하고, sdist를 선택 및 command line에서 그냥 ok를 눌러주면 dist 폴더 내 패키지 파일이 생성된다.관련 내용에 대한 자세한 정리 참고…Setuptools지난 글에서 파이썬의 표준 적인 설치 관행에 대해 살펴봤습니다. 기본적인 setup.py 파일도 제작했고요. 오늘은 Distutils 을 떠나, Setuptools 로 작업을 확장합니다. 지금 소개해 드리는 관행이 실제로 저희가 사용하고 있는 것인데 다음과 같은 기능들을 setup.py 에 추가하게 됩니다.모듈 의존성 관리 — install_requires비공개 모듈 설치 — dependency_links콘솔 스크립트 설치 — entry_points개발 모드 디플로이 — setup.py develop전과 마찬가지로 Flowdas Books 라는 장고 애플리케이션을 사용해서 설명 드리겠습니다.setup.pySetuptools 를 사용하도록 수정된 setup.py 은 이렇게 됩니다.from setuptools import setup, find_packagessetup_requires = [ ]install_requires = [ 'django==1.6b4', 'markdown==2.3.1', 'pyyaml==3.10', 'pillow==2.1.0', 'lxml==3.2.3', 'beautifulsoup4==4.3.1', ]dependency_links = [ 'git+https://github.com/django/django.git@stable/1.6.x#egg=Django-1.6b4', ]setup( name='Flowdas-Books', version='0.1', description='Flowdas Books', author='Flowdas', author_email='spammustdie@flowdas.com', packages=find_packages(), install_requires=install_requires, setup_requires=setup_requires, dependency_links=dependency_links, scripts=['manage.py'], entry_points={ 'console_scripts': [ 'publish = flowdas.books.script:main', 'scan = flowdas.books.script:main', 'update = flowdas.books.script:main', ], }, )setup(), find_packages()Setuptools 에서 제공하는 두 개의 함수 setup() 과 find_packages() 를 사용합니다. setup() 은 표준 라이브러리에 포함된 Distutils 의 setup() 을 대체하는 것입니다. Distutils 의 것에 비해 더 다양한 옵션들을 처리합니다.find_packages()예전에는 packages 옵션에 패키지 이름들을 일일이 적어주었습니다. 최상단 패키지만 적어주어야 한다면 크게 문제될 것이 없지만, 하위 패키지들을 많이 만드는 방식의 프로그래밍을 하시는 분들은 영 불편해합니다. Setuptools 가 제공하는 find_packages() 함수는 폴더를 뒤져서 패키지들의 목록을 만들어 줍니다. 혹 뒤져야 할 폴더가 다른 곳에 있거나, 포함시키지 말아야 할 패키지가 있다면 인자로 지정할 수 있습니다.install_requires가장 중요한 부분은 이 프로젝트가 사용하는 패키지들을 지정하는 것인데, install_requires 옵션을 사용합니다. 전부 6개의 패키지를 지정했는데, 모두 django==1.6b4 와 같이 구체적인 버전을 지정했습니다. 처음부터 버전을 지정하지는 않고, 어느 정도 호환성 확인이 된 후에 버전을 확인하여 고정하게 됩니다. 버전 확인에는 pip freeze 명령을 사용하면 됩니다. 패키지 이름의 대소문자는 중요하지 않습니다.setup_requiresinstall_requires 에 지정하는 것은 프로젝트를 위해 필요한 패키지들인데, 때로 setup.py 자신을 위해 필요한 패키지가 있을 수 있습니다. 이런 패키지들은 setup_requires 옵션을 사용하여 지정합니다. 이런 경우에 해당하는 패키지의 예는 setuptools_git 가 있습니다만, 저희는 사용하지 않기 때문에 자리만 마련하고 비워둡니다.dependency_links이 글을 쓰는 시점에 PyPI 에 등록된 장고의 최신 버전은 1.5.4 입니다. 때문에 위에서 지정한 1.6b4 버전은 PyPI 에서 발견할 수 없고, 당연히 setup.py 를 실행할 때 오류가 발생합니다. dependency_links 옵션은 PyPI 외의 장소에 있는 패키지를 설치할 수 있도록 합니다. 여러 가지 형태가 있습니다만 git 저장소를 사용하는 방법을 예시합니다. 장고의 git 저장소 주소인 https://github.com/django/django.git 앞에 git+ 를 붙여 URL 을 구성합니다. 여기에 1.6b4 버전이 들어있는 브랜치 stable/1.6.x 를 지정하는 @stable/1.6.x 를 붙입니다. 그냥 hash 를 붙여도 됩니다. 마지막으로 =Django-1.6b4 를 붙여서 패키지 이름과 버전을 지정합니다. 이 부분이 앞서 install_requires 에 지정된 부분과 일치해야 합니다.이 방법을 소개하는 이유는, 같은 방법으로 여러분의 회사가 사용하는 git 저장소도 지정할 수 있기 때문입니다. 모든 패키지를 PyPI 에 올려놓을 수 없는 분들은 이 방법을 사용하면 됩니다.import 순서 예시파이썬 표준라이브러리, 서드파티 라이브러리, 직접 정의한 패키지, local python 파일 순으로 import를 수행하는 것을 선호한다.그리고 각자를 구분하기 위해 한 줄씩 공백을 두고 구분을 수행한다.# 파이썬 표준 라이브러리import collectionsimport osimport sys# 서드파티 라이브러리import numpy# 직접 정의한 패키지import lesson_package# local python 파일 순import configprint(collections.__file__)file 을 통해 해당 패키지가 어디에 위치하고 있는지 확인할 수 있다.name 과 main__name__은 모듈의 이름이 저장되는 변수이며 import로 모듈을 가져왔을 때 모듈의 이름이 들어가게 된다.print(__name__) # __main__# hello.pyprint('hello 모듈 시작')print('hello.py __name__:', __name__) # __name__ 변수 출력print('hello 모듈 끝')# main.pyimport hello # hello 모듈을 가져옴print('main.py __name__:', __name__) # __name__ 변수 출력해당 코드의 결과는 다음과 같다.실행결과hello 모듈 시작hello.py name: hellohello 모듈 끝main.py name: main파이썬에서 import로 모듈을 가져오면 해당 스크립트 파일이 한 번 실행된다. 따라서 hello 모듈을 가져오면 hello.py 안의 코드가 실행됩니다. 따라서 hello.py의 name 변수에는 ‘hello’(import된 모듈은 모듈의 이름(파일명))가 들어가고, main.py의 name 변수에는 ‘main‘이 들어간다.즉 우리가 흔히 사용하는 if name==”main” 의 조건문의 경우 해당 파이썬 파일을 직접 실행하는 경우 즉, 프로그램의 시작점일 경우에만 실행된다.Timer 관련 참고 코드enter, exit 은 with 구문의 시작과 종료에 호출된다.import timeclass Timer(): def __init__(self): pass def __enter__(self): self.start_time = time.time() def __exit__(self, type, value, traceback): self.end_time = time.time() - self.start_timewith Timer(): time.sleep(5)클래스 생성자와 소멸자class Person(object): def __init__(self, name): self.name = name def __del__(self): print('bye')person = Person('Alex')del person # 소멸자 호출클래스의 계승class Car(object): def run(self): print('run')class HyundaiCar(Car): passclass TeslaCar(Car): def auto_run(self): print('auto_run')car = Car()car.run()# Car class를 계승했으므로 Car 메서드들을 사용할 수 있게된다.hcar = HyundaiCar()hcar.run()tcar = TeslaCar()tcar.run()tcar.auto_run()메서드 오버라이드 및 supersuper 명령어는 이런 상속 관계에서 상속의 대상인 부모 클래스를 호출하는 함수super()의 인자로는 두 개가 전달되며, 하위클래스의 이름과 하위클래스의 객체(object)가 필요class Car(object): def __init__(self, model=None) self.model = model def run(self): print('run')class HyundaiCar(Car): # Method Override def run(self): print('fast run')class TeslaCar(Car): def __init__(self, model='Model 3', enable_auto_run=False) # self.model = model super.__init__(model) self.enable_auto_run = enable_auto_run # Method Override def run(self): print('super fast run') def auto_run(self): print('auto_run')car = Car()car.run()# Car class를 계승했으므로 Car 메서드들을 사용할 수 있게된다.hcar = HyundaiCar()hcar.run()tcar = TeslaCar('Model S')tcar.run()tcar.auto_run()Property주로 파이썬 class 변수에서 다음과 같은 조건으로 변수명을 작성한다. 외부에서도 자유롭게 사용 가능할 때 self.var = 1 외부에서는 특정 조건에서만 읽고 쓰는 것이 가능하게 하고 싶을 때 self._var = 1 내부에서만 사용하는 변수로 사용하고 싶을 때 self.__var = 1 class Car(object): def __init__(self, model=None) self.model = model def run(self): print('run')class HyundaiCar(Car): # Method Override def run(self): print('fast run')class TeslaCar(Car): def __init__(self, model='Model 3', enable_auto_run=False, passwd = '123') # self.model = model super.__init__(model) self.enable_auto_run = enable_auto_run self.passwd = passwd @property # getter def enable_auto_run(self): return self._enable_auto_run # setter를 통해 값 설정이 가능해짐 @enable_auto_run.setter # setter def enable_auto_run(self, is_enable): # 값을 덮어쓸 때 제약을 걸고 싶을 때 property 와 setter를 사용한다. if self.passwd == '456' return self._enable_auto_run = is_enable else: raise ValueError # Method Override def run(self): print('super fast run') def auto_run(self): print('auto_run')car = Car()car.run()# Car class를 계승했으므로 Car 메서드들을 사용할 수 있게된다.hcar = HyundaiCar()hcar.run()tcar = TeslaCar('Model S', passwd='456')tcar.run()tcar.auto_run()tcar.enable_auto_run = True # Error property를 붙이게 되면 private 변수 성질을 가진다.덕타이핑덕 타이핑은 실제 타입(클래스)은 상관하지 않고, 구현된 메서드로만 판단하는 방식덕 타이핑은 “만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라 부르겠다.”라는 의미즉 해당 메서드를 호출할 수만 있다면 어떤 클래스이건 가리지 않고 호출하는 방식을 말하고 파이썬은 이를 지원한다.class Person(object): def __init__(self, age=1): self.age = age def drive(self): if self.age &gt;= 18: print('ok') else raise Exception('No drive')class Baby(Person): def __init__(self, age=1): if age &lt; 18: super().__init__(age) else: raise ValueErrorclass Adult(Person): def __init__(self, age=1): if age &lt; 18: super().__init__(age) else: raise ValueErrorbaby = Baby()adult = Adult()class Car(object): def __init__(self, model=None) self.model = model def run(self): print('run') # 파이썬의 덕타이핑 def ride(self, person): person.drive()car = Car()car.ride(adult) # ok추상 클래스" }, { "title": "정육면체 한번 더 굴리기", "url": "/posts/%EC%A0%95%EC%9C%A1%EB%A9%B4%EC%B2%B4-%ED%95%9C%EB%B2%88-%EB%8D%94-%EA%B5%B4%EB%A6%AC%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-15 00:00:00 +0900", "snippet": "정육면체 한번 더 굴리기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define OUT_OF_BOUND 99999int n, m, answer = 0, c_dir = 0, curr_x = 0, curr_y = 0, temp_score = 0, tnum = 0;// 격자 크기 n, 그리고 굴리는 횟수 mint arr[20][20] = { {0,}, };bool isvisited[20][20] = { {false,}, };int dy[4] = { 0, 1, 0, -1 };//우하좌상 설정(시계방향)int dx[4] = { 1, 0, -1, 0 };int u = 1, f = 2, r = 3;/** 주사위는 항상 초기에 격자판의 1행 1열에 놓여져 있고, 처음에는 항상 오른쪽으로 움직입니다.주사위를 움직일때마다, 격자판 위 주사위가 놓여있는 칸에 적혀있는 숫자와 상하좌우로 인접하며 같은 숫자가 적혀있는 모든 칸의 합만큼 점수를 얻게 됩니다.이때, 주사위의 아랫면이 보드의 해당 칸에 있는 숫자보다 크면 현재 진행방향에서 90' 시계방향으로 회전하여 다시 이동을 진행하게 되고,주사위의 아랫면의 숫자가 더 작다면 현재 진행방향에서 90' 반시계방향으로 회전하게 되며, 동일하다면 현재 방향으로 계속 진행하게 됩니다.이제 또 움직임을 반복하고, 점수를 얻게 되는 과정을 m번 진행하게 되는 것입니다.하지만 만약 진행 도중 다음과 같이 격자판을 벗어나게 된다면, 반사되어 방향이 반대로 바뀌게 된 뒤 한 칸 움직이게 됩니다.*/void input_func(){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\treturn;}void bfs(int y, int x, int tot_num){\t\tqueue&lt;pair&lt;int, int&gt; &gt; q;\t\tq.push(make_pair(y, x));\tisvisited[y][x] = true;\twhile (!q.empty())\t{\t\tint cy = q.front().first;\t\tint cx = q.front().second;\t\ttemp_score += tot_num;\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint ny = cy + dy[i];\t\t\tint nx = cx + dx[i];\t\t\t\t\t\tif (ny &lt; 0 || nx &lt; 0 || nx &gt;= n || ny &gt;= n)\t\t\t\tcontinue;\t\t\tif (!isvisited[ny][nx] &amp;&amp; arr[ny][nx] == tot_num)\t\t\t{\t\t\t\tq.push(make_pair(ny, nx));\t\t\t\tisvisited[ny][nx] = true;\t\t\t}\t\t}\t}\treturn;}int dice_roll(){\tint ny = curr_y + dy[c_dir];\tint nx = curr_x + dx[c_dir];\tif (ny &lt; 0 || nx &lt; 0 || ny &gt;= n || nx &gt;= n)\t\treturn OUT_OF_BOUND;\t// 벗어나지 않았을 경우 이동위치로 업데이트\telse\t{\t\tcurr_y = ny;\t\tcurr_x = nx;\t}\treturn 0;}void dice_process(){\tint c_status = 0;\t\t// 먼저 굴려본다.\tc_status = dice_roll();\tif (c_status == OUT_OF_BOUND)\t{\t\t// 벗어날 경우 방향전환하\t\tc_dir = (c_dir &lt; 2)? c_dir + 2 : c_dir - 2;\t\tc_status = dice_roll();\t}\ttemp_score = 0;\t// 한 사이클을 돌면 방문 체크는 초기화 한다.\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tisvisited[i][j] = false;\tbfs(curr_y, curr_x, arr[curr_y][curr_x]);\tanswer += temp_score;\t// 주사위 상태 업데이트\tswitch (c_dir)\t{\t// 우\tcase 0:\t\tu = 7 - r;\t\tr = u;\t\tbreak;\t// 하\tcase 1:\t\tu = 7 - f;\t\tf = u;\t\tbreak;\t// 좌\tcase 2:\t\tu = r;\t\tr = 7 - u;\t\tbreak;\t// 상\tcase 3:\t\tu = f;\t\tf = 7 - u;\t\tbreak;\tdefault:\t\tprintf(\"dir error\\n\");\t\tbreak;\t}\tint bottom = 7 - u;\t// 현재 주사위 위치의 바닥의 숫자가 바닥 주사위 숫자보다 큰 경우\tif (arr[curr_y][curr_x] &gt; bottom)\t\tc_dir = (c_dir + 1) % 4;\telse if(arr[curr_y][curr_x] &lt; bottom)\t\tc_dir = (c_dir + 7) % 4;\treturn;}int main(){\tinput_func();\tfor (int i = 0; i &lt; m; i++)\t{\t\tdice_process();\t}\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "나무 타이쿤", "url": "/posts/%EB%82%98%EB%AC%B4-%ED%83%80%EC%9D%B4%EC%BF%A4/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-15 00:00:00 +0900", "snippet": "나무 타이쿤#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;/*초기 특수 영양제는 n x n 격자의 좌하단의 4개의 칸에 주어집니다.1년동안 다음 단계를 거쳐 리브로수는 성장하게 됩니다.1. 특수 영양제를 이동 규칙에 따라 이동시킵니다.2. 특수 영양제를 이동 시킨 후 해당 땅에 특수 영양제를 투입합니다.3. 특수 영양제를 투입한 리브로수의 대각선으로 인접한 방향에 높이가 1 이상인 리브로수가 있는 만큼 높이가 더 성장합니다. 대각선으로 인접한 방향이 격자를 벗어나는 경우에는 세지 않습니다.4. 특수 영양제를 투입한 리브로수를 제외하고 높이가 2 이상인 리브로수는 높이 2를 베어서 잘라낸 리브로수로 특수 영양제를 사고, 해당 위치에 특수 영양제를 올려둡니다.*/int n, m, answer = 0;// 격자의 크기 n, 리브로수를 키우는 총 년 수 mint tree_map[15][15] = { {0,}, };int dir[100] = { 0, };int p[100] = { 0, };int dy[8] = { 0, -1, -1, -1, 0, 1, 1, 1};int dx[8] = { 1, 1, 0, -1, -1, -1, 0, 1};int diag_y[4] = {-1, -1, 1, 1};int diag_x[4] = {-1, 1, 1, -1};bool fert[15][15] = { {false,}, };bool fert_temp[15][15] = { {false,}, }; // 영양제 업데이트 내용 임시 저장용void input_func(){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tscanf(\"%d\", &amp;tree_map[i][j]);\t\t}\t}\tfor (int i = 0; i &lt; m; i++)\t{\t\tscanf(\"%d %d\", &amp;dir[i], &amp;p[i]);\t}\treturn;}void init_med(){\tfor (int i = n - 2; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; 2; j++)\t\t{\t\t\tfert[i][j] = true;\t\t}\t}\treturn;}void move(int d, int p){\t// fert 업데이트 용 임시 변수 저장\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tfert_temp[i][j] = false;\t// 이동 업데이트\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tif (fert[i][j])\t\t\t{\t\t\t\tint ny = (i + dy[d] * p + n * p) % n;\t\t\t\tint nx = (j + dx[d] * p + n * p) % n;\t\t\t\tfert_temp[ny][nx] = true;\t\t\t}\t\t\t\t\t}\t}\t// 임시변수 실제 영양제 지도에 덮어쓰기\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tfert[i][j] = fert_temp[i][j];\t\t\t\treturn;}void insert(){\t// 영양제가 있는 곳에 나무 높이 1 증가\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tif (fert[i][j])\t\t\t{\t\t\t\ttree_map[i][j]++;\t\t\t}\t\t}\t}\t//영양제가 있는 땅에 대각 방향에 리브로수 개수 만큼 높이 증가\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tif (fert[i][j])\t\t\t{\t\t\t\t\tint cnt = 0;\t\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t\t{\t\t\t\t\tint ny = i + diag_y[k];\t\t\t\t\tint nx = j + diag_x[k];\t\t\t\t\tif (nx &lt; 0 || ny &lt; 0 || nx &gt;= n || ny &gt;= n)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (tree_map[ny][nx] &gt;= 1)\t\t\t\t\t\tcnt++;\t\t\t\t}\t\t\t\ttree_map[i][j] += cnt;\t\t\t}\t\t\t\t\t}\t}\t\treturn;}void update(){\t// fert 업데이트 용 임시 변수 저장\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tfert_temp[i][j] = false;\t// 나무 가지치기 및 영양제 업데이트\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tif (tree_map[i][j] &gt;= 2 &amp;&amp; !fert[i][j])\t\t\t{\t\t\t\ttree_map[i][j] -= 2;\t\t\t\tfert_temp[i][j] = true;\t\t\t}\t\t}\t}\t\t\t// 임시변수 실제 영양제 지도에 덮어쓰기\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tfert[i][j] = fert_temp[i][j];\treturn;}void calc_answer(){\tfor (int i = 0; i &lt; n; i++)\t\tfor (int j = 0; j &lt; n; j++)\t\t\tanswer += tree_map[i][j];}int main(){\tinput_func();\t// 초기 영양제 위치\tinit_med();\t \tfor (int i = 0; i &lt; m; i++)\t{\t\t// 1. 영양제 이동\t\tmove(dir[i]-1, p[i]);\t\t// 2. 영양제 투입, 3. 성장 결과 업데이트\t\tinsert();\t\t// 4. 나무 가지치기 및 영양제 재 투입\t\tupdate();\t}\tcalc_answer();\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "조삼모사", "url": "/posts/%EC%A1%B0%EC%82%BC%EB%AA%A8%EC%82%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-14 00:00:00 +0900", "snippet": "조삼모사전형적인 조합문제로 재귀로 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;/*아침일과 저녁일을 적절히 조합해서 아침에 하는 일과 저녁에 하는 일의 업무 강도 차이의 최솟값을 구하는 문제*/int n, answer = 98765432;int p[20][20] = { {0,}, };bool morning_work[10] = { false, };void input_func(){\tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tscanf(\"%d\", &amp;p[i][j]);\t\t}\t}}int calc_workdiff(){\tint m_work = 0, e_work = 0;\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j= 0; j &lt; n; j++)\t\t{\t\t\tif (i == j)\t\t\t\tcontinue;\t\t\tif (morning_work[i] == true &amp;&amp; morning_work[j] == true)\t\t\t{\t\t\t\tm_work += p[i][j];\t\t\t}\t\t\telse if (morning_work[i] == false &amp;&amp; morning_work[j] == false)\t\t\t{\t\t\t\te_work += p[i][j];\t\t\t}\t\t}\t}\treturn abs(m_work - e_work);}void dfs(int idx, int cnt){\tif (cnt == n / 2)\t{\t\tanswer = min(answer, calc_workdiff());\t\treturn;\t}\tif (idx == n)\t\treturn;\tdfs(idx + 1, cnt);\tmorning_work[idx] = true;\tdfs(idx + 1, cnt + 1);\tmorning_work[idx] = false;\treturn;}int main(){\t\tinput_func();\tdfs(0, 0);\tprintf(\"%d\", answer);\treturn 0;}" }, { "title": "나무박멸", "url": "/posts/%EB%82%98%EB%AC%B4%EB%B0%95%EB%A9%B8/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2022-10-14 00:00:00 +0900", "snippet": "나무박멸#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;/*첫 번째 줄에 격자의 크기 n, 박멸이 진행되는 년 수 m, 제초제의 확산 범위 k, 제초제가 남아있는 년 수 c1. 인접한 네 개의 칸 중 나무가 있는 칸의 수만큼 나무가 성장합니다. 성장은 모든 나무에게 동시에 일어납니다2. 기존에 있었던 나무들은 인접한 4개의 칸 중 벽, 다른 나무, 제초제 모두 없는 칸에 번식을 진행합니다. 이때 각 칸의 나무 그루 수에서 총 번식이 가능한 칸의 개수만큼 나누어진 그루 수만큼 번식이 되며, 나눌 때 생기는 나머지는 버립니다. 번식의 과정은 모든 나무에서 동시에 일어나게 됩니다.3. 각 칸 중 제초제를 뿌렸을 때 나무가 가장 많이 박멸되는 칸에 제초제를 뿌립니다. 제초제를 뿌릴 때 4개의 대각선 방향으로 k칸만큼 전파되게 됩니다. 단 전파되는 도중 벽이 있거나 나무가 아얘 없는 칸이 있는 경우, 그 칸 까지는 제초제가 뿌려지며 그 이후의 칸으로는 제초제가 전파되지 않습니다. 제초제가 뿌려진 칸에는 c년만큼 제초제가 남아있다가 c+1년째가 될 때 사라지게 됩니다. 제초제가 뿌려진 곳에 다시 제초제가 뿌려지는 경우에는 새로 뿌려진 해로부터 다시 c년동안 제초제가 유지됩니다.*/int n, m, ks, c, answer = 0;// 상하좌우 탐색용 int b_dy[4] = { -1, 1, 0, 0 };int b_dx[4] = { 0, 0, -1, 1 };// 대각 탐색용int k_dy[4] = { -1, -1, 1, 1};int k_dx[4] = { -1, 1, 1, -1};int tree_map[20][20] = { {0,}, };int herb_map[20][20] = { {0, }, };void input_func(){\t//첫 번째 줄에 격자의 크기 n, 박멸이 진행되는 년 수 m, 제초제의 확산 범위 k, 제초제가 남아있는 년 수 c\tscanf(\"%d %d %d %d\", &amp;n, &amp;m, &amp;ks, &amp;c);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tscanf(\"%d\", &amp;tree_map[i][j]);\t\t}\t}}//1. 인접한 네 개의 칸 중 나무가 있는 칸의 수만큼 나무가 성장합니다. 성장은 모든 나무에게 동시에 일어납니다void growth(){\t\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\t// 벽이거나 나무가 없는 경우\t\t\tif (tree_map[i][j] &lt;= 0)\t\t\t\tcontinue;\t\t\tint cnt = 0;\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t{\t\t\t\tint ny = i + b_dy[k];\t\t\t\tint nx = j + b_dx[k];\t\t\t\tif(ny &lt; 0 || nx &lt; 0 || ny &gt;= n || nx &gt;= n)\t\t\t\t\tcontinue;\t\t\t\tif (tree_map[ny][nx] &gt; 0)\t\t\t\t\tcnt++;\t\t\t}\t\t\ttree_map[i][j] += cnt;\t\t}\t}\treturn;}void breeding(){ // 번식 알고리즘의 경우 주변의 값에 영향을 주기 때문에 한 번에 적용하기 위해 temp 변수를 설정한다. int temp_tree[20][20] = 0;\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\t// 벽이거나 나무가 없는 경우\t\t\t\t\t\tif (tree_map[i][j] &lt;= 0)\t\t\t\tcontinue;\t\t\tint cnt = 0;\t\t\tint startp = tree_map[i][j];\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t{\t\t\t\tint ny = i + b_dy[k];\t\t\t\tint nx = j + b_dx[k];\t\t\t\tif (ny &lt; 0 || nx &lt; 0 || ny &gt;= n || nx &gt;= n)\t\t\t\t\tcontinue;\t\t\t\tif (herb_map[ny][nx] != 0)\t\t\t\t\tcontinue;\t\t\t\t// 빈공간인 경우\t\t\t\tif (tree_map[ny][nx] == 0)\t\t\t\t\tcnt++;\t\t\t}\t\t\tif (cnt != 0)\t\t\t{\t\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t\t{\t\t\t\t\tint ny = i + b_dy[k];\t\t\t\t\tint nx = j + b_dx[k];\t\t\t\t\tif (ny &lt; 0 || nx &lt; 0 || ny &gt;= n || nx &gt;= n)\t\t\t\t\t\tcontinue;\t\t\t\t\tif (herb_map[ny][nx] != 0)\t\t\t\t\t\tcontinue;\t\t\t\t\t// 빈공간인 경우\t\t\t\t\tif (tree_map[ny][nx] == 0)\t\t\t\t\t\ttemp_tree[ny][nx] += (startp / cnt);\t\t\t\t}\t\t\t}\t\t\t\t\t}\t} for (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{ tree_map[i][j] += temp_tree[i][j]; } }\treturn;}void kill_tree(){\t// 나무를 가장많이 죽일 수 있는 포인트를 찾는다.\tint max_y = 0, max_x = 0, max_kill = 0;\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\t\t\t\tif (tree_map[i][j] &lt;= 0)\t\t\t\tcontinue;\t\t\tint killcnt = tree_map[i][j];\t\t\tfor (int k = 0; k &lt; 4; k++)\t\t\t{ int ny = i; int nx = j;\t\t\t\tfor (int l = 1; l &lt;= ks; l++)\t\t\t\t{\t\t\t\t\tny += k_dy[k];\t\t\t\t\tnx += k_dx[k];\t\t\t\t\tif (ny &lt; 0 || nx &lt; 0 || ny &gt;= n || nx &gt;= n)\t\t\t\t\t\tbreak;\t\t\t\t\tif (tree_map[ny][nx] &lt;= 0)\t\t\t\t\t\tbreak;\t\t\t\t\tkillcnt += tree_map[ny][nx];\t\t\t\t}\t\t\t\t\t\t\t}\t\t\tif (killcnt &gt; max_kill)\t\t\t{\t\t\t\tmax_kill = killcnt;\t\t\t\tmax_y = i;\t\t\t\tmax_x = j;\t\t\t}\t\t}\t}\t// 정답 업데이트(1년치)\tanswer += max_kill;\t// 제초제 업데이트\tif (tree_map[max_y][max_x] &gt; 0)\t{\t\ttree_map[max_y][max_x] = 0;\t\therb_map[max_y][max_x] = c;\t\tfor (int i = 0; i &lt; 4; i++)\t\t{ int ny = max_y; int nx = max_x;\t\t\tfor (int j = 1; j &lt;= ks; j++)\t\t\t{\t\t\t\tny += k_dy[i];\t\t\t\tnx += k_dx[i];\t\t\t\tif (ny &lt; 0 || nx &lt; 0 || ny &gt;= n || nx &gt;= n)\t\t\t\t\tbreak;\t\t\t\tif (tree_map[ny][nx] &lt; 0)\t\t\t\t\tbreak;\t\t\t\t// 빈공간인 경우 거기까지만 제초제 뿌리고 탈출\t\t\t\tif (tree_map[ny][nx] == 0)\t\t\t\t{\t\t\t\t\therb_map[ny][nx] = c;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t\ttree_map[ny][nx] = 0;\t\t\t\therb_map[ny][nx] = c;\t\t\t}\t\t}\t}}//1년이 지남에 따라 제초제 1씩 감소void vanish_herb(){\tfor(int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; n; j++)\t\t{\t\t\tif (herb_map[i][j] &gt; 0)\t\t\t\therb_map[i][j]--;\t\t}\t}}int main(){\t\tinput_func();\tfor (int i = 0; i &lt; m; i++)\t{\t\t// 성장\t\tgrowth();\t\t// 번식\t\tbreeding(); // 제초제 지속기간 업데이트\t\tvanish_herb();\t\t// 박멸\t\tkill_tree();\t\t\t}\tprintf(\"%d\", answer);\treturn 0;}" }, { "title": "아기 상어", "url": "/posts/%EC%95%84%EA%B8%B0-%EC%83%81%EC%96%B4/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-10-13 00:00:00 +0900", "snippet": "아기 상어문제 조건에 대한 복기가 필요한 코드(보완 필요)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;/*더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.(종료 조건)아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다.1, 먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.2. 먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.(거리가 가장 가까운 물고기를 어떻게 검출할지)거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다.*/int N, res_time = 0, eat_cnt = 0, shark = 2;int space[20][20]{ {0,}, };int dy[4] = { -1, 0, 1, 0 };//상좌하우(우선순위에 따라 배치)int dx[4] = { 0, -1, 0, 1 };bool isvisited[20][20] = { {false, }, };bool eat_flag = false; bool exit_flag = false; // 아무도 못먹는 경우(탈출 flag)vector&lt;pair&lt;int, int&gt;&gt; startp;void input_func(){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;space[i][j]);\t\t\tif (space[i][j] == 9)\t\t\t{\t\t\t\tstartp.push_back(make_pair(i, j));\t\t\t\tspace[i][j] = 0;\t\t\t}\t\t\t\t\t\t}\t}}// 물고기 탐색 및 먹을 때까지 넓이 탐색 수행void bfs(int y, int x){\tqueue&lt;pair&lt;pair&lt;int, int&gt;, int&gt; &gt; q;\tint temp_time = 0;\tspace[y][x] = 0; // 현재 상어 위치 삭제\tisvisited[y][x] = true; // 현재 위치 방문 처리\tq.push(make_pair(make_pair(y, x), 0));\twhile (!q.empty())\t{\t\tint cy = q.front().first.first;\t\tint cx = q.front().first.second;\t\tint cnt = q.front().second; // 현재 시간\t\t// 상어가 물고기를 먹은 이벤트 발생\t\t// 물고기를 먹은 상어 위치 업데이트\t\tif (temp_time == cnt &amp;&amp; space[cy][cx] &gt; 0 &amp;&amp; space[cy][cx] &lt; shark)\t\t{\t\t\t//거리 동일 시 위쪽 그 다음 왼쪽 우선 순위로 먹는다.\t\t\t// or 연산의 특성 사용\t\t\tint sy = startp[0].first;\t\t\tint sx = startp[0].second;\t\t\tif((sy &gt; cy) || ((sy == cy) &amp;&amp; (sx &gt; cx)))\t\t\t{\t\t\t\tstartp.pop_back();\t\t\t\tstartp.push_back(make_pair(cy, cx));\t\t\t\tcontinue;\t\t\t}\t\t}\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint ny = cy + dy[i];\t\t\tint nx = cx + dx[i];\t\t\t\t\t\tif (nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= N)\t\t\t\tcontinue;\t\t\t//먹을 수 있거나 지나갈 수 있는 경우\t\t\tif (!isvisited[ny][nx] &amp;&amp; space[ny][nx] &lt;= shark)\t\t\t{\t\t\t\t//먹은 경우\t\t\t\tif (space[ny][nx] &gt; 0 &amp;&amp; space[ny][nx] &lt; shark &amp;&amp; !eat_flag)\t\t\t\t{\t\t\t\t\teat_flag = true;\t\t\t\t\tstartp.pop_back();\t\t\t\t\tstartp.push_back(make_pair(ny, nx));\t\t\t\t\ttemp_time = cnt + 1; // 한마리 먹는데 소요된 시간\t\t\t\t\tres_time += temp_time; // 결과 시간 업데이트 \t\t\t\t}\t\t\t\t//못먹은 경우(지나치는 경우)\t\t\t\telse\t\t\t\t{\t\t\t\t\tq.push(make_pair(make_pair(ny, nx), cnt + 1));\t\t\t\t\tisvisited[ny][nx] = true; // 큐에 넣을 때 방문처리 위 if문을 만족하기 위해 여기서 방문 처리를 해준다.\t\t\t\t}\t\t\t}\t\t}\t}}int main(){\t\tinput_func();\t\twhile (true)\t{\t\tint cy = startp[0].first, cx = startp[0].second;\t\tmemset(isvisited, false, sizeof(isvisited));\t\tbfs(cy, cx);\t\t// 물고기를 먹었을 경우\t\tif (eat_flag)\t\t{\t\t\teat_flag = false; // 플래그 초기화\t\t\teat_cnt++;\t\t\tspace[cy][cx] = 0;\t\t\tif (eat_cnt == shark)\t\t\t{\t\t\t\tshark++;\t\t\t\teat_cnt = 0;\t\t\t}\t\t}\t\telse\t\t{\t\t\texit_flag = true;\t\t}\t\tif (exit_flag)\t\t\tbreak;\t}\tprintf(\"%d\\n\", res_time);\treturn 0;}" }, { "title": "치킨 배달", "url": "/posts/%EC%B9%98%ED%82%A8-%EB%B0%B0%EB%8B%AC/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2022-10-12 00:00:00 +0900", "snippet": "치킨 배달조합 문제로 재귀를 통해 조합을 구성하고 각 조합 별 거리를 계산한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;# define MAX 98765432using namespace std;/*치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.0은 빈 칸, 1은 집, 2는 치킨집이다.이 도시에서 가장 수익을 많이 낼 수 있는 치킨집의 개수는 최대 M개라는 사실을 알아내었다.전체 치킨집 중 M 개의 치킨 집을 골라 조합하는 문제도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성*/int N, M;// N 도시의 정보, M 최대 치킨집int cmap[50][50] = { {0,}, };bool pick[13] = { false, };vector&lt;pair&lt;int, int&gt; &gt; h_cord, c_cord, comb;int temp_sum = 0, answer = MAX;void input_func(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;cmap[i][j]);\t\t\t// 전체 집 위치와 전체 치킨집의 갯수 vector 값에 저장\t\t\tif (cmap[i][j] == 1)\t\t\t\th_cord.push_back(make_pair(i, j));\t\t\telse if (cmap[i][j] == 2)\t\t\t\tc_cord.push_back(make_pair(i, j));\t\t}\t}}void calc_distance(){\ttemp_sum = 0;\t\t\tfor (int i = 0; i &lt; h_cord.size(); i++)\t{\t\tint dist = 0, min_dist = MAX;\t\t// 치킨집 거리 중 가장 가까이 있는 치킨집 거리값 저장\t\tfor (int j = 0; j &lt; comb.size(); j++)\t\t{\t\t\tint x_diff = comb[j].first - h_cord[i].first;\t\t\tint y_diff = comb[j].second - h_cord[i].second;\t\t\tdist = abs(x_diff) + abs(y_diff);\t\t\tmin_dist = min(min_dist, dist);\t\t}\t\t\t\ttemp_sum += min_dist;\t}}void comb_chicken(int idx, int cnt){\tif (cnt == M)\t{\t\tcalc_distance();\t\tanswer = min(answer, temp_sum);\t\treturn;\t}\tfor (int i = idx; i &lt; c_cord.size(); i++)\t{\t\tif (pick[i] == true)\t\t\tcontinue;\t\tpick[i] = true;\t\tcomb.push_back(c_cord[i]);\t\t// 해당 치킨집을 골랐을 때\t\tcomb_chicken(i, cnt + 1);\t\tpick[i] = false;\t\tcomb.pop_back();\t}\t}int main(){\tinput_func();\tcomb_chicken(0, 0);\tprintf(\"%d\\n\", answer);\treturn 0;}" }, { "title": "연구소", "url": "/posts/%EC%97%B0%EA%B5%AC%EC%86%8C/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2022-10-10 00:00:00 +0900", "snippet": "연구소0이 빈칸, 1이 벽, 2는 바이러스가 있는 곳을 나타내며 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.이 때 벽을 총 3개 세울 수 있고 바이러스가 퍼질 수 없는 곳이 안전 영역 일 때 안전 영역의 크기의 최댓값을 구하는 문제바이러스가 상하좌우로 퍼진다 =&gt; 넓이 우선 탐색인 bfs을 활용한다.벽을 총 3개 세울 수 있다. =&gt; 조합으로 모든 빈 칸 중 3개를 선택하여 벽을 세우고 그 안전 영역을 구한다.=&gt; 이 때 임의의 벽을 세우는 새로운 지도를 생성하기 위해 임시 배열로 복사한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;#define ARR_MAX 8int N, M;int arr[ARR_MAX][ARR_MAX];int arr_temp[ARR_MAX][ARR_MAX];int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};int answer = 0;void bfs(){ memcpy(arr_temp, arr, sizeof(arr)); queue&lt;pair&lt;int, int&gt;&gt; q; for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { if(arr_temp[i][j] == 2) { q.push(make_pair(i, j)); } } } while(!q.empty()) { int x = q.front().first; int y = q.front().second; q.pop(); for(int i = 0; i &lt; 4; i++) { int cx = x + dx[i]; int cy = y + dy[i]; if(cx &gt;= 0 &amp;&amp; cx &lt; N &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt; M) { if(arr_temp[cx][cy] == 0) { arr_temp[cx][cy] = 2; q.push(make_pair(cx, cy)); } } } } int cnt = 0; for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { if(arr_temp[i][j] == 0) { cnt++; } } } answer = max(answer, cnt);}void virus_spread(int cnt){ if(cnt == 3) { bfs(); return; } for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { if(arr[i][j] == 0) { arr[i][j] = 1; virus_spread(cnt + 1); arr[i][j] = 0; } } }}int main(){ scanf(\"%d %d\", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; M; j++) { scanf(\"%d\", &amp;arr[i][j]); } } virus_spread(0); cout &lt;&lt; answer &lt;&lt; endl; return 0;}" }, { "title": "게리맨더링 2", "url": "/posts/%EA%B2%8C%EB%A6%AC%EB%A7%A8%EB%8D%94%EB%A7%81-2/", "categories": "CodingTest", "tags": "CodingTest, simulation", "date": "2022-10-10 00:00:00 +0900", "snippet": "게리맨더링 2문제에서 주어진 조건에 맞춰 그대로 구현을 진행한다.기본적으로 1,2,3,4,5 선거구로 나누고 그 중 기본이 되는 5번 선거구의 경계선과 기준점을 고르는 문제이다.따라서 기준점 및 경계선을 문제에서 주어진 범위 내에서 자유롭게 선택해서 선거구를 나누고 그 중 인구 차이의 최솟값을 구한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N, answer = 98765432;int arr[21][21] = { {0, }, };int sum = 0;void input_func(){\tscanf(\"%d\", &amp;N);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tfor (int j = 1; j &lt;= N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t\tsum += arr[i][j];\t\t}\t}}int diff(int x, int y, int d1, int d2){\tvector&lt;int&gt; population(5, 0);\tint temp_arr[21][21] = { {0,}, };\ttemp_arr[x][y] = 5;\t//(x, y), (x + 1, y - 1), ..., (x + d1, y - d1)\t//(x + d2, y + d2), (x + d2 + 1, y + d2 - 1), ..., (x + d2 + d1, y + d2 - d1)\tfor (int i = 1; i &lt;= d1; i++)\t{\t\ttemp_arr[x + i][y - i] = 5;\t\ttemp_arr[x + d2 + i][y + d2 - i] = 5;\t}\t//(x, y), (x + 1, y + 1), ..., (x + d2, y + d2)\t//(x + d1, y - d1), (x + d1 + 1, y - d1 + 1), ... (x + d1 + d2, y - d1 + d2)\tfor(int i = 1; i &lt;= d2; i++)\t{\t\ttemp_arr[x + i][y + i] = 5;\t\ttemp_arr[x + d1 + i][y - d1 + i] = 5;\t}\t//1번 선거구 : 1 ≤ r &lt; x + d1, 1 ≤ c ≤ y\t\tfor (int r = 1; r &lt; x + d1; r++)\t{\t\tfor (int c = 1; c &lt;= y; c++)\t\t{\t\t\tif (temp_arr[r][c] == 5)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tpopulation[0] += arr[r][c];\t\t\t}\t\t}\t}\t//2번 선거구 : 1 ≤ r ≤ x + d2, y &lt; c ≤ N\tfor (int r = 1; r &lt;= x + d2; r++)\t{\t\tfor (int c = N; c &gt; y; c--)\t\t{\t\t\tif (temp_arr[r][c] == 5)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tpopulation[1] += arr[r][c];\t\t\t}\t\t}\t}\t//3번 선거구 : x + d1 ≤ r ≤ N, 1 ≤ c &lt; y - d1 + d2\tfor (int r = x + d1; r &lt;= N; r++)\t{\t\tfor (int c = 1 ; c &lt; y - d1 + d2; c++)\t\t{\t\t\tif (temp_arr[r][c] == 5)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tpopulation[2] += arr[r][c];\t\t\t}\t\t}\t}\t//4번 선거구 : x + d2 &lt; r ≤ N, y - d1 + d2 ≤ c ≤ N\tfor (int r = x + d2 + 1; r &lt;= N; r++)\t{\t\tfor (int c = N; c &gt;= y - d1 + d2; c--)\t\t{\t\t\tif (temp_arr[r][c] == 5)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t\telse\t\t\t{\t\t\t\tpopulation[3] += arr[r][c];\t\t\t}\t\t}\t}\t//for (int r = 1; r &lt;= N; r++)\t//{\t//\tfor (int c = 1; c &lt;= N; c++)\t//\t{\t//\t\tif (temp_arr[r][c] == 5)\t//\t\t{\t//\t\t\tpopulation[4] += arr[r][c];\t//\t\t}\t//\t}\t//}\tpopulation[4] = sum - population[3] - population[2] - population[1] - population[0];\tsort(population.begin(), population.end());\treturn population[4] - population[0];}void sector(){\t//(d1, d2 ≥ 1 =&gt; 무조건 참, 1 ≤ x( =&gt; 무조건 참) &lt; x+d1+d2 ≤ N, 1 ≤ y-d1 &lt; y &lt; y+d2 ≤ N)\tfor (int x = 1; x &lt;= N; x++)\t{\t\tfor (int y = 1; y &lt;= N; y++)\t\t{\t\t\tfor (int d1 = 1; d1 &lt;= N; d1++)\t\t\t{\t\t\t\tfor (int d2 = 0; d2 &lt;= N ;d2++)\t\t\t\t{\t\t\t\t\tif (x + d1 + d2 &gt; N || 1 &gt; y - d1 || y + d2 &gt; N)\t\t\t\t\t\tcontinue;\t\t\t\t\tanswer = min(answer, diff(x, y, d1, d2));\t\t\t\t}\t\t\t}\t\t}\t}}/** 선거구 나누기기준점 (x, y)와 경계의 길이 d1, d2를 정한다. (d1, d2 ≥ 1, 1 ≤ x &lt; x+d1+d2 ≤ N, 1 ≤ y-d1 &lt; y &lt; y+d2 ≤ N)다음 칸은 경계선이다.(x, y), (x+1, y-1), ..., (x+d1, y-d1)(x, y), (x+1, y+1), ..., (x+d2, y+d2)(x+d1, y-d1), (x+d1+1, y-d1+1), ... (x+d1+d2, y-d1+d2)(x+d2, y+d2), (x+d2+1, y+d2-1), ..., (x+d2+d1, y+d2-d1)경계선과 경계선의 안에 포함되어있는 곳은 5번 선거구이다.5번 선거구에 포함되지 않은 구역 (r, c)의 선거구 번호는 다음 기준을 따른다.1번 선거구: 1 ≤ r &lt; x+d1, 1 ≤ c ≤ y2번 선거구: 1 ≤ r ≤ x+d2, y &lt; c ≤ N3번 선거구: x+d1 ≤ r ≤ N, 1 ≤ c &lt; y-d1+d24번 선거구: x+d2 &lt; r ≤ N, y-d1+d2 ≤ c ≤ N*/int main(int argc, char** argv){\tinput_func();\tsector();\tprintf(\"%d\\n\", answer);}" }, { "title": "배열 돌리기 3", "url": "/posts/%EB%B0%B0%EC%97%B4%EB%8F%8C%EB%A6%AC%EA%B8%B03/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-09 00:00:00 +0900", "snippet": "배열 돌리기 3배열의 상하, 좌우 반전, 90도 회전, 사분면 회전 등을 구현하는 문제이다.#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;int arr[101][101] = { {0, }, };int temp[101][101] = { {0,}, };int N, M, R;int calc_type = 0;// 우 하 좌 상int dy[4] = { 0,1,0,-1 };int dx[4] = { 1,0,-1,0 };void input_func(){ scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;R); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { scanf(\"%d\", &amp;arr[i][j]); } } }void copy_arr(){ for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { arr[i][j] = temp[i][j]; } }}void func1(){ memset(temp, 0x0, sizeof(temp)); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[N - 1 - i][j] = arr[i][j]; } } copy_arr();}void func2(){ memset(temp, 0x0, sizeof(temp)); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[i][M - 1 - j] = arr[i][j]; } } copy_arr();}// 점의 일대일 매칭을 해보면서 관계식을 찾는다.void func3(){ memset(temp, 0x0, sizeof(temp)); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[j][N - 1 - i] = arr[i][j]; } } int temp_num = N; N = M; M = temp_num; copy_arr();}// 점의 일대일 매칭을 해보면서 관계식을 찾는다.void func4(){ memset(temp, 0x0, sizeof(temp)); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { temp[M - 1 - j][i] = arr[i][j]; } } int temp_num = N; N = M; M = temp_num; copy_arr();}void func5(){ memset(temp, 0x0, sizeof(temp)); int div_n = N / 2; int div_m = M / 2; // 1 ==&gt; 2 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i][j + div_m] = arr[i][j]; } } // 2 ==&gt; 3 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i + div_n][j + div_m] = arr[i][j + div_m]; } } // 3 ==&gt; 4 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i+ div_n][j] = arr[i + div_n][j + div_m]; } } // 4 ==&gt; 1 for (int i = 0; i &lt; div_n; i++) { for (int j = 0; j &lt; div_m; j++) { temp[i][j] = arr[i + div_n][j]; } } copy_arr();}void print_output(){ for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { cout &lt;&lt; temp[i][j] &lt;&lt; \" \"; }cout &lt;&lt; \"\\n\"; }}int main() { input_func(); for (int i = 0; i &lt; R; i++) { scanf(\"%d\", &amp;calc_type); switch (calc_type) { case 1: func1(); break; case 2: func2(); break; case 3: func3(); break; case 4: func4(); break; case 5: func5(); break; case 6: // 6번 함수의 경우 5번 함수를 반대로 돌린 즉, 3번 돌린 결과와 같다. for (int i = 0; i &lt; 3; i++) { func5(); } break; default: break; } } print_output(); return 0;}" }, { "title": "1949. [모의 SW 역량테스트] 등산로 조성", "url": "/posts/1949.-%EB%AA%A8%EC%9D%98-SW-%EC%97%AD%EB%9F%89%ED%85%8C%EC%8A%A4%ED%8A%B8-%EB%93%B1%EC%82%B0%EB%A1%9C-%EC%A1%B0%EC%84%B1/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2022-10-09 00:00:00 +0900", "snippet": "1949. [모의 SW 역량테스트] 등산로 조성높이가 내려가는 등산로를 조성하는 문제로 문제 조건에 맞춰 구현을 수행한다.주의 : 재귀함수에서 매개변수 값에 연산을 수행하여 값을 넣는다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;using namespace std;int dy[4] = { 1, -1, 0, 0 };int dx[4] = { 0, 0, 1, -1 };int N, K;int mountmap[8][8] = { {0, }, };int longest_len = 0;int max_h = 0;bool isvisited[8][8] = { {false,}, };void input_func(){\tscanf(\"%d %d\", &amp;N, &amp;K);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;mountmap[i][j]);\t\t\tmax_h = max(mountmap[i][j], max_h);//최대 높이 탐색\t\t}\t}\tmemset(isvisited, false, sizeof(isvisited));}// lencnt는 등산로, flag K공사 깊이 만큼 깎았는지 여부void dfs(int y, int x, int lencnt, int flag){\tisvisited[y][x] = true;\tif (longest_len &lt; lencnt)\t{\t\tlongest_len = lencnt;\t}\tint cx = x;\tint cy = y;\tfor (int i = 0; i &lt; 4; i++)\t{\t\tint nx = cx + dx[i];\t\tint ny = cy + dy[i];\t\tif (nx &lt; 0 || ny &lt; 0 || nx == N || ny == N || isvisited[ny][nx])\t\t\tcontinue;\t\t// 현재 높이보다 낮은 경우(선택)\t\tif (mountmap[cy][cx] &gt; mountmap[ny][nx])\t\t{\t\t\t//flag 값을 확인하고 업데이트\t\t\tdfs(ny, nx, lencnt + 1, flag);\t\t}\t\t// 현재 높이보다 높거나 같은 경우(깎거나 종료)\t\telse\t\t{\t\t\t//깎을 경우 현재 높이보다 낮아진다면 선택, 그리고 flag는 true 일 때\t\t\tif ((mountmap[cy][cx] &gt; mountmap[ny][nx] - K) &amp;&amp; flag)\t\t\t{\t\t\t\tint temp = mountmap[ny][nx];\t\t\t\t// 현재 높이보다 1 낮을 때까지만 깎는다.\t\t\t\tmountmap[ny][nx] = mountmap[cy][cx] - 1;\t\t\t\tdfs(ny, nx, lencnt + 1, flag - 1);\t\t\t\tmountmap[ny][nx] = temp;\t\t\t}\t\t}\t}\tisvisited[y][x] = false;\treturn;}/*등산로 규칙 ① 등산로는 가장 높은 봉우리에서 시작해야 한다. ② 등산로는 산으로 올라갈 수 있도록 반드시 높은 지형에서 낮은 지형으로 가로 또는 세로 방향으로 연결이 되어야 한다.\t 즉, 높이가 같은 곳 혹은 낮은 지형이나, 대각선 방향의 연결은 불가능하다. ③ 긴 등산로를 만들기 위해 딱 한 곳을 정해서 최대 K 깊이만큼 지형을 깎는 공사를 할 수 있다. 이 때 만들 수 있는 가장 긴 등산롤르 찾아 그 길이를 출력하는 프로그램을 작성하라*/int main(int argc, char** argv){\tint tc;\tint T;\tscanf(\"%d\", &amp;T);\tfor (tc = 1; tc &lt;= T; ++tc)\t{\t\tlongest_len = 0;\t\tmax_h = 0;\t\tinput_func();\t\tfor (int i = 0; i &lt; N; i++)\t\t{\t\t\tfor (int j = 0; j &lt; N; j++)\t\t\t{\t\t\t\t// 최대 높이에서 깊이 탐색 수행\t\t\t\tif (mountmap[i][j] == max_h)\t\t\t\t{\t\t\t\t\tisvisited[i][j] = true;\t\t\t\t\tdfs(i, j, 1, 1);\t\t\t\t\tisvisited[i][j] = false;\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"#%d %d\\n\", tc, longest_len);\t}\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}" }, { "title": "배열 돌리기 2", "url": "/posts/%EB%B0%B0%EC%97%B4%EB%8F%8C%EB%A6%AC%EA%B8%B02/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-08 00:00:00 +0900", "snippet": "배열 돌리기 2첫 번째 배열 돌리기 문제에서 돌리는 횟수가 크게 증가할 경우 복잡성을 낮추는 문제이다.우리가 돌리려고 하는 사각형들의 총 길이를 알 수 있다면 그 숫자의 나머지만큼만 회전시키면 되기 때문에 1과 조금 다르게 rotate 함수에서 몇 번 회전시켜줄지를 결정한다.내 풀이#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[301][301] = { {0, }, };int N, M, R;// 우 하 좌 상 =&gt; 실제 이동방향 좌 상 우 하 마지막에 첫 좌 한칸 움직이며 소실된 startp, startp 위치를 미리 백업하고 startp+1, startp 에 저장하고 마무리int dy[4] = { 0,1,0,-1 };int dx[4] = { 1,0,-1,0 };void input_func(){ scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;R); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { scanf(\"%d\", &amp;arr[i][j]); } }}void rotate(int startp,int len) { int rect_len = R % len; //회전 횟수 설정 for (int i = 0; i &lt; rect_len; i++) { int startPoint = arr[startp][startp]; // 박스 시작 포인트 설정(시작 지점 백업) int cy = startp; int cx = startp; int k = 0; while (k &lt; 4) { int ny = cy + dy[k]; int nx = cx + dx[k]; //시작 지점은 그대로 둔다 if (ny == startp &amp;&amp; nx == startp) break; if (startp &lt;= ny &amp;&amp; ny &lt; N - startp &amp;&amp; startp &lt;= nx &amp;&amp; nx &lt; M - startp) { //차례로 시계 반대방향으로 옮김 arr[cy][cx] = arr[ny][nx]; cy = ny; cx = nx; } else { //다음에 옮길 칸이 배열 범위 넘어가버리면 해당 라인은 다 옮긴거라서 k 증가 k++; } } arr[startp + 1][startp] = startPoint; //백업 데이터 저장 }}void print_output(){ //결과 출력 for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { printf(\"%d \", arr[i][j]); } printf(\"\\n\"); }}int main() { input_func(); int cnt = min(N, M) / 2; // 박스 수 int n = N, m = M; for (int i = 0; i &lt; cnt; i++) { //박스 수만큼 회전 동작 반복 int len = (2 * n) + (2 * m) - 4; rotate(i, len); n -= 2; m -= 2; } print_output(); return 0;}" }, { "title": "배열 돌리기 1", "url": "/posts/%EB%B0%B0%EC%97%B4%EB%8F%8C%EB%A6%AC%EA%B8%B01/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-08 00:00:00 +0900", "snippet": "배열 돌리기 1배열을 돌리는 문제로 총 돌려야하는 사각형 갯수가 몇개인지, 그리고 회전을 수행할 때 반시계 방향으로 수행한다면,어떤 부분에 신경을 써야하는지에 대해서 생각해보며 문제를 해결한다.내 풀이#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int arr[300][300] = { {0, }, };int main(){\tint N, M, R;\tint srect_len;\tscanf(\"%d %d %d\", &amp;N, &amp;M, &amp;R);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; M; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[i][j]);\t\t}\t}\t//사각형 개수는 짧은 변의 절반에 해당한다. 대각점을 따라 외부사각형과 만나지않는 대각점의 개수와도 같다.\tsrect_len = N &gt; M ? M / 2 : N / 2;\t//돌릴 횟수와 돌려야하는 사각형 갯수만큼 회전을 수행한다.\tfor (int i = 0; i &lt; R; i++)\t{\t\tfor (int j = 0; j &lt; srect_len; j++)\t\t{\t\t\tint U = j;\t\t\tint D = N - 1 - j;\t\t\tint L = j;\t\t\tint R = M - 1 - j;\t\t\t// 좌 상 우 하 순으로 작업 진행\t\t\tint temp = arr[j][j];\t\t\tfor (int k = L; k &lt; R; k++)\t\t\t{\t\t\t\tarr[U][k] = arr[U][k + 1];\t\t\t}\t\t\tfor (int k = U; k &lt; D; k++)\t\t\t{\t\t\t\tarr[k][R] = arr[k + 1][R];\t\t\t}\t\t\tfor (int k = R; k &gt; L; k--)\t\t\t{\t\t\t\tarr[D][k] = arr[D][k - 1];\t\t\t}\t\t\tfor (int k = D; k &gt; U; k--)\t\t\t{\t\t\t\tarr[k][L] = arr[k - 1][L];\t\t\t}\t\t\tarr[j + 1][j] = temp;\t\t}\t}\t//결과 출력\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; M; j++)\t\t{\t\t\tprintf(\"%d \", arr[i][j]);\t\t}\t\tprintf(\"\\n\");\t}\t\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}참고할 풀이#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int arr[301][301] = { {0, }, };int N, M, R;// 우 하 좌 상int dy[4] = {0,1,0,-1};int dx[4] = {1,0,-1,0};void rotate(int rect){ for(int i = 0; i &lt; rect; i++){ //박스수만큼 반복(1칸 전진)(시작점은 start, start+1, start+2..) int startPoint = map[i][i]; //각 박스 시작은 [0][0] -&gt; [1][1] -&gt; [2][2]... int r = i; int c = i; int k = 0; while(k &lt; 4){ int nr = r + dy[k]; //map[nr][nc]는 옮길 대상임 (map[r][c]로 옮겨야 함) int nc = c + dx[k]; if(nr==i &amp;&amp; nc==i) break; if(i&lt;=nr &amp;&amp; nr&lt;N-i &amp;&amp; i&lt;=nc &amp;&amp; nc&lt;M-i){ //차례로 시계 반대방향으로 옮김 map[r][c] = map[nr][nc]; r = nr; c = nc; } else{ //다음에 옮길 칸이 배열 범위 넘어가버리면 해당 라인은 다 옮긴거라서 k 증가 k++; } } map[i+1][i] = startPoint; //처음에 시작지점 빼놨던거 마지막에 빈 자리에 넣어줌. } }int main(){ cin &gt;&gt; N &gt;&gt; M &gt;&gt; R; for(int i = 0; i&lt;N; i++){ for(int j = 0; j&lt;M; j++){ cin &gt;&gt; map[i][j]; } } int cnt = min(N,M)/2; // 박스 수 for(int i = 0; i&lt;R; i++){ //반복문 한번에 1칸 전진하는것. 총 R칸 전진 rotate(cnt); } for(int i = 0; i&lt;N; i++){ for(int j = 0; j&lt;M; j++){ cout &lt;&lt; map[i][j] &lt;&lt; \" \"; }cout &lt;&lt;\"\\n\"; } return 0;}" }, { "title": "3282. 0/1 Knapsack", "url": "/posts/3282.-01-Knapsack/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-10-08 00:00:00 +0900", "snippet": "3282. 0/1 Knapsack배낭채우기 문제(Knapsack Problem) 의 경우 보석(물건)을 자를 수 있는 Fractional Knapsack 문제와 0-1 Knapsack 문제가 있다.0-1 knapsack 문제는 DP로 문제를 해결한다.보석(물건)을 자를 수 없는 문제의 경우 특정한 기준을 정해놓고 그 기준순으로 높은 것 부터 챙기는 Greedy 알고리즘은 사용하기 어렵다.따라서 DP의 메모이제이션 특성을 이용해서 분할한 최적해들을 찾고 거슬로 올라가 최종적인 정답을 찾는다.(Divide and Conquer)이를 문제에 대입해 보면 집합 A에 N개의 보석들 중 최적으로 고른 부분집합을 가정했을 때, 집합 A가 n 번째 ㅐ보석을 포함하지 않고 있다면,n 번째 보석을 뺀 나머지 보석(n-1개) 중 최적으로 고른 부분집합이 되고, n 번째 보석을 포함하고 있다면 n-1 보석들 중 최적으로 고른 가격 합에다가 보석n의 가격을 더한 것과 같다#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int main(int argc, char** argv){\tint tc;\tint T, N, K;\tint V[101] = { 0, };\tint C[101] = { 0, };\tint dp[101][1001] = { {0,} };\tscanf(\"%d\", &amp;T);\tfor (tc = 1; tc &lt;= T; ++tc)\t{\t\tscanf(\"%d %d\", &amp;N, &amp;K);\t\tfor (int i = 1; i &lt;= N; i++)\t\t{\t\t\tscanf(\"%d %d\", &amp;V[i], &amp;C[i]);\t\t}\t\tfor (int i = 1; i &lt;= N; i++)\t\t{\t\t\tfor (int j = 1; j &lt;= K; j++)\t\t\t{\t\t\t\t// 현재 타겟으로 하는 무게보다 더 무거운 경우(선택 불가)\t\t\t\t// 물건은 선택하지 않음으로 이전 dp값을 불러온다.\t\t\t\tif (V[i] &gt; j)\t\t\t\t{\t\t\t\t\tdp[i][j] = dp[i - 1][j];\t\t\t\t}\t\t\t\t// 타겟으로 하는 무게보다 더 가벼운 경우(고를지 말지 선택 가능)\t\t\t\telse\t\t\t\t{\t\t\t\t\t// 해당 물건을 선택하는 경우와 선택하지 않은 경우 \t\t\t\t\tdp[i][j] = max((C[i] + dp[i - 1][j - V[i]]), dp[i - 1][j]);\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"#%d %d\\n\", tc, dp[N][K]);\t}\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}" }, { "title": "2819. 격자판의 숫자 이어 붙이기", "url": "/posts/2819.-%EA%B2%A9%EC%9E%90%ED%8C%90%EC%9D%98-%EC%88%AB%EC%9E%90-%EC%9D%B4%EC%96%B4-%EB%B6%99%EC%9D%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2022-10-07 00:00:00 +0900", "snippet": "2819. 격자판의 숫자 이어 붙이기격자판을 상하좌우 방향으로 이동하면서 서로 다른 일곱 자리 수들의 개수를 출력하는 문제=&gt; 해당 일곱 자리 수를 string으로 만들고 key 값으로 중복을 허용하지 않는 set container를 사용한다.=&gt; 결과 값을 set 변수의 크기를 리턴한다.test case가 여러개 반복되므로 set container는 clear() 함수를 이용해서 초기화를 수행한다.Set container노드 기반 컨테이너로 균형 이진트리로 구현되어 있음key 값들의 집합으로 이루어진 컨테이너, key 값의 중복은 허용되지 않음원소가 insert() 함수를 통해 값이 삽입되면 자동으로 정렬된다.(default 정렬 기준은 오름차순)set 선언set&lt;int&gt; s;set&lt;int&gt; s(pred); // pred를 통해 정렬 기준을 정한다.set&lt;int&gt; s2(s1); // s1을 s2에 복사한다.s.begin(); //첫 번째 원소를 가리키는 반복자s.end(); // 마지막 원소를 가리키는 반복자s.clear(); // 모든 원소 제거s.empty(); // set 원소가 비어있는 지 확인s.insert(k); //k 값 삽입s.erase(iter); // 해당 매개변수 반복자가 가리키는 원소 제거s.erase(start, end); //[start, end) 범위 원소 제거s.find(k); // 원소 k를 가리키는 반복자 반환s.size(); // 원소의 갯수 반환#include&lt;iostream&gt;#include&lt;cstdio&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;int dy[4] = { 0, 0, -1, 1 };int dx[4] = { 1, -1, 0, 0 };int arrmap[4][4] = { {0, }, };set&lt;string&gt; s;void dfs(int y, int x, int cnt, string str){\tif (cnt == 7) \t{\t\ts.insert(str);\t\treturn;\t}\tfor (int i = 0; i &lt; 4; i++)\t{\t\tint nx = x + dx[i];\t\tint ny = y + dy[i];\t\tchar ch = (char)(arrmap[ny][nx] + '0');\t\tif (nx &lt; 0 || ny &lt; 0 || nx &gt;= 4 || ny &gt;= 4)\t\t\tcontinue;\t\t\t\tdfs(ny, nx, cnt + 1, str + ch);\t}\treturn;}int main(int argc, char** argv){\tint tc;\tint T, N, K;\tint V[100] = { 0, };\tint C[100] = { 0, };\t\tscanf(\"%d\", &amp;T);\tfor (tc = 1; tc &lt;= T; ++tc)\t{\t\ts.clear();\t\tfor (int y = 0; y &lt; 4; y++)\t\t{\t\t\tfor (int x = 0; x &lt; 4; x++)\t\t\t{\t\t\t\tscanf(\"%d\", &amp;arrmap[y][x]);\t\t\t}\t\t}\t\tfor (int y = 0; y &lt; 4; y++)\t\t{\t\t\tfor (int x = 0; x &lt; 4; x++)\t\t\t{\t\t\t\tdfs(y, x, 0, \"\");\t\t\t}\t\t}\t\tprintf(\"#%d %d\\n\", tc, s.size());\t}\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}" }, { "title": "부분 수열의 합", "url": "/posts/%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-05 00:00:00 +0900", "snippet": "부분 수열의 합부분 수열을 구하고 그 합을 계산하는 문제재귀로 수열을 구하고 구한 수열의 합을 체크하여 타겟 값과 일치하는지 확인한다.#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int N, K;int A[20] = { 0, };int answer = 0;void recur_func(int curr, int total){\tif (curr == N)\t{\t\tif (total == K)\t\t{\t\t\tanswer++;\t\t}\t\treturn;\t}\t\trecur_func(curr + 1, total + A[curr]);\trecur_func(curr + 1, total);\treturn;}int main(int argc, char** argv){\tint tc;\tint T;\t\t\tscanf(\"%d\", &amp;T);\tfor (tc = 1; tc &lt;= T; ++tc)\t{\t\tanswer = 0;\t\tscanf(\"%d %d\", &amp;N, &amp;K);\t\tfor (int i = 0; i &lt; N; i++)\t\t{\t\t\tscanf(\"%d\", &amp;A[i]);\t\t}\t\trecur_func(0, 0);\t\t\t\tprintf(\"#%d %d\\n\", tc, answer);\t}\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}" }, { "title": "Digit sum", "url": "/posts/Digit-sum/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-05 00:00:00 +0900", "snippet": "Digit sum자릿수의 합을 구하는 문제로 최종적으로 한자리가 될 때까지 반복하여 자릿수를 더해준다.#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(int argc, char** argv){\tint tc;\tint T;\tscanf(\"%d\", &amp;T);\tfor (tc = 1; tc &lt;= T; ++tc)\t{\t\tlong long n = 0, fn = 0;\t\tscanf(\"%lld\", &amp;n);\t\twhile (true)\t\t{\t\t\tfn = n;\t\t\tif (n &lt; 10)\t\t\t{\t\t\t\tbreak;\t\t\t}\t\t\tn = 0;\t\t\twhile (true)\t\t\t{\t\t\t\tif (fn / 10 != 0)\t\t\t\t{\t\t\t\t\tn += (fn % 10);\t\t\t\t\tfn /= 10;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tn += (fn % 10);\t\t\t\t\tbreak;\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"#%d %lld\\n\", tc, n);\t}\treturn 0;//정상종료시 반드시 0을 리턴해야합니다.}" }, { "title": "가장 큰 정사각형 찾기", "url": "/posts/%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-04 00:00:00 +0900", "snippet": "가장 큰 정사각형 찾기가장 큰 정사각형을 찾는 문제로 점화식을 세워 해결한다.먼저 i+1, j+1 위치의 값이 1인지(정사각형 원소로 가능하면서 아직 값의 업데이트가 이뤄지지 않은 상태) 확인한다.그리고 왼쪽 대각선, 왼쪽, 위 이 세 포인트의 최솟값에 1을 더해 업데이트 한다.해당 방식으로 구한 포인트 중 max 값을 찾아 그 값을 제곱해서 정사각형 크기를 구한다.#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; board){ int answer = board[0][0]; //board가 1x1 크기 1의 정사각형으로 주어질 때 for(int i=0;i &lt; board.size() - 1;i++) { for(int j=0;j&lt;board[0].size() - 1;j++) { if(board[i+1][j+1]==1){ board[i+1][j+1] = 1 + min({board[i][j],board[i][j+1],board[i+1][j]}); answer = max(answer,board[i+1][j+1]); } } } return answer*answer;}" }, { "title": "자릿수 더하기", "url": "/posts/%EC%9E%90%EB%A6%BF%EC%88%98-%EB%8D%94%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-03 00:00:00 +0900", "snippet": "자릿수 더하기자릿수를 모두 더해 return 을 해주는 문제#include &lt;iostream&gt;using namespace std;int solution(int n){ int answer = 0; while(n &gt; 0) { answer += (n % 10); n /= 10; } return answer;}" }, { "title": "순열 검사", "url": "/posts/%EC%88%9C%EC%97%B4-%EA%B2%80%EC%82%AC/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-10-03 00:00:00 +0900", "snippet": "순열 검사배열에 배열의 길이만큼의 숫자가 1부터 n까지 중복없이 있는지 검사하는 문제#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool solution(vector&lt;int&gt; arr){ bool answer = true; sort(arr.begin(), arr.end()); for(int i = 0; i &lt; arr.size(); i++) { if(arr[i] != i + 1) { answer = false; break; } } return answer;}" }, { "title": "Embedded OS 개발", "url": "/posts/Embedded_OS-%EA%B0%9C%EB%B0%9C/", "categories": "Embedded Engineering, RTOS", "tags": "Embedded Engineering, RTOS", "date": "2022-09-19 00:00:00 +0900", "snippet": "Embedded OS 개발 프로젝트1장. 임베디드 운영체제임베디드 운영체제와 펌웨어임베디드 운영체제는 임베디드 시스템에서 동작하는 펌웨어의 일종으로서 하드웨어 성능이 일정 수준으로 올라온 현재 임베디드 장치에도 임베디드 운영체제를 많이 사용하고 있다.펌웨어란 임베디드 운영체제 유무에 상관없이 임베디드 시스템 용 전체 소프트웨어를 지칭한다.임베디드 운영체제 역시 일반 운영체제와 마찬가지로 프로세스 관리, 저장장치 관리, 네트워킹 관리, 사용자 관리, 디바이스 드라이버 등을 포함한다.여기서 디바이스 드라이버란 운영체제 안에서 하드웨어를 추상화(HAL)하는 계층을 말한다.RTOS(RealTime Operating System)운영체제3장. 기초 설정리셋 벡터ARM 코어에 전원이 들어가면 가장 먼저 수행하는 것은 리셋 벡터(reset vector)를 실행시킨다. 리셋 벡터란 0x00000000 번지 메모리 주소를 말하는 것으로 이곳에서 여러 하드웨어 세팅 등을 수행하면서 프로그램 실행을 위한 초기화 및 기초 세팅 작업을 수행한다.리셋 벡터 어셈블리 코드gcc 컴파일러는 어셈블리어로 작성된 파일도 컴파일할 수 있는데, 이때 파일 확장자의 대소문자를 구별한다..s(소문자) 파일은 전처리가 필요 없는 파일로 인식한다..S(대문자) 파일은 전처리가 필요한 파일로 인식한다.4장. 부팅실행 파일(ELF)는 메모리를 크게 세 가지로 나누어 사용한다..text 영역 : 코드가 있는 영역.data 영역 : 초기화된 전역 변수가 있는 공간.bss 영역 : 초기화되지 않은 전역 변수가 있는 공간 ⇒ 초기화되지 않은 전역 변수 이므로 파일에는 심벌과 크기만 들어있다.(변수가 실행 파일 메모리를 거의 잡아 먹지 않는다.)데이터의 형태 : 동작 모드별 스택, 태스크 스택, 전역 변수, 동적 메모리 할당데이터의 속성 : 성능 중시 데이터, 큰 공간이 필요한 데이터, 공유 데이터\\데이터의 형태와 속성에 따라 .data 영역에 할당할지, .bss 영역에 할당할지를 고민한다.위와 같이 부팅에는 두가지 옵션이 있다. 시스템에 전원이 들어가서 모든 초기화 작업을 마치고 펌웨어가 대기(idle)상태가 될 때까지 설정 시스템에 전원이 들어가고 ARM 코어가 리셋 익셉션 핸들러를 모두 처리한 다음에 본격적으로 c언어 코드로 넘어가기 직전까지 설정정 보통은 전자가 일반적이지만 이 책에서는 펌웨어가 대기 상태로 들어가는 단계를 설명하므로 후자로 표현한다.메모리 설계text 영역 : 코드가 있는 공간.data 영역 : 초기화된 전역 변수가 있는 공간.BSS 영역 : 초기화 하지 않은 전역 변수가 있는 공간text 영역 1MB 할당, data 영역과 BSS 영역에 들어갈 데이터 할당해야 함.QEMU에서는 의미가 없으므로 그냥 쭉 배치, 개별 동작 모드마다 각 1MB씩 할당.링커 스크립트 (Linker Script) QEMU가 펌웨어 파일을 읽어서 부팅하기 위해서는 입력으로 지정한 펌웨어 바이너리 파일이 ELF(Executable and Linkable Format) 형식이어야 한다. ELF 파일을 만들기 위해서는 링커(Linker)의 도움이 필요하다. 링커에게 링킹(linking)할 정보를 제공하기 위해 링커 스크립트를 정의해야 한다. 펌웨어 개발 시 동작하는 HW 환경에 맞춰 펌웨어의 섹션 배치를 조정해야 하나 여기서는 순서대로 작성하기로 한다. 링커 스크립트 navilos.ld를 작성한다익셉션 벡터 테이블(Exception Vector Table)인터럽트 및 예외 처리를 위한 주소를 모아놓은 테이블을 말한다.ARM 에는 7가지 Exception, 7가지 동작 모드가 있다Abort(ABT)Fast Interrupt Request(FIQ)Interrupt Request(IRQ)Supervisor(SVC)System(SYS)Undefined(UND)USER(USR)ABT, FIQ, IRQ, SVC, UND 모드는 exception이 발생할 때 자동으로 변경되는 동작모드SYS와 USR는 프로세서의 일반적인 동작 모드 예외 동작모드 Prefetch Abort ABT Data Abort   FIQ FIQ IRQ IRQ Reset SVC SWI   Undefined Undefined " }, { "title": "게임 맵 최단거리", "url": "/posts/%EA%B2%8C%EC%9E%84-%EB%A7%B5-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-09-04 00:00:00 +0900", "snippet": "게임 맵 최단거리최단 거리를 찾는 문제로 DFS에 비해 BFS가 더 문제해결에 적합할 것으로 판단하고 BFS로 문제를 해결한다.최단 거리를 찾기 위해 먼저 거리 배열을 생성하고, 최대 거리 값으로 초기화 한다(=&gt; 최소 거리를 찾기 위함)다음 BFS 방식으로 탐색하면서 빈 공간마다 최소거리를 업데이트 한다.이 때 BFS 탐색이 끝난 후에도 도착 지점의 최소 거리 값이 최대 거리 값에서 변하지 않았을 경우 도달 불가능한 경우이므로 -1 을 리턴하고,아닐 경우 해당 지점의 최소 거리를 그대로 리턴한다.#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};int dist[101][101] = { {10001, }, };int solution(vector&lt;vector&lt;int&gt; &gt; maps){ int answer = 0; int N = maps.size(), M = maps[0].size(); queue&lt;pair&lt;int, int&gt;&gt; q; memset(dist, 10001, sizeof(dist)); dist[0][0] = 1; answer = 1; q.push(make_pair(0, 0)); while(!q.empty()) { int cx = q.front().second; int cy = q.front().first; q.pop(); for(int i = 0; i &lt; 4; i++) { int nx = cx + dx[i]; int ny = cy + dy[i]; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; M &amp;&amp; ny &lt; N) { if(maps[ny][nx] == 0) continue; if(dist[ny][nx] &gt; dist[cy][cx] + 1) { dist[ny][nx] = dist[cy][cx] + 1; q.push(make_pair(ny, nx)); } } } } if(dist[N - 1][M - 1] == 286331153) { answer = -1; } else { answer = dist[N - 1][M - 1]; } return answer;}" }, { "title": "거리두기 확인하기", "url": "/posts/%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-09-04 00:00:00 +0900", "snippet": "거리두기 확인하기BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;" }, { "title": "신규 아이디 추천", "url": "/posts/%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/", "categories": "CodingTest", "tags": "CodingTest, 문자열", "date": "2022-09-01 00:00:00 +0900", "snippet": "신규 아이디 추천문자열 처리 관련 함수를 사용해볼 수 있는 문제이다.단계별 명령에 따라 문자열 정제를 수행한다.#include &lt;string&gt;#include &lt;vector&gt;using namespace std;string solution(string new_id) { string answer = \"\"; // Stage 1 for(int i = 0; i &lt; new_id.length(); i++) { if(new_id[i] &gt;= 'A' &amp;&amp; new_id[i] &lt;= 'Z') { new_id[i] = tolower(new_id[i]); } } // Stage 2 for(int i = 0; i &lt; new_id.length();) { if((new_id[i] &gt;= 'a' &amp;&amp; new_id[i] &lt;= 'z') || (new_id[i] &gt;= '0' &amp;&amp; new_id[i] &lt;= '9') || new_id[i] == '_' || new_id[i] == '-' || new_id[i] == '.') { i++; continue; } new_id.erase(new_id.begin() + i); } // Stage 3 for(int i = 0; i &lt; new_id.length() - 1;) { if(!(new_id[i] == '.' &amp;&amp; new_id[i + 1] == '.')) { i++; continue; } new_id.erase(new_id.begin() + i + 1); } // Stage 4 if(new_id[0] == '.' || new_id[new_id.length() - 1] == '.') { if(new_id[0] == '.') { new_id.erase(new_id.begin()); } else { new_id.erase(new_id.length() - 1); } } // Stage 5 if(new_id.length() == 0) { new_id = \"a\"; } // Stage 6 if(new_id.length() &gt;= 16) { while(new_id.length() != 15) { new_id.erase(new_id.length() - 1); } } if(new_id[new_id.length() - 1] == '.') { new_id.erase(new_id.length() - 1); } // Stage 7 if(new_id.length() &lt;= 2) { while(new_id.length() != 3) { new_id += new_id.back(); } } answer = new_id; return answer;}" }, { "title": "성격 유형 검사하기", "url": "/posts/%EC%84%B1%EA%B2%A9-%EC%9C%A0%ED%98%95-%EA%B2%80%EC%82%AC%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, 문자열", "date": "2022-09-01 00:00:00 +0900", "snippet": "성격 유형 검사하기map 과 문자열 분류를 통해 문제를 해결한다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;string solution(vector&lt;string&gt; survey, vector&lt;int&gt; choices) { string answer = \"\"; map&lt;char, int&gt; result; for(int i = 0; i &lt; choices.size(); i++) { if(choices[i] &gt; 4) { result[survey[i][1]] += (choices[i] - 4); } else if(choices[i] != 4) { result[survey[i][0]] += (4 - choices[i]); } } answer += (result['R'] &gt;= result['T'])? \"R\" : \"T\"; answer += (result['C'] &gt;= result['F'])? \"C\" : \"F\"; answer += (result['J'] &gt;= result['M'])? \"J\" : \"M\"; answer += (result['A'] &gt;= result['N'])? \"A\" : \"N\"; return answer;}" }, { "title": "퇴사 2", "url": "/posts/%ED%87%B4%EC%82%AC-2/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-08-17 00:00:00 +0900", "snippet": "퇴사 2동적 계획법으로 문제를 해결한다. 포인트는 해당 날짜에 돈을 최대한 많이 벌 수 있는 방향으로 값을 업데이트 하는 것이다.자세한 코드 설명은 코드와 함께 밑 주석으로 작성했다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;pair&lt;int, int&gt; TP[1500001];int dp[1500001] = {0, };int main(){\tint curmax = 0;\tint N;\tscanf(\"%d\", &amp;N);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d %d\", &amp;TP[i].first, &amp;TP[i].second);\t}\tfor (int i = 1; i &lt;= N + 1; i++)\t{\t\tcurmax = max(dp[i], curmax);\t\t// 해당 상담 일자표 날짜에 일을 했을 때 퇴사 날짜를 넘어가면 업데이트 하지 않는다.\t\tif (TP[i].first + i &gt; N + 1)\t\t\tcontinue;\t\t// 일을 마치는 날짜의 기존 최댓값과 해당 상담을 선택했을 때 최댓값을 비교하여 저장한다.\t\tdp[i + TP[i].first] = max(dp[i + TP[i].first], curmax + TP[i].second);\t}\tprintf(\"%d\\n\", curmax);\t\treturn 0;}" }, { "title": "AI 데이터 분석 트랙", "url": "/posts/AI-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D-%ED%8A%B8%EB%9E%99/", "categories": "Python, Machine Learning", "tags": "Python, Machine Learning", "date": "2022-08-17 00:00:00 +0900", "snippet": "AI 데이터 분석 트랙[AI 데이터 분석] 핵심 파이썬 기초 프로그래밍print() 함수의 경우 콤마(,)를 이용하여 여러 자료형을 동시에 출력할 수 있음print() print(3, \"Hello!\") 기본 자료형 숫자형 문자열=&gt; 큰 따옴표와 작은 따옴표로 구별 리스트(List)여러 자료를 보관하는 자료형다른 종류 자료형의 자료들을 함께 담을 수 있다.자료 안의 순서가 존재 cf) 주석# 주석 '''주석 주석'''변수 사용방법변수 이름 = 자료# 주석 num = 1num = \"hello\"answer = ['1', 2, 3]예약어, 공백문자, 연산자 등은 변수 이름에 들어갈 수 없다.논리 자료형참 또는 거짓을 나타내는 자료형=&gt; 비교 연산자(&lt;, &gt;=, != …)&amp;&amp; =&gt; and|| =&gt; or! =&gt; not조건문if~elif~else statement로 표현한다.반복문for idx in range(a, b):for idx in range(a):리스트 활용 list.append(d)자료 d를 리스트 마지막 원소 뒤에 추가 list.insert(i, d)인덱스 id에 자료 d를 추가, 오직 한 개의 자료만 넣을 수 있음 list.remove(d)처음 나오는 자료 d를 제거(중복 시 인덱스가 작은 원소가 제거됨) list.sort()리스트를 정렬숫자형은 오름차순, 문자열은 사전순=&gt;리스트에 원소가 모두 같은 자료형이어야 한다. 시퀀스 자료형순서가 있는 자료형리스트, 문자열, 튜플 등이 이에 속함시퀀스의 특징 원소 간의 순서가 존재=&gt; 인덱싱/슬라이싱이 가능함인덱싱/슬라이싱 할 때 음수를 넣거나 자리를 비우는 것도 가능ex)lista[-1], listb[:3] 멤버 조회in 연산자로 시퀀스 안에 원소가 있는지 확인가능ex)arr = ['a', 'b', 'c']print('a' in arr) # True 반환 길이 확인len 연산자로 시퀀스 안에 원소가 몇 개 있는지 확인 가능ex)arr = ['a', 'b', 'c']print(len(arr)) # 3 반환 연결 연산 연산자로 같은 시퀀스 두개를 이어 붙일 수 있다. a = [1, 2, 3]b = [4, 5]c = a + b # [1, 2, 3, 4, 5] 반복 연산 연산자로 시퀀스를 반복할 수 있다. ch = \"arr\" * 3 # arrarrarr 딕셔너리(Dictionary)짝꿍(인덱스, 데이터)이 있는 자료형{} 중괄호로 묶어 표현{key : value} 형식 : key를 알면 value를 조회할 수 있음Dict[key]=&gt; 딕셔너리에서 키 값을 통해 value 값을 다음과 같이 추출할 수 있음=&gt; 마찬가치로 이 방식으로 딕셔너리에 자료를 추가할 수 있음deldel 함수로 딕셔너리의 원소를 삭제할 수 있다.del Dict[key]딕셔너리의 특징 Key는 변할 수 없는 자료형이어야 한다.=&gt; 리스트는 안되고, 튜플은 된다.dict.keys() : dict의 key 값들을 모두 반환한다.dict.values() : dict의 value 값들을 모두 반환한다.data = {[1, 2, 3] : 'check'} # errordata = {(1, 2, 3) : 'check'} # ok함수의 종류 내장함수파이썬 개발자들이 이미 만들어 둔 함수2, 사용자 지정 함수사용자가 여러 코들르 묶어서 새로 만든 함수def 함수이름(매개변수): &lt;수행할 명령&gt; . . . return 반환값메서드(Method)특정 자료에 대해 특정 기능을 하는 코드함수 vs 메서드함수는 특정 기능을 한다.메서드는 특정 자료와 연관지어 기능을 한다(자료 뒤에 .을 찍어 사용한다)[AI 데이터 분석] 데이터 분석을 위한 라이브러리모듈특정 목적을 가진 함수, 자료의 모임import 키워드를 이용하여 모듈 사용.(dot) 을 쓴 후 모듈 속 함수/변수를 사용한다.패키지모듈을 폴더(Directory)로 구분하여 관리하는 것Numpy 모듈Numerical Python : 파이썬에서 대규모 다차원 배열을 다룰 수 있게 해주는 라이브러리반복문 없이 배열 처리 가능파이썬 리스트에 비해, 빠른 연산을 지원하고 메모리를 효율적으로 사용list, numpy 배열 차이점list의 경우 콤마(,) 로 배열 원소 구분numpy 의 경우 공백( )으로 배열 원소 구분파이썬 리스트와 달리 같은 데이터 타입만 저장 가능(dtype = ‘int64’ 와 같이 데이터 형 설정 가능)ndarray의 차원관련 속성 : ndim &amp; shapeindexing : 인덱스로 값을 찾아냄slicing : 인덱스의 값으로 배열의 일부분을 가져옴Boolean indexing : 배열의 각 요소의 선택여부를 Boolean mask를 이용하여 지정하는 방식Fancy indexing : 배열의 각 요소 선택을 index 배열을 전달하여 지정하는 방식원하는 요소를 지정하기 위해 indexing과 slicing을 혼합해서 사용 가능# [[ 1 2 3 4]# [ 5 6 7 8]# [ 9 10 11 12]]# 1. Indexing을 통해 값 2를 출력해보세요.answer1 = matrix[0, 1] # 2는 0행 1열에 있습니다.# 2. Slicing을 통해 매트릭스 일부인 9, 10을 가져와 출력해보세요.answer2 = matrix[2:, :2] # 2행 첫 두 개 열에 9, 10 이 있습니다. (2:, :2)# 3. Boolean indexing을 통해 5보다 작은 수를 찾아 출력해보세요.answer3 = matrix[matrix &lt; 5]# 4. Fancy indexing을 통해 두 번째 행만 추출하여 출력해보세요.answer4 = matrix[ [ 1 ] ] # 두번째 행의 인덱스는 1입니다.Pandas 모듈Pandas 란?구조화된 데이터를 효과적으로 처리하고 저장Array 계산에 특화된 Numpy 기반으로 설계됨 SeriesNumpy의 array 가 보강된 형태Data와 Index를 가지고 있음Series 는 값(value)을 ndarray 형태로 가지고 있음=&gt; numpy.ndarray classdtype 인자로 데이터 타입을 지정할 수 있음data = pd.Series([1,2,3,4], dtype = \"float\")`인덱스를 지정할 수 있고 인덱스로 접근 가능data = pd.Series([1,2,3,4], index = ['a','b','c','d'])Dictionary와 형태가 비슷하고 이를 활용하여 Series를 생성할 수 있다.fruit_dict = { 'apple' = 1, 'banana' = 2, 'pineapple' = 3}fruit_series = pd.Series(fruit_dict) DataFrame여러 개의 Series가 모여서 행과 열을 이룬 데이터fruit_dict = { 'apple' = 1, 'banana' = 2, 'pineapple' = 3}fruit_series = pd.Series(fruit_dict)country = pd.DataFrame({ 'fruit' : fruit_series 'vegetable' : vegetable_series})마찬가지로 Dictionary를 활용하여 DataFrame을 생성할 수 있다.set_index로 함수로 특정 Dict key 값을 DataFrame의 인덱스로 삼을 수 있다.DataFrame 속성shape : 데이터 shape을 표현한다.(인덱스 제외)size : 데이터 size를 표현한다.ndim : 데이터가 몇 차원지를 표현한다.values : 데이터 값들을 출력한다.DataFrame의 index와 column에 이름을 지정할 수 있다.데이터 선택 및 변경하기데이터 선택 indexing/Slicing loc : 명시적 iloc : 암묵적country.loc['china'] # 인덱싱country.loc['japan' : 'korea', : 'population'] # 슬라이싱 (index, column).iloc : 파이썬 스타일의 정수 인덱스 인덱싱 슬라이싱country.iloc[0] # 인덱싱country.iloc[1:3, :2] # 슬라이싱 (index, column)컬럼명을 활용하여 DataFrame에서 데이터 선택 가능country['gdp'] # 컬럼 즉 Series Classcountry[['gdp']] # DataFremeMasking 연산이나 query 함수를 활용하여 조건에 맞는 DataFrame 행 추출 가능country[country['population'] &lt; 10000]country.query(\"population &gt; 10000\")Series도 numpy array 처럼 연산자 활용 가능데이터 추가/수정리스트로 추가하거나 딕셔너리로 추가할 수 있음NaN 값으로 초기화 한 새로운 커럼 추가 가능country['gdp'] = np.nan # 새로운 컬럼 추가후 nan 값으로 초기화DataFrame 에서 컬럼 삭제 후 원본 변경`country.drop('gdp', axis = 1, inplace = True) # axis = 1 열 방향 / axis = 0 횡방향# inplace = True : 원본 변경 / inplace = False : 원본 변겯 XMatplotlib 모듈ax.legend( loc='upper left', # legend 위치 설정 shadow=True, # 음영 fancybox=True, # legend border를 둥글게 변경 borderpad=2 # legend border size 크기 조절)[AI 데이터 분석] 머신 러닝 시작하기머신러닝명시적으로 프로그래밍을 하지 않고도 컴퓨터가 학습할 수 있는 능력을 갖게 하는 것지도학습, 비지도학습, 강화학습으로 나눌 수 있음지도학습, 비지도학습예측해야 할 결과에 대한 정답 데이터가 있는 경우 지도학습 없는 경우 비지도 학습으로 나뉜다.강화학습의 경우 기계가 데이터를 스스로 생성하여 학습하는 것을 말한다.자료의 형태자료의 형태를 파악함으로써 머신러닝 모델을 결정하거나 데이터 전 처리를 어떤 방식으로 수행할지를 결정할 수 있다. 수치형 자료=&gt; 양적 자료=&gt; 수치로 측정이 가능한 자료 범주형 자료=&gt; 질적 자료=&gt; 수치로 측정이 불가능한 자료 수치형 자료의 특징범주형 자료와 달리 수치로 구성되어 있기에 통계값을 사용한 요약이 가능함시각적 자료로는 이론적 근거 제시가 쉽지 않는 단점을 보완함머신러닝을 위한 데이터 전 처리 이해하기머신러닝 과정데이터 수집 =&gt; 데이터 분석 및 전 처리 =&gt; 머신러닝 학습 =&gt; 머신러닝 평가데이터 전 처리의 역할 머신러닝의 입력 형태로 데이터 변환(특성 엔지니어링) 결측값 및 이상치를 처리하여 데이터 정제 학습용 및 평가용 데이터 분리전 처리를 통하여 데이터의 결측값 및 이상치를 처리하고 학습용과 평가용 데이터를 분리한다.범주형 자료 변환 방식 명목형 자료수치 매핑 방식 =&gt; 범주를 0 or 1로 매핑더미 기법 =&gt; 더미 기법을 사용하여 각 범주를 0 or 1로 변환(변수를 범주에 따라 만들어 매핑) 순서형 자료수치 매핑 방식 =&gt; 수치에 매핑하여 변환하지만 수치 간 크기 차이는 커스텀 가능, 이 크기 차이는 머신 러닝 결과에 영향을 끼친다. 수치형 자료 변환 방식 정규화 방식데이터 스케일링변수간 범위 차이가 많이 나면 사용정규화, 표준화, 범주화(=&gt; 변수의 값보다 범주가 중요한 경우 사용)결측값 처리하기일반적인 머신러닝 모델의 입력 값으로 결측값을 사용할 수 없음따라서 Null, None, NaN 등의 결측값 처리 필요1) 결측값이 존재하는 샘플 삭제2) 결측값이 많이 존재하는 변수 삭제3) 결측값을 다른 값으로 대체이상치 처리하기이상치가 있으면 모델의 성능의 저하를 초래이상치는 일반적으로 전 처리 과정에서 제거하고 어떤 값이 이상치인지 판단하는 기준이 중요함이상치 판단 기준 방법1) 통계 지표(카이제곱 검정, IQR 지표) 를 사용하여 판단2) 데이터 분포를 보고 직접 판단3) 머신러닝 기법을 사용하여 이상치 분류머신러닝 모델 평가를 위해서 학습에 사용하지 않은 평가용 데이터를 필요하고 보통 전체 데이터 량의 7:3~8:2 정도의 비율로 학습용, 평가용 데이터를 분리한다.지도학습 데이터 분리feature 데이터 : label을 예측하기 위한 입력 값label 데이터 : 예측해야할 대상이 되는 데이터회귀 분석이란?데이터를 가장 잘 설명하는 모델을 찾아 입력값에 따른 미래 결과값을 예측하는 알고리즘=&gt; 완벽한 예측은 불가능하므로 최대한 잘 근사하도록 하는 선형 회귀 모델을 찾아야 한다.단순 선형 회귀=&gt; 데이터를 설명하는 모델을 직선 형태(1차 함수)로 가정=&gt; 이를 위해 y절편 값과 기울기를 구해야한다.Loss 함수=&gt; 실제 값과 예측 값의 차이의 제곱의 합으로 Loss 함수를 정의한다.Loss 함수에서 주어진 값은 입력 값과 실제 값이다.Loss 함수 크기 값을 줄이기 위해1) 경사 하강법, least squraes 등의 방법이 있다.이러한 단순 선형 회귀의 특징으로는,입력값이 1개인 경우에만 적용이 가능입력값과 결과값의 관계를 알아보는 데 용이함입력값이 결과값에 얼마나 영향을 미치는지 알 수 있음두 변수 간의 관계를 직관적으로 해석하고자 하는 경우 활용다중 선형 회귀=&gt; 입력 값이 여러 개인 경우 활용할 수 있는 회귀 알고리즘여러 개의 입력값과 결과값 간의 관계 확인 가능어떤 입력값이 결과값에 어떠한 영향을 미치는지 알 수 있음여러 개의 입력값 사이 간의 상관 관계가 높은 경우 결과에 대한 신뢰성을 잃을 가능성이 있음회귀 평가 지표RSS - 단순 오차실제 값과 예측 값의 단순 오차 제곱의 합MSE - 평균 제곱 오차RSS 에서 데이터 수 만큼 나눈 값, 작을 수록 모델의 성능이 높다고 평가 가능MAE - 평균 절대 오차절댓값을 씌운 오차 값MSE의 경우 Outlier에 민감하고 MAE의 경우 변동성이 큰 지표와 낮은 지표를 같이 예측할 시 유용R^2(결정 계수)회귀 모델의 설명력을 표현하는 지표1에 가까울수록 높은 성능의 모델이라고 해석할 수 있음TSS는 데이터 평균 값과 실제 값의 차이의 제곱오차가 없을수록 1에 가까운 값을 갖음값이 0인 경우, 데이터의 평균 값을 출력하는 직선 모델을 의미함음수 값이 나온 경우, 평균 값 예측보다 성능이 좋지 않음[AI 데이터 분석] 딥러닝 시작하기퍼셉트론인공지능 « 머신러닝 « 딥러닝머신러닝 기술 중 대표적인 한 가지 기술로 머신러닝을 꼽을 수 있다.인공 신경망이란 생물학의 신경망에서 영감을 얻은 학습 알고리즘으로 사람의 신경 시스템을 모방했다.생물의 신경 세포를 본따 입력에 따라 actiivation function, weight, bias 값 등을 통해 출력값을 도출한다.퍼셉트론은 선형 분류기로써 데이터 분류가 가능함단일 퍼셉트론으로는 선형 분류기 이상의 문제 해결이 어려움 =&gt; 다층 퍼셉트론의 등장단층 퍼셉트론을 여러 개 쌓아 다층 퍼셉트론을 구현한다.입력층과 출력층 사이의 모든 layer 명칭 =&gt; Hidden layer다층 퍼셉트론의 경우장점으로는 분류의 성능이 올라가지만 단점으로 가중치의 개수가 늘어나고 그 가중치를 모두 구해야한다는 단점이 있다.어떠한 클래스에 속할지 값을 도출하는 알고리즘 =&gt; 분류 알고리즘ex)트리 구조 기반, 확률 모델 기반, 결정 경계 기반, 인공신경망의사 결정 나무란?스무고개 처럼 여러 질문들을 통해 정답을 찾아가는 모델을 말한다.혼동 행렬=&gt; 분류 모델의 성능을 평가하기 위해 사용함Negative가 중요한 경우 =&gt; 잘못 예측하는 상황이 더 큰 영향을 미침Positive가 중요한 경우 =&gt; 악성 종양을 양성 종양으로 오판정하는 것과 같이 에러를 검출하는 것을 실패하는 것이 크리티컬 한 경우재현율(Recall, TPR)실제로 Positive 인 데이터 중에서 모델이 Positive 인 데이터를 Negative로 판단하면 안되는 경우 사용하는 지표딥러닝 모델예측값과 실제값 간 오차를 최소화하는 모델의 파라미터 등을 찾고 loss function 을 최소화하는 가중치를 찾는다.Forward propagation입력 값을 바탕으로 출력 값을 계산가중치를 loss function 값이 작아지도록 업데이트 하기 위해 경사 하강법과 같은 방식을 사용한다.이미지 데이터를 위한 딥러닝 모델이미지 데이터의 경우 모두 같은 크기를 갖는 이미지로 통일한다.(해상도 통일)또한 색을 표현 하는 방식도 통일한다.합성곱 신경망(CNN)특징 위주로 학습을 하기 때문에 이미지 학습에 적절한다.CNN + FC=&gt; Convolution layer + Pooling layer 조합으로 특징을 추출하고 Fully-Connnected Layer 분류를 수행한다.Convolution layer 은 필터(커널)를 통해 이미지를 이동하며 새로운 이미지(피쳐맵)을 생성한다.피쳐 맵의 크기 변경(Padding, Striding)Padding : 원본 이미지의 상화좌우에 더미 값 추가Striding : 필터 이동거리(Stride) 설정 Pooling layer 이미지의 왜곡(noise) 영향을 축소하는 과정Max PoolingAverage Pooling Fully Connected Layer 추출된 특징을 사용하여 이미지를 분류자연어 처리를 위한 데이터 전처리과정 자연어 전 처리 단어 표현 모델 적용하기자연어 전처리에는 Noise canceling, Tokenizing, StopWord removal 등이 있다.Noise Canceling(오류 교정)자연어 문장의 스펠링 체크 및 띄어쓰기 교정Tokenizing(토큰화)문장을 토큰으로 나눔, 토큰은 어절 단어 등으로 목적에 따라 다르게 정의한다.StopWord removal(불용어 제거)불필요한 단어를 의미하는 불용어를 제거하는 방법" }, { "title": "섬의 개수", "url": "/posts/%EC%84%AC%EC%9D%98-%EA%B0%9C%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, Graph, BFS, DFS", "date": "2022-08-16 00:00:00 +0900", "snippet": "섬의 개수섬의 개수를 세는 문제로 Flood fill algorithm으로 해결한다.DFS, BFS 두 가지 방식으로 문제를 풀이할 수 있다.BFS 문제 풀이#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int w, h;int map[51][51] = { {0, }, };bool isvisited[51][51] = { {false, }, };int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };void bfs(int y, int x){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tisvisited[y][x] = true;\tq.push(make_pair(y, x));\twhile (!q.empty())\t{\t\tint cy = q.front().first;\t\tint cx = q.front().second;\t\tq.pop();\t\tfor (int i = 0; i &lt; 8; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\tif (nx &gt;= 0 &amp;&amp; nx &lt; w &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; h)\t\t\t{\t\t\t\tif (!isvisited[ny][nx] &amp;&amp; map[ny][nx])\t\t\t\t{\t\t\t\t\tisvisited[ny][nx] = true;\t\t\t\t\tq.push(make_pair(ny, nx));\t\t\t\t}\t\t\t}\t\t}\t\t\t}\treturn;}int main(){\t\twhile (true)\t{\t\tscanf(\"%d %d\", &amp;w, &amp;h);\t\tif (w == 0 &amp;&amp; h == 0)\t\t\tbreak;\t\tint island = 0;\t\tfor (int i = 0; i &lt; h; i++)\t\t{\t\t\tfor (int j = 0; j &lt; w; j++)\t\t\t{\t\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t\t}\t\t}\t\tfor (int i = 0; i &lt; h; i++)\t\t{\t\t\tfor (int j = 0; j &lt; w; j++)\t\t\t{\t\t\t\tif (!isvisited[i][j] &amp;&amp; map[i][j])\t\t\t\t{\t\t\t\t\tisland++;\t\t\t\t\tbfs(i, j);\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"%d\\n\", island);\t\tmemset(map, 0, sizeof(map));\t\tmemset(isvisited, false, sizeof(isvisited));\t}\treturn 0;}DFS 문제 풀이##include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;int w, h;int map[51][51] = { {0, }, };bool isvisited[51][51] = { {false, }, };int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };int dy[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };void dfs(int y, int x){\tisvisited[y][x] = true;\tfor (int i = 0; i &lt; 8; i++)\t{\t\tint nx = x + dx[i];\t\tint ny = y + dy[i];\t\tif (nx &gt;= 0 &amp;&amp; nx &lt; w &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; h)\t\t{\t\t\tif (!isvisited[ny][nx] &amp;&amp; map[ny][nx])\t\t\t{\t\t\t\tisvisited[ny][nx] = true;\t\t\t\tdfs(ny, nx);\t\t\t}\t\t}\t}\treturn;}int main(){\t\twhile (true)\t{\t\tscanf(\"%d %d\", &amp;w, &amp;h);\t\tif (w == 0 &amp;&amp; h == 0)\t\t\tbreak;\t\tint island = 0;\t\tfor (int i = 0; i &lt; h; i++)\t\t{\t\t\tfor (int j = 0; j &lt; w; j++)\t\t\t{\t\t\t\tscanf(\"%d\", &amp;map[i][j]);\t\t\t}\t\t}\t\tfor (int i = 0; i &lt; h; i++)\t\t{\t\t\tfor (int j = 0; j &lt; w; j++)\t\t\t{\t\t\t\tif (!isvisited[i][j] &amp;&amp; map[i][j])\t\t\t\t{\t\t\t\t\tisland++;\t\t\t\t\tdfs(i, j);\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"%d\\n\", island);\t\tmemset(map, 0, sizeof(map));\t\tmemset(isvisited, false, sizeof(isvisited));\t}\treturn 0;}" }, { "title": "연결 요소의 개수", "url": "/posts/%EC%97%B0%EA%B2%B0-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B0%9C%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, Graph, BFS, DFS", "date": "2022-08-15 00:00:00 +0900", "snippet": "연결 요소의 개수그래프 노드 연결 요소의 개수를 세는 문제로 총 몇개의 연결 요소가 존재하는지 확인하는 문제이다.DFS, BFS 두 가지 방식으로 문제를 풀이해보면 다음과 같다.BFS 문제 풀이#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define MAX_NUM 1001vector&lt;int&gt; connected[MAX_NUM];bool isvisited[MAX_NUM] = { false, };int N, M;void bfs(int num){\tqueue&lt;int&gt; q;\t \tisvisited[num] = true;\tq.push(num);\twhile (!q.empty())\t{\t\tint cur = q.front();\t\tq.pop();\t\tfor (int i = 0; i &lt; connected[cur].size(); i++)\t\t{\t\t\tint next = connected[cur][i];\t\t\tif (!isvisited[next])\t\t\t{\t\t\t\tisvisited[next] = true;\t\t\t\tq.push(next);\t\t\t}\t\t}\t}}int main(){\tint a, b, answer = 0;\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; M; i++)\t{\t\tscanf(\"%d %d\", &amp;a, &amp;b);\t\tconnected[b].push_back(a);\t\tconnected[a].push_back(b);\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tif (!isvisited[i])\t\t{\t\t\tanswer++;\t\t\tbfs(i); \t\t}\t}\tprintf(\"%d\", answer);\treturn 0;}DFS 문제 풀이#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;#define MAX_NUM 1001vector&lt;int&gt; connected[MAX_NUM];bool isvisited[MAX_NUM] = { false, };int N, M;void dfs(int num){\tisvisited[num] = true;\tfor (int i = 0; i &lt; connected[num].size(); i++)\t{\t\tint next = connected[num][i];\t\tif (!isvisited[next])\t\t{\t\t\tdfs(next);\t\t}\t}\treturn;}int main(){\tint a, b, answer = 0;\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; M; i++)\t{\t\tscanf(\"%d %d\", &amp;a, &amp;b);\t\tconnected[b].push_back(a);\t\tconnected[a].push_back(b);\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tif (!isvisited[i])\t\t{\t\t\tanswer++;\t\t\tdfs(i);\t\t}\t}\tprintf(\"%d\", answer);\treturn 0;}" }, { "title": "결혼식", "url": "/posts/%EA%B2%B0%ED%98%BC%EC%8B%9D/", "categories": "CodingTest", "tags": "CodingTest, Graph", "date": "2022-08-15 00:00:00 +0900", "snippet": "결혼식그래프 문제로, 조건을 보면 친구와 친구의 친구까지 초대하기로 했고 그 숫자를 세는 문제이다.먼저 나와 연결된 친구를 먼저 체크하고 방문체크를 수행한다. 이 후, 내 친구를 루트 노드로 삼아 친구의 친구를 탐색하여 방문처리한다.최종적으로 방문 처리된 노드들을 체크하여 총 초대 인원을 계산한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define MAX_NUM 501int relation[MAX_NUM][MAX_NUM] = { {0,}, };bool isvisited[MAX_NUM] = { false, };bool afriend[MAX_NUM] = { false, };int main(){\tint n, m, answer = 0;\tscanf(\"%d\", &amp;n);\tscanf(\"%d\", &amp;m);\tfor (int i = 0; i &lt; m; i++)\t{\t\tint a, b;\t\tscanf(\"%d %d\", &amp;a, &amp;b);\t\trelation[a][b] = 1;\t\trelation[b][a] = 1;\t}\tfor (int i = 2; i &lt;= n; i++)\t{\t\tif (relation[1][i] == 1)\t\t{\t\t\tisvisited[i] = true;\t\t\tafriend[i] = true;\t\t}\t}\tfor (int i = 2; i &lt;= n; i++)\t{\t\tif (afriend[i])\t\t{\t\t\tfor (int j = 1; j &lt;= n; j++)\t\t\t{\t\t\t\tif (relation[i][j] == 1 &amp;&amp; isvisited[j] == false)\t\t\t\t{\t\t\t\t\tisvisited[j] = true;\t\t\t\t}\t\t\t}\t\t}\t}\tfor (int i = 2; i &lt;= n; i++)\t{\t\tif (isvisited[i])\t\t{\t\t\tanswer++;\t\t}\t}\tprintf(\"%d\", answer);\treturn 0;}" }, { "title": "책 리뷰(파이썬을 여행하는 히치하이커를 위한 안내서)", "url": "/posts/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%84-%EC%97%AC%ED%96%89%ED%95%98%EB%8A%94-%ED%9E%88%EC%B9%98%ED%95%98%EC%9D%B4%EC%BB%A4%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%95%88%EB%82%B4%EC%84%9C/", "categories": "Book Review", "tags": "Book Review", "date": "2022-08-14 00:00:00 +0900", "snippet": "책 리뷰(파이썬을 여행하는 히치하이커를 위한 안내서)4장 코드 작성하기 관련 내용 요약코드 스타일PEP8파이썬을 위한 코드 스타일 카이드이며 작명 컨벤션, 코드 레이아웃, 공백 등 코드 스타일 주제를 다룬다.PEP20파이썬 코드 스타일 관련 20계명이 담겨있다.Python에서 권장되는 코딩 스타일 명시보다는 암시가 좋다. 여유로운 것이 밀집한 것보다 좋다. try문을 사용하여 오류를 처리하라 함수 인자는 사용하기에 직관적이어야 한다.4.1. 위치 인자4.2. 키워드 인자4.3. 가변 인자 리스트4.4. 가변 키워드 인자 딕셔너리 함수의 결과 값은 한 곳에서만 반환하자 컨벤션 같음을 확인하는 방법 딕셔너리 요소에 접근하기 리스트 다루기 매우 긴 한 줄의 코드를 여러 줄로 나누기 관용구" }, { "title": "스택 수열", "url": "/posts/%EC%8A%A4%ED%83%9D-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, Stack", "date": "2022-08-13 00:00:00 +0900", "snippet": "스택 수열문제의 조건을 해설해보면스택의 숫자를 오름차순으로 Push하고 이 때 Stack을 이용해서 해당 숫자들로 구성된 수열을 만들 수 있는지에 대한 문제이다.따라서 일단 입력한 숫자를 cnt 변수라는 오름차순 위한 변수와 비교하며 스택에 숫자를 쌓고 이 때 스택의 맨 위값과 입력값이 같으면 pop을,그렇지 않으면 해당 수열은 stack으로 구현할 수 없으므로 NO를 출력하고 프로그램을 종료한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ stack&lt;int&gt; st; vector&lt;char&gt; answer; int n; int cnt = 1; scanf(\"%d\", &amp;n); for (int i = 0; i &lt; n; i++) { int num; scanf(\"%d\", &amp;num); while (cnt &lt;= num) { st.push(cnt); cnt++; answer.push_back('+'); } if (st.top() == num) { st.pop(); answer.push_back('-'); } else { printf(\"NO\\n\"); return 0; } } for (int i = 0; i &lt; answer.size(); i++) { printf(\"%c\\n\", answer[i]); } return 0;}" }, { "title": "CERT C Coding Rule", "url": "/posts/CERT_C/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-08-11 00:00:00 +0900", "snippet": "CERT C Coding Rule Const를 캐스트로 없애지 마라\tConst로 선언된 자료형의 자료를 캐스팅하여 없애고 수정하는 등의 행위를 하지 말고 복사 등의 방식을 활용하여 수정하고 활용하라 Sizeof 피연산자가 다른 부수 효과를 가지면 안 된다.\tSizeof 안 피연산자에 다른 연산 넣지 않기( 적용 안됨) 타입이나 변수의 크기를 결정할 때는 sizeof를 사용하라 논리연산자 and 나 or의 단축평가 방식 인지\t(and, or 연산이 이미 결정된 경우 그 다음 논리 조건은 따지지 않고 넘어감) Volatile 지정자를 캐스팅하여 없애지 마라 초기화되지 않은 메모리를 참조하지 마라 널포인터가 역참조 되지 않음을 보장하라\tMalloc 할당 시 반환되는 포인터가 NULL이 아님을 체크하라 포인터를 더 엄격하게 할당된 포인터 타입으로 변환하지 마라\tEx) int* -&gt; char* 불분명한 소스에서 얻어지는 정수 값은 제한을 강제하라\t경계값을 설정하여 강제하기 열거형 상수가 유일한 값으로 매핑되도록 보장하라\t명시적 선언이 없거나, 첫 번째 멤버만 값을 주거나, 모든 멤버에 명시적으로 값을 표현하거나 이 세가지 방식으로 열거형 표현 % 연산자를 쓸 때 나머지가 양수라고 가정하지 마라 비트 연산자는 unsigned 피연산자에만 사용하라 동일한 데이터에 비트 연산자와 산술 연산자를 수행하지 마라\tEx) (x « 2) + 1 과 같은 행동 금지 Unsigned 정수 연산이 래핑되지 않도록 주의하라 \t0 – 1=&gt; 65535 등의 일 발생하지 않도록 경계 검사 수행 Signed 정수 연산이 오버플로우가 발생하지 않도록 주의 하라. 음수나 피연산자의 비트보다 더 많은 비트를 시프트 하지마라. 부동소수점의 에러를 발견하고 처리하라\tZero division error 등의 에러 예외처리 부동소수점 변수를 루프 카운터로 사용하지 마라 함수에 복소수를 사용하면서 실제 값을 얻을 거라 기대하지 마라 수학 함수에서 도메인 에러나 영역 에러를 찾고 예방하라\tSqrt(-1), log(-1) 과 같은 에러를 방지하기 위해 예외를 처리하라는 것 부동소수점 연산용 정수는 먼저 부동소수점으로 바꿔라\t오버플로우 등을 방지하기 위해 부동소수점 변수로 바꿔서(대입, 타입캐스팅) 연산 수행 부동소수점 변환이 새로운 타입의 범위 안에 들어가는지 확인하라 배열의 크기를 얻을 때 포인터를 sizeof 피연산자로 사용하지 마라\t배열이 해당 지역 내에서 선언된 것이 아닐 경우 sizeof를 하게 되면 배열의 크기가 아닌 포인터가 반환되기 때문에 따로 배열의 크기를 매개변수로 받아라 암시적으로 초기화된 경우라도 배열의 경계를 명시적으로 지정하라 배열의 인덱스가 유효한 범위 안에 있음을 보장하라 충분한 크기의 공간에서 복사가 진행됨을 보장하라 루프에서 반복자가 배열의 끝을 넘어 접근하지 않게 하라 배열이 아닌 객체에 대한 포인터에 정수를 더하거나 빼지 마라" }, { "title": "짝지어 제거하기", "url": "/posts/%EC%A7%9D%EC%A7%80%EC%96%B4-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, 문자열", "date": "2022-08-09 00:00:00 +0900", "snippet": "짝지어 제거하기기본적인 스택 문제로 문자열이 짝지어질 경우 스택에서 꺼내고 최종적으로 스택이 비어있는지 차있는지를 확인한다.#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;int solution(string s){ int answer = 0; stack&lt;int&gt; st; for(int i = 0; i &lt; s.length(); i++) { if(!st.empty() &amp;&amp; st.top() == s[i]) { st.pop(); } else { st.push(s[i]); } } if(st.empty()) { answer = 1; } return answer;}" }, { "title": "집합", "url": "/posts/%EC%A7%91%ED%95%A9/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-08-09 00:00:00 +0900", "snippet": "집합비트 마스킹 문제로 문제를 이진(1 or 0)으로 표현할 수 있을 때 이를 비트 마스킹 문제로 해결한다.해당 문제의 경우 조건을 보면,add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)all: S를 {1, 2, …, 20} 으로 바꾼다.empty: S를 공집합으로 바꾼다.다음과 같이 추가 or 제거 등으로 표현할 수 있으므로 이를 이진으로 표현할 수 있다.해당 연산들의 비트 마스킹 기법들을 생각해두자.#include &lt;iostream&gt;using namespace std;int main(){ ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); int M = 0, answer = 0, num = 0; string str; cin &gt;&gt; M; while(M--) { cin &gt;&gt; str; if (str == \"add\") { cin &gt;&gt; num; answer |= (1 &lt;&lt; num); } else if (str == \"remove\") { cin &gt;&gt; num; answer &amp;= ~(1 &lt;&lt; num); } else if (str == \"check\") { cin &gt;&gt; num; if (answer &amp; (1 &lt;&lt; num)) { cout &lt;&lt; 1 &lt;&lt; '\\n'; } else { cout &lt;&lt; 0 &lt;&lt; '\\n'; } } else if (str == \"toggle\") { cin &gt;&gt; num; answer ^= (1 &lt;&lt; num); } else if (str == \"all\") { answer = (1 &lt;&lt; 21) - 1; } else if (str == \"empty\") { answer = 0; } } return 0;}" }, { "title": "로봇 청소기", "url": "/posts/%EB%A1%9C%EB%B4%87%EC%B2%AD%EC%86%8C%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DFS", "date": "2022-08-09 00:00:00 +0900", "snippet": "로봇 청소기로봇 청소기 작동 방식현재 위치를 청소한다.현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.DFS 로 해결했고 기본적인 탐색 문제에 방향 전환이 추가된 문제이다.다만 방향을 표현하는 d 변수가 실제 반시계로 회전했을 때 인덱스와 맞춰주는 과정이 필요하다.또한 종료 조건으로는 후진한 상태에서 4. 종료조건을 만났을 때 결과 출력 후 뒤이은 재귀 호출 잆이 프로세스를 종료하도록 exit(0) 함수를 사용한다.return 문과 exit(0), exit(1)의 차이exit 함수는 c언어 에서는 stdlib.h 헤더파일에 존재하는 함수로 C언어로 작성된 프로세스 내 파일 입출력 중인 것을 저장하고 프로세스 종료하여 운영체제로 권한을 넘기는 것을 의미한다.이 때 exit(0) 함수는 정상종료를, exit(1) 은 비정상 에러메시지 종료를 의미한다.return 문의 경우 함수 속에서 함수를 종료하는 함수로 exit와 같이 그 프로세스를 종료하는 것은 아니다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int map[51][51] = { 0, };// 왼쪽부터 회전 서 =&gt; 남 =&gt; 동 =&gt; 북// 방향 번호 북 =&gt; 동 =&gt; 남 =&gt; 서int dx[4] = { -1, 0, 1, 0 };int dy[4] = { 0, 1, 0, -1 };int N, M;int answer = 0;void dfs(int cx, int cy, int cd){ if (map[cx][cy] == 0) { // 방문 처리 =&gt; 청소가 되었음을 표현 map[cx][cy] = 2; answer++; } for (int i = 0; i &lt; 4; i++) { int nd = (cd + 3 - i) % 4; int nx = cx + dx[nd]; int ny = cy + dy[nd]; // 북동남서 순을 서남동북 순으로 변환하기 위해 +3 을 해주고 순서가 정 반대이므로 -i 를 하여 뒤집어준다. if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) { if (map[nx][ny] == 0) { dfs(nx, ny, nd); } } } // 네 방향 모두 청소가 이미 되어있거나 벽인 경우 에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다. // 뒤집기 즉 후진 하기 위해서는 방향을 반대로 바꿔야한다. int nd = (cd + 2) % 4; int nx = cx + dx[nd]; int ny = cy + dy[nd]; // 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다. // 뒤쪽 방향이 모두 벽인 경우 바로 프로세스 종료 if (map[nx][ny] == 1) { printf(\"%d\\n\", answer); exit(0); } // 바라보는 방향 유지 dfs(nx, ny, cd);}int main(){ int r, c, d; scanf(\"%d %d\", &amp;N, &amp;M); scanf(\"%d %d %d\", &amp;r, &amp;c, &amp;d); for (int i = 0; i &lt; N; i++) { for (int j = 0; j &lt; M; j++) { scanf(\"%d\", &amp;map[i][j]); } } dfs(r, c, d); return 0;}" }, { "title": "피보나치 함수", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-08-08 00:00:00 +0900", "snippet": "피보나치 함수0 =&gt; 1 01 =&gt; 0 12 =&gt; 1 13 =&gt; 1 24 =&gt; 2 35 =&gt; 3 56 =&gt; 5 8대각 형태로 숫자가 꼬리물기 하는 것을 볼 수 있다.0 =&gt; 1 =&gt; 1 =&gt; 1 =&gt; 2 =&gt; 3 =&gt; 5…점화식을 세워보면,dp[i] = dp[i - 1] + dp[i - 2]0 과 1의 경우만 따로 케이스를 세워 출력하여 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int T;int dp[41] = { 0, 1, 1, };int maxnum = 0;int main(){\tscanf(\"%d\", &amp;T);\tfor (int i = 3; i &lt;= 40; i++)\t{\t\tdp[i] = dp[i - 1] + dp[i - 2];\t}\tfor (int i = 0; i &lt; T; i++)\t{\t\tint x;\t\tscanf(\"%d\", &amp;x);\t\tif (x == 0)\t\t\tcout &lt;&lt; \"1\" &lt;&lt; \" \" &lt;&lt; \"0\" &lt;&lt; \"\\n\";\t\telse if (x == 1)\t\t\tcout &lt;&lt; \"0\" &lt;&lt; \" \" &lt;&lt; \"1\" &lt;&lt; \"\\n\";\t\telse\t\t\tcout &lt;&lt; dp[x - 1] &lt;&lt; \" \" &lt;&lt; dp[x] &lt;&lt; \"\\n\";\t}\treturn 0;}" }, { "title": "python Tip", "url": "/posts/Python_Tip/", "categories": "python", "tags": "python", "date": "2022-08-07 00:00:00 +0900", "snippet": "python TipPycharm 에서 코드 내 pip install 명령어 사용하기 subprocess.check_call() 함수 사용하기```pythonimport subprocesssubprocess.check_call([sys.executable, “-m”, “pip”, “install”, ‘numpy’])subprocess.check_call([sys.executable, “-m”, “pip”, “install”, ‘pandas==1.3.5’])2. os.system() 함수 사용하기```pythonimport osos.system(\"pip install numpy\")파이썬을 파이썬 답게해당 내용은 프로그래머스에 ‘파이썬을 파이썬 답게’ 라는 교육프로그램을 요약한 것입니다.2차원 배열 각 행 길이 반환def solution(mylist): return list(map(len, mylist))몫과 나머지 함수파이썬의 divmod와 unpacking을 이용하여 몫과 나머지를 다음과 같이 구할 수 있다.a = 9b = 2print(*divmod(a, b))n진법으로 표기된 string을 10진법 숫자로 변환하기 - int 함수파이썬의 경우 int 함수에서 다음과 같이 진법 변환을 지원한다. int(x, base=10)num = '3212'base = 5answer = int(num, base)문자열 정렬함수문자열 좌측, 중앙, 우측 정렬에 관련된 함수는 다음과 같다.s = '가나다라'n = 7s.ljust(n) # 좌측 정렬s.center(n) # 가운데 정렬s.rjust(n) # 우측 정렬파이썬에는 알파벳을 출력하는 별도의 함수가 있다.import string string.ascii_lowercase # 소문자 abcdefghijklmnopqrstuvwxyzstring.ascii_uppercase # 대문자 ABCDEFGHIJKLMNOPQRSTUVWXYZstring.ascii_letters # 대소문자 모두 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZstring.digits # 숫자 0123456789원본을 유지한채 정렬된 리스트 구하기원래대로라면 깊은 복사 수행 후 sort 함수 사용list1 = [3, 2, 5, 1]list2 = copy.deepcopy(list1)list2.sort()다음과 같이 sorted 함수를 사용하면 해당 문제를 해결할 수 있음list1 = [3, 2, 5, 1]list2 = sorted(list1)zip 함수에 대해…zip 함수를 이용한 2차원 배열 뒤집기를 예로 들면,기존 스타일의 2차원 배열 뒤집기의 경우 다음과 같이 표현될 수 있다.mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]new_list = [[], [], []]for i in range(len(mylist)): for j in range(len(mylist[i])): new_list[i].append(mylist[j][i])다음과 같이 unpacking과 zip 함수를 사용하여 구현할 수 있다.mylist = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]new_list = list(map(list, zip(*mylist))) 리스트 언패킹으로 괄호 제거([1, 2, 3] [4, 5, 6] [7, 8, 9]) zip([], [], []) : zip 함수 내에 3개씩의 정수를 가진 세 개의 리스트가 들어가있는 형태 각각의 리스트에서 한개씩 꺼내 3개의 튜플을 반환([(1, 4, 7), (2, 5, 8), (3, 6, 9)]) map 함수로 리스트화[[1, 4, 7], [2, 5, 8], [3, 6, 9]]packing 과 unpackingpacking : 인자로 받은 여러개의 값을 하나의 객체로 합쳐서 받을 수 있도록 한다.def sum_func(*num): result = 0 for num in num: result += num return resultprint(sum_all(1, 2, 3)) # 6print(sum_all(1, 2, 3, 4, 5, 6)) # 21unpacking : 여러개의 객체를 포함하고 있는 하나의 객체를 풀어준다.packing의 경우 매개변수에 *를 붙이고 unpacking의 경우 인자 앞에 붙여서 사용한다.def sum_func(x, y, z): return x + y + znumbers = [1, 2, 3]print(sum(*numbers)) # 출력 : 6zip 함수 세부 활용법zip 함수 설명=&gt; zip(*iterables)는 각 iterables 의 요소들을 모으는 이터레이터를 만듭니다.튜플의 이터레이터를 돌려주는데, i 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 i 번째 요소를 포함합니다.사용 예 #1 - 여러 개의 Iterable 동시에 순회할 때 사용list1 = [1, 2, 3, 4]list2 = [100, 120, 30, 300]list3 = [392, 2, 33, 1]answer = []for number1, number2, number3 in zip(list1, list2, list3): print(number1 + number2 + number3)사용 예 #2 - Key 리스트와 Value 리스트로 딕셔너리 생성하기파이썬의 zip 함수와 dict 생성자를 이용하면 코드 단 한 줄로, 두 리스트를 합쳐 딕셔너리로 만들 수 있습니다.animals = ['cat', 'dog', 'lion']sounds = ['meow', 'woof', 'roar']answer = dict(zip(animals, sounds)) # {'cat': 'meow', 'dog': 'woof', 'lion': 'roar'}index를 활용하여 원소에 접근하는 방법 대신 zip 함수 활용 케이스인접한 list 내부 변수끼리의 차 계산def solution(mylist): answer = [] for i in range(len(mylist)-1): answer.append(abs(mylist[i] - mylist[i+1])) return answerif __name__ == '__main__': mylist = [83, 48, 13, 4, 71, 11] print(solution(mylist))def solution(mylist): answer = [] for number1, number2 in zip(mylist, mylist[1:]): answer.append(abs(number1 - number2)) return answerif __name__ == '__main__': mylist = [83, 48, 13, 4, 71, 11] print(solution(mylist))모든 멤버의 type 변환하기 - maplist1 = ['1', '100', '33']list2 = list(map(int, list1))sequence 멤버를 하나로 이어붙이기 - joinjoin 함수를 사용하여 문자열을 concat 할 수 있음my_list = ['1', '100', '33']answer = ''for value in my_list: answer += valuemy_list = ['1', '100', '33']answer = ''.join(my_list) # '110033'sequence type의 * 연산파이썬에서는 * 연산자를 통해 반복 리스트나 문자열을 만들 수 있다.n = 3answer = 'abc' * n # 'abcabcabc'n = 3answer= [123, 456] * n # [123, 456, 123, 456, 123, 456]곱집합(Cartesian product) 구하기 - product파이썬에서는 itertools.product를 이용하면, for 문을 사용하지 않고도 곱집합을 구할 수 있다.import itertoolsiterable1 = 'ABCD'iterable2 = 'xy'iterable3 = '1234'print(list(itertools.product(iterable1, iterable2, iterable3)))2차원 리스트를 1차원 리스트로 만들기(Flatten) - from_iterablemy_list = [[1, 2], [3, 4], [5, 6]]# 방법 1 - sum 함수answer = sum(my_list, [])# 방법 2 - itertools.chainimport itertoolslist(itertools.chain.from_iterable(my_list))# 방법 3 - itertools와 unpackingimport itertoolslist(itertools.chain(*my_list))# 방법 4 - list comprehension 이용[element for array in my_list for element in array]# 방법 5 - reduce 함수 이용 1from functools import reducelist(reduce(lambda x, y: x+y, my_list))# 방법 6 - reduce 함수 이용 2from functools import reduceimport operatorlist(reduce(operator.add, my_list))# 방법 7 - numpy 라이브러리의 flatten 이용import numpy as npnp.array(my_list).flatten().tolist()순열과 조합 - combinations, permutations순열과 조합에 관한 파이썬에서의 함수 설명import itertoolspool = ['A', 'B', 'C']print(list(map(''.join, itertools.permutations(pool)))) # 3개의 원소로 순열 만들기print(list(map(''.join, itertools.permutations(pool, 2)))) # 2개의 원소로 순열 만들기print(list(map(''.join, itertools.combinations(pool)))) # 3개의 원소로 순열 만들기print(list(map(''.join, itertools.combinations(pool, 2)))) # 2개의 원소로 순열 만들기가장 많이 문자, 숫자 찾기 - Counter파이썬의 collections.Counter 클래스를 사용하면 해당 문제를 간단하게 해결할 수 있음import collectionsmy_list = [1, 2, 3, 4, 5, 6, 7, 8, 7, 9, 1, 2, 3, 3, 5, 2, 6, 8, 9, 0, 1, 1, 4, 7, 0]answer = collections.Counter(my_list)print(answer[1]) # = 4print(answer[3]) # = 3print(answer[100]) # = 0flag 대신 for-else 사용하기flag 옵션을 사용해서 문제를 해결하는 경우import mathif __name__ == '__main__': numbers = [int(input()) for _ in range(5)] multiplied = 1 flag = True for number in numbers: multiplied *= number if math.sqrt(multiplied) == int(math.sqrt(multiplied)): flag = False print('found') break if flag: print('not found')import mathif __name__ == '__main__': numbers = [int(input()) for _ in range(5)] multiplied = 1 for number in numbers: multiplied *= number if math.sqrt(multiplied) == int(math.sqrt(multiplied)): print('found') break else: print('not found') # for 구문이 break 등으로 중간에 빠져나오지 않고 끝가지 실행 됐을 때 else 문 실행두 변수의 값 바꾸기 - swap파이썬의 경우 다른 언어와 다르게 temp 라는 swap을 위한 임시 변수 없이 바로 두 변수의 값을 바꿀 수 있음a = 3b = 'abc'temp = aa = bb = tempa = 3b = 'abc'a, b = b, a # 다음과 같이 값 스왑 가능이진 탐색하기 - binary search파이썬에는 이진 탐색 알고리즘 모듈이 있어 해당 메소드를 사용하여 이진 탐색을 수행할 수 있다.import bisectmylist = [1, 2, 3, 7, 9, 11, 33]print(bisect.bisect(mylist, 3)) # 3이라는 값의 위치를 찾아 반환클래스 인스턴스 출력하기 - class의 자동 string casting기존처럼 클래스 인스턴스를 출력(print)하기 위해서 별도의 print 메서드를 선언하고 사용해야 한다.class Coord(object): def __init__(self, x, y): self.x, self.y = x, ypoint = Coord(1, 2)print( '({}, {})'.format(point.x, point.y) ) # 또는def print_coord(coord): print( '({}, {})'.format(coord.x, coord.y) )print_coord(point)class Coord(object): def __init__ (self, x, y): self.x, self.y = x, y def __str__ (self): return '({}, {})'.format(self.x, self.y)point = Coord(1, 2) print(point)# __str__ 호출가장 큰 수, infMAX 값 등을 할당 할때 사용min_val = float('inf')max_val = float('-inf')with-as 구문을 이용한 파일 입출력기존 방식은 EOF를 만날 때까지, 파일 읽기를 라인 바이로 반복한다.f = open('myfile.txt', 'r')while True: line = f.readline() if not line: break raw = line.split() print(raw)f.close()파이썬에서는 with-as 구문을 이용하여 코드를 간결하게 만들 수 있다.별도의 file close 함수를 호출 할 필요가 없고, readlines가 EOF 까지 읽으므로, EOF 체크가 불필요하다.with open('myfile.txt') as file: for line in file.readlines(): print(line.strip().split('\\t'))" }, { "title": "정수 삼각형", "url": "/posts/%EC%A0%95%EC%88%98-%EC%82%BC%EA%B0%81%ED%98%95/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-08-06 00:00:00 +0900", "snippet": "정수 삼각형dp 문제로 총 2가지 경우의 수가 있다. 삼각형 외곽위치의 경우 본인 + 이전 위치의 끝 or 처음 dp값 삼각형 내부의 경우 현재 위치에서 왼쪽 대각선, 오른쪽 대각선의 dp값 크기 비교 후 저장해당 경우의 수를 고려하며 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int n;int tri[501][501] = { {0,}, };int dp[501][501] = { {0,}, };int maxnum = 0;void dp_func(int(*arr)[501]){\tdp[0][0] = tri[0][0];\tfor (int i = 1; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt;= i; j++)\t\t{\t\t\tif (j == 0)\t\t\t\tdp[i][j] = dp[i - 1][j] + tri[i][j];\t\t\telse if (j == i)\t\t\t\tdp[i][j] = dp[i - 1][j - 1] + tri[i][j];\t\t\telse\t\t\t\tdp[i][j] = max(dp[i - 1][j - 1] + tri[i][j], dp[i - 1][j] + tri[i][j]);\t\t\t\t\t}\t}}int main(){\tscanf(\"%d\", &amp;n);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt;= i; j++)\t\t{\t\t\tscanf(\"%d\", &amp;tri[i][j]);\t\t}\t}\tdp_func(tri);\tfor (int i = 0; i &lt; n; i++)\t{\t\tif (dp[n - 1][i] &gt; maxnum)\t\t\tmaxnum = dp[n - 1][i];\t}\tcout &lt;&lt; maxnum &lt;&lt; '\\n';\treturn 0;}" }, { "title": "포도주 시식", "url": "/posts/%ED%8F%AC%EB%8F%84%EC%A3%BC-%EC%8B%9C%EC%8B%9D/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-08-01 00:00:00 +0900", "snippet": "포도주 시식예전 풀었던 계단 오르기 문제와 유사한 문제이지만 조건이 다른 것은 계단 오르기는 마지막 숫자를 무조건 골라야했지만이 문제는 선택할 수 있다. 이 점에 유의하면서 경우의 수를 찾아보면 해당 위치의 포도주를 고르지 않는 경우 해당 위치의 포도주를 고르고 이전 두개를 고르는 경우 해당 위치의 포도주를 고르고 하나를 고르는 경우=&gt; 이 세가지 경우 중 최댓값을 메모리에 저장한다.(Memoization)```cpp#include #include #include #include using namespace std;int n;int arr[10001] = { 0, };int dp[10001] = { 0, };void dp_func(int* arr){\tdp[0] = 0;\tdp[1] = arr[1];\tdp[2] = arr[1] + arr[2];\tfor (int i = 3; i &lt;= n; i++)\t{\t\tdp[i] = max(dp[i - 1], max((dp[i - 3] + arr[i - 1] + arr[i]), (dp[i - 2] + arr[i])));} } int main() {scanf(\"%d\", &amp;n);for (int i = 1; i &lt;= n; i++){\tscanf(\"%d\", &amp;arr[i]);}dp_func(arr); cout &lt;&lt; dp[n] &lt;&lt; '\\n';return 0; }```" }, { "title": "최대공약수와 최소공배수", "url": "/posts/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98%EC%99%80-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-31 00:00:00 +0900", "snippet": "최대공약수와 최소공배수유클리드 호제법을 사용하여 최대 공약수와 최소 공배수를 구한다.먼저 최대공약수의 경우 입력받은 숫자가 10000 이하의 숫자이므로 10000이하의 숫자에서 최대공약수를 탐색한다.최대공배수의 경우 두 숫자를 모두 최대공약수로 나누고 최소공배수를 곱해 답을 구한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int gcd(int x, int y){\tint answer = 1;\tfor (int i = 2; i &lt;= 10000; i++)\t{\t\tif (x % i == 0 &amp;&amp; y % i == 0)\t\t{\t\t\tanswer = i;\t\t}\t}\treturn answer;}int lcm(int x, int y, int gn){\tint tx = 0, ty = 0;\ttx = x / gn;\tty = y / gn;\treturn tx * ty * gn;}int main(){\tint gn = 0, ln = 0;\tscanf(\"%d %d\", &amp;N, &amp;M);\tgn = gcd(N, M);\tln = lcm(N, M, gn);\tprintf(\"%d\\n\", gn);\tprintf(\"%d\\n\", ln);\treturn 0;}" }, { "title": "책 리뷰(반도체 넥스트 시나리오)", "url": "/posts/%EB%B0%98%EB%8F%84%EC%B2%B4-%EB%84%A5%EC%8A%A4%ED%8A%B8-%EC%8B%9C%EB%82%98%EB%A6%AC%EC%98%A4/", "categories": "Book Review", "tags": "Book Review", "date": "2022-07-31 00:00:00 +0900", "snippet": "책 리뷰(반도체 넥스트 시나리오)PCB가 주로 초록색인 이유?PCB에 반도체를 접합할 때는 대량 생산에 적합한 SMT(Surface Mount Technology) 기술을 활용한다. 이는 PCB에 솔도 페이스트 라는 접합 소재를 인쇄하고열을 가해 그 위에 반도체를 붙이는 것이 때 PCB 접합부 에 결함이 발생하여 전기 신호가 잘 전달되지 못하는 등의 결함이 발생할 수 있는데 옛날에는 사람이 이것을 확인했기 때문에 눈에 편안한초록색 PCB를 사용하게 되었다.용어 정리반도체반도체란 전기가 통하지 않는 재질(Ex 실리콘)에 13족 15족의 불순물 원소를 화학적으로 결합(도핑) 재질의 비저항 상수를 낮춘 물체즉 도핑을 통해 조건에 따라 전기가 흐르기도하고 안 흐르기도 하게 조절하는 물체비저항 상수 : 전자 흐름에 대한 저항성 영향MOSFETMOSFET의 기능은 캐리어(정공 또는 전자)의 흐름과 함께 채널 폭에서 발생하는 전기적 변화전하 캐리어는 소스 단자를 통해 채널로 들어가고 드레인을 통해 방출채널의 너비는 Gate의 전극의 전압에 의해 제어가 되며 소스와 드레인 사이에 존재CMOSN-type MOSFET과 P-type MOSFET의 특성을 상호보완하는 특징이는 소비 전력면에서 개별 MOSFET보다 우수하고 BJT 트랜지스터에 비해 집적도과 50~100배 더 높다기본적인 NOR, NOT Gater를 구성하기 위해 훨씬 더 많은 트랜지스터가 필요하기 때문D램 , S램D램구조가 매우 간단(Transistor 1개, Capacitor 1개), 전력 소모량이 적다.데이터를 기억하고 있으려면 주기적으로 전기를 충전(refresh)해줘야 함S램구조가 상대적으로 복잡(Transistor 6개), 전력소모가 심함, 주로 캐시 메모리로 사용Fe램강유전체인 Fe를 사용하여 전원이 끊어저도 데이터를 보존하는 비휘발성 메모리단점으로는 크기를 꼽고있다.FOWLP, FOPLPFOWLP(Fan Out Wafer Level Package)WLP : 패키징 공정을 수행하고 소자를 자른 과정 =&gt; 패키징 공정 수월, 소자의 크기 줄임, 접합 소재를 많이 달지 못함FOPLP(Fan Out Panel Level Package)PLP : 웨이퍼 대신 PCB를 사용하기 때문에 원형 웨이퍼를 사용할 때보다 면적 효율이 높다.단점으로는 열에 약하다는 단점이 있다.SoC, SiPSoC(System on Chip) : CPU, GPU, RAM 등 모든 반도체를 하나의 반도체로 통합하는 기술SiP(System in Package) : 모든 반도체를 하나의 패키지로 만드는 기술Firmware 란?Firmware는 하드웨어와 소프트웨어의 특성을 모두 가지고 있는 것으로 하드웨어를 원하는 동작을 하게 하기 위해 필요한 핵심 프로그램을 말한다.이를 제어하는 회로로 만들기에는 하드웨어의 구조가 복잡해지기에 이를 적은 비용을 소모하는 소프트웨어로 대체하는 것이다.기존에는 ROM에 저장하여 수정이 불가능했지만 요즘은 Flash에 펌웨어를 저장하여 업데이트가 가능하도록 한다.MCU(Micro Controller Unit)IC 칩 내부에 프로세서와 메모리 입출력버스 등을 하나주로 기능을 설정하고 정해진 일을 수행하도록 프로그래밍 시켜 기기를 동작시키는데 사용한다." }, { "title": "N과 M (6)", "url": "/posts/N%EA%B3%BC-M-(7)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking, Permutation", "date": "2022-07-27 00:00:00 +0900", "snippet": "N과 M (6)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력 가능 =&gt; 방문 여부 체크 X#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 0; i &lt; N; i++)\t{\t\tansarr[cnt] = arr[i];\t\tdfs(cnt + 1);\t}}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + N);\tdfs(0);\treturn 0;}" }, { "title": "N과 M (6)", "url": "/posts/N%EA%B3%BC-M-(6)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking, Combination", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (6)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력해해서는 안된다. =&gt; 방문 여부 체크사전 순 증가하는 순서로 출력해야한다. =&gt; 배열 정렬오름차순인 수열만 출력한다 =&gt; 출력전 수열이 오름차순인지 체크#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };bool isvisited[10001] = { false, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M - 1; i++)\t\t{\t\t\tif (ansarr[i] &gt;= ansarr[i + 1])\t\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\t\tif (isvisited[arr[i]] == true)\t\t\tcontinue;\t\telse\t\t\tansarr[cnt] = arr[i];\t\tisvisited[arr[i]] = true;\t\tdfs(cnt + 1);\t\tisvisited[arr[i]] = false;\t}\treturn;}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + (N + 1));\tdfs(0);\treturn 0;}" }, { "title": "N과 M (5)", "url": "/posts/N%EA%B3%BC-M-(5)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking, Combination", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (5)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.중복되는 순열을 출력해해서는 안된다. =&gt; 방문 여부 체크사전 순 증가하는 순서로 출력해야한다. =&gt; 배열 정렬#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[9] = { 0, };int ansarr[9] = { 0, };bool isvisited[10001] = { false, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", ansarr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\t\tif (isvisited[arr[i]] == true)\t\t\tcontinue;\t\telse\t\t\tansarr[cnt] = arr[i];\t\tisvisited[arr[i]] = true;\t\tdfs(cnt + 1);\t\tisvisited[arr[i]] = false;\t}\treturn;}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tfor (int i = 1; i &lt;= N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tsort(arr, arr + (N + 1));\tdfs(0);\treturn 0;}" }, { "title": "N과 M (3)", "url": "/posts/N%EA%B3%BC-M-(4)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking, Permutation", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (4)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.조건 중 중요한 것은,같은 수를 여러 번 골라도 된다.고른 수열은 비내림차순이어야 한다.길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다.다음과 같이 다음 숫자가 이전 숫자보다 작아서는 안된다.따라서 작은 경우 출력하지 않은 형태로 간단히 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N, M;bool isvisited[8] = {false, };int arr[8] = { 0, };void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M - 1; i++)\t\t{\t\t\tif (arr[i] &gt; arr[i + 1])\t\t\t\treturn;\t\t}\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", arr[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn ;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tarr[cnt] = i;\t\tdfs(cnt + 1);\t}}int main(){\tscanf(\"%d %d\", &amp;N, &amp;M);\tdfs(0);\treturn 0;}" }, { "title": "N과 M (3)", "url": "/posts/N%EA%B3%BC-M-(3)/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking, Permutation", "date": "2022-07-23 00:00:00 +0900", "snippet": "N과 M (3)순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.같은 수를 여러번 체크해도 되므로 방문 문자열은 굳이 쓰지 않아도 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int N, M;int arr[8] = { 0, };bool isvisited[8] = {false,};void dfs(int cnt){\tif (cnt == M)\t{\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tprintf(\"%d \", arr[i]);\t\t\t\t\t}\t\tcout &lt;&lt; '\\n';\t\treturn ;\t}\tfor (int i = 1; i &lt;= N; i++)\t{\t\tisvisited[i] = true;\t\tarr[cnt] = i;\t\tdfs(cnt + 1);\t\tisvisited[i] = false;\t}}int main(){\t\tscanf(\"%d %d\", &amp;N, &amp;M);\tdfs(0);\treturn 0;}" }, { "title": "괄호 회전하기", "url": "/posts/%EA%B4%84%ED%98%B8-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Stack", "date": "2022-07-22 00:00:00 +0900", "snippet": "괄호 회전하기스택 문제로 추가적인 조건으로 문자열을 한칸씩 shift register 처럼 밀어가며 체크해야하는 문제이다.이를 반복문과 문자열 회전 부분을 추가하여 문제를 해결한다.#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;int solution(string s) { int answer = 0; for(int i = 0; i &lt; s.length(); i++) { stack&lt;int&gt; st; bool flag = true; for(int j = 0; j &lt; s.length(); j++) { if(s[j] == '[' || s[j] == '(' || s[j] == '{') { st.push(s[j]); } else if(s[j] == ']') { if(st.top() == '[') st.pop(); else { flag = false; break; } } else if(s[j] == '}') { if(st.top() == '{') st.pop(); else { flag = false; break; } } else if(s[j] == ')') { if(st.top() == '(') st.pop(); else { flag = false; break; } } } if(st.empty() &amp;&amp; flag == true) answer++; /* rotate */ char ch = s.front(); s.erase(s.begin()); s.push_back(ch); } return answer;}" }, { "title": "이친수", "url": "/posts/%EC%9D%B4%EC%B9%9C%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-07-21 00:00:00 +0900", "snippet": "이친수DP 문제로 DP[1] 의 경우 1, DP[2] 의 경우 10DP[3] 의 경우 100, 101DP[4] 의 경우 1000, 1001, 1010DP[5] 의 경우 10000, 10001, 10101, 10100, 10010…을 미루어 보아 하기 코드와 같은 점화식을 짤 수 있다.해당 패턴은 트리 구조로 손으로 써 내려가면 경우의 수를 빨리 찾을 수 있다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N;long long dp[91] = { 0, };int main(){\tscanf(\"%d\", &amp;N);\tdp[1] = 1;\tdp[2] = 1;\tfor (int i = 3; i &lt;= N; i++)\t{\t\tdp[i] = dp[i - 1] + dp[i - 2];\t}\tcout &lt;&lt; dp[N] &lt;&lt; '\\n';\treturn 0;}" }, { "title": "로또", "url": "/posts/%EB%A1%9C%EB%98%90/", "categories": "CodingTest", "tags": "CodingTest, recursive, back-tracking", "date": "2022-07-20 00:00:00 +0900", "snippet": "로또순열 문제로 재귀와 백트래킹을 사용하여 문제를 해결한다.dfs 함수에서 start 매개변수의 경우 lotto의 인덱스를 가리키고 depth 매개 변수의 경우 S의 인덱스를 나타낸다.dfs(0, 0) 부터 시작해서 dfs(6, 6)까지 진행하며 첫 번째 결과를 출력하고 다시 dfs(5, 5)로 돌아가 i++이 된 상태로 S[depth] 에 lotto[i] 가 저장된다.이상태로 S[5] 가 들어갈 수 있는 값이 모두 결정되면 dfs(4, 4)로 돌아가 S[4], S[5] 가 결정 될 수 있는 경우의 수를 출력한다…이 과정을 반복하며 모든 순열을 출력하고 함수가 종료된다.재귀 함수로 설계하므로 종료조건에 대해서 고민하고 return; 을 붙여주자.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int n;int lotto[14] = {0, };int S[6] = { 0, };void dfs(int start, int depth){\tif (depth == 6)\t{\t\tfor (int i = 0; i &lt; 6; i++)\t\t{\t\t\tprintf(\"%d \",S[i]);\t\t}\t\tprintf(\"\\n\");\t\treturn;\t}\tfor (int i = start; i &lt; n; i++)\t{\t\tS[depth] = lotto[i];\t\tdfs(i + 1, depth + 1);\t}}int main(){\twhile (true)\t{\t\tscanf(\"%d\", &amp;n);\t\tif (n == 0)\t\t\tbreak;\t\tmemset(lotto, 0x0, sizeof(int) * 13);\t\tfor (int i = 0; i &lt; n; i++)\t\t{\t\t\tscanf(\"%d\", &amp;lotto[i]);\t\t}\t\tdfs(0, 0);\t\tprintf(\"\\n\");\t}\t\treturn 0;}" }, { "title": "예산", "url": "/posts/%EC%98%88%EC%82%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-16 00:00:00 +0900", "snippet": "예산이분 탐색 문제#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int N, M;int arr[10000] = { 0, };int bsearch(int end){\tint start = 0, sum = 0, cost = 0;\twhile (start &lt;= end)\t{\t\tsum = 0;\t\tcost = (start + end) / 2;\t\tfor (int i = 0; i &lt; N; i++)\t\t{\t\t\tif (arr[i] &gt; cost)\t\t\t\tsum += cost;\t\t\telse\t\t\t\tsum += arr[i];\t\t}\t\tif (sum &lt;= M)\t\t\tstart = cost + 1;\t\telse\t\t\tend = cost - 1;\t}\treturn end;}int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;arr[i]);\t}\tscanf(\"%d\", &amp;M);\tsort(arr, arr + N);\tprintf(\"%d\", bsearch(arr[N - 1]));\treturn 0;}" }, { "title": "삼각형과 세 변", "url": "/posts/%EC%82%BC%EA%B0%81%ED%98%95%EA%B3%BC-%EC%84%B8-%EB%B3%80/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-16 00:00:00 +0900", "snippet": "삼각형과 세 변단순 구현 문제로 삼각형의 세 변 길이를 보고 삼각형의 형태를 파악하는 문제이다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(){\tvector&lt;int&gt; v;\twhile (true)\t{\t\tfor (int i = 0; i &lt; 3; i++)\t\t{\t\t\tint len;\t\t\tscanf(\"%d\", &amp;len);\t\t\tv.push_back(len);\t\t}\t\tsort(v.begin(), v.end(), greater&lt;int&gt;());\t\tif (v[0] == 0)\t\t\tbreak;\t\tif (v[0] &gt;= (v[1] + v[2]))\t\t{\t\t\tprintf(\"Invalid\\n\");\t\t}\t\telse if (v[0] == v[1] &amp;&amp; v[1] == v[2])\t\t{\t\t\tprintf(\"Equilateral\\n\");\t\t}\t\telse if (v[0] == v[1] || v[1] == v[2])\t\t{\t\t\tprintf(\"Isosceles\\n\");\t\t}\t\telse\t\t{\t\t\tprintf(\"Scalene\\n\");\t\t}\t\tv.clear();\t}\t\treturn 0;}" }, { "title": "최소 힙", "url": "/posts/%EC%B5%9C%EC%86%8C-%ED%9E%99/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-14 00:00:00 +0900", "snippet": "최소 힙우선순위 큐를 이용하여 최소 힙을 구현하고 0이 나올 때마다 최소 값을 출력하는 로직을 설계한다.=&gt; 우선순위 큐에 greater 를 사용한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int main(void){\tint N, x;\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;x);\t\tif(x != 0)\t\t\tpq.push(x);\t\tif (x == 0)\t\t{\t\t\tif (pq.empty())\t\t\t{\t\t\t\tprintf(\"0\\n\");\t\t\t\tcontinue;\t\t\t}\t\t\t\t\t\t\tprintf(\"%d\\n\", pq.top());\t\t\tpq.pop();\t\t}\t}\treturn 0;}" }, { "title": "올림픽", "url": "/posts/%EC%98%AC%EB%A6%BC%ED%94%BD/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-13 00:00:00 +0900", "snippet": "올림픽단순 구현 문제금메달 비교 =&gt; 동등? =&gt; 은메달 비교 =&gt; 동등? =&gt; 동메달 비교#include &lt;iostream&gt;using namespace std;int N, K;int gold[1001] = { 0, }, silver[1001] = { 0, }, bronze[1001] = { 0, };int main(void){\tint place = 1;\tscanf(\"%d %d\", &amp;N, &amp;K);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint country;\t\tscanf(\"%d\", &amp;country);\t\tscanf(\"%d %d %d\", &amp;gold[country], &amp;silver[country], &amp;bronze[country]);\t}\tfor (int i = 0; i &lt; N; i++)\t{\t\tif (gold[i] &gt; gold[K])\t\t{\t\t\tplace++;\t\t}\t\telse\t\t{\t\t\tif (gold[i] == gold[K])\t\t\t{\t\t\t\tif (silver[i] &gt; silver[K])\t\t\t\t{\t\t\t\t\tplace++;\t\t\t\t}\t\t\t\telse\t\t\t\t{\t\t\t\t\tif (silver[i] == silver[K])\t\t\t\t\t{\t\t\t\t\t\tif (bronze[i] &gt; bronze[K])\t\t\t\t\t\t\tplace++;\t\t\t\t\t}\t\t\t\t}\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", place);\treturn 0;}" }, { "title": "책 리뷰(코딩의 기술)", "url": "/posts/Book_Review(%EC%BD%94%EB%94%A9%EC%9D%98-%EA%B8%B0%EC%88%A0)/", "categories": "Book Review", "tags": "Book Review", "date": "2022-07-13 00:00:00 +0900", "snippet": "책 리뷰(코딩의 기술)1장. 읽기 좋은 코드를 작성하는 기술읽기 좋은 코드는 가독성을 지표로 표현할 수 있다. 이러한 코드의 가독성은 코드의 보수성에 영향을 주는데,여기서 코드의 보수성이란 코드의 변경, 추가 테스트가 얼마나 용이한지를 의미한다.읽기 좋은 코드를 작성하는 요령을 간단히 설명하면,“복잡한 코드 문제를 작게 나누고, 읽기 좋은 이름을 붙여 정리하자”이다.1.2 변수와 상수변수 이름의 경우 의도 파악 등을 위해 명확한 이름을 붙인다.상수의 경우 우리가 글로 이해할 수 있는 이름의 열거형을 선언하여 표현하면 코드의 가독성을 높일 수 있다.typedef enum state_e{ STATE_INIT = 0, STATE_STANDBY, STATE_GO, STATE_STOP};1.3 조건식과 계산식1.3.1 설명 전용 변수 사용if-statement와 같은 조건 문에 복잡한 조건이 사용되는 경우 설명 전용 변수를 사용한다.const bool isZero = (y != 0);const bool isStateFail = (state == STATE_FAIL);const bool Judge = (!isZero &amp;&amp; !isStateFail);if(Judge){}1.3.2 조건식 함수화bool isZero() { return y != 0; } bool isStateFail() { return state == STATE_FAIL; } bool Judge() { return (!isZero &amp;&amp; !isStateFail); }1.3.3 설명 전용 변수 사용설명 전용 변수를 사용하여 가독성을 높인다.const int maxSpeed = FACTOR * 2.0U * MAX_WHEEL_SPEED;const int minSpeed = FACTOR * 2.0U * MIN_WHEEL_SPEED;if(speed &gt; maxSpeed){}else if(speed &lt;= maxSpeed &amp;&amp; speed &gt; minSpeed){}else{}1.3.4 계산식 함수화계산식을 함수화 하여 그냥 봐도 무엇을 하는 코드인지 알게한다.int FindMaxSpeed(int x){ return FACTOR * x * MAX_WHEEL_SPEED;}int FindMinSpeed(int x){ return FACTOR * x * MIN_WHEEL_SPEED; }void speedfunc(){ const int maxSpeed = FindMaxSpeed(); const int minSpeed = FindMinSpeed(); if(speed &gt; maxSpeed) { } else if(speed &lt;= maxSpeed &amp;&amp; speed &gt; minSpeed) { } else { }}2장. 간단할 설계를 위한 원칙과 패턴3장. 소스 코드 품질 측정" }, { "title": "우선순위 큐(Priority_queue)", "url": "/posts/Priority_queue/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-07-12 00:00:00 +0900", "snippet": "우선순위 큐(Priority_queue)우선순위 큐란?큐의 모든 원소 중에서 가장 큰 값이 Top 위치에 위치하도록 우선순위가 크도록 설계되어 있는 큐를 말한다.내부적으로는 Heap 자료구조를 사용한다.C++에서 우선순위 큐의 메소드추가 및 삭제push() : 우선순위 큐에 원소를 추가한다pop() : 우선순위 큐에서 Top의 원소를 제거한다서칭top() : 우선순위 큐에서 Top에 있는 원소 즉 우선순위가 높은 원소를 반환한다Etc.empty() : 우선순위 큐가 비어있으면 True를 반환하고 그렇지 않으면 False를 반환한다size() : 우선순위 큐에 포함되어 있는 원소의 수를 반환한다선언priority_queue&lt;자료형, Container, 비교함수&gt; 변수명ex) 오름차순으로 정렬되는 우선순위 큐priority_queue&lt;int , vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;" }, { "title": "N번째 큰 수", "url": "/posts/N%EB%B2%88%EC%A7%B8-%ED%81%B0-%EC%88%98/", "categories": "CodingTest", "tags": "CodingTest, Priority Queue", "date": "2022-07-12 00:00:00 +0900", "snippet": "N번째 큰 수우선순위 큐 문제로 우선 순위 큐에 데이터를 오름차순 정렬 형태로 채워 놓고,큐의 사이즈가 N보다 커지면 하나씩 꺼내 최종적으로 큐에 N개만 남게한다.이렇게 되면 Queue의 Top은 N 번째로 큰 숫자가 된다.#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(void){\tint N, x;\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N * N; i++)\t{\t\t\t\tscanf(\"%d\", &amp;x);\t\tpq.push(x);\t\tif (pq.size() &gt; N)\t\t\tpq.pop();\t}\t\tcout &lt;&lt; pq.top() &lt;&lt; '\\n';}" }, { "title": "줄세우기", "url": "/posts/%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Simulation", "date": "2022-07-11 00:00:00 +0900", "snippet": "줄세우기얼핏 정렬를 해야하는 문제처럼 보이지만, 현재 위치에서 나보다 큰 숫자가 있을 경우 바꾸고 한 칸씩 땡기는 것을 카운트만 하면 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int P;int arr[20];int main(void){\tscanf(\"%d\", &amp;P);\tfor (int i = 0; i &lt; P; i++)\t{\t\tint T;\t\tint sum = 0;\t\tscanf(\"%d\", &amp;T);\t\tfor (int j = 0; j &lt; 20; j++)\t\t{\t\t\tscanf(\"%d\", &amp;arr[j]);\t\t}\t\tfor (int j = 0; j &lt; 20; j++)\t\t{\t\t\tfor (int k = 0; k &lt; j; k++)\t\t\t{\t\t\t\tif (arr[j] &lt; arr[k])\t\t\t\t\tsum++;\t\t\t}\t\t}\t\tcout &lt;&lt; T &lt;&lt; \" \" &lt;&lt; sum &lt;&lt; '\\n';\t}}" }, { "title": "함수포인터", "url": "/posts/%ED%95%A8%EC%88%98%ED%8F%AC%EC%9D%B8%ED%84%B0/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-07-10 00:00:00 +0900", "snippet": "함수포인터함수의 이름은 하나의 Symbol 이고 Symbol은 하나의 물리적 주소를 가진다.즉 실제 함수의 이름이 의미하는 것은 함수의 시작 주소를 의미한다.이를 통해 우리는 포인터를 활용하면 원하는 함수를 같은 지점에서 그 때 그 때 사정에 따라 다른 함수를 실행 시킬 수 있게된다.함수 포인터의 선언포인터 함수의 선언의 경우 다음과 같이 이루어진다.자료형 (함수 포인터 이름)(매개변수)int (funcp)(int);=&gt; 이는 int 형 return 값을 가지고 int 형 매개 변수를 하나 가지는 포인터 함수를 의미한다.함수 포인터 배열다음은 사칙연산 함수를 호출하는 함수 포인터 배열과 그 초기화 이다.int(* funcp[4])(int,int) = { add, sub, mul, div};함수 포인터와 Typedef를 활용한 구조체함수 포인터의 경우 역시 구조체 멤버로 사용할 수 있다.struct 구조체 이름{ 자료형(* 함수포인터 이름)(매개변수);}typedef struct calc_t{ int (*funcp)(int, int);}int main(){ struct calc_t ct; c.funcp = add;}" }, { "title": "돌 게임", "url": "/posts/%EB%8F%8C-%EA%B2%8C%EC%9E%84/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-07-10 00:00:00 +0900", "snippet": "돌 게임결과적으로 짝수와 홀수를 판단하는 문제로무조건 1개 혹은 3개를 가져갈 수 있어 짝수일 때는 창영이, 홀수일 때는 상근이 이기게 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(void){\tint N;\tscanf(\"%d\", &amp;N);\tstring answer = ((N &amp; 1) == 0) ? \"CY\" : \"SK\";\tcout &lt;&lt; answer &lt;&lt; '\\n';\treturn 0;}" }, { "title": "Little Endian, Big Endian", "url": "/posts/Little_Endian_Big_Endian/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-07-10 00:00:00 +0900", "snippet": "Little Endian, Big Endian모든 프로세서들은 Little Endian, Big Endian 둘 중 하나의 order 를 따른다.Little Endian의 경우 상위 bit 주소(MSB)에 상위 주소를 저장한다.Big Endian의 경우 하위 bit 주소(LSB)에 상위 주소를 저장한다.대표적인 프로세서 중 하나인 ARM Procesor의 경우 Little Endian, Big Endian 모두를 지원하지만 default는 Little Endian이다." }, { "title": "등수 매기기", "url": "/posts/%EB%93%B1%EC%88%98-%EB%A7%A4%EA%B8%B0%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-07-09 00:00:00 +0900", "snippet": "등수 매기기그리디 문제로, 동석차 없이 1~N까지 숫자를 줄세울 수 있도록 만드는 문제=&gt; 정렬하고 오차 발생시 절댓값의 오차 만큼을 정답 카운트에 더해줌#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N;vector&lt;int&gt; v;int main(void){\tlong long answer = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint num;\t\tscanf(\"%d\", &amp;num);\t\tv.push_back(num);\t}\tsort(v.begin(), v.end());\tfor (int i = 1; i &lt;= N; i++)\t{\t\tanswer += abs(i - v[i - 1]);\t}\tcout &lt;&lt; answer &lt;&lt; '\\n';\treturn 0;}" }, { "title": "단지번호붙이기", "url": "/posts/%EB%8B%A8%EC%A7%80%EB%B2%88%ED%98%B8%EB%B6%99%EC%9D%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-07-08 00:00:00 +0900", "snippet": "단지번호붙이기BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define MAXLEN 25int N;int arrmap[MAXLEN][MAXLEN] = { { 0, }, };bool isvisited[MAXLEN][MAXLEN] = { { false, }, };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};int cnt;void bfs(int x, int y){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tq.push(make_pair(x, y));\twhile (!q.empty())\t{\t\tint cx = q.front().first;\t\tint cy = q.front().second;\t\t\t\tcnt++;\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\t\t\t\tif (arrmap[nx][ny] == 1 &amp;&amp; isvisited[nx][ny] == false &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N)\t\t\t{\t\t\t\tq.push(make_pair(nx, ny));\t\t\t\tisvisited[nx][ny] = true;\t\t\t\t\t\t\t}\t\t}\t}}int main(void){\tvector&lt;int&gt; v;\tint total_area = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tscanf(\"%1d\", &amp;arrmap[i][j]);\t\t}\t}\tfor (int i = 0; i &lt; N; i++)\t{\t\tfor (int j = 0; j &lt; N; j++)\t\t{\t\t\tif (arrmap[i][j] == 1 &amp;&amp; isvisited[i][j] == false)\t\t\t{\t\t\t\tcnt = 0;\t\t\t\tisvisited[i][j] = true;\t\t\t\tbfs(i, j);\t\t\t\ttotal_area++;\t\t\t\tv.push_back(cnt);\t\t\t}\t\t}\t}\tsort(v.begin(), v.end());\tprintf(\"%d\\n\", total_area);\tfor (int i = 0; i &lt; v.size(); i++)\t{\t\tprintf(\"%d\\n\", v[i]);\t}\treturn 0;}" }, { "title": "유기농 배추", "url": "/posts/%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-07-04 00:00:00 +0900", "snippet": "유기농 배추BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;int T, M, N, K;int field[50][50] = { { 0, }, };bool isvisited[50][50] = { {false, } };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};int whitebug = 0;void bfs(int x, int y){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tq.push(make_pair(x, y));\twhile (!q.empty())\t{\t\tint cx = q.front().first;\t\tint cy = q.front().second;\t\tq.pop();\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\t\t\t\tif (isvisited[nx][ny] == false &amp;&amp; field[nx][ny] == 1 &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; M &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N)\t\t\t{\t\t\t\tq.push(make_pair(nx, ny));\t\t\t\tisvisited[nx][ny] = true;\t\t\t}\t\t}\t}\treturn;}int main(void){\tint tmp_x, tmp_y;\tscanf(\"%d\", &amp;T);\tfor (int tc = 0; tc &lt; T; tc++)\t{\t\twhitebug = 0;\t\tscanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);\t\tfor (int i = 0; i &lt; K; i++)\t\t{\t\t\t\tscanf(\"%d %d\", &amp;tmp_x, &amp;tmp_y);\t\t\tfield[tmp_y][tmp_x] = 1;\t\t}\t\tfor (int i = 0; i &lt; M; i++)\t\t{\t\t\tfor (int j = 0; j &lt; N; j++)\t\t\t{\t\t\t\tif (field[i][j] == 1 &amp;&amp; isvisited[i][j] == false)\t\t\t\t{\t\t\t\t\tisvisited[i][j] = true;\t\t\t\t\tbfs(i, j);\t\t\t\t\twhitebug++;\t\t\t\t}\t\t\t}\t\t}\t\tprintf(\"%d\\n\", whitebug);\t\tmemset(field, 0, sizeof(int) * 50 * 50);\t\tmemset(isvisited, false, sizeof(bool) * 50 * 50);\t}\t\treturn 0;}" }, { "title": "TASKING Compiler", "url": "/posts/TASKING_Complier/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-07-03 00:00:00 +0900", "snippet": "TASKING Compiler빌드 옵션clear, noclear초기화되지 않은 전역 변수의 경우 .bss 섹션에 저장된다.=&gt; 이 경우 Startup 코드에서 0으로 clear되는 것이 일반적초기화 되는 전역변수인 .data 섹션의 경우 noclear에 해당한다.이러한 clear와 no clear 를 빌드 옵션으로 지정할 수 있다.#include &lt;stdio.h&gt;#pragma noclearint init_data#pragma clear위의 예시에서 pragma 명령어를 통해 init_data를 프로그램 시작 시 전역에서 초기화 시키지 않고 이전 값을 유지하기 위하여 코드를 다음과 같이 설정했다.=&gt; .bss 섹션에 해당하는 변수이므로 Startup 코드에서 초기화되어야 하지만 그렇지 않은 것Section 코드 영역=&gt; 모든 코드의 경우 .text 섹션으로 정의한다. 변수 영역2.1 데이터 영역(.data)=&gt; 초기값이 있는 전역 변수가 이에 해당하고 ROM에 원본이 있고 RAM으로 copy하여 사용한다.2.2 .bss =&gt; 초기값이 없는 전역 변수로 RAM에만 세팅되어 사용된다2.3 .rodata=&gt; const 변수로 ROM에만 세팅된다또한 각 타입별로 3가지 접근 방식을 가질수 있고 그 내용은 다음과 같다. __far=&gt; 기본 타입으로 어떤 주소 번지에든 위치할 수 있다. __near=&gt; 섹션 타입 앞에 z가 붙고 각 세그먼트의 앞 16kb 에만 위치 가능 레지스터 타입(__a0, __a1)=&gt; 각 레지스터 타입 별 기준 주소가 존재하고 그 주소를 기준으로 16bit offset 공간에 위치 가능near 타입의 경우 가장 적은 어셈 라인으로 변수를 Read/Write 할 수 있다.=&gt; 속도 면에서 가장 효과적인 섹션 타입섹션 타입 지정 방법char __far ch1;char __a0 ch2;int __near var1;#pragma default_near_sizeint var1;int var2;#pragma default_near_size default" }, { "title": "그림", "url": "/posts/%EA%B7%B8%EB%A6%BC/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-07-02 00:00:00 +0900", "snippet": "그림BFS Flood Fill Algorithm : 다차원 배열에서 연결된 특정 영역를 찾는 알고리즘=&gt; 2차원 이상의 배열에서 색 채우기 알고리즘BFS 구현의 절차의 경우, 먼저 방문하지 않은 노드를 방문하고 방문 처리 및 큐에 넣는다. 큐에서 맨 앞 노드를 꺼내 인접 점을 탐색하고 방문하지 않았을 경우 큐에 넣는다. 넓이의 경우 큐에서 꺼낼 때 카운트를 하고 영역의 개수의 경우 최초 1을 발견하는 시점에 CNT를 수행한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int n, m;int draw[501][501];bool isivisited[501][501] = { { 0, }, };int dx[4] = { 0, 0, -1, 1 };int dy[4] = { -1, 1, 0, 0 };int area = 0, number = 0;void bfs(int x, int y){\tqueue&lt;pair&lt;int, int&gt;&gt; q;\tint cnt = 0;\tq.push(make_pair(x, y));\twhile (!q.empty())\t{\t\tint cx = q.front().first;\t\tint cy = q.front().second;\t\tisivisited[cx][cy] = true;\t\tq.pop();\t\tcnt++;\t\tfor (int i = 0; i &lt; 4; i++)\t\t{\t\t\tint nx = cx + dx[i];\t\t\tint ny = cy + dy[i];\t\t\tif (isivisited[nx][ny] == false &amp;&amp; nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m)\t\t\t{\t\t\t\tif (draw[nx][ny] == 1)\t\t\t\t{\t\t\t\t\tq.push(make_pair(nx, ny));\t\t\t\t\tisivisited[nx][ny] = true;\t\t\t\t\t\t\t\t\t}\t\t\t}\t\t}\t}\tarea = max(cnt, area);}int main(void){\tscanf(\"%d %d\", &amp;n, &amp;m);\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; m; j++)\t\t{\t\t\tscanf(\"%d\", &amp;draw[i][j]);\t\t}\t}\tfor (int i = 0; i &lt; n; i++)\t{\t\tfor (int j = 0; j &lt; m; j++)\t\t{\t\t\tif (isivisited[i][j] == false &amp;&amp; draw[i][j] == 1)\t\t\t{\t\t\t\tbfs(i, j);\t\t\t\tnumber++;\t\t\t}\t\t\t\t\t}\t}\tprintf(\"%d\\n\", number);\tprintf(\"%d\\n\", area);\treturn 0;}" }, { "title": "좌표 정렬하기", "url": "/posts/%EC%A2%8C%ED%91%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-30 00:00:00 +0900", "snippet": "좌표 정렬하기c++의 vector와 pair를 활용한 정렬 기본문제#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int N;int x[100001] = { 0, };int y[100001] = { 0, };bool compare(pair&lt;int, int&gt;a1, pair&lt;int, int&gt; a2){\tif (a1.second == a2.second)\t{\t\treturn a1.first &lt; a2.first;\t}\telse\t{\t\treturn a1.second &lt; a2.second;\t}}int main(void){\tvector&lt;pair&lt;int, int&gt;&gt; v;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tint tmp_x = 0, tmp_y = 0;\t\tscanf(\"%d %d\", &amp;tmp_x, &amp;tmp_y);\t\tv.push_back(make_pair(tmp_x, tmp_y));\t}\tsort(v.begin(), v.end(), compare);\tfor (int i = 0; i &lt; N; i++)\t{\t\tprintf(\"%d %d\\n\", v[i].first, v[i].second);\t}\treturn 0;}" }, { "title": "수뒤집기", "url": "/posts/%EC%88%98%EB%92%A4%EC%A7%91%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-28 00:00:00 +0900", "snippet": "수뒤집기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;int main(void){\tstring S;\tint zeroarea = 0, onearea = 0;\tbool flag = false;\tcin &gt;&gt; S;\tfor (int i = 0; i &lt; S.length(); i++)\t{\t\tif (S[i] != S[i+1])\t\t{\t\t\tif (S[i] == '0')\t\t\t\tzeroarea++;\t\t\telse\t\t\t\tonearea++;\t\t}\t}\tif(zeroarea &gt; onearea)\t\tcout &lt;&lt; onearea &lt;&lt; '\\n';\telse\t\tcout &lt;&lt; zeroarea &lt;&lt; '\\n';\treturn 0;}" }, { "title": "게임을 만든 동준이", "url": "/posts/%EA%B2%8C%EC%9E%84%EC%9D%84-%EB%A7%8C%EB%93%A0-%EB%8F%99%EC%A4%80%EC%9D%B4/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-06-28 00:00:00 +0900", "snippet": "게임을 만든 동준이오름차순을 만드는 문제로 볼 수 있고 따라서, 문제의 접근을 뒤에서부터 가지면 좋다.오름차순 =&gt;앞의 숫자보다 뒤의 숫자가 무조건 크면 된다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;int N;int point[100] = { 0, };int main(void){\tint answer = 0;\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;point[i]);\t}\tfor (int i = N - 1; i &gt; 0; i--)\t{\t\tif (N == 1)\t\t\tbreak;\t\twhile (point[i - 1] &gt;= point[i])\t\t{\t\t\tpoint[i - 1]--;\t\t\tanswer++;\t\t}\t}\tcout &lt;&lt; answer &lt;&lt; '\\n';\treturn 0;}" }, { "title": "주식", "url": "/posts/%EC%A3%BC%EC%8B%9D/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-06-18 00:00:00 +0900", "snippet": "주식그리디 문제로, 뒤의 날짜 즉 미래를 보면서 수익 계산을 하면 용이하다.뒤에서부터 최대 이익을 계산하면서 최고가를 보면 max_price값을 정정하면서 수익을 집계한다.(저가) -&gt; (연중 최고가, 매도) -&gt; (저가) -&gt; (저가) -&gt; (주중 최고가, 매도)#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int T, N;int price[1000000] = { 0 };int main(void){\t\tscanf(\"%d\", &amp;T);\tfor (int i = 0; i &lt; T; i++)\t{\t\tll max_benefit = 0;\t\tscanf(\"%d\", &amp;N);\t\tfor(int j = 1; j &lt;= N; j++)\t\t{\t\t\tscanf(\"%d\", &amp;price[j]);\t\t}\t\tint max_price = price[N];\t\tfor(int j = N - 1; j &gt; 0; j--)\t\t{\t\t\tif (max_price &lt;= price[j])\t\t\t{\t\t\t\tmax_price = price[j];\t\t\t}\t\t\telse\t\t\t{\t\t\t\tmax_benefit += (ll)(max_price - price[j]);\t\t\t}\t\t}\t\tcout &lt;&lt; max_benefit &lt;&lt; '\\n';\t}\t\treturn 0;}" }, { "title": "반복수열", "url": "/posts/%EB%B0%98%EB%B3%B5%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-18 00:00:00 +0900", "snippet": "반복수열#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;#define NUM_MAX 300001int A, P;int D[NUM_MAX] ={ 0, };int cnt_arr[NUM_MAX] ={ 0, };int answer = 0;int main(void){ int cnt = 0, current_num = 0, next_num = 0; scanf(\"%d %d\", &amp;A, &amp;P); current_num = A; D[A]++; cnt_arr[A] = cnt; while(true) { int check_num = current_num % 10; if(current_num / 10 != 0) { next_num += pow(check_num, P); current_num /= 10; } else { next_num += pow(check_num, P); current_num = next_num; D[next_num]++; if(D[next_num] == 2) { break; } else { cnt++; cnt_arr[next_num] = cnt; } next_num = 0; } } cout &lt;&lt; cnt_arr[next_num] &lt;&lt; '\\n';}" }, { "title": "로프", "url": "/posts/%EB%A1%9C%ED%94%84/", "categories": "CodingTest", "tags": "CodingTest, Greedy", "date": "2022-06-18 00:00:00 +0900", "snippet": "로프그리디 문제로, 병렬로 균등하게 무게가 배분되므로 로프의 하중 견디는 값이 높은 로프를 쓸수록 로프는 적게 쓸 수 밖에 없어진다.이를 생각하며 정렬을 사용하여 문제를 해결한다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;#define MAX_NUM 100000int N;int weight[MAX_NUM] = { 0 };int rope[MAX_NUM] = { 0 };int main(void){\tscanf(\"%d\", &amp;N);\tfor (int i = 0; i &lt; N; i++)\t{\t\tscanf(\"%d\", &amp;rope[i]);\t}\tsort(rope, rope + N, greater&lt;int&gt;());\tfor (int i = 0; i &lt; N; i++)\t{\t\tweight[i] = rope[i] * (i + 1);\t}\tsort(weight, weight + N, greater&lt;int&gt;());\tcout &lt;&lt; weight[0] &lt;&lt; '\\n';\treturn 0;}" }, { "title": "스타트업 코드(StartupCode)", "url": "/posts/StartupCode/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-15 00:00:00 +0900", "snippet": "스타트업(Startup) 코드란?프로그램이 작동되기 위해서 필요한 준비 과정을 위한 코드로 여러 초기화 작업과 C에서 사용할 메모리(스택, 힙) 등을 할당하고 마지막에 main() 함수를 호출하여 프로그램을 동작하게 한다.운영체제(OS)가 있는 경우의 main 호출 과정1. Shell 상에서 프로그램 수행2. fork로 새로운 프로세스 복사3. 시스템 콜 함수 sys_execve() 호출=&gt; 사용자 모드에서 커널 모드로 전환4. do_execve() =&gt; open_exec()로 파일 정보를 읽어 적합한 binary handler 실행5. flush_old_exec()가 기본 프로세스 정보를 삭제하고 현재 프로세스를 current 로 설정6. 새로운 프로세스에 사용할 메모리 레이아웃 설정7. 동적 링커 메모리에 로딩8. start_thread()=&gt; elf 인터프리터 실행9. sys_execve() 종료 =&gt; 커널 모드에서 사용자 모드로 전환10. reschedule() =&gt; context switching 수행11. _start_ 코드로 main 호출운영체제(Non-OS)가 없는 경우의 main 호출 과정프로그램이 작동되기 전 하드웨어의 초기화는 부트 코드에서, 임베디드 코드의 초기화는 스타트업 코드에서 처리한다1. 모든 인터럽트 중지2. 초기화된 데이터를 ROM to RAM 복사3. 초기화되지 않은 데이터 영역 0으로 초기화4. 스택을 위한 공간을 할당하고 초기화5. 프로세서의 스택 포인터 초기화6. 힙을 생성하고 초기화7. 인터럽트 활성화8. main() 함수 호출세부 설명1. 모든 인터럽트 중지=&gt; 스타트업 코드 실행 중에 인터럽트가 발생하여 ISR(Interrput Service Routine)으로 분기하면 해당 동작이 어떤 결과를 초래하는지 예측하기 어렵다따라서 인터럽트나 워치독(Watchdog)을 Disable 시킨다2. 초기화된 데이터를 ROM to RAM 복사=&gt; ROM에 있는 data segment를 RAM으로 복사한다bss segment의 경우 0으로 초기화 한다최종적으로 해당 과정들을 통해 임베디드 프로그램(C 프로그램) main()을 호출하고 스타트업 코드로 돌아오게 한다그 다음코드는 레이블 0만 반복하여 메모리가 임의의 주소로 빠지는 일을 막는다 " }, { "title": "MemoryMap", "url": "/posts/MemoryMap/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-15 00:00:00 +0900", "snippet": "Memory Map 에 관하여…Symbol 이란?Symbol은 Memory Map에서 Linker가 알아볼 수 있는 최소 단위를 말한다Linker의 Linking 과정 이후에 자신만의 주소를 갖게되는 단위를 말한다ELF File 형식에서 Linker에 의해 Symbol table을 두며 파일 단위의 관점에서 볼 때 참조되는 모든 Symbol의 이름과주소가 들어있고, 외부에서 선언된 Symbol은 없어 해당 Object에서 Symbol table은 불완전하다변수 관점에서는 Symbol은 Global 변수들을 나타낸다고 볼 수 있다.=&gt; 고유한 주소를 가지고 경우에 따라 다른 파일의 함수에서도 직접 접근하여 사용가능하다.Symbol을 성질에 따라 ZI, RO, RW 로 구별한다.ZI(Zero Initialization) : 초기 값이 0인 전역 변수(.bss)RO(Read Only) : 수정이 불가능한 const 전역변수와 text인 code(.text, .constdata)RW(Read Write) : 초기 값이 있는 전역 변수(.data)" }, { "title": "Embedded_c", "url": "/posts/Embedded_C/", "categories": "", "tags": "", "date": "2022-06-15 00:00:00 +0900", "snippet": "Embedded C 프로그래밍" }, { "title": "코드 최적화(CodeOptimization)", "url": "/posts/CodeOptimization/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-15 00:00:00 +0900", "snippet": "코드 최적화최적화의 등가교환(Trade-Off)크기 vs 속도성능 vs 가독성임베디드 소프트웨어의 최적화 규칙최선의 알고리즘, 최적의 코드를 찾아라하드웨어 특성(프로세서), 개발 툴 등을 잘 이해하고 활용하라헤더 인클루드 중복성 제거```C#ifndef FUNC_H// 정의가 되어있지 않을 경우 인클루드(딱 한번만 인클루드 하게 됨)#define FUNC_H/* 내용 */#endif FUNC_H```C에서 최적화를 위한 표현법비용이 낮은 연산자를 선택하라어셈블리 단에서 확인해보면, 나누기 곱셈과 같은 연산보다 비트 쉬프트 연산이 더 적은 명령어를 사용한다.따라서 2의 지수 승의 나누기 곱셈 연산을 할 때는 쉬프트 연산을 활용하는 것이 좋다Short Circuit 원리의 활용&amp;&amp; : 첫 비교문이 거짓이면 모두 거짓이므로, 뒤의 비교문은 보지 않는다.=&gt; 거짓의 확률이 높은 비교문을 앞에 둔다.|| : 첫 비교문이 참이면 모두 참이 되므로 그 뒤의 비교문은 모두 수행하지 않는다.=&gt; 참의 확률이 높은 비교문을 앞에 둔다.연관된 표현은 묶어서 처리한다=&gt; 이 부분의 경우 속도와 코드의 가독성의 Trade-off 관계실수 연산실수의 나누기는 느리다실수에서 나누기의 연산은 상당히 많은 연산시간을 잡아먹는다.가능하면 double 자료형 대신 float 자료형을 사용하라Math 라이브러리 함수를 되도록 사용하지 않는다=&gt; Math 라이브러리 함수들은 오버헤드가 크다.=&gt; 자주 사용되는 값을 테이블로 설정하여 사용한다.가능하면 고정 소수점으로 변환하여 사용하라" }, { "title": "최소직사각형", "url": "/posts/%EC%B5%9C%EC%86%8C%EC%A7%81%EC%82%AC%EA%B0%81%ED%98%95/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "width와 height 중 width 가 더 크도록 정렬 후 sizes 벡터에 대해 max 값을 찾는다.#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(vector&lt;vector&lt;int&gt;&gt; sizes) { int answer = 0; int w_max = 0, h_max = 0; for(int i = 0; i &lt; sizes.size(); i++) { if(sizes[i][0] &lt; sizes[i][1]) { int tmp = sizes[i][0]; sizes[i][0] = sizes[i][1]; sizes[i][1] = tmp; } } for(int i = 0; i &lt; sizes.size(); i++) { w_max = max(sizes[i][0], w_max); h_max = max(sizes[i][1], h_max); } answer = w_max * h_max; return answer;}" }, { "title": "약수의 개수와 덧셈", "url": "/posts/%EC%95%BD%EC%88%98%EC%9D%98-%EA%B0%9C%EC%88%98%EC%99%80-%EB%8D%A7%EC%85%88/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(int left, int right) { int answer = 0, div_num_cnt = 0; for(int i = left; i &lt;=right; i++) { div_num_cnt = 1; for(int j = 2; j &lt;= i; j++) { if(i % j == 0) { div_num_cnt++; } } if((div_num_cnt &amp; 1) == 0) { answer += i; } else { answer -= i; } } return answer;}" }, { "title": "부족한 금액 계산하기", "url": "/posts/%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "using namespace std;long long solution(int price, int money, int count){ long long answer = -1; long long total_price = 0; for(int i = 1; i &lt;= count; i++) { total_price += (price * i); } if(total_price &lt;= money) { answer = 0; } else { answer = total_price - money; } return answer;}" }, { "title": "로또의 최고 순위와 최저 순위", "url": "/posts/%EB%A1%9C%EB%98%90%EC%9D%98-%EC%B5%9C%EA%B3%A0-%EC%88%9C%EC%9C%84%EC%99%80-%EC%B5%9C%EC%A0%80-%EC%88%9C%EC%9C%84/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "정렬 이후 0은 어떠한 숫자로든 변할 수 있으므로 이에 따라 max와 min이 정해지는 것을 활용하여 문제 풀이#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; solution(vector&lt;int&gt; lottos, vector&lt;int&gt; win_nums) { vector&lt;int&gt; answer; int max_win = 0, min_win = 0; int answer_max = 0, answer_min = 0; sort(lottos.begin(), lottos.end()); sort(win_nums.begin(), win_nums.end()); for(int i = lottos.size() - 1; i &gt;= 0 ; i--) { for(int j = lottos.size() - 1; j &gt;= 0 ; j--) { if(lottos[i] == win_nums[j]) { max_win++; min_win++; break; } } } for(int i = 0; i &lt; lottos.size() ; i++) { if(lottos[i] == 0) { max_win++; } } switch(max_win) { case 1: answer_max = 6; break; case 2: answer_max = 5; break; case 3: answer_max = 4; break; case 4: answer_max = 3; break; case 5: answer_max = 2; break; case 6: answer_max = 1; break; default: answer_max = 6; } switch(min_win) { case 1: answer_min = 6; break; case 2: answer_min = 5; break; case 3: answer_min = 4; break; case 4: answer_min = 3; break; case 5: answer_min = 2; break; case 6: answer_min = 1; break; default: answer_min = 6; } answer.push_back(answer_max); answer.push_back(answer_min); return answer;}" }, { "title": "나머지가 1이 되는 수 찾기", "url": "/posts/%EB%82%98%EB%A8%B8%EC%A7%80%EA%B0%80-1%EC%9D%B4-%EB%90%98%EB%8A%94-%EC%88%98-%EC%B0%BE%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest", "date": "2022-06-14 00:00:00 +0900", "snippet": "#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int solution(int n) { int answer = 0, x = 0; for(int i = 1; i &lt;= n; i++) { if(n % i == 1) { x = i; break; } } answer = x; return answer;}" }, { "title": "미로 탐색", "url": "/posts/%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/", "categories": "CodingTest", "tags": "CodingTest, BFS", "date": "2022-06-12 00:00:00 +0900", "snippet": "미로 탐색(bfs)bfs의 기초문제로 숫자가 붙어있어 데이터를 문자열로 받고 queue를 활용하여 bfs를 구현하여 문제를 해결한다.방문과 동시에 해당 좌표까지 도달하기 위한 cost(check 배열)을 이동 전 위치보다 +1를 하여 저장하면서 cost를 계산해나간다.#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;int N, M;char arrmap[101][101];bool isvisited[100][100] = { { false } };int check[100][100] = { { 0 } };int dx[4] = {0, 0, -1, 1};int dy[4] = {-1, 1, 0, 0};void bfs(int x, int y){ isvisited[x][y] = true; queue&lt;pair&lt;int, int&gt;&gt; q; q.push(make_pair(x, y)); while(!q.empty()) { int cx = q.front().first; int cy = q.front().second; q.pop(); for(int i = 0; i &lt; 4; i++) { int nx = cx + dx[i]; int ny = cy + dy[i]; if(nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt; M) { if(isvisited[nx][ny] == false &amp;&amp; arrmap[nx][ny] == '1') { q.push(make_pair(nx, ny)); isvisited[nx][ny] = true; check[nx][ny] = check[cx][cy] + 1; } } } }}int main(void){ scanf(\"%d %d\", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) { scanf(\"%s\", arrmap[i]); } bfs(0, 0); printf(\"%d\", check[N-1][M-1] + 1); return 0;}" }, { "title": "Embedded C 프로그래밍", "url": "/posts/StartupCode/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "스타트업(Startup) 코드란?프로그램이 작동되기 위해서 필요한 준비 과정을 위한 코드로 여러 초기화 작업과 C에서 사용할 메모리(스택, 힙) 등을 할당하고 마지막에 main() 함수를 호출하여 프로그램을 동작하게 한다.운영체제(OS)가 있는 경우의 main 호출 과정1. Shell 상에서 프로그램 수행2. fork로 새로운 프로세스 복사3. 시스템 콜 함수 sys_execve() 호출=&gt; 사용자 모드에서 커널 모드로 전환4. do_execve() =&gt; open_exec()로 파일 정보를 읽어 적합한 binary handler 실행5. flush_old_exec()가 기본 프로세스 정보를 삭제하고 현재 프로세스를 current 로 설정6. 새로운 프로세스에 사용할 메모리 레이아웃 설정7. 동적 링커 메모리에 로딩8. start_thread()=&gt; elf 인터프리터 실행9. sys_execve() 종료 =&gt; 커널 모드에서 사용자 모드로 전환10. reschedule() =&gt; context switching 수행11. _start_ 코드로 main 호출운영체제(Non-OS)가 없는 경우의 main 호출 과정프로그램이 작동되기 전 하드웨어의 초기화는 부트 코드에서, 임베디드 코드의 초기화는 스타트업 코드에서 처리한다1. 모든 인터럽트 중지2. 초기화된 데이터를 ROM to RAM 복사3. 초기화되지 않은 데이터 영역 0으로 초기화4. 스택을 위한 공간을 할당하고 초기화5. 프로세서의 스택 포인터 초기화6. 힙을 생성하고 초기화7. 인터럽트 활성화8. main() 함수 호출세부 설명1. 모든 인터럽트 중지=&gt; 스타트업 코드 실행 중에 인터럽트가 발생하여 ISR(Interrput Service Routine)으로 분기하면 해당 동작이 어떤 결과를 초래하는지 예측하기 어렵다따라서 인터럽트나 워치독(Watchdog)을 Disable 시킨다2. 초기화된 데이터를 ROM to RAM 복사=&gt; ROM에 있는 data segment를 RAM으로 복사한다bss segment의 경우 0으로 초기화 한다최종적으로 해당 과정들을 통해 임베디드 프로그램(C 프로그램) main()을 호출하고 스타트업 코드로 돌아오게 한다그 다음코드는 레이블 0만 반복하여 메모리가 임의의 주소로 빠지는 일을 막는다 " }, { "title": "Memory Map 에 관하여...", "url": "/posts/MemoryMap/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "Memory Map 에 관하여…Symbol 이란?Symbol은 Memory Map에서 Linker가 알아볼 수 있는 최소 단위를 말한다Linker의 Linking 과정 이후에 자신만의 주소를 갖게되는 단위를 말한다ELF File 형식에서 Linker에 의해 Symbol table을 두며 파일 단위의 관점에서 볼 때 참조되는 모든 Symbol의 이름과주소가 들어있고, 외부에서 선언된 Symbol은 없어 해당 Object에서 Symbol table은 불완전하다변수 관점에서는 Symbol은 Global 변수들을 나타낸다고 볼 수 있다.=&gt; 고유한 주소를 가지고 경우에 따라 다른 파일의 함수에서도 직접 접근하여 사용가능하다.Symbol을 성질에 따라 ZI, RO, RW 로 구별한다.ZI(Zero Initialization) : 초기 값이 0인 전역 변수(.bss)RO(Read Only) : 수정이 불가능한 const 전역변수와 text인 code(.text, .constdata)RW(Read Write) : 초기 값이 있는 전역 변수(.data)" }, { "title": "Embedded C 프로그래밍", "url": "/posts/Embedded_C/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "Embedded C 프로그래밍ISR(Interrupt Service Routine)Interrupt handler 라고도 불리고 주로 외부 하드웨어적 요인이나 설정한 소프트웨어적 변경사항에 의해 발생하는 것을 사용자가 정의하고,그 일이 발생할 경우 현재의 작업을 중단하고 우선 처리하는 작업을 말한다.반대의 경우로는 폴링(Polling)이 있으며 폴링의 경우 해당 이벤트가 발생할 때까지 계속 확인하다가 발생하면 이벤트를 수행하는 것을 말한다.이러한 인터럽트가 걸렸다는 신호로 IRQ(Interrput Request)라는 것이 있고, 이 IRQ가 어떤 Interrupt에 해당하는지를 구별해준다.이러한 인터럽트에 관련된 플래그, 변수 등은 volatile로 선언된다.=&gt; 컴파일러 최적화 옵션에서 제외하여, 불분명한 결과를 야기하는 것을 피하기 위해서ISR 실행 과정 주 프로그램 실행 인터럽트 발생 복귀주소(PC) 저장 인터럽트 벡터로 점프 인터럽트 처리 인터럽트 처리 완료 복귀주소 로드 마지막에 실행된 주소로 점프 1번 과정 다음 PC 위치로 이동인터럽트 구성요소 우선순위=&gt; 2개 이상의 요청이 동시에 들어올 경우 어떤 우선 순위로 서비스를 실행하는가? 인터럽트 벡터(Interrput Vector)=&gt; 인터럽트 벡터는 인터럽트가 발생했을 때 할 일을 적어 놓은 것으로 ISR의 시작주소를 말한다. 발원지=&gt; 인터럽트가 발생한 지점이 어디인가?부트(Boot)에 대해..전원 동작 후 BIOS가 불러오는 것으로 커널을 메모리에 로드하고 본격적인 동작을 위해 필요한 작업을 수행플래시 메모리(rom)에서 시작되는 시스템 소프트웨어로서 하드웨어 초기화 커널을 RAM에 적재이 후 인터럽트, GPIO 등을 점검 및 실행 가능한 상태로 만들어준다.부트로더(BootLoader)부트로더란 운영체제가 시동되기 이전에 미리 실행되면서 커널이 올바르게 시동되기 위해 필요한 모든 관련 작업을 마무리하고 최종적으로 운영체제를 시동시키기 위한 목적을 가진 프로그램을 말한다.기본적인 OS 실행 순서는 다음고 같다.BIOS -&gt; 1차 부트로더 -&gt; 2차 부트로더 -&gt; 커널 -&gt; 운영체제컴퓨터가 실행되면 BIOS가 로드되고 BIOS에 연결된 저장 매체에서 설정된 부팅 순서대로 부트로더들을 불러온다.BIOS는 MBR에 존재하는 하드디스크 파티션 테이블을 읽은 후 활성화되어있는 파티션의 PBR을 읽어 그 데이터로 부팅하게 된다. 여기서 MBR, PBR이 바로 1차 부트로더이다.윈도우와 같은 큰 용량이 필요한 운영체제는 2차 부트로더가 필요하며 1차 부트로더가 2차 부트로더를 로드하고 다시 2차 부트로더가 커널을 로드하는 방식이다.2차 부트로더에는 GRUB(리눅스, 윈도우), SYSLINUX(리눅스), LILO(리눅스) 등이 있다.커널(Kernel)에 대해..컴퓨터 운영체제 중 핵심이 되는 프로그램으로 시스템 자원의 효율적 관리(스케쥴링), 하드웨어 추상화 등을 통해 Application S/W 개발을 도움커널은 컴퓨터의 운영체제의 핵심이 되는 컴퓨터 프로그램의 하나로 운영체제의 전체적인 시스템을 통제하고 시스템 자원을 효율적으로 관리하여 응용 프로그램 수행에 필요한 서비스를 제공커널이 하는 일프로세스 관리 : 프로세스에 CPU를 배분하고 작업에 필요한 환경 제공메모리 관리 : 프로세스에 작업 공간을 배치하고 실제 메모리보다 큰 가상공간을 제공파일 시스템 관리 : 데이터를 저장하고 접근할 수 있는 인터페이스 제공입출력 관리 : 필요한 입력과 출력 서비스 제공프로세스 간 통신 관리 : 공동 작업을 위한 각 프로세스 간 통신 환경 제공매크로 함수 장단점매크로 함수 장점 상대적으로 실행속도가 빠르다.=&gt; 호출과 동시에 함수의 생성부터(스택메모리 할당) 함수의 종료(return 문을 통한 값 반환)까지 이루어진다.(선행처리기에서 처리)=&gt; 즉 전체 프로그램의 실행 속도에는 영향을 주지 않는다. 자료형에 구애받지 않는다.=&gt; 전달인자의 자료형은 알아서 치환된다(묵시적 형변환) 매크로 함수 단점 디버깅이 어렵다. 매크로 함수의 길이가 길어질수록 가독성이 떨어진다. C언어 매크로 연산자# 연산자문자열로 변환시켜주는 연산자로 매크로 변수를 문자열로 바꿔주는 역할을 한다.매크로 함수의 전달인자를 다른 대상(전달인자, 숫자, 문자, 문자열 등)과 이어줄 때 사용하는 매크로 연산자#define PRINT_FUNC(s) printf(#s)int main(){ PRINT_FUNC(HELLO WORLD) return 0;}## 연산자여러 코드를 붙이는 매크로 연산자(concat)#define CONCAT_FUNC(a, b) a##bint take = 1;int word = 2;int takeword = 10;int main(){ CONCAT_FUNC(take, word); return 0;}결과 값으로 10이 출력된다." }, { "title": "코드 최적화(CodeOptimization)", "url": "/posts/CodeOptimization/", "categories": "Embedded Engineering", "tags": "Embedded Engineering", "date": "2022-06-12 00:00:00 +0900", "snippet": "코드 최적화최적화의 등가교환(Trade-Off)크기 vs 속도성능 vs 가독성임베디드 소프트웨어의 최적화 규칙최선의 알고리즘, 최적의 코드를 찾아라하드웨어 특성(프로세서), 개발 툴 등을 잘 이해하고 활용하라헤더 인클루드 중복성 제거#ifndef FUNC_H// 정의가 되어있지 않을 경우 인클루드(딱 한번만 인클루드 하게 됨)#define FUNC_H/* 내용 */#endif FUNC_HC에서 최적화를 위한 표현법비용이 낮은 연산자를 선택하라어셈블리 단에서 확인해보면, 나누기 곱셈과 같은 연산보다 비트 쉬프트 연산이 더 적은 명령어를 사용한다.따라서 2의 지수 승의 나누기 곱셈 연산을 할 때는 쉬프트 연산을 활용하는 것이 좋다Short Circuit 원리의 활용&amp;&amp; : 첫 비교문이 거짓이면 모두 거짓이므로, 뒤의 비교문은 보지 않는다.=&gt; 거짓의 확률이 높은 비교문을 앞에 둔다.|| : 첫 비교문이 참이면 모두 참이 되므로 그 뒤의 비교문은 모두 수행하지 않는다.=&gt; 참의 확률이 높은 비교문을 앞에 둔다.연관된 표현은 묶어서 처리한다=&gt; 이 부분의 경우 속도와 코드의 가독성의 Trade-off 관계실수 연산실수의 나누기는 느리다실수에서 나누기의 연산은 상당히 많은 연산시간을 잡아먹는다.가능하면 double 자료형 대신 float 자료형을 사용하라Math 라이브러리 함수를 되도록 사용하지 않는다 Math 라이브러리 함수들은 오버헤드가 크다. 자주 사용되는 값을 테이블로 설정하여 사용한다.가능하면 고정 소수점으로 변환하여 사용하라펌웨어 개발 규칙숫자 대신 의미 있는 상수명 사용const 사용#define 사용열거형 enum 사용함수 포인터 사용#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef void (pCallback)(uint8_t sec);typedef struct{ pCallback Forward; pCallback Backward;}MotorCallback_t;MotorCallback_t MC;static void Forward(uint8_t sec){}static void Backward(uint8_t sec){}void RegisterCallback(void){ MC.Forward = Forward; MC.Backward = Backward;}int main(){ RegisterCallback(); MC.Forward(5); MC.Forward(10);}volatile 키워드 사용IO 포트 접근하드웨어 주소에 접근하는 경우 volatile을 선언한다.인터럽트 핸들러와 공유하여 사용하는 global 변수global 변수를 인터럽트 핸들러 또는 일반 프로세스보다 우선순위가 높은 스레드와 공유하여 사용하는 경우 volatile을 선언한다.기능이 없어 컴파일 단계에서 무시될 수 있지만, 무시되면 안되는 경우의미없는 for loop 를 통해 delay를 구현하려는 경우 count 변수에 volatile 이 필요하다.하드웨어 접근을 위한 포인터 사용법하드웨어 레지스터도 특정 버스 주소에 연결되어 있기 때문에 volatile 을 사용한다.메모리 정렬 attribute((aligned (4))) #pragma pack(4)일반 변수int gVar __attribute__((aligned (4)));구조체 변수char 같은 경우 aligned 4를 사용하게 되면 메모리 낭비가 이루어질 수 있으므로 자주 사용되는 변수에만 사용하여 소요 시간 절감을 이루면서 메모리 낭비를 막는다.typedef struct{ int var __attribute__((aligned (4))); char ch __attribute__((aligned (4)));}var_t;함수__attribute__((aligned (4))) void func(){}실수 사용시 고료사항실수의 연산속도별도의 FPU 와 같은 하드웨어가 없을 경우 연산 처리 속도가 10배 이상 느려질 수 있다. 따라서 고정 소수점을 사용하거나 정수 연산을 많이 사용하고, 필요한 경우에만 부동 소수점 연산을 사용한다.실수 변수들의 비교 주의실수 변수들끼리 비교연산을 사용할 때 == 과 같은 같다 비교 연산은 되도록 사용하지 않도록 한다. 사용할 경우 특정 값을 곱해 고정 소수점 연산으로 비교하는 방법으로 사용해도 좋다.태스크의 병렬처리인터럽트 핸들러와 임계 영역(Critical Section) 여러 태스크가 동시에 접근한는 공유자원을 같이 쓰고 읽어 간섭이 일어날 수 있는 영역을 임계 영역(Critical Section) 이라고 한다. 임계 영역을 처리하는 기본적인 방식은 한 태스크가 공유자원을 점유할 때 다른 태스크가 접근하지 못하도록 세마포어(Semaphore), 뮤텍스(Mutex) 와 같은 방법을 사용한다. 일반 펌웨어 동작과 인터럽트 핸들러와 관련해서는 공유자원을 사용하는 경우 Interrupt 비활성화를 수행한다.int gVar = 0;/* 공유자원 접근 */void test_func(){ __disable_irq(); gVar = 1; __enable_irq();}기타 성능 규칙register 지시자 사용 register 지시자는 C 언어에서 변수를 CPU 레지스터에 저장하도록 컴파일러에게 힌트를 주는 역할을 한다. 레지스터에 저장된 변수는 메모리에서 값을 읽거나 쓰는 것보다 훨씬 빠르기 때문에, 매우 빈번하게 접근하는 변수에 사용하면 성능을 최적화할 수 있다. 그러나 현대 컴파일러들은 최적화를 자동으로 수행하기 때문에, register 지시자를 사용하는 것은 거의 필요하지 않으며, 실제 성능 차이는 미미할 수 있다. 또한, register 지시자는 주소 연산(&amp;)을 사용할 수 없다. 이는 레지스터에 저장된 변수의 주소를 알 수 없기 때문이다.```c#include int main() { // register 지시자를 사용하여 변수 i를 레지스터에 저장하도록 요청 register int i; int sum = 0;for (i = 0; i &lt; 1000; i++) { sum += i;}printf(\"Sum: %d\\n\", sum);return 0; } ```나눗셈 연산 대신 비트 사용 비트 연산을 사용하여 나눗셈 연산을 구현할 수 있다. 특히, 2의 거듭제곱으로 나누는 경우, 비트 시프트 연산을 사용하는 것이 매우 효율적입니다. 아래는 이를 활용한 예시이다.```c#include int main() { int dividend = 40; int divisor = 8;// 비트 시프트를 이용한 나눗셈 (divisor가 2의 거듭제곱일 때만 사용 가능)int quotient = dividend &gt;&gt; 3; // 40을 8로 나누는 것과 동일 (8은 2^3이므로 오른쪽으로 3비트 시프트)printf(\"Quotient using bit shift: %d\\n\", quotient); // 결과 5return 0; }```인자의 포인터 전달반복문 사용펌웨어의 양산 및 유지 보수버전 관리디버깅 레벨에 따른 printf 함수 관리" }, { "title": "피보나치는 지겨웡~", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%EB%8A%94-%EC%A7%80%EA%B2%A8%EC%9B%A1~/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "피보나치는 지겨웡~#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n;int arr[51] = { 1, 1, 3, };void dp(int * arr){ for(int i = 3; i &lt;= n; i++) { arr[i] = (arr[i -1] + arr[i - 2] + 1) % 1000000007; } cout &lt;&lt; arr[n] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;n); dp(arr); return 0;}" }, { "title": "피보나치 수 7", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98-7/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "피보나치 수 7#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n;int arr[1000001] = { 0, 1, 1, };void dp(int * arr){ for(int i = 3; i &lt;= n; i++) { arr[i] = (arr[i - 1] + arr[i - 2]) % 1000000007; } cout &lt;&lt; arr[n] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;n); dp(arr); return 0;}" }, { "title": "피보나치 비스무리한 수열", "url": "/posts/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EB%B9%84%EC%8A%A4%EB%AC%B4%EB%A6%AC%ED%95%9C-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "피보나치 비스무리한 수열#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int n;long long arr[117] = { 0, 1, 1, 1, };void dp(long long * arr){ for(int i = 4; i &lt;= n; i++) { arr[i] = arr[i - 1] + arr[i - 3]; } return;}int main(void){ scanf(\"%d\", &amp;n); dp(arr); cout &lt;&lt; arr[n] &lt;&lt; '\\n'; return 0;}" }, { "title": "파도반 수열", "url": "/posts/%ED%8C%8C%EB%8F%84%EB%B0%98-%EC%88%98%EC%97%B4/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "파도반 수열#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;int T, N;int max_num = 0;long long arr[101] = { 0, 1, 1, };int main(void){ scanf(\"%d\", &amp;T); for(int i = 0; i &lt; T; i++) { scanf(\"%d\", &amp;N); if(N &lt; 3) { } else if(arr[N] == 0) { for (int i = 3; i &lt;= N; i++) { arr[i] = arr[i - 2] + arr[i - 3]; } } cout &lt;&lt; arr[N] &lt;&lt; endl; } return 0;}" }, { "title": "계단 오르기", "url": "/posts/%EA%B3%84%EB%8B%A8-%EC%98%A4%EB%A5%B4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "계단 오르기#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int number;int score[301] = { 0 };int answer[301] = { 0 };void dp(int *arr){ answer[0] = arr[0]; answer[1] = arr[0] + arr[1]; answer[2] = max(arr[0] + arr[2], arr[1] + arr[2]); for(int i = 3; i &lt; number; i++) { answer[i] = max(answer[i - 2] + arr[i],answer[i - 3] + arr[i - 1] + arr[i]); }}int main(void){ scanf(\"%d\", &amp;number); for(int i = 0; i &lt; number; i++) { scanf(\"%d\", &amp;score[i]); } dp(score); printf(\"%d\", answer[number - 1]); return 0;}" }, { "title": "정렬(Sort)", "url": "/posts/Sort/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-06-11 00:00:00 +0900", "snippet": "SortC++ STL sort() 함수sort() 함수의 사용법은 아래 예시와 같이 배열의 시작점 주소와 마지막 주소+1 을 매개변수로 대입한다#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main(void){ int arr[10] = {0,.3 ,5, 6, 2, 4, 2, 1, 3, 2}; sort(arr, arr+10); for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; ' '; } return 0;}또한 sort 함수의 새번째 매개변수로 함수를 받아 자신이 원하는 방식으로 정렬을 할 수 있게 한다.#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;/* 내림차순 정렬 함수 */bool compare(int a, int b){ return a &gt; b;}int main(void){ int arr[10] = {0,.3 ,5, 6, 2, 4, 2, 1, 3, 2}; sort(arr, arr+10, compare); for(int i = 0; i &lt; 10; i++) { cout &lt;&lt; arr[i] &lt;&lt; ' '; } return 0;}compare 함수 위치에는 greater&lt;int&gt;() =&gt; 내림차순 정렬, less&lt;int&gt;() =&gt; 오름차순 정렬(default)또한 특정 class 변수 혹은 구조체 변수일 경우 다음과 같은 방식으로 특정 변수를 기준으로 정렬이 가능해진다.Pair 라이브러리를 통한 정렬#include #include #include using namespace std;bool compare(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b) {\tif (a.first == b.first) {\t\treturn a.second &lt; b.second;\t}\telse {\t\treturn a.first &lt; b.first;\t}}void init(vector&lt;pair&lt;int, int&gt;&gt; &amp;v){\tv.push_back({1, 13});\tv.push_back({5, 2});\tv.push_back({7, 14});\tv.push_back({1, 22});\tv.push_back({4, 3});}int main(){\tvector&lt;pair&lt;int, int&gt;&gt;v;\tinit(v);\tsort(v.begin(), v.end(), compare);\tfor(int i = 0; i &lt; v.size(); ++&gt;) {\t\tcout &lt;&lt; v[i].first &lt;&lt; \" \" &lt;&lt; v[i].second;\t}}" }, { "title": "에라토스테네스의 체(Sieve of Eratosthenes)", "url": "/posts/SieveofEratosthenes/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-06-11 00:00:00 +0900", "snippet": "Sieve of Eratosthenes(에라토스테네스의 체)소수 판별 알고리즘으로 주로 시간 제한이 걸려있는 소수 판별 문제에 사용한다그리고 대량의 숫자 범위 내의 소수 판정에 사용한다.기존 소수 판별 알고리즘 즉 그리디 방식의 경우 시간복잡도는 o(N^(1/2)) ~ o(N)기존 방식#include &lt;stdio.h&gt;#include &lt;math.h&gt;bool isPrime(int x){ int range = sqrt(x); // 두 숫자의 곱으로 표현될 때 각 약수들은 대칭을 이루기 때문에 제곱근까지만 파악하면 됨 for(int i = 2; i &lt;= range; i++) { if(x % i == 0) return False; } return True;}int main(void){ printf(\"%d\\n\". isPrime(123124)); return 0;}에라토스테네스의 체 알고리즘 방식은 대략적으로 다음과 같다 배열을 선언하고 탐색하고자 하는 범위내의 자연수를 넣는다. 2부터 시작하여 해당 숫자의 배수의 숫자들은 모두 지운다.(자기 자신은 지우지 않는다.)void PrimeSieve(int *arr){ for(int i = 2; i &lt; 100; i++) { if(arr[i] == 0) continue; for(int j = 2 * i; j &lt; 100; j += i) { arr[j] = 0; } } return ;}int main(void){ int arr[100] = { 0 }; for(int i = 2; i &lt; 100; i++) { arr[i] = i; } PrimeSieve(arr); for(int i = 2; i &lt; 100; i++) { printf(\"%d\\n\". arr[i]); } return 0;}" }, { "title": "해밍 가중치(Hamming Weight)", "url": "/posts/HammingWeight/", "categories": "Algorithm", "tags": "Algorithm", "date": "2022-06-11 00:00:00 +0900", "snippet": "해밍 가중치(Hamming Weight)길이가 모두 0인 Hamming Distance 와 동일/* Divide and Conquer */ int OneBitCnt(int data){ data = (data &amp; 0x55555555) + ((data &gt;&gt; 1) &amp; 0x55555555); //인접한 1비트의 분할정복 data = (data &amp; 0x33333333) + ((data &gt;&gt; 2) &amp; 0x33333333); //인접한 2비트의 분할정복 data = (data &amp; 0x0f0f0f0f) + ((data &gt;&gt; 4) &amp; 0x0f0f0f0f); //인접한 4비트의 분할정복 data = (data &amp; 0x00ff00ff) + ((data &gt;&gt; 8) &amp; 0x00ff00ff); //인접한 8비트의 분할정복 data = (data &amp; 0x0000ffff) + ((data &gt;&gt; 16) &amp; 0x0000ffff); //인접한 16비트의 분할정복 return data;} 모든 odd bit의 1값 탐색(data &amp; 0x55555555) 모든 even bit의 1값 탐색((data » 1) &amp; 0x55555555) 결과는 각 2비트씩 쪼개서 봤을 때 1의 개수를 이진수로 표현한 것과 같다. 이를 모두 더하면 전체 비트의 1의 개수와 같다 모든 하위 2비트 1값 탐색(data &amp; 0x33333333) 모든 상위 2비트 1값 탐색((data » 2) &amp; 0x33333333) 결과는 각 4비트씩 쪼개서 봤을 때 1의 개수를 이진수로 표현한 것과 같다. 이를 모두 더하면 전체 비트의 1의 개수와 같다…반복했을 때 최종적으로data = (data &amp; 0x0000ffff) + ((data » 16) &amp; 0x0000ffff);내용까지 수행하면 전체 비트의 1의 개수를 구할 수 있게 된다" }, { "title": "2×n 타일링 2", "url": "/posts/2-n-%ED%83%80%EC%9D%BC%EB%A7%81-2/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "2×n 타일링 2#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n = 0;long long arr[1001] = {0,1,3, };void dp(long long *arr){ for(int i = 3; i &lt;= n; i++) { arr[i] = (arr[i - 1] + 2 * arr[i - 2]) % 10007; } return;}int main(void){ long long answer = 0; scanf(\"%d\", &amp;n); dp(arr); cout &lt;&lt; arr[n] &lt;&lt; '\\n'; return 0;}" }, { "title": "1로 만들기", "url": "/posts/1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "1로 만들기#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int N;int arr[1000001] = { 0, 0, 1, 1, };void dp(int * arr){ for(int i = 4; i &lt;= N; i++) { //먼저 1을 빼는 연산을 최솟값으로 설정 arr[i] = arr[i - 1] +1; // 3으로 나누는 연산과 1을 빼는 연산 간 크기 비교 if(i % 3 == 0) { arr[i] = min(arr[i], arr[i/3] + 1); } // 2으로 나누는 연산과 1을 빼는 연산 간 크기 비교 if(i % 2 == 0) { arr[i] = min(arr[i], arr[i/2] + 1); } } cout &lt;&lt; arr[N] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;N); dp(arr); return 0;}" }, { "title": "1, 2, 3 더하기", "url": "/posts/1,-2,-3-%EB%8D%94%ED%95%98%EA%B8%B0/", "categories": "CodingTest", "tags": "CodingTest, DP", "date": "2022-06-11 00:00:00 +0900", "snippet": "1, 2, 3 더하기#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int n, T;int arr[11] = { 0, 1, 2, 4, };void dp(int * arr){ for(int i = 4; i &lt;= n; i++) { arr[i] = arr[i -1] + arr[i - 2] + arr[i - 3]; } cout &lt;&lt; arr[n] &lt;&lt; '\\n';}int main(void){ scanf(\"%d\", &amp;T); for(int i = 0; i &lt; T; i++) { scanf(\"%d\", &amp;n); dp(arr); } return 0;}" } ]
